{"version":3,"sources":["../../src/methods/create.ts"],"sourcesContent":["import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js'\nimport { DocumentsStore, createDocumentsStore } from '../components/documents-store.js'\nimport { FUNCTION_COMPONENTS, OBJECT_COMPONENTS, SINGLE_OR_ARRAY_COMPONENTS } from '../components/hooks.js'\nimport { Index, createIndex } from '../components/index.js'\nimport { createInternalDocumentIDStore } from '../components/internal-document-id-store.js'\nimport { Sorter, createSorter } from '../components/sorter.js'\nimport { createTokenizer } from '../components/tokenizer/index.js'\nimport { createError } from '../errors.js'\nimport {\n  AfterSearch,\n  ArrayCallbackComponents,\n  Components,\n  FunctionComponents,\n  IDocumentsStore,\n  IIndex,\n  ISorter,\n  MultipleCallbackComponent,\n  Orama,\n  SingleCallbackComponent,\n  SingleOrArray,\n  SingleOrArrayCallbackComponents,\n  SorterConfig,\n  Tokenizer\n} from '../types.js'\nimport { uniqueId } from '../utils.js'\n\ninterface CreateArguments<OramaSchema, TIndex, TDocumentStore, TSorter> {\n  schema: OramaSchema,\n  sort?: SorterConfig\n  language?: string\n  components?: Components<Orama<OramaSchema, TIndex, TDocumentStore, TSorter>, OramaSchema, TIndex, TDocumentStore, TSorter>\n  id?: string\n}\n\nfunction validateComponents<OramaSchema, TIndex, TDocumentStore, TSorter, TOrama extends Orama<OramaSchema, TIndex, TDocumentStore, TSorter>>(components: Components<TOrama, OramaSchema, TIndex, TDocumentStore, TSorter>) {\n  const defaultComponents = {\n    formatElapsedTime,\n    getDocumentIndexId,\n    getDocumentProperties,\n    validateSchema,\n  }\n\n  for (const rawKey of FUNCTION_COMPONENTS) {\n    const key = rawKey as keyof FunctionComponents<OramaSchema>\n\n    if (components[key]) {\n      if (typeof components[key] !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION', key)\n      }\n    } else {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = defaultComponents[key]\n    }\n  }\n\n  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {\n    const key = rawKey as keyof ArrayCallbackComponents<TOrama>\n\n    const component:\n      | SingleOrArray<AfterSearch<TOrama>>\n      | SingleOrArray<SingleCallbackComponent<TOrama>>\n      | SingleOrArray<MultipleCallbackComponent<TOrama>>\n      | undefined = components[key]\n    if (!component) {\n      components[key] = []\n    } else if (!Array.isArray(components[key])) {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = [components[key]]\n    }\n\n    for (const fn of components[key] as unknown as SingleOrArrayCallbackComponents<TOrama>[]) {\n      if (typeof fn !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS', key)\n      }\n    }\n  }\n\n  for (const rawKey of Object.keys(components)) {\n    if (\n      !OBJECT_COMPONENTS.includes(rawKey) &&\n      !FUNCTION_COMPONENTS.includes(rawKey) &&\n      !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)\n    ) {\n      throw createError('UNSUPPORTED_COMPONENT', rawKey)\n    }\n  }\n}\n\nexport async function create<\n  OramaSchema,\n  TIndex = IIndex<Index>, \n  TDocumentStore = IDocumentsStore<DocumentsStore>, \n  TSorter = ISorter<Sorter>> ({\n  schema,\n  sort,\n  language,\n  components,\n  id,\n}: CreateArguments<OramaSchema, TIndex, TDocumentStore, TSorter>): Promise<Orama<OramaSchema, TIndex, TDocumentStore, TSorter>> {\n  if (!components) {\n    components = {}\n  }\n\n  if (!id) {\n    id = await uniqueId()\n  }\n\n  let tokenizer = components.tokenizer as Tokenizer\n  let index: TIndex | undefined = components.index\n  let documentsStore: TDocumentStore | undefined = components.documentsStore\n  let sorter: TSorter | undefined = components.sorter\n\n  if (!tokenizer) {\n    // Use the default tokenizer\n    tokenizer = await createTokenizer({ language: language ?? 'english' })\n  } else if (!tokenizer.tokenize) {\n    // If there is no tokenizer function, we assume this is a TokenizerConfig\n    tokenizer = await createTokenizer(tokenizer)\n  }\n\n  if (components.tokenizer && language) {\n    // Accept language only if a tokenizer is not provided\n    throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER')\n  }\n\n  const internalDocumentStore = createInternalDocumentIDStore()\n\n  index ||= await createIndex() as TIndex\n  sorter ||= await createSorter() as TSorter\n  documentsStore ||= await createDocumentsStore() as TDocumentStore\n\n  // Validate all other components\n  validateComponents(components)\n\n  // Assign only recognized components and hooks\n  const {\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n  } = components\n\n  const orama = {\n    data: {},\n    caches: {},\n    schema,\n    tokenizer,\n    index,\n    sorter,\n    documentsStore,\n    internalDocumentIDStore: internalDocumentStore,\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n    id,\n  } as unknown as Orama<OramaSchema, TIndex, TDocumentStore, TSorter>\n\n  orama.data = {\n    index: await orama.index.create(orama, internalDocumentStore, schema),\n    docs: await orama.documentsStore.create(orama, internalDocumentStore),\n    sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort),\n  }\n\n  return orama\n}\n"],"names":["formatElapsedTime","getDocumentIndexId","getDocumentProperties","validateSchema","createDocumentsStore","FUNCTION_COMPONENTS","OBJECT_COMPONENTS","SINGLE_OR_ARRAY_COMPONENTS","createIndex","createInternalDocumentIDStore","createSorter","createTokenizer","createError","uniqueId","validateComponents","components","defaultComponents","rawKey","key","component","Array","isArray","fn","Object","keys","includes","create","schema","sort","language","id","tokenizer","index","documentsStore","sorter","tokenize","internalDocumentStore","beforeInsert","afterInsert","beforeRemove","afterRemove","beforeUpdate","afterUpdate","afterSearch","beforeMultipleInsert","afterMultipleInsert","beforeMultipleRemove","afterMultipleRemove","beforeMultipleUpdate","afterMultipleUpdate","orama","data","caches","internalDocumentIDStore","docs","sorting"],"mappings":"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"}