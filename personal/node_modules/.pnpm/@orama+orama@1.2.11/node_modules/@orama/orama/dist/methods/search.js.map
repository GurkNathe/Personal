{"version":3,"sources":["../../src/methods/search.ts"],"sourcesContent":["import { prioritizeTokenScores } from '../components/algorithms.js'\nimport { getFacets } from '../components/facets.js'\nimport { intersectFilteredIDs } from '../components/filters.js'\nimport { getGroups } from '../components/groups.js'\nimport { runAfterSearch } from '../components/hooks.js'\nimport {\n  InternalDocumentID,\n  getDocumentIdFromInternalId,\n  getInternalDocumentId,\n} from '../components/internal-document-id-store.js'\nimport { createError } from '../errors.js'\nimport { getNanosecondsTime, getNested, sortTokenScorePredicate, safeArrayPush } from '../utils.js';\nimport type {\n  AnyOrama,\n  BM25Params,\n  CustomSorterFunctionItem,\n  ElapsedTime,\n  IndexMap,\n  LiteralUnion,\n  Result,\n  Results,\n  SearchContext,\n  SearchParams,\n  SearchableValue,\n  TokenMap,\n  TokenScore,\n  Tokenizer,\n  TypedDocument,\n} from '../types.js'\n\nconst defaultBM25Params: BM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5,\n}\n\nasync function createSearchContext<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  tokenizer: Tokenizer,\n  index: T['index'],\n  documentsStore: T['documentsStore'],\n  language: string | undefined,\n  params: SearchParams<T, ResultDocument>,\n  properties: string[],\n  tokens: string[],\n  docsCount: number,\n  timeStart: bigint,\n): Promise<SearchContext<T, ResultDocument>> {\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n  // let whereFiltersIDs: string[] = [];\n\n  // if (hasFilters) {\n  //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n  // }\n\n  // indexMap is an object containing all the indexes considered for the current search,\n  // and an array of doc IDs for each token in all the indices.\n  //\n  // Given the search term \"quick brown fox\" on the \"description\" index,\n  // indexMap will look like this:\n  //\n  // {\n  //   description: {\n  //     quick: [doc1, doc2, doc3],\n  //     brown: [doc2, doc4],\n  //     fox:   [doc2]\n  //   }\n  // }\n  const indexMap: IndexMap = {}\n\n  // After we create the indexMap, we need to calculate the intersection\n  // between all the postings lists for each token.\n  // Given the example above, docsIntersection will look like this:\n  //\n  // {\n  //   description: [doc2]\n  // }\n  //\n  // as doc2 is the only document present in all the postings lists for the \"description\" index.\n  const docsIntersection: TokenMap = {}\n\n  for (const prop of properties) {\n    const tokensMap: TokenMap = {}\n    for (const token of tokens) {\n      tokensMap[token] = []\n    }\n    indexMap[prop] = tokensMap\n    docsIntersection[prop] = []\n  }\n\n  return {\n    timeStart,\n    tokenizer,\n    index,\n    documentsStore,\n    language,\n    params,\n    docsCount,\n    uniqueDocsIDs: {},\n    indexMap,\n    docsIntersection,\n  }\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParams<T, ResultDocument>,\n  language?: string,\n): Promise<Results<ResultDocument>> {\n  const timeStart = await getNanosecondsTime()\n\n  params.relevance = Object.assign(params.relevance ?? {}, defaultBM25Params)\n\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0\n  const { limit = 10, offset = 0, term, properties, threshold = 1, distinctOn } = params\n  const isPreflight = params.preflight === true\n\n  const { index, docs } = orama.data\n  const tokens = await orama.tokenizer.tokenize(term ?? '', language)\n\n  // Get searchable string properties\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string'),\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  if (properties && properties !== '*') {\n    for (const prop of properties) {\n      if (!propertiesToSearch.includes(prop as string)) {\n        throw createError('UNKNOWN_INDEX', prop as string, propertiesToSearch.join(', '))\n      }\n    }\n\n    propertiesToSearch = propertiesToSearch.filter((prop: string) => (properties as string[]).includes(prop))\n  }\n\n  // Create the search context and the results\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(docs),\n    timeStart,\n  )\n\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  const hasFilters = Object.keys(params.where ?? {}).length > 0\n  let whereFiltersIDs: InternalDocumentID[] = []\n\n  if (hasFilters) {\n    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where!)\n  }\n\n  const tokensLength = tokens.length\n\n  if (tokensLength || (properties && properties.length > 0)) {\n    // Now it's time to loop over all the indices and get the documents IDs for every single term\n    const indexesLength = propertiesToSearch.length\n    for (let i = 0; i < indexesLength; i++) {\n      const prop = propertiesToSearch[i]\n\n      if (tokensLength !== 0) {\n        for (let j = 0; j < tokensLength; j++) {\n          const term = tokens[j]\n\n          // Lookup\n          const scoreList = await orama.index.search(context, index, prop, term)\n\n          safeArrayPush(context.indexMap[prop][term], scoreList);\n        }\n      } else {\n        context.indexMap[prop][''] = []\n        const scoreList = await orama.index.search(context, index, prop, '')\n        safeArrayPush(context.indexMap[prop][''], scoreList);\n      }\n\n      const docIds = context.indexMap[prop]\n      const vals = Object.values(docIds)\n      context.docsIntersection[prop] = prioritizeTokenScores(vals, params?.boost?.[prop] ?? 1, threshold, tokensLength)\n      const uniqueDocs = context.docsIntersection[prop]\n\n      const uniqueDocsLength = uniqueDocs.length\n      for (let i = 0; i < uniqueDocsLength; i++) {\n        const [id, score] = uniqueDocs[i]\n        const prevScore = context.uniqueDocsIDs[id]\n        if (prevScore) {\n          context.uniqueDocsIDs[id] = prevScore + score + 0.5\n        } else {\n          context.uniqueDocsIDs[id] = score\n        }\n      }\n    }\n  } else if (tokens.length === 0 && term) {\n    // This case is hard to handle correctly.\n    // For the time being, if tokenizer returns empty array but the term is not empty,\n    // we returns an empty result set\n    context.uniqueDocsIDs = {}\n  } else {\n    context.uniqueDocsIDs = Object.fromEntries(\n      Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map(k => [k, 0]),\n    )\n  }\n\n  // Get unique doc IDs from uniqueDocsIDs map\n  let uniqueDocsArray = Object.entries(context.uniqueDocsIDs).map(([id, score]) => [+id, score] as TokenScore)\n\n  // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n  if (hasFilters) {\n    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray)\n  }\n\n  if (params.sortBy) {\n    if (typeof params.sortBy === 'function') {\n      const ids = uniqueDocsArray.map(([id]) => id)\n      const docs = await orama.documentsStore.getMultiple(orama.data.docs, ids)\n      const docsWithIdAndScore: CustomSorterFunctionItem<ResultDocument>[] = docs.map((d, i) => [\n        uniqueDocsArray[i][0],\n        uniqueDocsArray[i][1],\n        d!,\n      ])\n      docsWithIdAndScore.sort(params.sortBy)\n      uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [id, score])\n    } else {\n      uniqueDocsArray = await orama.sorter\n        .sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy)\n        .then(results =>\n          results.map(([id, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id), score]),\n        )\n    }\n  } else {\n    uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate)\n  }\n\n  let results\n  if (!isPreflight && distinctOn) {\n    results = await fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn)\n  } else if (!isPreflight) {\n    results = await fetchDocuments(orama, uniqueDocsArray, offset, limit)\n  }\n\n  const searchResult: Results<ResultDocument> = {\n    elapsed: {\n      formatted: '',\n      raw: 0,\n    },\n    // We keep the hits array empty if it's a preflight request.\n    hits: [],\n    count: uniqueDocsArray.length,\n  }\n\n  if (typeof results !== 'undefined') {\n    searchResult.hits = results.filter(Boolean)\n  }\n\n  if (shouldCalculateFacets) {\n    // Populate facets if needed\n    const facets = await getFacets(orama, uniqueDocsArray, params.facets!)\n    searchResult.facets = facets\n  }\n\n  if (params.groupBy) {\n    searchResult.groups = await getGroups<T, ResultDocument>(orama, uniqueDocsArray, params.groupBy)\n  }\n\n  if (orama.afterSearch) {\n    await runAfterSearch(orama.afterSearch, orama, params, language, searchResult)\n  }\n\n  // Calculate elapsed time only at the end of the function\n  searchResult.elapsed = (await orama.formatElapsedTime(\n    (await getNanosecondsTime()) - context.timeStart,\n  )) as ElapsedTime\n\n  return searchResult\n}\n\nasync function fetchDocumentsWithDistinct<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  orama: T,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number,\n  distinctOn: LiteralUnion<T['schema']>,\n): Promise<Result<ResultDocument>[]> {\n  const docs = orama.data.docs\n\n  // Keep track which values we already seen\n  const values = new Map<SearchableValue, true>()\n\n  // We cannot know how many results we will have in the end,\n  // so we need cannot pre-allocate the array.\n  const results: Result<ResultDocument>[] = []\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n  const uniqueDocsArrayLength = uniqueDocsArray.length\n  let count = 0\n  for (let i = 0; i < uniqueDocsArrayLength; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      continue\n    }\n\n    const [id, score] = idAndScore\n\n    if (resultIDs.has(id)) {\n      continue\n    }\n\n    const doc = await orama.documentsStore.get(docs, id)\n    const value = await getNested(doc as object, distinctOn)\n    if (typeof value === 'undefined' || values.has(value)) {\n      continue\n    }\n    values.set(value, true)\n\n    count++\n    // We shouldn't consider the document if it's not in the offset range\n    if (count <= offset) {\n      continue\n    }\n\n    results.push({ id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: doc! })\n    resultIDs.add(id)\n\n    // reached the limit, break the loop\n    if (count >= offset + limit) {\n      break\n    }\n  }\n\n  return results\n}\n\nasync function fetchDocuments<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  orama: T,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number,\n): Promise<Result<ResultDocument>[]> {\n  const docs = orama.data.docs\n\n  const results: Result<ResultDocument>[] = Array.from({\n    length: limit,\n  })\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n\n  // We already have the list of ALL the document IDs containing the search terms.\n  // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n  // to provide pagination capabilities to the search.\n  for (let i = offset; i < limit + offset; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      break\n    }\n\n    const [id, score] = idAndScore\n\n    if (!resultIDs.has(id)) {\n      // We retrieve the full document only AFTER making sure that we really want it.\n      // We never retrieve the full document preventively.\n      const fullDoc = await orama.documentsStore.get(docs, id)\n      results[i] = { id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: fullDoc! }\n      resultIDs.add(id)\n    }\n  }\n  return results\n}\n"],"names":["prioritizeTokenScores","getFacets","intersectFilteredIDs","getGroups","runAfterSearch","getDocumentIdFromInternalId","getInternalDocumentId","createError","getNanosecondsTime","getNested","sortTokenScorePredicate","safeArrayPush","defaultBM25Params","k","b","d","createSearchContext","tokenizer","index","documentsStore","language","params","properties","tokens","docsCount","timeStart","indexMap","docsIntersection","prop","tokensMap","token","uniqueDocsIDs","search","orama","relevance","Object","assign","shouldCalculateFacets","facets","keys","length","limit","offset","term","threshold","distinctOn","isPreflight","preflight","docs","data","tokenize","propertiesToSearch","caches","propertiesToSearchWithTypes","getSearchablePropertiesWithTypes","getSearchableProperties","filter","startsWith","includes","join","context","count","hasFilters","where","whereFiltersIDs","searchByWhereClause","tokensLength","indexesLength","i","j","scoreList","docIds","vals","values","boost","uniqueDocs","uniqueDocsLength","id","score","prevScore","fromEntries","getAll","map","uniqueDocsArray","entries","sortBy","ids","getMultiple","docsWithIdAndScore","sort","sorter","sorting","then","results","internalDocumentIDStore","fetchDocumentsWithDistinct","fetchDocuments","searchResult","elapsed","formatted","raw","hits","Boolean","groupBy","groups","afterSearch","formatElapsedTime","Map","resultIDs","Set","uniqueDocsArrayLength","idAndScore","has","doc","get","value","set","push","document","add","Array","from","fullDoc"],"mappings":"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"}