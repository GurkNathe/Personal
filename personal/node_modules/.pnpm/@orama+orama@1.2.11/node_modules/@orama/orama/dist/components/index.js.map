{"version":3,"sources":["../../src/components/index.ts"],"sourcesContent":["import type {\n  AnyIndexStore,\n  AnyOrama,\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  EnumArrComparisonOperator,\n  EnumComparisonOperator,\n  IIndex,\n  ScalarSearchableType,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  Tokenizer,\n  TokenScore,\n  TypedDocument,\n  VectorIndex,\n  VectorType,\n  WhereCondition,\n} from '../types.js'\nimport { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  Node as AVLNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument,\n} from '../trees/avl.js'\nimport {\n  create as flatCreate,\n  filter as flatFilter,\n  filterArr as flatFilterArr,\n  insert as flatInsert,\n  removeDocument as flatRemoveDocument,\n  FlatTree,\n} from '../trees/flat.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument,\n} from '../trees/radix.js'\n\nimport { intersect, safeArrayPush } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getMagnitude } from './cosine-similarity.js'\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n} from './internal-document-id-store.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: InternalDocumentID]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: InternalDocumentID[]\n  false: InternalDocumentID[]\n}\n\nexport type TreeType =\n  | 'AVL'\n  | 'Radix'\n  | 'Bool'\n  | 'Flat'\n\nexport type TTree<T = TreeType, N = unknown> = {\n  type: T,\n  node: N\n  isArray: boolean\n}\n\nexport type Tree =\n  | TTree<'Radix', RadixNode>\n  | TTree<'AVL',   AVLNode<number, InternalDocumentID[]>>\n  | TTree<'Bool',  BooleanIndex>\n  | TTree<'Flat',  FlatTree>\n\nexport interface Index extends AnyIndexStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  indexes: Record<string, Tree>\n  vectorIndexes: Record<string, VectorIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrences: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<InternalDocumentID, number | undefined>>\n}\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][internalId] = tokens.length\n  index.frequencies[prop][internalId] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  token: string,\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][internalId]![token] = tf\n\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] =\n    (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]!) / (docsCount - 1)\n  index.fieldLengths[prop][internalId] = undefined\n  index.frequencies[prop][internalId] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrences[prop][token]--\n}\n\nexport async function calculateResultScores<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: DocumentID[],\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrences = index.tokenOccurrences[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k])\n    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrences,\n      context.docsCount,\n      fieldLengths[internalId]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>,\n    )\n\n    scoreList.push([internalId, bm25])\n  }\n  return scoreList\n}\n\nexport async function create<T extends AnyOrama, TSchema extends T['schema']>(\n  orama: T,\n  sharedInternalDocumentStore: T['internalDocumentIDStore'],\n  schema: TSchema,\n  index?: Index,\n  prefix = '',\n): Promise<Index> {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      vectorIndexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {},\n    }\n  }\n\n  for (const [prop, type] of Object.entries<SearchableType>(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type, index, path)\n      continue\n    }\n\n    if (isVectorType(type)) {\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n      index.vectorIndexes[path] = {\n        size: getVectorSize(type),\n        vectors: {},\n      }\n    } else {\n      const isArray = /\\[/.test(type as string)\n      switch (type) {\n        case 'boolean':\n        case 'boolean[]':\n          index.indexes[path] = { type: 'Bool', node: { true: [], false: [] }, isArray }\n          break\n        case 'number':\n        case 'number[]':\n          index.indexes[path] = { type: 'AVL', node: avlCreate<number, InternalDocumentID[]>(0, []), isArray }\n          break\n        case 'string':\n        case 'string[]':\n          index.indexes[path] = { type: 'Radix', node: radixCreate(), isArray }\n          index.avgFieldLength[path] = 0\n          index.frequencies[path] = {}\n          index.tokenOccurrences[path] = {}\n          index.fieldLengths[path] = {}\n          break\n        case 'enum':\n        case 'enum[]':\n          index.indexes[path] = { type: 'Flat', node: flatCreate(), isArray }\n          break\n        default:\n          throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path)\n      }\n\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n    }\n  }\n\n  return index\n}\n\nasync function insertScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'Bool': {\n      node[value ? 'true' : 'false'].push(internalId)\n      break\n    }\n    case 'AVL':\n      avlInsert(node, value as number, [internalId])\n      break\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n      await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount)\n\n      for (const token of tokens) {\n        await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token)\n\n        radixInsert(node, token, internalId)\n      }\n\n      break\n    }\n    case 'Flat': {\n      flatInsert(node, value as ScalarSearchableType, internalId)\n      break\n    }\n  }\n}\n\nexport async function insert(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  if (isVectorType(schemaType)) {\n    return insertVector(index, prop, value as number[] | Float32Array, id)\n  }\n\n  if (!isArrayType(schemaType)) {\n    return insertScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n}\n\nfunction insertVector(index: Index, prop: string, value: number[] | VectorType, id: DocumentID): void {\n  if (!(value instanceof Float32Array)) {\n    value = new Float32Array(value)\n  }\n\n  const size = index.vectorIndexes[prop].size\n  const magnitude = getMagnitude(value, size)\n\n  index.vectorIndexes[prop].vectors[id] = [magnitude, value]\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  if (isVectorType(schemaType)) {\n    delete index.vectorIndexes[prop].vectors[id]\n    return true\n  }\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'AVL': {\n      avlRemoveDocument(node, internalId, value as number)\n      return true\n    }\n    case 'Bool': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = node[booleanKey].indexOf(internalId)\n\n      node[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(node, token, internalId)\n      }\n\n      return true\n    }\n    case 'Flat': {\n      flatRemoveDocument(node, internalId, value as ScalarSearchableType)\n      return true\n    }\n  }\n}\n\nexport async function remove(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  prop: string,\n  term: string,\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrences)) {\n    return []\n  }\n\n  const { node, type } = index.indexes[prop]\n  if (type !== 'Radix') {\n    throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop)\n  }\n\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(node, { term, exact, tolerance })\n  const ids = new Set<InternalDocumentID>()\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  filters: Partial<WhereCondition<T['schema']>>,\n): Promise<number[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, InternalDocumentID[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc,\n    }),\n    {},\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]!\n\n    if (typeof index.indexes[param] === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param)\n    }\n\n    const { node, type, isArray } = index.indexes[param]\n\n    if (type === 'Bool') {\n      const idx = node\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      safeArrayPush(filtersMap[param], filteredIDs);\n      continue\n    }\n\n    if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        for (const t of term) {\n          const filteredIDsResults = radixFind(node, { term: t, exact: true })\n          safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat())}\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    if (type === 'Flat') {\n      if (isArray) {\n        safeArrayPush(filtersMap[param], flatFilterArr(node, operation as EnumArrComparisonOperator))\n      } else {\n        safeArrayPush(filtersMap[param], flatFilter(node, operation as EnumComparisonOperator))\n      }\n      continue\n    }\n\n    if (type === 'AVL') {\n      const operationOpt = operationKeys[0] as keyof ComparisonOperator\n      const operationValue = (operation as ComparisonOperator)[operationOpt]\n      let filteredIDs: InternalDocumentID[] = [];\n\n      switch (operationOpt) {\n        case 'gt': {\n          filteredIDs = avlGreaterThan(node, operationValue, false)\n          break\n        }\n        case 'gte': {\n          filteredIDs = avlGreaterThan(node, operationValue, true)\n          break\n        }\n        case 'lt': {\n          filteredIDs = avlLessThan(node, operationValue, false)\n          break\n        }\n        case 'lte': {\n          filteredIDs = avlLessThan(node, operationValue, true)\n          break\n        }\n        case 'eq': {\n          filteredIDs = avlFind(node, operationValue) ?? []\n          break\n        }\n        case 'between': {\n          const [min, max] = operationValue as number[]\n          filteredIDs = avlRangeSearch(node, min, max)\n          break\n        }\n      }\n\n      safeArrayPush(filtersMap[param], filteredIDs)\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap))\n\n  return result\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nfunction loadRadixNode(node: RadixNode): RadixNode {\n  const convertedNode = radixCreate(node.e, node.s, node.k)\n\n  convertedNode.d = node.d\n  convertedNode.w = node.w\n\n  for (const childrenKey of Object.keys(node.c)) {\n    convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey])\n  }\n\n  return convertedNode\n}\n\nfunction loadFlatNode(node: unknown): FlatTree {\n  return {\n    numberToDocumentId: new Map(node as [ScalarSearchableType, InternalDocumentID[]][]),\n  }\n}\n\nfunction saveFlatNode(node: FlatTree): unknown {\n  return Array.from(node.numberToDocumentId.entries())\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Index> {\n  const {\n    indexes: rawIndexes,\n    vectorIndexes: rawVectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = raw as Index\n\n  const indexes: Index['indexes'] = {}\n  const vectorIndexes: Index['vectorIndexes'] = {}\n\n  for (const prop of Object.keys(rawIndexes)) {\n    const { node, type, isArray } = rawIndexes[prop]\n\n    switch (type) {\n      case 'Radix':\n        indexes[prop] = {\n          type: 'Radix',\n          node: loadRadixNode(node),\n          isArray\n        }\n        break\n      case 'Flat':\n        indexes[prop] = {\n          type: 'Flat',\n          node: loadFlatNode(node),\n          isArray\n        }\n        break\n      default:\n        indexes[prop] = rawIndexes[prop]\n    }\n  }\n\n  for (const idx of Object.keys(rawVectorIndexes)) {\n    const vectors = rawVectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], new Float32Array(vectors[vec][1])]\n    }\n\n    vectorIndexes[idx] = {\n      size: rawVectorIndexes[idx].size,\n      vectors,\n    }\n  }\n\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = index\n\n  const vectorIndexesAsArrays: Index['vectorIndexes'] = {}\n\n  for (const idx of Object.keys(vectorIndexes)) {\n    const vectors = vectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], Array.from(vectors[vec][1]) as unknown as Float32Array]\n    }\n\n    vectorIndexesAsArrays[idx] = {\n      size: vectorIndexes[idx].size,\n      vectors,\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const savedIndexes: any = {}\n  for (const name of Object.keys(indexes)) {\n    const {type, node, isArray} = indexes[name]\n    if (type !== 'Flat') {\n      savedIndexes[name] = indexes[name]\n      continue\n    }\n    savedIndexes[name] = {\n      type: 'Flat',\n      node: saveFlatNode(node),\n      isArray,\n    }\n  }\n\n  return {\n    indexes: savedIndexes,\n    vectorIndexes: vectorIndexesAsArrays,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } as R\n}\n\nexport async function createIndex(): Promise<IIndex<Index>> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save,\n  }\n}\n"],"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","flatCreate","filter","flatFilter","filterArr","flatFilterArr","flatInsert","flatRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","intersect","safeArrayPush","BM25","getMagnitude","getInnerType","getVectorSize","isArrayType","isVectorType","getInternalDocumentId","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","internalId","sharedInternalDocumentStore","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrences","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","documentIDs","Array","from","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","k","bm25","params","relevance","push","orama","schema","prefix","indexes","vectorIndexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","path","isArray","size","vectors","test","node","true","false","insertScalar","implementation","value","schemaType","language","tokenizer","tokenize","insertVector","innerSchemaType","elements","elementsLength","i","Float32Array","magnitude","removeScalar","booleanKey","position","indexOf","splice","remove","search","exact","tolerance","searchResult","Set","key","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","raw","flat","filteredIDsResults","values","operationKeys","operationOpt","operationValue","min","max","result","getSearchableProperties","getSearchablePropertiesWithTypes","loadRadixNode","convertedNode","e","s","d","w","childrenKey","c","loadFlatNode","numberToDocumentId","Map","saveFlatNode","load","rawIndexes","rawVectorIndexes","vec","save","vectorIndexesAsArrays","savedIndexes","name","createIndex"],"mappings":"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"}