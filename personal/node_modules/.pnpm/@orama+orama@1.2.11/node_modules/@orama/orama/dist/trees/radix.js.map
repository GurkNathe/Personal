{"version":3,"sources":["../../src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getOwnProperty } from '../utils.js'\n\nexport class Node {\n  constructor (key: string, subWord: string, end: boolean) {\n    this.k = key\n    this.s = subWord\n    this.e = end\n  }\n\n  // Node key\n  public k: string\n  // Node subword\n  public s: string\n  // Node children\n  public c: Record<string, Node> = {}\n  // Node documents\n  public d: InternalDocumentID[] = []\n  // Node end\n  public e: boolean\n  // Node word\n  public w = ''\n\n  public toJSON (): object {\n    return {\n      w: this.w,\n      s: this.s,\n      c: this.c,\n      d: this.d,\n      e: this.e\n    }\n  }\n}\n\ninterface FindParams {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, InternalDocumentID[]>\n\nfunction updateParent (node: Node, parent: Node): void {\n  node.w = parent.w + node.s\n}\n\nfunction addDocument (node: Node, docID: InternalDocumentID): void {\n  node.d.push(docID)\n}\n\nfunction removeDocument (node: Node, docID: InternalDocumentID): boolean {\n  const index = node.d.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.d.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords (node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.e) {\n    const { w, d: docIDs } = node\n\n    if (exact && w !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, w) == null) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - w.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n          output[w] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[w] = []\n      }\n    }\n\n    // check if _output[w] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if ((getOwnProperty(output, w) != null) && (docIDs.length > 0)) {\n      const docs = new Set(output[w])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[w] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.c)) {\n    findAllWords(node.c[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix (a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create (end = false, subWord = '', key = ''): Node {\n  return new Node(key, subWord, end)\n}\n\nexport function insert (root: Node, word: string, docId: InternalDocumentID) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.c[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.s\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.e = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.c[edgeLabelAtCommonPrefix]\n        newNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.k = edgeLabelAtCommonPrefix\n\n        root.c[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.c[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.k = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.c[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.c[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nfunction _findLevenshtein (\n  node: Node,\n  term: string,\n  index: number,\n  tolerance: number,\n  originalTolerance: number,\n  output: FindResult\n) {\n  if (tolerance < 0) {\n    return\n  }\n\n  if (node.e) {\n    const { w, d: docIDs } = node\n    if (w) {\n      const difference = Math.abs(term.length - w.length)\n      if (difference <= originalTolerance && syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n        output[w] = []\n      }\n      if ((getOwnProperty(output, w) != null) && (docIDs.length > 0)) {\n        const docs = new Set(output[w])\n\n        const docIDsLength = docIDs.length\n        for (let i = 0; i < docIDsLength; i++) {\n          docs.add(docIDs[i])\n        }\n        output[w] = Array.from(docs)\n      }\n    }\n  }\n\n  if (index >= term.length) {\n    return\n  }\n\n  // Match current character without consuming tolerance\n  if (term[index] in node.c) {\n    _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output)\n  }\n\n  // If tolerance is still available, consider other branches:\n  // 1. Deletion (skip the current term character)\n  _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output)\n\n  // 2. Insertion (skip the current tree node character)\n  for (const character in node.c) {\n    _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output)\n  }\n\n  // 3. Substitution (skip both current term character and tree node character)\n  for (const character in node.c) {\n    if (character !== term[index]) {\n      _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output)\n    }\n  }\n}\n\nexport function find (root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // Find the closest node to the term\n\n  // Use `if` condition because tolerance `0` is supposed to match only prefix.\n  // (allows infinite insertions at end, which is against normal levenshtein logic).\n  // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n  if (tolerance && !exact) {\n    const output: FindResult = {}\n    tolerance = tolerance || 0\n    _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output)\n    return output\n  } else {\n    for (let i = 0; i < term.length; i++) {\n      const character = term[i]\n      if (character in root.c) {\n        const rootChildCurrentChar = root.c[character]\n        const edgeLabel = rootChildCurrentChar.s\n        const termSubstring = term.substring(i)\n\n        // find the common prefix between two words ex: prime and primate = prim\n        const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n        const commonPrefixLength = commonPrefix.length\n        // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n        // if the common prefix is equal to the term means it is contained in the node\n        if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n          // if tolerance is set we take the current node as the closest\n          if (tolerance) break\n          return {}\n        }\n\n        // skip the subword length and check the next divergent character\n        i += rootChildCurrentChar.s.length - 1\n        // navigate into the child node\n        root = rootChildCurrentChar\n      } else {\n        return {}\n      }\n    }\n\n    const output: FindResult = {}\n    // found the closest node we recursively search through children\n    findAllWords(root, output, term, exact, tolerance)\n\n    return output\n  }\n}\n\nexport function contains (root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.c) {\n      const rootChildrenChar = root.c[character]\n      const edgeLabel = rootChildrenChar.s\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.s.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord (root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.c) {\n      i += root.c[character].s.length - 1\n      root = root.c[character]\n\n      if (Object.keys(root.c).length === 0) {\n        delete parent.c[root.k]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord (root: Node, term: string, docID: InternalDocumentID, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.c) {\n      const rootChildCurrentChar = root.c[character]\n      i += rootChildCurrentChar.s.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.w !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"names":["syncBoundedLevenshtein","getOwnProperty","Node","constructor","key","subWord","end","k","s","e","c","d","w","toJSON","updateParent","node","parent","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","docs","Set","docIDsLength","i","add","Array","from","character","Object","keys","getCommonPrefix","a","b","commonPrefix","len","min","create","insert","root","word","docId","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","_findLevenshtein","originalTolerance","find","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"mappings":"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"}