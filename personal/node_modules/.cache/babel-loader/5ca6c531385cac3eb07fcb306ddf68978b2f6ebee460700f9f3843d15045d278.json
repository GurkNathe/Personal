{"ast":null,"code":"import { Vector2, Matrix4 } from \"three\";\nvar SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: /* @__PURE__ */new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 5e-3\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tNormal;\", \"uniform sampler2D tDepth;\", \"uniform sampler2D tNoise;\", \"uniform vec3 kernel[ KERNEL_SIZE ];\", \"uniform vec2 resolution;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform mat4 cameraProjectionMatrix;\", \"uniform mat4 cameraInverseProjectionMatrix;\", \"uniform float kernelRadius;\", \"uniform float minDistance;\",\n  // avoid artifacts caused by neighbour fragments with minimal depth difference\n  \"uniform float maxDistance;\",\n  // avoid the influence of fragments which are too far away\n  \"varying vec2 vUv;\", \"#include <packing>\", \"float getDepth( const in vec2 screenPosition ) {\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"}\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\", \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\", \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\", \"\tclipPosition *= clipW; // unprojection.\", \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\", \"}\", \"vec3 getViewNormal( const in vec2 screenPosition ) {\", \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tfloat viewZ = getViewZ( depth );\", \"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\", \"\tvec3 viewNormal = getViewNormal( vUv );\", \" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\", \"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n  // compute matrix used to reorient a kernel vector\n  \"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\", \"\tvec3 bitangent = cross( viewNormal, tangent );\", \"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\", \" float occlusion = 0.0;\", \" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\", \"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\",\n  // reorient sample vector in view space\n  \"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\",\n  // calculate sample point\n  \"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\",\n  // project point and calculate NDC\n  \"\t\tsamplePointNDC /= samplePointNDC.w;\", \"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\",\n  // compute uv coordinates\n  \"\t\tfloat realDepth = getLinearDepth( samplePointUv );\",\n  // get linear depth from depth texture\n  \"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\",\n  // compute linear depth of the sample view Z value\n  \"\t\tfloat delta = sampleDepth - realDepth;\", \"\t\tif ( delta > minDistance && delta < maxDistance ) {\",\n  // if fragment is before sample point, increase occlusion\n  \"\t\t\tocclusion += 1.0;\", \"\t\t}\", \"\t}\", \"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\", \"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nvar SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"varying vec2 vUv;\", \"#include <packing>\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getLinearDepth( vUv );\", \"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nvar SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: /* @__PURE__ */new Vector2()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 texelSize = ( 1.0 / resolution );\", \"\tfloat result = 0.0;\", \"\tfor ( int i = - 2; i <= 2; i ++ ) {\", \"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\", \"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\", \"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };","map":{"version":3,"names":["Vector2","Matrix4","SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","cameraProjectionMatrix","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","join","fragmentShader","SSAODepthShader","SSAOBlurShader"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/shaders/SSAOShader.js"],"sourcesContent":["import { Vector2, Matrix4 } from \"three\";\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tDepth: { value: null },\n    tNoise: { value: null },\n    kernel: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    kernelRadius: { value: 8 },\n    minDistance: { value: 5e-3 },\n    maxDistance: { value: 0.05 }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform sampler2D tNormal;\",\n    \"uniform sampler2D tDepth;\",\n    \"uniform sampler2D tNoise;\",\n    \"uniform vec3 kernel[ KERNEL_SIZE ];\",\n    \"uniform vec2 resolution;\",\n    \"uniform float cameraNear;\",\n    \"uniform float cameraFar;\",\n    \"uniform mat4 cameraProjectionMatrix;\",\n    \"uniform mat4 cameraInverseProjectionMatrix;\",\n    \"uniform float kernelRadius;\",\n    \"uniform float minDistance;\",\n    // avoid artifacts caused by neighbour fragments with minimal depth difference\n    \"uniform float maxDistance;\",\n    // avoid the influence of fragments which are too far away\n    \"varying vec2 vUv;\",\n    \"#include <packing>\",\n    \"float getDepth( const in vec2 screenPosition ) {\",\n    \"\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"}\",\n    \"float getLinearDepth( const in vec2 screenPosition ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n    \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n    \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\t\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"\t#endif\",\n    \"}\",\n    \"float getViewZ( const in float depth ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#endif\",\n    \"}\",\n    \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n    \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n    \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n    \"\tclipPosition *= clipW; // unprojection.\",\n    \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n    \"}\",\n    \"vec3 getViewNormal( const in vec2 screenPosition ) {\",\n    \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n    \"}\",\n    \"void main() {\",\n    \"\tfloat depth = getDepth( vUv );\",\n    \"\tfloat viewZ = getViewZ( depth );\",\n    \"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\",\n    \"\tvec3 viewNormal = getViewNormal( vUv );\",\n    \" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\",\n    \"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n    // compute matrix used to reorient a kernel vector\n    \"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\",\n    \"\tvec3 bitangent = cross( viewNormal, tangent );\",\n    \"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\",\n    \" float occlusion = 0.0;\",\n    \" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\n    \"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\",\n    // reorient sample vector in view space\n    \"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\",\n    // calculate sample point\n    \"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\",\n    // project point and calculate NDC\n    \"\t\tsamplePointNDC /= samplePointNDC.w;\",\n    \"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\",\n    // compute uv coordinates\n    \"\t\tfloat realDepth = getLinearDepth( samplePointUv );\",\n    // get linear depth from depth texture\n    \"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\",\n    // compute linear depth of the sample view Z value\n    \"\t\tfloat delta = sampleDepth - realDepth;\",\n    \"\t\tif ( delta > minDistance && delta < maxDistance ) {\",\n    // if fragment is before sample point, increase occlusion\n    \"\t\t\tocclusion += 1.0;\",\n    \"\t\t}\",\n    \"\t}\",\n    \"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\",\n    \"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDepth;\",\n    \"uniform float cameraNear;\",\n    \"uniform float cameraFar;\",\n    \"varying vec2 vUv;\",\n    \"#include <packing>\",\n    \"float getLinearDepth( const in vec2 screenPosition ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n    \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n    \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\t\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"\t#endif\",\n    \"}\",\n    \"void main() {\",\n    \"\tfloat depth = getLinearDepth( vUv );\",\n    \"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform vec2 resolution;\",\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvec2 texelSize = ( 1.0 / resolution );\",\n    \"\tfloat result = 0.0;\",\n    \"\tfor ( int i = - 2; i <= 2; i ++ ) {\",\n    \"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\",\n    \"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\",\n    \"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\",\n    \"\t\t}\",\n    \"\t}\",\n    \"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  SSAOBlurShader,\n  SSAODepthShader,\n  SSAOShader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}