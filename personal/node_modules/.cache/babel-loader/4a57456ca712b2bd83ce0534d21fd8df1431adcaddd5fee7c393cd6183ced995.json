{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, LoaderUtils } from \"three\";\nvar PLYLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PLYLoader, _Loader);\n  var _super = _createSuper(PLYLoader);\n  function PLYLoader(manager) {\n    var _this;\n    _classCallCheck(this, PLYLoader);\n    _this = _super.call(this, manager);\n    _this.propertyNameMapping = {};\n    return _this;\n  }\n  _createClass(PLYLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"setPropertyNameMapping\",\n    value: function setPropertyNameMapping(mapping) {\n      this.propertyNameMapping = mapping;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseHeader(data2) {\n        var patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n        var headerText = \"\";\n        var headerLength = 0;\n        var result = patternHeader.exec(data2);\n        if (result !== null) {\n          headerText = result[1];\n          headerLength = new Blob([result[0]]).size;\n        }\n        var header = {\n          comments: [],\n          elements: [],\n          headerLength: headerLength,\n          objInfo: \"\"\n        };\n        var lines = headerText.split(\"\\n\");\n        var currentElement;\n        function make_ply_element_property(propertValues, propertyNameMapping) {\n          var property = {\n            type: propertValues[0]\n          };\n          if (property.type === \"list\") {\n            property.name = propertValues[3];\n            property.countType = propertValues[1];\n            property.itemType = propertValues[2];\n          } else {\n            property.name = propertValues[1];\n          }\n          if (property.name in propertyNameMapping) {\n            property.name = propertyNameMapping[property.name];\n          }\n          return property;\n        }\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n          if (line === \"\") continue;\n          var lineValues = line.split(/\\s+/);\n          var lineType = lineValues.shift();\n          line = lineValues.join(\" \");\n          switch (lineType) {\n            case \"format\":\n              header.format = lineValues[0];\n              header.version = lineValues[1];\n              break;\n            case \"comment\":\n              header.comments.push(line);\n              break;\n            case \"element\":\n              if (currentElement !== void 0) {\n                header.elements.push(currentElement);\n              }\n              currentElement = {};\n              currentElement.name = lineValues[0];\n              currentElement.count = parseInt(lineValues[1]);\n              currentElement.properties = [];\n              break;\n            case \"property\":\n              currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n              break;\n            case \"obj_info\":\n              header.objInfo = line;\n              break;\n            default:\n              console.log(\"unhandled\", lineType, lineValues);\n          }\n        }\n        if (currentElement !== void 0) {\n          header.elements.push(currentElement);\n        }\n        return header;\n      }\n      function parseASCIINumber(n, type) {\n        switch (type) {\n          case \"char\":\n          case \"uchar\":\n          case \"short\":\n          case \"ushort\":\n          case \"int\":\n          case \"uint\":\n          case \"int8\":\n          case \"uint8\":\n          case \"int16\":\n          case \"uint16\":\n          case \"int32\":\n          case \"uint32\":\n            return parseInt(n);\n          case \"float\":\n          case \"double\":\n          case \"float32\":\n          case \"float64\":\n            return parseFloat(n);\n        }\n      }\n      function parseASCIIElement(properties, line) {\n        var values = line.split(/\\s+/);\n        var element = {};\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === \"list\") {\n            var list = [];\n            var n = parseASCIINumber(values.shift(), properties[i].countType);\n            for (var j = 0; j < n; j++) {\n              list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n            }\n            element[properties[i].name] = list;\n          } else {\n            element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n          }\n        }\n        return element;\n      }\n      function parseASCII(data2, header) {\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var result;\n        var patternBody = /end_header\\s([\\s\\S]*)$/;\n        var body = \"\";\n        if ((result = patternBody.exec(data2)) !== null) {\n          body = result[1];\n        }\n        var lines = body.split(\"\\n\");\n        var currentElement = 0;\n        var currentElementCount = 0;\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n          if (line === \"\") {\n            continue;\n          }\n          if (currentElementCount >= header.elements[currentElement].count) {\n            currentElement++;\n            currentElementCount = 0;\n          }\n          var element = parseASCIIElement(header.elements[currentElement].properties, line);\n          handleElement(buffer, header.elements[currentElement].name, element);\n          currentElementCount++;\n        }\n        return postProcess(buffer);\n      }\n      function postProcess(buffer) {\n        var geometry2 = new BufferGeometry();\n        if (buffer.indices.length > 0) {\n          geometry2.setIndex(buffer.indices);\n        }\n        geometry2.setAttribute(\"position\", new Float32BufferAttribute(buffer.vertices, 3));\n        if (buffer.normals.length > 0) {\n          geometry2.setAttribute(\"normal\", new Float32BufferAttribute(buffer.normals, 3));\n        }\n        if (buffer.uvs.length > 0) {\n          geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.uvs, 2));\n        }\n        if (buffer.colors.length > 0) {\n          geometry2.setAttribute(\"color\", new Float32BufferAttribute(buffer.colors, 3));\n        }\n        if (buffer.faceVertexUvs.length > 0) {\n          geometry2 = geometry2.toNonIndexed();\n          geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n        }\n        geometry2.computeBoundingSphere();\n        return geometry2;\n      }\n      function handleElement(buffer, elementName, element) {\n        if (elementName === \"vertex\") {\n          buffer.vertices.push(element.x, element.y, element.z);\n          if (\"nx\" in element && \"ny\" in element && \"nz\" in element) {\n            buffer.normals.push(element.nx, element.ny, element.nz);\n          }\n          if (\"s\" in element && \"t\" in element) {\n            buffer.uvs.push(element.s, element.t);\n          }\n          if (\"red\" in element && \"green\" in element && \"blue\" in element) {\n            buffer.colors.push(element.red / 255, element.green / 255, element.blue / 255);\n          }\n        } else if (elementName === \"face\") {\n          var vertex_indices = element.vertex_indices || element.vertex_index;\n          var texcoord = element.texcoord;\n          if (vertex_indices.length === 3) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n            if (texcoord && texcoord.length === 6) {\n              buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n              buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n              buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n            }\n          } else if (vertex_indices.length === 4) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n            buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n          }\n        }\n      }\n      function binaryRead(dataview, at, type, little_endian) {\n        switch (type) {\n          case \"int8\":\n          case \"char\":\n            return [dataview.getInt8(at), 1];\n          case \"uint8\":\n          case \"uchar\":\n            return [dataview.getUint8(at), 1];\n          case \"int16\":\n          case \"short\":\n            return [dataview.getInt16(at, little_endian), 2];\n          case \"uint16\":\n          case \"ushort\":\n            return [dataview.getUint16(at, little_endian), 2];\n          case \"int32\":\n          case \"int\":\n            return [dataview.getInt32(at, little_endian), 4];\n          case \"uint32\":\n          case \"uint\":\n            return [dataview.getUint32(at, little_endian), 4];\n          case \"float32\":\n          case \"float\":\n            return [dataview.getFloat32(at, little_endian), 4];\n          case \"float64\":\n          case \"double\":\n            return [dataview.getFloat64(at, little_endian), 8];\n        }\n      }\n      function binaryReadElement(dataview, at, properties, little_endian) {\n        var element = {};\n        var result,\n          read = 0;\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === \"list\") {\n            var list = [];\n            result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n            var n = result[0];\n            read += result[1];\n            for (var j = 0; j < n; j++) {\n              result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n              list.push(result[0]);\n              read += result[1];\n            }\n            element[properties[i].name] = list;\n          } else {\n            result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n            element[properties[i].name] = result[0];\n            read += result[1];\n          }\n        }\n        return [element, read];\n      }\n      function parseBinary(data2, header) {\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var little_endian = header.format === \"binary_little_endian\";\n        var body = new DataView(data2, header.headerLength);\n        var result,\n          loc = 0;\n        for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n          for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n            result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n            loc += result[1];\n            var element = result[0];\n            handleElement(buffer, header.elements[currentElement].name, element);\n          }\n        }\n        return postProcess(buffer);\n      }\n      var geometry;\n      var scope = this;\n      if (data instanceof ArrayBuffer) {\n        var text = LoaderUtils.decodeText(new Uint8Array(data));\n        var header = parseHeader(text);\n        geometry = header.format === \"ascii\" ? parseASCII(text, header) : parseBinary(data, header);\n      } else {\n        geometry = parseASCII(data, parseHeader(data));\n      }\n      return geometry;\n    }\n  }]);\n  return PLYLoader;\n}(Loader);\nexport { PLYLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","Float32BufferAttribute","LoaderUtils","PLYLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","propertyNameMapping","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","data","parseHeader","data2","patternHeader","headerText","headerLength","result","exec","Blob","size","header","comments","elements","objInfo","lines","split","currentElement","make_ply_element_property","propertValues","property","type","name","countType","itemType","i","length","line","trim","lineValues","lineType","shift","join","format","version","push","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","parseASCII","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","patternBody","body","currentElementCount","handleElement","postProcess","geometry2","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","x","y","z","nx","ny","nz","s","t","red","green","blue","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","parseBinary","DataView","loc","geometry","ArrayBuffer","decodeText","Uint8Array"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/PLYLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, LoaderUtils } from \"three\";\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.propertyNameMapping = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n  parse(data) {\n    function parseHeader(data2) {\n      const patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      let headerText = \"\";\n      let headerLength = 0;\n      const result = patternHeader.exec(data2);\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength,\n        objInfo: \"\"\n      };\n      const lines = headerText.split(\"\\n\");\n      let currentElement;\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = { type: propertValues[0] };\n        if (property.type === \"list\") {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === \"\")\n          continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(\" \");\n        switch (lineType) {\n          case \"format\":\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case \"comment\":\n            header.comments.push(line);\n            break;\n          case \"element\":\n            if (currentElement !== void 0) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case \"property\":\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case \"obj_info\":\n            header.objInfo = line;\n            break;\n          default:\n            console.log(\"unhandled\", lineType, lineValues);\n        }\n      }\n      if (currentElement !== void 0) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case \"char\":\n        case \"uchar\":\n        case \"short\":\n        case \"ushort\":\n        case \"int\":\n        case \"uint\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n          return parseInt(n);\n        case \"float\":\n        case \"double\":\n        case \"float32\":\n        case \"float64\":\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/);\n      const element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          const n = parseASCIINumber(values.shift(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function parseASCII(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      let result;\n      const patternBody = /end_header\\s([\\s\\S]*)$/;\n      let body = \"\";\n      if ((result = patternBody.exec(data2)) !== null) {\n        body = result[1];\n      }\n      const lines = body.split(\"\\n\");\n      let currentElement = 0;\n      let currentElementCount = 0;\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === \"\") {\n          continue;\n        }\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n        const element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      let geometry2 = new BufferGeometry();\n      if (buffer.indices.length > 0) {\n        geometry2.setIndex(buffer.indices);\n      }\n      geometry2.setAttribute(\"position\", new Float32BufferAttribute(buffer.vertices, 3));\n      if (buffer.normals.length > 0) {\n        geometry2.setAttribute(\"normal\", new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry2.setAttribute(\"color\", new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry2 = geometry2.toNonIndexed();\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n      geometry2.computeBoundingSphere();\n      return geometry2;\n    }\n    function handleElement(buffer, elementName, element) {\n      if (elementName === \"vertex\") {\n        buffer.vertices.push(element.x, element.y, element.z);\n        if (\"nx\" in element && \"ny\" in element && \"nz\" in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n        if (\"s\" in element && \"t\" in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n        if (\"red\" in element && \"green\" in element && \"blue\" in element) {\n          buffer.colors.push(element.red / 255, element.green / 255, element.blue / 255);\n        }\n      } else if (elementName === \"face\") {\n        const vertex_indices = element.vertex_indices || element.vertex_index;\n        const texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        case \"int8\":\n        case \"char\":\n          return [dataview.getInt8(at), 1];\n        case \"uint8\":\n        case \"uchar\":\n          return [dataview.getUint8(at), 1];\n        case \"int16\":\n        case \"short\":\n          return [dataview.getInt16(at, little_endian), 2];\n        case \"uint16\":\n        case \"ushort\":\n          return [dataview.getUint16(at, little_endian), 2];\n        case \"int32\":\n        case \"int\":\n          return [dataview.getInt32(at, little_endian), 4];\n        case \"uint32\":\n        case \"uint\":\n          return [dataview.getUint32(at, little_endian), 4];\n        case \"float32\":\n        case \"float\":\n          return [dataview.getFloat32(at, little_endian), 4];\n        case \"float64\":\n        case \"double\":\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {};\n      let result, read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          const n = result[0];\n          read += result[1];\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n      return [element, read];\n    }\n    function parseBinary(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      const little_endian = header.format === \"binary_little_endian\";\n      const body = new DataView(data2, header.headerLength);\n      let result, loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n      return postProcess(buffer);\n    }\n    let geometry;\n    const scope = this;\n    if (data instanceof ArrayBuffer) {\n      const text = LoaderUtils.decodeText(new Uint8Array(data));\n      const header = parseHeader(text);\n      geometry = header.format === \"ascii\" ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n}\nexport {\n  PLYLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}