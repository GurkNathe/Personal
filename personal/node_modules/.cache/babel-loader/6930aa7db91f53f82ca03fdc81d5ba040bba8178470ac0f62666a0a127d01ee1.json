{"ast":null,"code":"import { Vector3, Plane, Line3, Sphere, Box3, Triangle } from \"three\";\nimport { Capsule } from \"./Capsule.js\";\nconst _v1 = /* @__PURE__ */new Vector3();\nconst _v2 = /* @__PURE__ */new Vector3();\nconst _plane = /* @__PURE__ */new Plane();\nconst _line1 = /* @__PURE__ */new Line3();\nconst _line2 = /* @__PURE__ */new Line3();\nconst _sphere = /* @__PURE__ */new Sphere();\nconst _capsule = /* @__PURE__ */new Capsule();\nclass Octree {\n  constructor(box) {\n    this.triangles = [];\n    this.box = box;\n    this.subTrees = [];\n  }\n  addTriangle(triangle) {\n    if (!this.bounds) this.bounds = new Box3();\n    this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.triangles.push(triangle);\n    return this;\n  }\n  calcBox() {\n    this.box = this.bounds.clone();\n    this.box.min.x -= 0.01;\n    this.box.min.y -= 0.01;\n    this.box.min.z -= 0.01;\n    return this;\n  }\n  split(level) {\n    if (!this.box) return;\n    const subTrees = [];\n    const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5);\n    for (let x = 0; x < 2; x++) {\n      for (let y = 0; y < 2; y++) {\n        for (let z = 0; z < 2; z++) {\n          const box = new Box3();\n          const v = _v1.set(x, y, z);\n          box.min.copy(this.box.min).add(v.multiply(halfsize));\n          box.max.copy(box.min).add(halfsize);\n          subTrees.push(new Octree(box));\n        }\n      }\n    }\n    let triangle;\n    while (triangle = this.triangles.pop()) {\n      for (let i = 0; i < subTrees.length; i++) {\n        if (subTrees[i].box.intersectsTriangle(triangle)) {\n          subTrees[i].triangles.push(triangle);\n        }\n      }\n    }\n    for (let i = 0; i < subTrees.length; i++) {\n      const len = subTrees[i].triangles.length;\n      if (len > 8 && level < 16) {\n        subTrees[i].split(level + 1);\n      }\n      if (len !== 0) {\n        this.subTrees.push(subTrees[i]);\n      }\n    }\n    return this;\n  }\n  build() {\n    this.calcBox();\n    this.split(0);\n    return this;\n  }\n  getRayTriangles(ray, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!ray.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getRayTriangles(ray, triangles);\n      }\n    }\n    return triangles;\n  }\n  triangleCapsuleIntersect(capsule, triangle) {\n    triangle.getPlane(_plane);\n    const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\n    const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\n    if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\n      return false;\n    }\n    const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\n    const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\n    if (triangle.containsPoint(intersectPoint)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: intersectPoint.clone(),\n        depth: Math.abs(Math.min(d1, d2))\n      };\n    }\n    const r2 = capsule.radius * capsule.radius;\n    const line1 = _line1.set(capsule.start, capsule.end);\n    const lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n    for (let i = 0; i < lines.length; i++) {\n      const line2 = _line2.set(lines[i][0], lines[i][1]);\n      const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);\n      if (point1.distanceToSquared(point2) < r2) {\n        return {\n          normal: point1.clone().sub(point2).normalize(),\n          point: point2.clone(),\n          depth: capsule.radius - point1.distanceTo(point2)\n        };\n      }\n    }\n    return false;\n  }\n  triangleSphereIntersect(sphere, triangle) {\n    triangle.getPlane(_plane);\n    if (!sphere.intersectsPlane(_plane)) return false;\n    const depth = Math.abs(_plane.distanceToSphere(sphere));\n    const r2 = sphere.radius * sphere.radius - depth * depth;\n    const plainPoint = _plane.projectPoint(sphere.center, _v1);\n    if (triangle.containsPoint(sphere.center)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: plainPoint.clone(),\n        depth: Math.abs(_plane.distanceToSphere(sphere))\n      };\n    }\n    const lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n    for (let i = 0; i < lines.length; i++) {\n      _line1.set(lines[i][0], lines[i][1]);\n      _line1.closestPointToPoint(plainPoint, true, _v2);\n      const d = _v2.distanceToSquared(sphere.center);\n      if (d < r2) {\n        return {\n          normal: sphere.center.clone().sub(_v2).normalize(),\n          point: _v2.clone(),\n          depth: sphere.radius - Math.sqrt(d)\n        };\n      }\n    }\n    return false;\n  }\n  getSphereTriangles(sphere, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!sphere.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getSphereTriangles(sphere, triangles);\n      }\n    }\n  }\n  getCapsuleTriangles(capsule, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!capsule.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getCapsuleTriangles(capsule, triangles);\n      }\n    }\n  }\n  sphereIntersect(sphere) {\n    _sphere.copy(sphere);\n    const triangles = [];\n    let result,\n      hit = false;\n    this.getSphereTriangles(sphere, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\n        hit = true;\n        _sphere.center.add(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _sphere.center.clone().sub(sphere.center);\n      const depth = collisionVector.length();\n      return {\n        normal: collisionVector.normalize(),\n        depth\n      };\n    }\n    return false;\n  }\n  capsuleIntersect(capsule) {\n    _capsule.copy(capsule);\n    const triangles = [];\n    let result,\n      hit = false;\n    this.getCapsuleTriangles(_capsule, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\n        hit = true;\n        _capsule.translate(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\n      const depth = collisionVector.length();\n      return {\n        normal: collisionVector.normalize(),\n        depth\n      };\n    }\n    return false;\n  }\n  rayIntersect(ray) {\n    if (ray.direction.length() === 0) return;\n    const triangles = [];\n    let triangle,\n      position,\n      distance = 1e100;\n    this.getRayTriangles(ray, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\n      if (result) {\n        const newdistance = result.sub(ray.origin).length();\n        if (distance > newdistance) {\n          position = result.clone().add(ray.origin);\n          distance = newdistance;\n          triangle = triangles[i];\n        }\n      }\n    }\n    return distance < 1e100 ? {\n      distance,\n      triangle,\n      position\n    } : false;\n  }\n  fromGraphNode(group) {\n    group.updateWorldMatrix(true, true);\n    group.traverse(obj => {\n      if (obj.isMesh === true) {\n        let geometry,\n          isTemp = false;\n        if (obj.geometry.index !== null) {\n          isTemp = true;\n          geometry = obj.geometry.toNonIndexed();\n        } else {\n          geometry = obj.geometry;\n        }\n        const positionAttribute = geometry.getAttribute(\"position\");\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const v1 = new Vector3().fromBufferAttribute(positionAttribute, i);\n          const v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1);\n          const v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2);\n          v1.applyMatrix4(obj.matrixWorld);\n          v2.applyMatrix4(obj.matrixWorld);\n          v3.applyMatrix4(obj.matrixWorld);\n          this.addTriangle(new Triangle(v1, v2, v3));\n        }\n        if (isTemp) {\n          geometry.dispose();\n        }\n      }\n    });\n    this.build();\n    return this;\n  }\n}\nexport { Octree };","map":{"version":3,"names":["Vector3","Plane","Line3","Sphere","Box3","Triangle","Capsule","_v1","_v2","_plane","_line1","_line2","_sphere","_capsule","Octree","constructor","box","triangles","subTrees","addTriangle","triangle","bounds","min","x","Math","a","b","c","y","z","max","push","calcBox","clone","split","level","halfsize","copy","sub","multiplyScalar","v","set","add","multiply","pop","i","length","intersectsTriangle","len","build","getRayTriangles","ray","subTree","intersectsBox","j","indexOf","triangleCapsuleIntersect","capsule","getPlane","d1","distanceToPoint","start","radius","d2","end","delta","abs","intersectPoint","lerp","containsPoint","normal","point","depth","r2","line1","lines","line2","point1","point2","lineLineMinimumPoints","distanceToSquared","normalize","distanceTo","triangleSphereIntersect","sphere","intersectsPlane","distanceToSphere","plainPoint","projectPoint","center","closestPointToPoint","d","sqrt","getSphereTriangles","getCapsuleTriangles","sphereIntersect","result","hit","collisionVector","capsuleIntersect","translate","getCenter","rayIntersect","direction","position","distance","intersectTriangle","newdistance","origin","fromGraphNode","group","updateWorldMatrix","traverse","obj","isMesh","geometry","isTemp","index","toNonIndexed","positionAttribute","getAttribute","count","v1","fromBufferAttribute","v2","v3","applyMatrix4","matrixWorld","dispose"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/math/Octree.js"],"sourcesContent":["import { Vector3, Plane, Line3, Sphere, Box3, Triangle } from \"three\";\nimport { Capsule } from \"./Capsule.js\";\nconst _v1 = /* @__PURE__ */ new Vector3();\nconst _v2 = /* @__PURE__ */ new Vector3();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _line1 = /* @__PURE__ */ new Line3();\nconst _line2 = /* @__PURE__ */ new Line3();\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst _capsule = /* @__PURE__ */ new Capsule();\nclass Octree {\n  constructor(box) {\n    this.triangles = [];\n    this.box = box;\n    this.subTrees = [];\n  }\n  addTriangle(triangle) {\n    if (!this.bounds)\n      this.bounds = new Box3();\n    this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.triangles.push(triangle);\n    return this;\n  }\n  calcBox() {\n    this.box = this.bounds.clone();\n    this.box.min.x -= 0.01;\n    this.box.min.y -= 0.01;\n    this.box.min.z -= 0.01;\n    return this;\n  }\n  split(level) {\n    if (!this.box)\n      return;\n    const subTrees = [];\n    const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5);\n    for (let x = 0; x < 2; x++) {\n      for (let y = 0; y < 2; y++) {\n        for (let z = 0; z < 2; z++) {\n          const box = new Box3();\n          const v = _v1.set(x, y, z);\n          box.min.copy(this.box.min).add(v.multiply(halfsize));\n          box.max.copy(box.min).add(halfsize);\n          subTrees.push(new Octree(box));\n        }\n      }\n    }\n    let triangle;\n    while (triangle = this.triangles.pop()) {\n      for (let i = 0; i < subTrees.length; i++) {\n        if (subTrees[i].box.intersectsTriangle(triangle)) {\n          subTrees[i].triangles.push(triangle);\n        }\n      }\n    }\n    for (let i = 0; i < subTrees.length; i++) {\n      const len = subTrees[i].triangles.length;\n      if (len > 8 && level < 16) {\n        subTrees[i].split(level + 1);\n      }\n      if (len !== 0) {\n        this.subTrees.push(subTrees[i]);\n      }\n    }\n    return this;\n  }\n  build() {\n    this.calcBox();\n    this.split(0);\n    return this;\n  }\n  getRayTriangles(ray, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!ray.intersectsBox(subTree.box))\n        continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1)\n            triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getRayTriangles(ray, triangles);\n      }\n    }\n    return triangles;\n  }\n  triangleCapsuleIntersect(capsule, triangle) {\n    triangle.getPlane(_plane);\n    const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\n    const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\n    if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\n      return false;\n    }\n    const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\n    const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\n    if (triangle.containsPoint(intersectPoint)) {\n      return { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs(Math.min(d1, d2)) };\n    }\n    const r2 = capsule.radius * capsule.radius;\n    const line1 = _line1.set(capsule.start, capsule.end);\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a]\n    ];\n    for (let i = 0; i < lines.length; i++) {\n      const line2 = _line2.set(lines[i][0], lines[i][1]);\n      const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);\n      if (point1.distanceToSquared(point2) < r2) {\n        return {\n          normal: point1.clone().sub(point2).normalize(),\n          point: point2.clone(),\n          depth: capsule.radius - point1.distanceTo(point2)\n        };\n      }\n    }\n    return false;\n  }\n  triangleSphereIntersect(sphere, triangle) {\n    triangle.getPlane(_plane);\n    if (!sphere.intersectsPlane(_plane))\n      return false;\n    const depth = Math.abs(_plane.distanceToSphere(sphere));\n    const r2 = sphere.radius * sphere.radius - depth * depth;\n    const plainPoint = _plane.projectPoint(sphere.center, _v1);\n    if (triangle.containsPoint(sphere.center)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: plainPoint.clone(),\n        depth: Math.abs(_plane.distanceToSphere(sphere))\n      };\n    }\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a]\n    ];\n    for (let i = 0; i < lines.length; i++) {\n      _line1.set(lines[i][0], lines[i][1]);\n      _line1.closestPointToPoint(plainPoint, true, _v2);\n      const d = _v2.distanceToSquared(sphere.center);\n      if (d < r2) {\n        return {\n          normal: sphere.center.clone().sub(_v2).normalize(),\n          point: _v2.clone(),\n          depth: sphere.radius - Math.sqrt(d)\n        };\n      }\n    }\n    return false;\n  }\n  getSphereTriangles(sphere, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!sphere.intersectsBox(subTree.box))\n        continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1)\n            triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getSphereTriangles(sphere, triangles);\n      }\n    }\n  }\n  getCapsuleTriangles(capsule, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!capsule.intersectsBox(subTree.box))\n        continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1)\n            triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getCapsuleTriangles(capsule, triangles);\n      }\n    }\n  }\n  sphereIntersect(sphere) {\n    _sphere.copy(sphere);\n    const triangles = [];\n    let result, hit = false;\n    this.getSphereTriangles(sphere, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\n        hit = true;\n        _sphere.center.add(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _sphere.center.clone().sub(sphere.center);\n      const depth = collisionVector.length();\n      return { normal: collisionVector.normalize(), depth };\n    }\n    return false;\n  }\n  capsuleIntersect(capsule) {\n    _capsule.copy(capsule);\n    const triangles = [];\n    let result, hit = false;\n    this.getCapsuleTriangles(_capsule, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\n        hit = true;\n        _capsule.translate(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\n      const depth = collisionVector.length();\n      return { normal: collisionVector.normalize(), depth };\n    }\n    return false;\n  }\n  rayIntersect(ray) {\n    if (ray.direction.length() === 0)\n      return;\n    const triangles = [];\n    let triangle, position, distance = 1e100;\n    this.getRayTriangles(ray, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\n      if (result) {\n        const newdistance = result.sub(ray.origin).length();\n        if (distance > newdistance) {\n          position = result.clone().add(ray.origin);\n          distance = newdistance;\n          triangle = triangles[i];\n        }\n      }\n    }\n    return distance < 1e100 ? { distance, triangle, position } : false;\n  }\n  fromGraphNode(group) {\n    group.updateWorldMatrix(true, true);\n    group.traverse((obj) => {\n      if (obj.isMesh === true) {\n        let geometry, isTemp = false;\n        if (obj.geometry.index !== null) {\n          isTemp = true;\n          geometry = obj.geometry.toNonIndexed();\n        } else {\n          geometry = obj.geometry;\n        }\n        const positionAttribute = geometry.getAttribute(\"position\");\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const v1 = new Vector3().fromBufferAttribute(positionAttribute, i);\n          const v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1);\n          const v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2);\n          v1.applyMatrix4(obj.matrixWorld);\n          v2.applyMatrix4(obj.matrixWorld);\n          v3.applyMatrix4(obj.matrixWorld);\n          this.addTriangle(new Triangle(v1, v2, v3));\n        }\n        if (isTemp) {\n          geometry.dispose();\n        }\n      }\n    });\n    this.build();\n    return this;\n  }\n}\nexport {\n  Octree\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}