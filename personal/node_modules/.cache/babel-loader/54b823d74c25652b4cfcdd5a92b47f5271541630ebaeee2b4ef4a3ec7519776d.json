{"ast":null,"code":"import _assertThisInitialized from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, Scene, Object3D, Group, Vector3, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, RepeatWrapping, ClampToEdgeWrapping, DataTexture, Vector2, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, TextureLoader } from \"three\";\nimport { createToken, Lexer, CstParser } from \"chevrotain\";\nvar VRMLLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(VRMLLoader, _Loader);\n  var _super = _createSuper(VRMLLoader);\n  function VRMLLoader(manager) {\n    _classCallCheck(this, VRMLLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(VRMLLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, path) {\n      var nodeMap = {};\n      function generateVRMLTree(data2) {\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n        var lexingResult = lexer.lex(data2);\n        parser.input = lexingResult.tokens;\n        var cstOutput = parser.vrml();\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error(\"THREE.VRMLLoader: Parsing errors detected.\");\n        }\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n      function createTokens() {\n        var RouteIdentifier = createToken({\n          name: \"RouteIdentifier\",\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: \"Identifier\",\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        });\n        var nodeTypes = [\"Anchor\", \"Billboard\", \"Collision\", \"Group\", \"Transform\",\n        // grouping nodes\n        \"Inline\", \"LOD\", \"Switch\",\n        // special groups\n        \"AudioClip\", \"DirectionalLight\", \"PointLight\", \"Script\", \"Shape\", \"Sound\", \"SpotLight\", \"WorldInfo\",\n        // common nodes\n        \"CylinderSensor\", \"PlaneSensor\", \"ProximitySensor\", \"SphereSensor\", \"TimeSensor\", \"TouchSensor\", \"VisibilitySensor\",\n        // sensors\n        \"Box\", \"Cone\", \"Cylinder\", \"ElevationGrid\", \"Extrusion\", \"IndexedFaceSet\", \"IndexedLineSet\", \"PointSet\", \"Sphere\",\n        // geometries\n        \"Color\", \"Coordinate\", \"Normal\", \"TextureCoordinate\",\n        // geometric properties\n        \"Appearance\", \"FontStyle\", \"ImageTexture\", \"Material\", \"MovieTexture\", \"PixelTexture\", \"TextureTransform\",\n        // appearance\n        \"ColorInterpolator\", \"CoordinateInterpolator\", \"NormalInterpolator\", \"OrientationInterpolator\", \"PositionInterpolator\", \"ScalarInterpolator\",\n        // interpolators\n        \"Background\", \"Fog\", \"NavigationInfo\", \"Viewpoint\",\n        // bindable nodes\n        \"Text\"\n        // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ];\n\n        var Version = createToken({\n          name: \"Version\",\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: \"NodeName\",\n          pattern: new RegExp(nodeTypes.join(\"|\")),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: \"DEF\",\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: \"USE\",\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: \"ROUTE\",\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: \"TO\",\n          pattern: /TO/,\n          longer_alt: Identifier\n        });\n        var StringLiteral = createToken({\n          name: \"StringLiteral\",\n          pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n        });\n        var HexLiteral = createToken({\n          name: \"HexLiteral\",\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: \"NumberLiteral\",\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: \"TrueLiteral\",\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: \"FalseLiteral\",\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: \"NullLiteral\",\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: \"LSquare\",\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: \"RSquare\",\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: \"LCurly\",\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: \"RCurly\",\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: \"Comment\",\n          pattern: /#.*/,\n          group: Lexer.SKIPPED\n        });\n        var WhiteSpace = createToken({\n          name: \"WhiteSpace\",\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED\n        });\n        var tokens = [WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n      function createVisitor(BaseVRMLVisitor) {\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function vrml(ctx) {\n            var data2 = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data2.nodes.push(this.visit(node));\n            }\n            if (ctx.route) {\n              for (var _i = 0, _l = ctx.route.length; _i < _l; _i++) {\n                var route = ctx.route[_i];\n                data2.routes.push(this.visit(route));\n              }\n            }\n            return data2;\n          },\n          version: function version(ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function node(ctx) {\n            var data2 = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n            if (ctx.field) {\n              for (var i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data2.fields.push(this.visit(field));\n              }\n            }\n            if (ctx.def) {\n              data2.DEF = this.visit(ctx.def[0]);\n            }\n            return data2;\n          },\n          field: function field(ctx) {\n            var data2 = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result;\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            }\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n            data2.type = result.type;\n            data2.values = result.values;\n            return data2;\n          },\n          def: function def(ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function use(ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function singleFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function multiFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          route: function route(ctx) {\n            var data2 = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data2;\n          }\n        });\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n          if (ctx.node) {\n            field.type = \"node\";\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n          if (ctx.use) {\n            field.type = \"use\";\n            for (var _i2 = 0, _l2 = ctx.use.length; _i2 < _l2; _i2++) {\n              var use = ctx.use[_i2];\n              field.values.push(scope.visit(use));\n            }\n          }\n          if (ctx.StringLiteral) {\n            field.type = \"string\";\n            for (var _i3 = 0, _l3 = ctx.StringLiteral.length; _i3 < _l3; _i3++) {\n              var stringLiteral = ctx.StringLiteral[_i3];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, \"\"));\n            }\n          }\n          if (ctx.NumberLiteral) {\n            field.type = \"number\";\n            for (var _i4 = 0, _l4 = ctx.NumberLiteral.length; _i4 < _l4; _i4++) {\n              var numberLiteral = ctx.NumberLiteral[_i4];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n          if (ctx.HexLiteral) {\n            field.type = \"hex\";\n            for (var _i5 = 0, _l5 = ctx.HexLiteral.length; _i5 < _l5; _i5++) {\n              var hexLiteral = ctx.HexLiteral[_i5];\n              field.values.push(hexLiteral.image);\n            }\n          }\n          if (ctx.TrueLiteral) {\n            field.type = \"boolean\";\n            for (var _i6 = 0, _l6 = ctx.TrueLiteral.length; _i6 < _l6; _i6++) {\n              var trueLiteral = ctx.TrueLiteral[_i6];\n              if (trueLiteral.image === \"TRUE\") field.values.push(true);\n            }\n          }\n          if (ctx.FalseLiteral) {\n            field.type = \"boolean\";\n            for (var _i7 = 0, _l7 = ctx.FalseLiteral.length; _i7 < _l7; _i7++) {\n              var falseLiteral = ctx.FalseLiteral[_i7];\n              if (falseLiteral.image === \"FALSE\") field.values.push(false);\n            }\n          }\n          if (ctx.NullLiteral) {\n            field.type = \"null\";\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n          return field;\n        }\n        return new VRMLToASTVisitor();\n      }\n      function parseTree(tree2) {\n        var nodes = tree2.nodes;\n        var scene2 = new Scene();\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        }\n        for (var _i8 = 0, _l8 = nodes.length; _i8 < _l8; _i8++) {\n          var _node = nodes[_i8];\n          var object = getNode(_node);\n          if (object instanceof Object3D) scene2.add(object);\n          if (_node.name === \"WorldInfo\") scene2.userData.worldInfo = object;\n        }\n        return scene2;\n      }\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          if (field.type === \"node\") {\n            var fieldValues = field.values;\n            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n      function getNode(node) {\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n        if (node.build !== void 0) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      }\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n        switch (nodeName) {\n          case \"Group\":\n          case \"Transform\":\n          case \"Collision\":\n            build = buildGroupingNode(node);\n            break;\n          case \"Background\":\n            build = buildBackgroundNode(node);\n            break;\n          case \"Shape\":\n            build = buildShapeNode(node);\n            break;\n          case \"Appearance\":\n            build = buildAppearanceNode(node);\n            break;\n          case \"Material\":\n            build = buildMaterialNode(node);\n            break;\n          case \"ImageTexture\":\n            build = buildImageTextureNode(node);\n            break;\n          case \"PixelTexture\":\n            build = buildPixelTextureNode(node);\n            break;\n          case \"TextureTransform\":\n            build = buildTextureTransformNode(node);\n            break;\n          case \"IndexedFaceSet\":\n            build = buildIndexedFaceSetNode(node);\n            break;\n          case \"IndexedLineSet\":\n            build = buildIndexedLineSetNode(node);\n            break;\n          case \"PointSet\":\n            build = buildPointSetNode(node);\n            break;\n          case \"Box\":\n            build = buildBoxNode(node);\n            break;\n          case \"Cone\":\n            build = buildConeNode(node);\n            break;\n          case \"Cylinder\":\n            build = buildCylinderNode(node);\n            break;\n          case \"Sphere\":\n            build = buildSphereNode(node);\n            break;\n          case \"ElevationGrid\":\n            build = buildElevationGridNode(node);\n            break;\n          case \"Extrusion\":\n            build = buildExtrusionNode(node);\n            break;\n          case \"Color\":\n          case \"Coordinate\":\n          case \"Normal\":\n          case \"TextureCoordinate\":\n            build = buildGeometricNode(node);\n            break;\n          case \"WorldInfo\":\n            build = buildWorldInfoNode(node);\n            break;\n          case \"Anchor\":\n          case \"Billboard\":\n          case \"Inline\":\n          case \"LOD\":\n          case \"Switch\":\n          case \"AudioClip\":\n          case \"DirectionalLight\":\n          case \"PointLight\":\n          case \"Script\":\n          case \"Sound\":\n          case \"SpotLight\":\n          case \"CylinderSensor\":\n          case \"PlaneSensor\":\n          case \"ProximitySensor\":\n          case \"SphereSensor\":\n          case \"TimeSensor\":\n          case \"TouchSensor\":\n          case \"VisibilitySensor\":\n          case \"Text\":\n          case \"FontStyle\":\n          case \"MovieTexture\":\n          case \"ColorInterpolator\":\n          case \"CoordinateInterpolator\":\n          case \"NormalInterpolator\":\n          case \"OrientationInterpolator\":\n          case \"PositionInterpolator\":\n          case \"ScalarInterpolator\":\n          case \"Fog\":\n          case \"NavigationInfo\":\n          case \"Viewpoint\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown node:\", nodeName);\n            break;\n        }\n        if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty(\"name\") === true) {\n          build.name = node.DEF;\n        }\n        return build;\n      }\n      function buildGroupingNode(node) {\n        var object = new Group();\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"bboxCenter\":\n              break;\n            case \"bboxSize\":\n              break;\n            case \"center\":\n              break;\n            case \"children\":\n              parseFieldChildren(fieldValues, object);\n              break;\n            case \"collide\":\n              break;\n            case \"rotation\":\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n            case \"scale\":\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"scaleOrientation\":\n              break;\n            case \"translation\":\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"proxy\":\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return object;\n      }\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"groundAngle\":\n              groundAngle = fieldValues;\n              break;\n            case \"groundColor\":\n              groundColor = fieldValues;\n              break;\n            case \"backUrl\":\n              break;\n            case \"bottomUrl\":\n              break;\n            case \"frontUrl\":\n              break;\n            case \"leftUrl\":\n              break;\n            case \"rightUrl\":\n              break;\n            case \"topUrl\":\n              break;\n            case \"skyAngle\":\n              skyAngle = fieldValues;\n              break;\n            case \"skyColor\":\n              skyColor = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var radius = 1e4;\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        }\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        }\n        group.renderOrder = -Infinity;\n        return group;\n      }\n      function buildShapeNode(node) {\n        var fields = node.fields;\n        var material = new MeshBasicMaterial({\n          color: 0\n        });\n        var geometry;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"appearance\":\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n              break;\n            case \"geometry\":\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var object;\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n          if (type === \"points\") {\n            var pointsMaterial = new PointsMaterial({\n              color: 16777215\n            });\n            if (geometry.attributes.color !== void 0) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === \"line\") {\n            var lineMaterial = new LineBasicMaterial({\n              color: 16777215\n            });\n            if (geometry.attributes.color !== void 0) {\n              lineMaterial.vertexColors = true;\n            } else {\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            if (geometry._solid !== void 0) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            }\n            if (geometry.attributes.color !== void 0) {\n              material.vertexColors = true;\n            }\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D();\n          object.visible = false;\n        }\n        return object;\n      }\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"material\":\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                material = new MeshBasicMaterial({\n                  color: 0\n                });\n              }\n              break;\n            case \"texture\":\n              var textureNode = fieldValues[0];\n              if (textureNode !== null) {\n                if (textureNode.name === \"ImageTexture\" || textureNode.name === \"PixelTexture\") {\n                  material.map = getNode(textureNode);\n                } else {}\n              }\n              break;\n            case \"textureTransform\":\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (material.map) {\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1;\n                break;\n              case TEXTURE_TYPE.RGB:\n                material.color.set(16777215);\n                break;\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(16777215);\n                material.opacity = 1;\n                break;\n              default:\n            }\n            delete material.map.__type;\n          }\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n        return material;\n      }\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"ambientIntensity\":\n              break;\n            case \"diffuseColor\":\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"emissiveColor\":\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"shininess\":\n              materialData.shininess = fieldValues[0];\n              break;\n            case \"specularColor\":\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"transparency\":\n              materialData.transparency = fieldValues[0];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return materialData;\n      }\n      function parseHexColor(hex, textureType, color) {\n        var value;\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = 1;\n            break;\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            value = parseInt(\"0x\" + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt(\"0x\" + hex.substring(4, 6));\n            break;\n          case TEXTURE_TYPE.RGB:\n            color.r = parseInt(\"0x\" + hex.substring(2, 4));\n            color.g = parseInt(\"0x\" + hex.substring(4, 6));\n            color.b = parseInt(\"0x\" + hex.substring(6, 8));\n            color.a = 1;\n            break;\n          case TEXTURE_TYPE.RGBA:\n            color.r = parseInt(\"0x\" + hex.substring(2, 4));\n            color.g = parseInt(\"0x\" + hex.substring(4, 6));\n            color.b = parseInt(\"0x\" + hex.substring(6, 8));\n            color.a = parseInt(\"0x\" + hex.substring(8, 10));\n            break;\n          default:\n        }\n      }\n      function getTextureType(num_components) {\n        var type;\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n          default:\n        }\n        return type;\n      }\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"image\":\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var textureType = getTextureType(num_components);\n              var data2 = new Uint8Array(4 * width * height);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n              for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n                var stride = k * 4;\n                data2[stride + 0] = color.r;\n                data2[stride + 1] = color.g;\n                data2[stride + 2] = color.b;\n                data2[stride + 3] = color.a;\n              }\n              texture = new DataTexture(data2, width, height);\n              texture.needsUpdate = true;\n              texture.__type = textureType;\n              break;\n            case \"repeatS\":\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case \"repeatT\":\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"url\":\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n            case \"repeatS\":\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case \"repeatT\":\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"center\":\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n            case \"rotation\":\n              transformData.rotation = fieldValues[0];\n              break;\n            case \"scale\":\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n            case \"translation\":\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return transformData;\n      }\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"title\":\n              worldInfo.title = fieldValues[0];\n              break;\n            case \"info\":\n              worldInfo.info = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return worldInfo;\n      }\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n          solid = true,\n          creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n          normalPerVertex = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"coord\":\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case \"normal\":\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case \"texCoord\":\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n            case \"colorIndex\":\n              colorIndex = fieldValues;\n              break;\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n            case \"convex\":\n              break;\n            case \"coordIndex\":\n              coordIndex = fieldValues;\n              break;\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n            case \"normalIndex\":\n              normalIndex = fieldValues;\n              break;\n            case \"normalPerVertex\":\n              normalPerVertex = fieldValues[0];\n              break;\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n            case \"texCoordIndex\":\n              texCoordIndex = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (coordIndex === void 0) {\n          console.warn(\"THREE.VRMLLoader: Missing coordIndex.\");\n          return new BufferGeometry();\n        }\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              var _triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceColors);\n            }\n          }\n        }\n        if (normal) {\n          if (normalPerVertex === true) {\n            if (normalIndex && normalIndex.length > 0) {\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            if (normalIndex && normalIndex.length > 0) {\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              var _triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceNormals);\n            }\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n        if (texCoord) {\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        if (uvAttribute) geometry.setAttribute(\"uv\", uvAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"coord\":\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case \"colorIndex\":\n              colorIndex = fieldValues;\n              break;\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n            case \"coordIndex\":\n              coordIndex = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex);\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              var expandedColorIndex = expandLineIndex(colorIndex);\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n            } else {\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              var flattenLineColors = flattenData(color, colorIndex);\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n            } else {\n              var _expandedLineColors = expandLineData(color, coordIndex);\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, _expandedLineColors);\n            }\n          }\n        }\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute(\"position\", positionAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        geometry._type = \"line\";\n        return geometry;\n      }\n      function buildPointSetNode(node) {\n        var color, coord;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"coord\":\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n        geometry._type = \"points\";\n        return geometry;\n      }\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"size\":\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n      function buildConeNode(node) {\n        var radius = 1,\n          height = 2,\n          openEnded = false;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"bottom\":\n              openEnded = !fieldValues[0];\n              break;\n            case \"bottomRadius\":\n              radius = fieldValues[0];\n              break;\n            case \"height\":\n              height = fieldValues[0];\n              break;\n            case \"side\":\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n      function buildCylinderNode(node) {\n        var radius = 1,\n          height = 2;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"bottom\":\n              break;\n            case \"radius\":\n              radius = fieldValues[0];\n              break;\n            case \"height\":\n              height = fieldValues[0];\n              break;\n            case \"side\":\n              break;\n            case \"top\":\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"radius\":\n              radius = fieldValues[0];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"normal\":\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case \"texCoord\":\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case \"height\":\n              height = fieldValues;\n              break;\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n            case \"normalPerVertex\":\n              normalPerVertex = fieldValues[0];\n              break;\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n            case \"xDimension\":\n              xDimension = fieldValues[0];\n              break;\n            case \"xSpacing\":\n              xSpacing = fieldValues[0];\n              break;\n            case \"zDimension\":\n              zDimension = fieldValues[0];\n              break;\n            case \"zSpacing\":\n              zSpacing = fieldValues[0];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n        for (var _i9 = 0; _i9 < zDimension; _i9++) {\n          for (var j = 0; j < xDimension; j++) {\n            var index = _i9 * xDimension + j;\n            var x = xSpacing * _i9;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z);\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            }\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            }\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(_i9 / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        }\n        var indices = [];\n        for (var _i10 = 0; _i10 < xDimension - 1; _i10++) {\n          for (var _j = 0; _j < zDimension - 1; _j++) {\n            var a = _i10 + _j * xDimension;\n            var _b = _i10 + (_j + 1) * xDimension;\n            var c = _i10 + 1 + (_j + 1) * xDimension;\n            var d = _i10 + 1 + _j * xDimension;\n            if (ccw === true) {\n              indices.push(a, c, _b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, _b, c);\n              indices.push(c, d, a);\n            }\n          }\n        }\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute;\n        if (color) {\n          if (colorPerVertex === false) {\n            for (var _i11 = 0; _i11 < xDimension - 1; _i11++) {\n              for (var _j2 = 0; _j2 < zDimension - 1; _j2++) {\n                var _index = _i11 + _j2 * (xDimension - 1);\n                var _r = color[_index * 3 + 0];\n                var _g = color[_index * 3 + 1];\n                var _b2 = color[_index * 3 + 2];\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n              }\n            }\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        }\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (var _i12 = 0; _i12 < xDimension - 1; _i12++) {\n              for (var _j3 = 0; _j3 < zDimension - 1; _j3++) {\n                var _index2 = _i12 + _j3 * (xDimension - 1);\n                var _xn = normal[_index2 * 3 + 0];\n                var _yn = normal[_index2 * 3 + 1];\n                var _zn = normal[_index2 * 3 + 2];\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n              }\n            }\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        }\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        geometry.setAttribute(\"uv\", uvAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"beginCap\":\n              beginCap = fieldValues[0];\n              break;\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n            case \"convex\":\n              break;\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n            case \"crossSection\":\n              crossSection = fieldValues;\n              break;\n            case \"endCap\":\n              endCap = fieldValues[0];\n              break;\n            case \"orientation\":\n              orientation = fieldValues;\n              break;\n            case \"scale\":\n              scale = fieldValues;\n              break;\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n            case \"spine\":\n              spine = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n        for (var _i13 = 0, j = 0, o = 0, il = spine.length; _i13 < il; _i13 += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, _i13);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n          for (var k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1];\n            vertex.multiply(scaling);\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion);\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        }\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n        for (var _i14 = 0; _i14 < spineCount - 1; _i14++) {\n          for (var _j4 = 0; _j4 < crossSectionCount - 1; _j4++) {\n            var a = _j4 + _i14 * crossSectionCount;\n            var b = _j4 + 1 + _i14 * crossSectionCount;\n            var c = _j4 + (_i14 + 1) * crossSectionCount;\n            var d = _j4 + 1 + (_i14 + 1) * crossSectionCount;\n            if (_j4 === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = _i14 * crossSectionCount;\n              d = (_i14 + 1) * crossSectionCount;\n            }\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        }\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n          for (var _i15 = 0, _l9 = crossSection.length; _i15 < _l9; _i15 += 2) {\n            contour.push(new Vector2(crossSection[_i15], crossSection[_i15 + 1]));\n          }\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n          for (var _i16 = 0, _l10 = faces.length; _i16 < _l10; _i16++) {\n            var face = faces[_i16];\n            capIndices.push(face[0], face[1], face[2]);\n          }\n          if (beginCap === true) {\n            for (var _i17 = 0, _l11 = capIndices.length; _i17 < _l11; _i17 += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 1], capIndices[_i17 + 2]);\n              } else {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 2], capIndices[_i17 + 1]);\n              }\n            }\n          }\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1);\n            for (var _i18 = 0, _l12 = capIndices.length; _i18 < _l12; _i18 += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 2], indexOffset + capIndices[_i18 + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 1], indexOffset + capIndices[_i18 + 2]);\n              }\n            }\n          }\n        }\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node);\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n      function parseFieldChildren(children, owner) {\n        for (var i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n      function triangulateFaceIndex(index, ccw) {\n        var indices = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3);\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n        return indices;\n      }\n      function triangulateFaceData(data2, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          triangulatedData.push(x, y, z);\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      function flattenData(data2, index) {\n        var flattenData2 = [];\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          flattenData2.push(x, y, z);\n        }\n        return flattenData2;\n      }\n      function expandLineIndex(index) {\n        var indices = [];\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2);\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n        return indices;\n      }\n      function expandLineData(data2, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          triangulatedData.push(x, y, z);\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n      function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {\n        var array = [];\n        for (var i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          if (itemSize === 2) {\n            uvA.fromArray(data2, a * itemSize);\n            uvB.fromArray(data2, b * itemSize);\n            uvC.fromArray(data2, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data2, a * itemSize);\n            vB.fromArray(data2, b * itemSize);\n            vC.fromArray(data2, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n        return new Float32BufferAttribute(array, itemSize);\n      }\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n        for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n        for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n          index2 = 0;\n        for (var i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n          for (var j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n      var ab = new Vector3();\n      var cb = new Vector3();\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {};\n        for (var i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === void 0) vertexNormals[a] = [];\n          if (vertexNormals[b] === void 0) vertexNormals[b] = [];\n          if (vertexNormals[c] === void 0) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        }\n        var normals = [];\n        for (var _i19 = 0, _l13 = faces.length; _i19 < _l13; _i19++) {\n          var _face = faces[_i19];\n          var nA = weightedNormal(vertexNormals[_face.a], _face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[_face.b], _face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[_face.c], _face.normal, creaseAngle);\n          vA.fromArray(coord, _face.a * 3);\n          vB.fromArray(coord, _face.b * 3);\n          vC.fromArray(coord, _face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n        return new Float32BufferAttribute(normals, 3);\n      }\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (var i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n        return normal.normalize();\n      }\n      function toColorArray(colors) {\n        var array = [];\n        for (var i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n        return array;\n      }\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n        for (var i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        }\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n        for (var _i20 = 0; _i20 < indices.count; _i20++) {\n          var index = indices.getX(_i20);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA = void 0,\n            thresholdIndexB = void 0;\n          var t = 1;\n          for (var j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n            if (topDown === true) {\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n        geometry.setAttribute(\"color\", colorAttribute);\n      }\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      if (data.indexOf(\"#VRML V2.0\") === -1) {\n        throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");\n      }\n      var tree = generateVRMLTree(data);\n      var scene = parseTree(tree);\n      return scene;\n    }\n  }]);\n  return VRMLLoader;\n}(Loader);\nvar VRMLLexer = /*#__PURE__*/function () {\n  function VRMLLexer(tokens) {\n    _classCallCheck(this, VRMLLexer);\n    this.lexer = new Lexer(tokens);\n  }\n  _createClass(VRMLLexer, [{\n    key: \"lex\",\n    value: function lex(inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error(\"THREE.VRMLLexer: Lexing errors detected.\");\n      }\n      return lexingResult;\n    }\n  }]);\n  return VRMLLexer;\n}();\nvar VRMLParser = /*#__PURE__*/function (_CstParser) {\n  _inherits(VRMLParser, _CstParser);\n  var _super2 = _createSuper(VRMLParser);\n  function VRMLParser(tokenVocabulary) {\n    var _this;\n    _classCallCheck(this, VRMLParser);\n    _this = _super2.call(this, tokenVocabulary);\n    var $ = _assertThisInitialized(_this);\n    var Version = tokenVocabulary[\"Version\"];\n    var LCurly = tokenVocabulary[\"LCurly\"];\n    var RCurly = tokenVocabulary[\"RCurly\"];\n    var LSquare = tokenVocabulary[\"LSquare\"];\n    var RSquare = tokenVocabulary[\"RSquare\"];\n    var Identifier = tokenVocabulary[\"Identifier\"];\n    var RouteIdentifier = tokenVocabulary[\"RouteIdentifier\"];\n    var StringLiteral = tokenVocabulary[\"StringLiteral\"];\n    var HexLiteral = tokenVocabulary[\"HexLiteral\"];\n    var NumberLiteral = tokenVocabulary[\"NumberLiteral\"];\n    var TrueLiteral = tokenVocabulary[\"TrueLiteral\"];\n    var FalseLiteral = tokenVocabulary[\"FalseLiteral\"];\n    var NullLiteral = tokenVocabulary[\"NullLiteral\"];\n    var DEF = tokenVocabulary[\"DEF\"];\n    var USE = tokenVocabulary[\"USE\"];\n    var ROUTE = tokenVocabulary[\"ROUTE\"];\n    var TO = tokenVocabulary[\"TO\"];\n    var NodeName = tokenVocabulary[\"NodeName\"];\n    $.RULE(\"vrml\", function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE(\"version\", function () {\n      $.CONSUME(Version);\n    });\n    $.RULE(\"node\", function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE(\"field\", function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function ALT() {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function ALT() {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE(\"def\", function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"use\", function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"singleFieldValue\", function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE(\"multiFieldValue\", function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE(\"route\", function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    _this.performSelfAnalysis();\n    return _this;\n  }\n  return _createClass(VRMLParser);\n}(CstParser);\nvar Face = /*#__PURE__*/_createClass(function Face(a, b, c) {\n  _classCallCheck(this, Face);\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.normal = new Vector3();\n});\nvar TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","Scene","Object3D","Group","Vector3","SphereGeometry","MeshBasicMaterial","BackSide","Mesh","PointsMaterial","Points","LineBasicMaterial","LineSegments","FrontSide","DoubleSide","MeshPhongMaterial","Color","RepeatWrapping","ClampToEdgeWrapping","DataTexture","Vector2","BufferGeometry","Float32BufferAttribute","BoxGeometry","ConeGeometry","CylinderGeometry","Quaternion","ShapeUtils","BufferAttribute","TextureLoader","createToken","Lexer","CstParser","VRMLLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","data2","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","RouteIdentifier","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","prototype","Object","assign","create","constructor","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree2","scene2","buildNodeMap","object","getNode","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","geometry","attributes","_type","pointsMaterial","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","parseHexColor","hex","textureType","INTENSITY","parseInt","r","g","b","a","substring","getTextureType","num_components","texture","wrapS","wrapT","width","height","Uint8Array","k","stride","needsUpdate","textureLoader","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","positionAttribute","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","size","x","y","z","openEnded","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","flattenData2","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","normalize","nA","weightedNormal","nB","nC","vector","angleTo","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","count","getX","fromBufferAttribute","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","resourcePath","setCrossOrigin","crossOrigin","indexOf","tree","scene","inputText","tokenize","_CstParser","_super2","_this","$","_assertThisInitialized","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/VRMLLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, Scene, Object3D, Group, Vector3, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, RepeatWrapping, ClampToEdgeWrapping, DataTexture, Vector2, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, TextureLoader } from \"three\";\nimport { createToken, Lexer, CstParser } from \"chevrotain\";\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data, path) {\n    const nodeMap = {};\n    function generateVRMLTree(data2) {\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n      const lexingResult = lexer.lex(data2);\n      parser.input = lexingResult.tokens;\n      const cstOutput = parser.vrml();\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error(\"THREE.VRMLLoader: Parsing errors detected.\");\n      }\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n    function createTokens() {\n      const RouteIdentifier = createToken({\n        name: \"RouteIdentifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: \"Identifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      });\n      const nodeTypes = [\n        \"Anchor\",\n        \"Billboard\",\n        \"Collision\",\n        \"Group\",\n        \"Transform\",\n        // grouping nodes\n        \"Inline\",\n        \"LOD\",\n        \"Switch\",\n        // special groups\n        \"AudioClip\",\n        \"DirectionalLight\",\n        \"PointLight\",\n        \"Script\",\n        \"Shape\",\n        \"Sound\",\n        \"SpotLight\",\n        \"WorldInfo\",\n        // common nodes\n        \"CylinderSensor\",\n        \"PlaneSensor\",\n        \"ProximitySensor\",\n        \"SphereSensor\",\n        \"TimeSensor\",\n        \"TouchSensor\",\n        \"VisibilitySensor\",\n        // sensors\n        \"Box\",\n        \"Cone\",\n        \"Cylinder\",\n        \"ElevationGrid\",\n        \"Extrusion\",\n        \"IndexedFaceSet\",\n        \"IndexedLineSet\",\n        \"PointSet\",\n        \"Sphere\",\n        // geometries\n        \"Color\",\n        \"Coordinate\",\n        \"Normal\",\n        \"TextureCoordinate\",\n        // geometric properties\n        \"Appearance\",\n        \"FontStyle\",\n        \"ImageTexture\",\n        \"Material\",\n        \"MovieTexture\",\n        \"PixelTexture\",\n        \"TextureTransform\",\n        // appearance\n        \"ColorInterpolator\",\n        \"CoordinateInterpolator\",\n        \"NormalInterpolator\",\n        \"OrientationInterpolator\",\n        \"PositionInterpolator\",\n        \"ScalarInterpolator\",\n        // interpolators\n        \"Background\",\n        \"Fog\",\n        \"NavigationInfo\",\n        \"Viewpoint\",\n        // bindable nodes\n        \"Text\"\n        // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ];\n      const Version = createToken({\n        name: \"Version\",\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: \"NodeName\",\n        pattern: new RegExp(nodeTypes.join(\"|\")),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: \"DEF\",\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: \"USE\",\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: \"ROUTE\",\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: \"TO\",\n        pattern: /TO/,\n        longer_alt: Identifier\n      });\n      const StringLiteral = createToken({\n        name: \"StringLiteral\",\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n      });\n      const HexLiteral = createToken({ name: \"HexLiteral\", pattern: /0[xX][0-9a-fA-F]+/ });\n      const NumberLiteral = createToken({ name: \"NumberLiteral\", pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ });\n      const TrueLiteral = createToken({ name: \"TrueLiteral\", pattern: /TRUE/ });\n      const FalseLiteral = createToken({ name: \"FalseLiteral\", pattern: /FALSE/ });\n      const NullLiteral = createToken({ name: \"NullLiteral\", pattern: /NULL/ });\n      const LSquare = createToken({ name: \"LSquare\", pattern: /\\[/ });\n      const RSquare = createToken({ name: \"RSquare\", pattern: /]/ });\n      const LCurly = createToken({ name: \"LCurly\", pattern: /{/ });\n      const RCurly = createToken({ name: \"RCurly\", pattern: /}/ });\n      const Comment = createToken({\n        name: \"Comment\",\n        pattern: /#.*/,\n        group: Lexer.SKIPPED\n      });\n      const WhiteSpace = createToken({\n        name: \"WhiteSpace\",\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED\n      });\n      const tokens = [\n        WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName,\n        DEF,\n        USE,\n        ROUTE,\n        TO,\n        TrueLiteral,\n        FalseLiteral,\n        NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version,\n        Identifier,\n        RouteIdentifier,\n        StringLiteral,\n        HexLiteral,\n        NumberLiteral,\n        LSquare,\n        RSquare,\n        LCurly,\n        RCurly,\n        Comment\n      ];\n      const tokenVocabulary = {};\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n      return { tokens, tokenVocabulary };\n    }\n    function createVisitor(BaseVRMLVisitor) {\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function(ctx) {\n          const data2 = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data2.nodes.push(this.visit(node));\n          }\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data2.routes.push(this.visit(route));\n            }\n          }\n          return data2;\n        },\n        version: function(ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function(ctx) {\n          const data2 = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data2.fields.push(this.visit(field));\n            }\n          }\n          if (ctx.def) {\n            data2.DEF = this.visit(ctx.def[0]);\n          }\n          return data2;\n        },\n        field: function(ctx) {\n          const data2 = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result;\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          }\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n          data2.type = result.type;\n          data2.values = result.values;\n          return data2;\n        },\n        def: function(ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function(ctx) {\n          return { USE: (ctx.Identifier || ctx.NodeName)[0].image };\n        },\n        singleFieldValue: function(ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function(ctx) {\n          return processField(this, ctx);\n        },\n        route: function(ctx) {\n          const data2 = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data2;\n        }\n      });\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n        if (ctx.node) {\n          field.type = \"node\";\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n        if (ctx.use) {\n          field.type = \"use\";\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n        if (ctx.StringLiteral) {\n          field.type = \"string\";\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, \"\"));\n          }\n        }\n        if (ctx.NumberLiteral) {\n          field.type = \"number\";\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n        if (ctx.HexLiteral) {\n          field.type = \"hex\";\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n        if (ctx.TrueLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === \"TRUE\")\n              field.values.push(true);\n          }\n        }\n        if (ctx.FalseLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === \"FALSE\")\n              field.values.push(false);\n          }\n        }\n        if (ctx.NullLiteral) {\n          field.type = \"null\";\n          ctx.NullLiteral.forEach(function() {\n            field.values.push(null);\n          });\n        }\n        return field;\n      }\n      return new VRMLToASTVisitor();\n    }\n    function parseTree(tree2) {\n      const nodes = tree2.nodes;\n      const scene2 = new Scene();\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      }\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D)\n          scene2.add(object);\n        if (node.name === \"WorldInfo\")\n          scene2.userData.worldInfo = object;\n      }\n      return scene2;\n    }\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        if (field.type === \"node\") {\n          const fieldValues = field.values;\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n    function getNode(node) {\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n      if (node.build !== void 0)\n        return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    }\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n      switch (nodeName) {\n        case \"Group\":\n        case \"Transform\":\n        case \"Collision\":\n          build = buildGroupingNode(node);\n          break;\n        case \"Background\":\n          build = buildBackgroundNode(node);\n          break;\n        case \"Shape\":\n          build = buildShapeNode(node);\n          break;\n        case \"Appearance\":\n          build = buildAppearanceNode(node);\n          break;\n        case \"Material\":\n          build = buildMaterialNode(node);\n          break;\n        case \"ImageTexture\":\n          build = buildImageTextureNode(node);\n          break;\n        case \"PixelTexture\":\n          build = buildPixelTextureNode(node);\n          break;\n        case \"TextureTransform\":\n          build = buildTextureTransformNode(node);\n          break;\n        case \"IndexedFaceSet\":\n          build = buildIndexedFaceSetNode(node);\n          break;\n        case \"IndexedLineSet\":\n          build = buildIndexedLineSetNode(node);\n          break;\n        case \"PointSet\":\n          build = buildPointSetNode(node);\n          break;\n        case \"Box\":\n          build = buildBoxNode(node);\n          break;\n        case \"Cone\":\n          build = buildConeNode(node);\n          break;\n        case \"Cylinder\":\n          build = buildCylinderNode(node);\n          break;\n        case \"Sphere\":\n          build = buildSphereNode(node);\n          break;\n        case \"ElevationGrid\":\n          build = buildElevationGridNode(node);\n          break;\n        case \"Extrusion\":\n          build = buildExtrusionNode(node);\n          break;\n        case \"Color\":\n        case \"Coordinate\":\n        case \"Normal\":\n        case \"TextureCoordinate\":\n          build = buildGeometricNode(node);\n          break;\n        case \"WorldInfo\":\n          build = buildWorldInfoNode(node);\n          break;\n        case \"Anchor\":\n        case \"Billboard\":\n        case \"Inline\":\n        case \"LOD\":\n        case \"Switch\":\n        case \"AudioClip\":\n        case \"DirectionalLight\":\n        case \"PointLight\":\n        case \"Script\":\n        case \"Sound\":\n        case \"SpotLight\":\n        case \"CylinderSensor\":\n        case \"PlaneSensor\":\n        case \"ProximitySensor\":\n        case \"SphereSensor\":\n        case \"TimeSensor\":\n        case \"TouchSensor\":\n        case \"VisibilitySensor\":\n        case \"Text\":\n        case \"FontStyle\":\n        case \"MovieTexture\":\n        case \"ColorInterpolator\":\n        case \"CoordinateInterpolator\":\n        case \"NormalInterpolator\":\n        case \"OrientationInterpolator\":\n        case \"PositionInterpolator\":\n        case \"ScalarInterpolator\":\n        case \"Fog\":\n        case \"NavigationInfo\":\n        case \"Viewpoint\":\n          break;\n        default:\n          console.warn(\"THREE.VRMLLoader: Unknown node:\", nodeName);\n          break;\n      }\n      if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty(\"name\") === true) {\n        build.name = node.DEF;\n      }\n      return build;\n    }\n    function buildGroupingNode(node) {\n      const object = new Group();\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bboxCenter\":\n            break;\n          case \"bboxSize\":\n            break;\n          case \"center\":\n            break;\n          case \"children\":\n            parseFieldChildren(fieldValues, object);\n            break;\n          case \"collide\":\n            break;\n          case \"rotation\":\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n          case \"scale\":\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"scaleOrientation\":\n            break;\n          case \"translation\":\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"proxy\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return object;\n    }\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"groundAngle\":\n            groundAngle = fieldValues;\n            break;\n          case \"groundColor\":\n            groundColor = fieldValues;\n            break;\n          case \"backUrl\":\n            break;\n          case \"bottomUrl\":\n            break;\n          case \"frontUrl\":\n            break;\n          case \"leftUrl\":\n            break;\n          case \"rightUrl\":\n            break;\n          case \"topUrl\":\n            break;\n          case \"skyAngle\":\n            skyAngle = fieldValues;\n            break;\n          case \"skyColor\":\n            skyColor = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const radius = 1e4;\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({ fog: false, side: BackSide, depthWrite: false, depthTest: false });\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      }\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      }\n      group.renderOrder = -Infinity;\n      return group;\n    }\n    function buildShapeNode(node) {\n      const fields = node.fields;\n      let material = new MeshBasicMaterial({ color: 0 });\n      let geometry;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"appearance\":\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n            break;\n          case \"geometry\":\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let object;\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n        if (type === \"points\") {\n          const pointsMaterial = new PointsMaterial({ color: 16777215 });\n          if (geometry.attributes.color !== void 0) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === \"line\") {\n          const lineMaterial = new LineBasicMaterial({ color: 16777215 });\n          if (geometry.attributes.color !== void 0) {\n            lineMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          if (geometry._solid !== void 0) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          }\n          if (geometry.attributes.color !== void 0) {\n            material.vertexColors = true;\n          }\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D();\n        object.visible = false;\n      }\n      return object;\n    }\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"material\":\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor)\n                material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor)\n                material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess)\n                material.shininess = materialData.shininess;\n              if (materialData.specularColor)\n                material.specular.copy(materialData.specularColor);\n              if (materialData.transparency)\n                material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0)\n                material.transparent = true;\n            } else {\n              material = new MeshBasicMaterial({ color: 0 });\n            }\n            break;\n          case \"texture\":\n            const textureNode = fieldValues[0];\n            if (textureNode !== null) {\n              if (textureNode.name === \"ImageTexture\" || textureNode.name === \"PixelTexture\") {\n                material.map = getNode(textureNode);\n              } else {\n              }\n            }\n            break;\n          case \"textureTransform\":\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (material.map) {\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1;\n              break;\n            case TEXTURE_TYPE.RGB:\n              material.color.set(16777215);\n              break;\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(16777215);\n              material.opacity = 1;\n              break;\n            default:\n          }\n          delete material.map.__type;\n        }\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n      return material;\n    }\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"ambientIntensity\":\n            break;\n          case \"diffuseColor\":\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"emissiveColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"shininess\":\n            materialData.shininess = fieldValues[0];\n            break;\n          case \"specularColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"transparency\":\n            materialData.transparency = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return materialData;\n    }\n    function parseHexColor(hex, textureType, color) {\n      let value;\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          value = parseInt(\"0x\" + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt(\"0x\" + hex.substring(4, 6));\n          break;\n        case TEXTURE_TYPE.RGB:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.RGBA:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = parseInt(\"0x\" + hex.substring(8, 10));\n          break;\n        default:\n      }\n    }\n    function getTextureType(num_components) {\n      let type;\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n        default:\n      }\n      return type;\n    }\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"image\":\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const textureType = getTextureType(num_components);\n            const data2 = new Uint8Array(4 * width * height);\n            const color = { r: 0, g: 0, b: 0, a: 0 };\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n              const stride = k * 4;\n              data2[stride + 0] = color.r;\n              data2[stride + 1] = color.g;\n              data2[stride + 2] = color.b;\n              data2[stride + 3] = color.a;\n            }\n            texture = new DataTexture(data2, width, height);\n            texture.needsUpdate = true;\n            texture.__type = textureType;\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false)\n              wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false)\n              wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"url\":\n            const url = fieldValues[0];\n            if (url)\n              texture = textureLoader.load(url);\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false)\n              wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false)\n              wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"center\":\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"rotation\":\n            transformData.rotation = fieldValues[0];\n            break;\n          case \"scale\":\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"translation\":\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return transformData;\n    }\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"title\":\n            worldInfo.title = fieldValues[0];\n            break;\n          case \"info\":\n            worldInfo.info = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return worldInfo;\n    }\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true, solid = true, creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true, normalPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalIndex\":\n            normalIndex = fieldValues;\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"texCoordIndex\":\n            texCoordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (coordIndex === void 0) {\n        console.warn(\"THREE.VRMLLoader: Missing coordIndex.\");\n        return new BufferGeometry();\n      }\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === true) {\n          if (normalIndex && normalIndex.length > 0) {\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(\n              triangulatedCoordIndex,\n              triangulatedNormalIndex,\n              normal,\n              3\n            );\n          } else {\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          if (normalIndex && normalIndex.length > 0) {\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n      if (texCoord) {\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      if (colorAttribute)\n        geometry.setAttribute(\"color\", colorAttribute);\n      if (uvAttribute)\n        geometry.setAttribute(\"uv\", uvAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex);\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            const expandedColorIndex = expandLineIndex(colorIndex);\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            const flattenLineColors = flattenData(color, colorIndex);\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          } else {\n            const expandedLineColors = expandLineData(color, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          }\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      if (colorAttribute)\n        geometry.setAttribute(\"color\", colorAttribute);\n      geometry._type = \"line\";\n      return geometry;\n    }\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(coord, 3));\n      if (color)\n        geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n      geometry._type = \"points\";\n      return geometry;\n    }\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"size\":\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n    function buildConeNode(node) {\n      let radius = 1, height = 2, openEnded = false;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            openEnded = !fieldValues[0];\n            break;\n          case \"bottomRadius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n    function buildCylinderNode(node) {\n      let radius = 1, height = 2;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            break;\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          case \"top\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"height\":\n            height = fieldValues;\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"xDimension\":\n            xDimension = fieldValues[0];\n            break;\n          case \"xSpacing\":\n            xSpacing = fieldValues[0];\n            break;\n          case \"zDimension\":\n            zDimension = fieldValues[0];\n            break;\n          case \"zSpacing\":\n            zSpacing = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          const index = i * xDimension + j;\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z);\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          }\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          }\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      }\n      const indices = [];\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension;\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute;\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2];\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry.setAttribute(\"uv\", uvAttribute);\n      if (colorAttribute)\n        geometry.setAttribute(\"color\", colorAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"beginCap\":\n            beginCap = fieldValues[0];\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"crossSection\":\n            crossSection = fieldValues;\n            break;\n          case \"endCap\":\n            endCap = fieldValues[0];\n            break;\n          case \"orientation\":\n            orientation = fieldValues;\n            break;\n          case \"scale\":\n            scale = fieldValues;\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"spine\":\n            spine = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1];\n          vertex.multiply(scaling);\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion);\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      }\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        }\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        }\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1);\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 2],\n                indexOffset + capIndices[i + 1]\n              );\n            } else {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 1],\n                indexOffset + capIndices[i + 2]\n              );\n            }\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node);\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D)\n          owner.add(object);\n      }\n    }\n    function triangulateFaceIndex(index, ccw) {\n      const indices = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n      return indices;\n    }\n    function triangulateFaceData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    function flattenData(data2, index) {\n      const flattenData2 = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        flattenData2.push(x, y, z);\n      }\n      return flattenData2;\n    }\n    function expandLineIndex(index) {\n      const indices = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n      return indices;\n    }\n    function expandLineData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n    function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {\n      const array = [];\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        if (itemSize === 2) {\n          uvA.fromArray(data2, a * itemSize);\n          uvB.fromArray(data2, b * itemSize);\n          uvC.fromArray(data2, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data2, a * itemSize);\n          vB.fromArray(data2, b * itemSize);\n          vC.fromArray(data2, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n      return new Float32BufferAttribute(array, itemSize);\n    }\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0, index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n    const ab = new Vector3();\n    const cb = new Vector3();\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {};\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === void 0)\n          vertexNormals[a] = [];\n        if (vertexNormals[b] === void 0)\n          vertexNormals[b] = [];\n        if (vertexNormals[c] === void 0)\n          vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      }\n      const normals = [];\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n      return new Float32BufferAttribute(normals, 3);\n    }\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n      return normal.normalize();\n    }\n    function toColorArray(colors) {\n      const array = [];\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n      return array;\n    }\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      }\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n          if (topDown === true) {\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n      geometry.setAttribute(\"color\", colorAttribute);\n    }\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    if (data.indexOf(\"#VRML V2.0\") === -1) {\n      throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");\n    }\n    const tree = generateVRMLTree(data);\n    const scene = parseTree(tree);\n    return scene;\n  }\n}\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens);\n  }\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error(\"THREE.VRMLLexer: Lexing errors detected.\");\n    }\n    return lexingResult;\n  }\n}\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary[\"Version\"];\n    const LCurly = tokenVocabulary[\"LCurly\"];\n    const RCurly = tokenVocabulary[\"RCurly\"];\n    const LSquare = tokenVocabulary[\"LSquare\"];\n    const RSquare = tokenVocabulary[\"RSquare\"];\n    const Identifier = tokenVocabulary[\"Identifier\"];\n    const RouteIdentifier = tokenVocabulary[\"RouteIdentifier\"];\n    const StringLiteral = tokenVocabulary[\"StringLiteral\"];\n    const HexLiteral = tokenVocabulary[\"HexLiteral\"];\n    const NumberLiteral = tokenVocabulary[\"NumberLiteral\"];\n    const TrueLiteral = tokenVocabulary[\"TrueLiteral\"];\n    const FalseLiteral = tokenVocabulary[\"FalseLiteral\"];\n    const NullLiteral = tokenVocabulary[\"NullLiteral\"];\n    const DEF = tokenVocabulary[\"DEF\"];\n    const USE = tokenVocabulary[\"USE\"];\n    const ROUTE = tokenVocabulary[\"ROUTE\"];\n    const TO = tokenVocabulary[\"TO\"];\n    const NodeName = tokenVocabulary[\"NodeName\"];\n    $.RULE(\"vrml\", function() {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function() {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function() {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE(\"version\", function() {\n      $.CONSUME(Version);\n    });\n    $.RULE(\"node\", function() {\n      $.OPTION(function() {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function() {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE(\"field\", function() {\n      $.CONSUME(Identifier);\n      $.OR2([\n        {\n          ALT: function() {\n            $.SUBRULE($.singleFieldValue);\n          }\n        },\n        {\n          ALT: function() {\n            $.SUBRULE($.multiFieldValue);\n          }\n        }\n      ]);\n    });\n    $.RULE(\"def\", function() {\n      $.CONSUME(DEF);\n      $.OR([\n        {\n          ALT: function() {\n            $.CONSUME(Identifier);\n          }\n        },\n        {\n          ALT: function() {\n            $.CONSUME(NodeName);\n          }\n        }\n      ]);\n    });\n    $.RULE(\"use\", function() {\n      $.CONSUME(USE);\n      $.OR([\n        {\n          ALT: function() {\n            $.CONSUME(Identifier);\n          }\n        },\n        {\n          ALT: function() {\n            $.CONSUME(NodeName);\n          }\n        }\n      ]);\n    });\n    $.RULE(\"singleFieldValue\", function() {\n      $.AT_LEAST_ONE(function() {\n        $.OR([\n          {\n            ALT: function() {\n              $.SUBRULE($.node);\n            }\n          },\n          {\n            ALT: function() {\n              $.SUBRULE($.use);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(StringLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(HexLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NumberLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(TrueLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(FalseLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NullLiteral);\n            }\n          }\n        ]);\n      });\n    });\n    $.RULE(\"multiFieldValue\", function() {\n      $.CONSUME(LSquare);\n      $.MANY(function() {\n        $.OR([\n          {\n            ALT: function() {\n              $.SUBRULE($.node);\n            }\n          },\n          {\n            ALT: function() {\n              $.SUBRULE($.use);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(StringLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(HexLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NumberLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NullLiteral);\n            }\n          }\n        ]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE(\"route\", function() {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n}\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n}\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport {\n  VRMLLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}