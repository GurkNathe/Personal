{"ast":null,"code":"import _slicedToArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { prioritizeTokenScores } from '../components/algorithms.js';\nimport { getFacets } from '../components/facets.js';\nimport { intersectFilteredIDs } from '../components/filters.js';\nimport { getGroups } from '../components/groups.js';\nimport { createError } from '../errors.js';\nimport { getNanosecondsTime, getNested, sortTokenScorePredicate } from '../utils.js';\nvar defaultBM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5\n};\nfunction createSearchContext(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n  return _createSearchContext.apply(this, arguments);\n}\nfunction _createSearchContext() {\n  _createSearchContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenizer, index, documentsStore, language, params, properties, tokens, docsCount) {\n    var indexMap, docsIntersection, _iterator, _step, prop, tokensMap, _iterator2, _step2, token;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          // If filters are enabled, we need to get the IDs of the documents that match the filters.\n          // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n          // let whereFiltersIDs: string[] = [];\n          // if (hasFilters) {\n          //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n          // }\n          // indexMap is an object containing all the indexes considered for the current search,\n          // and an array of doc IDs for each token in all the indices.\n          //\n          // Given the search term \"quick brown fox\" on the \"description\" index,\n          // indexMap will look like this:\n          //\n          // {\n          //   description: {\n          //     quick: [doc1, doc2, doc3],\n          //     brown: [doc2, doc4],\n          //     fox:   [doc2]\n          //   }\n          // }\n          indexMap = {}; // After we create the indexMap, we need to calculate the intersection\n          // between all the postings lists for each token.\n          // Given the example above, docsIntersection will look like this:\n          //\n          // {\n          //   description: [doc2]\n          // }\n          //\n          // as doc2 is the only document present in all the postings lists for the \"description\" index.\n          docsIntersection = {};\n          _iterator = _createForOfIteratorHelper(properties);\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              prop = _step.value;\n              tokensMap = {};\n              _iterator2 = _createForOfIteratorHelper(tokens);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  token = _step2.value;\n                  tokensMap[token] = [];\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              indexMap[prop] = tokensMap;\n              docsIntersection[prop] = [];\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          _context.next = 6;\n          return getNanosecondsTime();\n        case 6:\n          _context.t0 = _context.sent;\n          _context.t1 = tokenizer;\n          _context.t2 = index;\n          _context.t3 = documentsStore;\n          _context.t4 = language;\n          _context.t5 = params;\n          _context.t6 = docsCount;\n          _context.t7 = {};\n          _context.t8 = indexMap;\n          _context.t9 = docsIntersection;\n          return _context.abrupt(\"return\", {\n            timeStart: _context.t0,\n            tokenizer: _context.t1,\n            index: _context.t2,\n            documentsStore: _context.t3,\n            language: _context.t4,\n            params: _context.t5,\n            docsCount: _context.t6,\n            uniqueDocsIDs: _context.t7,\n            indexMap: _context.t8,\n            docsIntersection: _context.t9\n          });\n        case 17:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _createSearchContext.apply(this, arguments);\n}\nexport function search(_x9, _x10, _x11) {\n  return _search.apply(this, arguments);\n}\nfunction _search() {\n  _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(orama, params, language) {\n    var _params$relevance, _params$where;\n    var shouldCalculateFacets, _params$limit, limit, _params$offset, offset, term, properties, _params$threshold, threshold, distinctOn, isPreflight, _orama$data, index, docs, tokens, propertiesToSearch, propertiesToSearchWithTypes, _iterator3, _step3, prop, context, hasFilters, whereFiltersIDs, indexesLength, i, _ref, _params_boost, _prop, tokensLength, j, _context$indexMap$_pr, _term, scoreList, docIds, vals, uniqueDocs, uniqueDocsLength, _i, _uniqueDocs$_i, id, score, prevScore, uniqueDocsArray, ids, _docs, docsWithIdAndScore, results, searchResult, facets;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          params.relevance = Object.assign((_params$relevance = params.relevance) !== null && _params$relevance !== void 0 ? _params$relevance : {}, defaultBM25Params);\n          shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;\n          _params$limit = params.limit, limit = _params$limit === void 0 ? 10 : _params$limit, _params$offset = params.offset, offset = _params$offset === void 0 ? 0 : _params$offset, term = params.term, properties = params.properties, _params$threshold = params.threshold, threshold = _params$threshold === void 0 ? 1 : _params$threshold, distinctOn = params.distinctOn;\n          isPreflight = params.preflight === true;\n          _orama$data = orama.data, index = _orama$data.index, docs = _orama$data.docs;\n          _context2.next = 7;\n          return orama.tokenizer.tokenize(term !== null && term !== void 0 ? term : '', language);\n        case 7:\n          tokens = _context2.sent;\n          // Get searchable string properties\n          propertiesToSearch = orama.caches['propertiesToSearch'];\n          if (propertiesToSearch) {\n            _context2.next = 18;\n            break;\n          }\n          _context2.next = 12;\n          return orama.index.getSearchablePropertiesWithTypes(index);\n        case 12:\n          propertiesToSearchWithTypes = _context2.sent;\n          _context2.next = 15;\n          return orama.index.getSearchableProperties(index);\n        case 15:\n          propertiesToSearch = _context2.sent;\n          propertiesToSearch = propertiesToSearch.filter(function (prop) {\n            return propertiesToSearchWithTypes[prop].startsWith('string');\n          });\n          orama.caches['propertiesToSearch'] = propertiesToSearch;\n        case 18:\n          if (!(properties && properties !== '*')) {\n            _context2.next = 37;\n            break;\n          }\n          _iterator3 = _createForOfIteratorHelper(properties);\n          _context2.prev = 20;\n          _iterator3.s();\n        case 22:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 28;\n            break;\n          }\n          prop = _step3.value;\n          if (propertiesToSearch.includes(prop)) {\n            _context2.next = 26;\n            break;\n          }\n          throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '));\n        case 26:\n          _context2.next = 22;\n          break;\n        case 28:\n          _context2.next = 33;\n          break;\n        case 30:\n          _context2.prev = 30;\n          _context2.t0 = _context2[\"catch\"](20);\n          _iterator3.e(_context2.t0);\n        case 33:\n          _context2.prev = 33;\n          _iterator3.f();\n          return _context2.finish(33);\n        case 36:\n          propertiesToSearch = propertiesToSearch.filter(function (prop) {\n            return properties.includes(prop);\n          });\n        case 37:\n          _context2.t1 = createSearchContext;\n          _context2.t2 = orama.tokenizer;\n          _context2.t3 = orama.index;\n          _context2.t4 = orama.documentsStore;\n          _context2.t5 = language;\n          _context2.t6 = params;\n          _context2.t7 = propertiesToSearch;\n          _context2.t8 = tokens;\n          _context2.next = 47;\n          return orama.documentsStore.count(docs);\n        case 47:\n          _context2.t9 = _context2.sent;\n          _context2.next = 50;\n          return (0, _context2.t1)(_context2.t2, _context2.t3, _context2.t4, _context2.t5, _context2.t6, _context2.t7, _context2.t8, _context2.t9);\n        case 50:\n          context = _context2.sent;\n          // If filters are enabled, we need to get the IDs of the documents that match the filters.\n          hasFilters = Object.keys((_params$where = params.where) !== null && _params$where !== void 0 ? _params$where : {}).length > 0;\n          whereFiltersIDs = [];\n          if (!hasFilters) {\n            _context2.next = 57;\n            break;\n          }\n          _context2.next = 56;\n          return orama.index.searchByWhereClause(context, index, params.where);\n        case 56:\n          whereFiltersIDs = _context2.sent;\n        case 57:\n          if (!tokens.length) {\n            _context2.next = 84;\n            break;\n          }\n          // Now it's time to loop over all the indices and get the documents IDs for every single term\n          indexesLength = propertiesToSearch.length;\n          i = 0;\n        case 60:\n          if (!(i < indexesLength)) {\n            _context2.next = 82;\n            break;\n          }\n          _prop = propertiesToSearch[i];\n          tokensLength = tokens.length;\n          j = 0;\n        case 64:\n          if (!(j < tokensLength)) {\n            _context2.next = 73;\n            break;\n          }\n          _term = tokens[j]; // Lookup\n          _context2.next = 68;\n          return orama.index.search(context, index, _prop, _term);\n        case 68:\n          scoreList = _context2.sent;\n          (_context$indexMap$_pr = context.indexMap[_prop][_term]).push.apply(_context$indexMap$_pr, _toConsumableArray(scoreList));\n        case 70:\n          j++;\n          _context2.next = 64;\n          break;\n        case 73:\n          docIds = context.indexMap[_prop];\n          vals = Object.values(docIds);\n          context.docsIntersection[_prop] = prioritizeTokenScores(vals, (_ref = params === null || params === void 0 ? void 0 : (_params_boost = params.boost) === null || _params_boost === void 0 ? void 0 : _params_boost[_prop]) !== null && _ref !== void 0 ? _ref : 1, threshold);\n          uniqueDocs = context.docsIntersection[_prop];\n          uniqueDocsLength = uniqueDocs.length;\n          for (_i = 0; _i < uniqueDocsLength; _i++) {\n            _uniqueDocs$_i = _slicedToArray(uniqueDocs[_i], 2), id = _uniqueDocs$_i[0], score = _uniqueDocs$_i[1];\n            prevScore = context.uniqueDocsIDs[id];\n            if (prevScore) {\n              context.uniqueDocsIDs[id] = prevScore + score + 0.5;\n            } else {\n              context.uniqueDocsIDs[id] = score;\n            }\n          }\n        case 79:\n          i++;\n          _context2.next = 60;\n          break;\n        case 82:\n          _context2.next = 95;\n          break;\n        case 84:\n          if (!(tokens.length === 0 && term)) {\n            _context2.next = 88;\n            break;\n          }\n          // This case is hard to handle correctly.\n          // For the time being, if tokenizer returns empty array but the term is not empty,\n          // we returns an empty result set\n          context.uniqueDocsIDs = {};\n          _context2.next = 95;\n          break;\n        case 88:\n          _context2.t10 = Object;\n          _context2.t11 = Object;\n          _context2.next = 92;\n          return orama.documentsStore.getAll(orama.data.docs);\n        case 92:\n          _context2.t12 = _context2.sent;\n          _context2.t13 = _context2.t11.keys.call(_context2.t11, _context2.t12).map(function (k) {\n            return [k, 0];\n          });\n          context.uniqueDocsIDs = _context2.t10.fromEntries.call(_context2.t10, _context2.t13);\n        case 95:\n          // Get unique doc IDs from uniqueDocsIDs map\n          uniqueDocsArray = Object.entries(context.uniqueDocsIDs); // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n          if (hasFilters) {\n            uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray);\n          }\n          if (!params.sortBy) {\n            _context2.next = 113;\n            break;\n          }\n          if (!(typeof params.sortBy === 'function')) {\n            _context2.next = 108;\n            break;\n          }\n          ids = uniqueDocsArray.map(function (_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 1),\n              id = _ref3[0];\n            return id;\n          });\n          _context2.next = 102;\n          return orama.documentsStore.getMultiple(orama.data.docs, ids);\n        case 102:\n          _docs = _context2.sent;\n          docsWithIdAndScore = _docs.map(function (d, i) {\n            return [uniqueDocsArray[i][0], uniqueDocsArray[i][1], d];\n          });\n          docsWithIdAndScore.sort(params.sortBy);\n          uniqueDocsArray = docsWithIdAndScore.map(function (_ref4) {\n            var _ref5 = _slicedToArray(_ref4, 2),\n              id = _ref5[0],\n              score = _ref5[1];\n            return [id, score];\n          });\n          _context2.next = 111;\n          break;\n        case 108:\n          _context2.next = 110;\n          return orama.sorter.sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy);\n        case 110:\n          uniqueDocsArray = _context2.sent;\n        case 111:\n          _context2.next = 114;\n          break;\n        case 113:\n          uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate);\n        case 114:\n          if (!(!isPreflight && distinctOn)) {\n            _context2.next = 120;\n            break;\n          }\n          _context2.next = 117;\n          return fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn);\n        case 117:\n          results = _context2.sent;\n          _context2.next = 124;\n          break;\n        case 120:\n          if (isPreflight) {\n            _context2.next = 124;\n            break;\n          }\n          _context2.next = 123;\n          return fetchDocuments(orama, uniqueDocsArray, offset, limit);\n        case 123:\n          results = _context2.sent;\n        case 124:\n          searchResult = {\n            elapsed: {\n              raw: 0,\n              formatted: ''\n            },\n            // We keep the hits array empty if it's a preflight request.\n            hits: [],\n            count: uniqueDocsArray.length\n          };\n          if (typeof results !== 'undefined') {\n            searchResult.hits = results.filter(Boolean);\n          }\n          if (!shouldCalculateFacets) {\n            _context2.next = 131;\n            break;\n          }\n          _context2.next = 129;\n          return getFacets(orama, uniqueDocsArray, params.facets);\n        case 129:\n          facets = _context2.sent;\n          searchResult.facets = facets;\n        case 131:\n          if (!params.groupBy) {\n            _context2.next = 135;\n            break;\n          }\n          _context2.next = 134;\n          return getGroups(orama, uniqueDocsArray, params.groupBy);\n        case 134:\n          searchResult.groups = _context2.sent;\n        case 135:\n          _context2.t14 = orama;\n          _context2.next = 138;\n          return getNanosecondsTime();\n        case 138:\n          _context2.t15 = _context2.sent;\n          _context2.t16 = context.timeStart;\n          _context2.t17 = _context2.t15 - _context2.t16;\n          _context2.next = 143;\n          return _context2.t14.formatElapsedTime.call(_context2.t14, _context2.t17);\n        case 143:\n          searchResult.elapsed = _context2.sent;\n          return _context2.abrupt(\"return\", searchResult);\n        case 145:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[20, 30, 33, 36]]);\n  }));\n  return _search.apply(this, arguments);\n}\nfunction fetchDocumentsWithDistinct(_x12, _x13, _x14, _x15, _x16) {\n  return _fetchDocumentsWithDistinct.apply(this, arguments);\n}\nfunction _fetchDocumentsWithDistinct() {\n  _fetchDocumentsWithDistinct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(orama, uniqueDocsArray, offset, limit, distinctOn) {\n    var docs, values, results, resultIDs, uniqueDocsArrayLength, count, i, idAndScore, _idAndScore, id, score, doc, value;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          docs = orama.data.docs; // Keep track which values we already seen\n          values = new Map(); // We cannot know how many results we will have in the end,\n          // so we need cannot pre-allocate the array.\n          results = [];\n          resultIDs = new Set();\n          uniqueDocsArrayLength = uniqueDocsArray.length;\n          count = 0;\n          i = 0;\n        case 7:\n          if (!(i < uniqueDocsArrayLength)) {\n            _context3.next = 33;\n            break;\n          }\n          idAndScore = uniqueDocsArray[i]; // If there are no more results, just break the loop\n          if (!(typeof idAndScore === 'undefined')) {\n            _context3.next = 11;\n            break;\n          }\n          return _context3.abrupt(\"continue\", 30);\n        case 11:\n          _idAndScore = _slicedToArray(idAndScore, 2), id = _idAndScore[0], score = _idAndScore[1];\n          if (!resultIDs.has(id)) {\n            _context3.next = 14;\n            break;\n          }\n          return _context3.abrupt(\"continue\", 30);\n        case 14:\n          _context3.next = 16;\n          return orama.documentsStore.get(docs, id);\n        case 16:\n          doc = _context3.sent;\n          _context3.next = 19;\n          return getNested(doc, distinctOn);\n        case 19:\n          value = _context3.sent;\n          if (!(typeof value === 'undefined' || values.has(value))) {\n            _context3.next = 22;\n            break;\n          }\n          return _context3.abrupt(\"continue\", 30);\n        case 22:\n          values.set(value, true);\n          count++;\n          // We shouldn't consider the document if it's not in the offset range\n          if (!(count <= offset)) {\n            _context3.next = 26;\n            break;\n          }\n          return _context3.abrupt(\"continue\", 30);\n        case 26:\n          results.push({\n            id: id,\n            score: score,\n            document: doc\n          });\n          resultIDs.add(id);\n          // reached the limit, break the loop\n          if (!(count >= offset + limit)) {\n            _context3.next = 30;\n            break;\n          }\n          return _context3.abrupt(\"break\", 33);\n        case 30:\n          i++;\n          _context3.next = 7;\n          break;\n        case 33:\n          return _context3.abrupt(\"return\", results);\n        case 34:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _fetchDocumentsWithDistinct.apply(this, arguments);\n}\nfunction fetchDocuments(_x17, _x18, _x19, _x20) {\n  return _fetchDocuments.apply(this, arguments);\n}\nfunction _fetchDocuments() {\n  _fetchDocuments = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(orama, uniqueDocsArray, offset, limit) {\n    var docs, results, resultIDs, i, idAndScore, _idAndScore2, id, score, fullDoc;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          docs = orama.data.docs;\n          results = Array.from({\n            length: limit\n          });\n          resultIDs = new Set(); // We already have the list of ALL the document IDs containing the search terms.\n          // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n          // to provide pagination capabilities to the search.\n          i = offset;\n        case 4:\n          if (!(i < limit + offset)) {\n            _context4.next = 18;\n            break;\n          }\n          idAndScore = uniqueDocsArray[i]; // If there are no more results, just break the loop\n          if (!(typeof idAndScore === 'undefined')) {\n            _context4.next = 8;\n            break;\n          }\n          return _context4.abrupt(\"break\", 18);\n        case 8:\n          _idAndScore2 = _slicedToArray(idAndScore, 2), id = _idAndScore2[0], score = _idAndScore2[1];\n          if (resultIDs.has(id)) {\n            _context4.next = 15;\n            break;\n          }\n          _context4.next = 12;\n          return orama.documentsStore.get(docs, id);\n        case 12:\n          fullDoc = _context4.sent;\n          results[i] = {\n            id: id,\n            score: score,\n            document: fullDoc\n          };\n          resultIDs.add(id);\n        case 15:\n          i++;\n          _context4.next = 4;\n          break;\n        case 18:\n          return _context4.abrupt(\"return\", results);\n        case 19:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _fetchDocuments.apply(this, arguments);\n}","map":{"version":3,"names":["prioritizeTokenScores","getFacets","intersectFilteredIDs","getGroups","createError","getNanosecondsTime","getNested","sortTokenScorePredicate","defaultBM25Params","k","b","d","createSearchContext","_x","_x2","_x3","_x4","_x5","_x6","_x7","_x8","_createSearchContext","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","tokenizer","index","documentsStore","language","params","properties","tokens","docsCount","indexMap","docsIntersection","_iterator","_step","prop","tokensMap","_iterator2","_step2","token","wrap","_callee$","_context","prev","next","_createForOfIteratorHelper","s","n","done","value","err","e","f","t0","sent","t1","t2","t3","t4","t5","t6","t7","t8","t9","abrupt","timeStart","uniqueDocsIDs","stop","search","_x9","_x10","_x11","_search","_callee2","orama","_params$relevance","_params$where","shouldCalculateFacets","_params$limit","limit","_params$offset","offset","term","_params$threshold","threshold","distinctOn","isPreflight","_orama$data","docs","propertiesToSearch","propertiesToSearchWithTypes","_iterator3","_step3","context","hasFilters","whereFiltersIDs","indexesLength","i","_ref","_params_boost","_prop","tokensLength","j","_context$indexMap$_pr","_term","scoreList","docIds","vals","uniqueDocs","uniqueDocsLength","_i","_uniqueDocs$_i","id","score","prevScore","uniqueDocsArray","ids","_docs","docsWithIdAndScore","results","searchResult","facets","_callee2$","_context2","relevance","Object","assign","keys","length","preflight","data","tokenize","caches","getSearchablePropertiesWithTypes","getSearchableProperties","filter","startsWith","includes","join","finish","count","where","searchByWhereClause","push","_toConsumableArray","values","boost","_slicedToArray","t10","t11","getAll","t12","t13","call","map","fromEntries","entries","sortBy","_ref2","_ref3","getMultiple","sort","_ref4","_ref5","sorter","sorting","fetchDocumentsWithDistinct","fetchDocuments","elapsed","raw","formatted","hits","Boolean","groupBy","groups","t14","t15","t16","t17","formatElapsedTime","_x12","_x13","_x14","_x15","_x16","_fetchDocumentsWithDistinct","_callee3","resultIDs","uniqueDocsArrayLength","idAndScore","_idAndScore","doc","_callee3$","_context3","Map","Set","has","get","set","document","add","_x17","_x18","_x19","_x20","_fetchDocuments","_callee4","_idAndScore2","fullDoc","_callee4$","_context4","Array","from"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/methods/search.ts"],"sourcesContent":["import { prioritizeTokenScores } from '../components/algorithms.js'\nimport { getFacets } from '../components/facets.js'\nimport { intersectFilteredIDs } from '../components/filters.js'\nimport { getGroups } from '../components/groups.js'\nimport { createError } from '../errors.js'\nimport {\n  BM25Params,\n  IndexMap,\n  Orama,\n  Result,\n  Results,\n  SearchContext,\n  SearchParams,\n  TokenMap,\n  ElapsedTime,\n  IIndex,\n  Tokenizer,\n  IDocumentsStore,\n  CustomSorterFunctionItem,\n  OpaqueIndex,\n  OpaqueDocumentStore,\n  SearchableValue,\n} from '../types.js'\nimport { getNanosecondsTime, getNested, sortTokenScorePredicate } from '../utils.js'\n\nconst defaultBM25Params: BM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5,\n}\n\nasync function createSearchContext<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  tokenizer: Tokenizer,\n  index: IIndex<I>,\n  documentsStore: IDocumentsStore<D>,\n  language: string | undefined,\n  params: SearchParams<AggValue>,\n  properties: string[],\n  tokens: string[],\n  docsCount: number,\n): Promise<SearchContext<I, D, AggValue>> {\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n  // let whereFiltersIDs: string[] = [];\n\n  // if (hasFilters) {\n  //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n  // }\n\n  // indexMap is an object containing all the indexes considered for the current search,\n  // and an array of doc IDs for each token in all the indices.\n  //\n  // Given the search term \"quick brown fox\" on the \"description\" index,\n  // indexMap will look like this:\n  //\n  // {\n  //   description: {\n  //     quick: [doc1, doc2, doc3],\n  //     brown: [doc2, doc4],\n  //     fox:   [doc2]\n  //   }\n  // }\n  const indexMap: IndexMap = {}\n\n  // After we create the indexMap, we need to calculate the intersection\n  // between all the postings lists for each token.\n  // Given the example above, docsIntersection will look like this:\n  //\n  // {\n  //   description: [doc2]\n  // }\n  //\n  // as doc2 is the only document present in all the postings lists for the \"description\" index.\n  const docsIntersection: TokenMap = {}\n\n  for (const prop of properties) {\n    const tokensMap: TokenMap = {}\n    for (const token of tokens) {\n      tokensMap[token] = []\n    }\n    indexMap[prop] = tokensMap\n    docsIntersection[prop] = []\n  }\n\n  return {\n    timeStart: await getNanosecondsTime(),\n    tokenizer,\n    index,\n    documentsStore,\n    language,\n    params,\n    docsCount,\n    uniqueDocsIDs: {},\n    indexMap,\n    docsIntersection,\n  }\n}\n\nexport async function search<AggValue = Result[]>(orama: Orama, params: SearchParams<AggValue>, language?: string): Promise<Results<AggValue>> {\n  params.relevance = Object.assign(params.relevance ?? {}, defaultBM25Params)\n\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0\n  const { limit = 10, offset = 0, term, properties, threshold = 1, distinctOn } = params\n  const isPreflight = params.preflight === true\n\n  const { index, docs } = orama.data\n  const tokens = await orama.tokenizer.tokenize(term ?? '', language)\n\n  // Get searchable string properties\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string'),\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  if (properties && properties !== '*') {\n    for (const prop of properties) {\n      if (!propertiesToSearch.includes(prop)) {\n        throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '))\n      }\n    }\n\n    propertiesToSearch = propertiesToSearch.filter((prop: string) => properties.includes(prop))\n  }\n\n  // Create the search context and the results\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(docs),\n  )\n\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  const hasFilters = Object.keys(params.where ?? {}).length > 0\n  let whereFiltersIDs: string[] = []\n\n  if (hasFilters) {\n    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where!)\n  }\n\n  if (tokens.length) {\n    // Now it's time to loop over all the indices and get the documents IDs for every single term\n    const indexesLength = propertiesToSearch.length\n    for (let i = 0; i < indexesLength; i++) {\n      const prop = propertiesToSearch[i]\n\n      const tokensLength = tokens.length\n      for (let j = 0; j < tokensLength; j++) {\n        const term = tokens[j]\n\n        // Lookup\n        const scoreList = await orama.index.search(context, index, prop, term)\n\n        context.indexMap[prop][term].push(...scoreList)\n      }\n\n      const docIds = context.indexMap[prop]\n      const vals = Object.values(docIds)\n      context.docsIntersection[prop] = prioritizeTokenScores(vals, params?.boost?.[prop] ?? 1, threshold)\n      const uniqueDocs = context.docsIntersection[prop]\n\n      const uniqueDocsLength = uniqueDocs.length\n      for (let i = 0; i < uniqueDocsLength; i++) {\n        const [id, score] = uniqueDocs[i]\n\n        const prevScore = context.uniqueDocsIDs[id]\n        if (prevScore) {\n          context.uniqueDocsIDs[id] = prevScore + score + 0.5\n        } else {\n          context.uniqueDocsIDs[id] = score\n        }\n      }\n    }\n  } else if (tokens.length === 0 && term) {\n    // This case is hard to handle correctly.\n    // For the time being, if tokenizer returns empty array but the term is not empty,\n    // we returns an empty result set\n    context.uniqueDocsIDs = {}\n  } else {\n    context.uniqueDocsIDs = Object.fromEntries(\n      Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map(k => [k, 0]),\n    )\n  }\n\n  // Get unique doc IDs from uniqueDocsIDs map\n  let uniqueDocsArray = Object.entries(context.uniqueDocsIDs)\n\n  // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n  if (hasFilters) {\n    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray)\n  }\n\n  if (params.sortBy) {\n    if (typeof params.sortBy === 'function') {\n      const ids: string[] = uniqueDocsArray.map(([id]) => id)\n      const docs = await orama.documentsStore.getMultiple(orama.data.docs, ids)\n      const docsWithIdAndScore: CustomSorterFunctionItem[] = docs.map((d, i) => [\n        uniqueDocsArray[i][0],\n        uniqueDocsArray[i][1],\n        d!,\n      ])\n      docsWithIdAndScore.sort(params.sortBy)\n      uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [id, score])\n    } else {\n      uniqueDocsArray = await orama.sorter.sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy)\n    }\n  } else {\n    uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate)\n  }\n\n  let results\n  if (!isPreflight && distinctOn) {\n    results = await fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn)\n  } else if (!isPreflight) {\n    results = await fetchDocuments(orama, uniqueDocsArray, offset, limit)\n  }\n\n  const searchResult: Results<AggValue> = {\n    elapsed: {\n      raw: 0,\n      formatted: '',\n    },\n    // We keep the hits array empty if it's a preflight request.\n    hits: [],\n    count: uniqueDocsArray.length,\n  }\n\n  if (typeof results !== 'undefined') {\n    searchResult.hits = results.filter(Boolean)\n  }\n\n  if (shouldCalculateFacets) {\n    // Populate facets if needed\n    const facets = await getFacets(orama, uniqueDocsArray, params.facets!)\n    searchResult.facets = facets\n  }\n\n  if (params.groupBy) {\n    searchResult.groups = await getGroups(orama, uniqueDocsArray, params.groupBy)\n  }\n\n  searchResult.elapsed = (await orama.formatElapsedTime(\n    (await getNanosecondsTime()) - context.timeStart,\n  )) as ElapsedTime\n\n  return searchResult\n}\n\nasync function fetchDocumentsWithDistinct(\n  orama: Orama,\n  uniqueDocsArray: [string, number][],\n  offset: number,\n  limit: number,\n  distinctOn: string,\n): Promise<Result[]> {\n  const docs = orama.data.docs\n\n  // Keep track which values we already seen\n  const values = new Map<SearchableValue, true>()\n\n  // We cannot know how many results we will have in the end,\n  // so we need cannot pre-allocate the array.\n  const results: Result[] = []\n\n  const resultIDs: Set<string> = new Set()\n  const uniqueDocsArrayLength = uniqueDocsArray.length\n  let count = 0\n  for (let i = 0; i < uniqueDocsArrayLength; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      continue\n    }\n\n    const [id, score] = idAndScore\n\n    if (resultIDs.has(id)) {\n      continue\n    }\n\n    const doc = await orama.documentsStore.get(docs, id)\n    const value = await getNested(doc as object, distinctOn)\n    if (typeof value === 'undefined' || values.has(value)) {\n      continue\n    }\n    values.set(value, true)\n\n    count++\n    // We shouldn't consider the document if it's not in the offset range\n    if (count <= offset) {\n      continue\n    }\n\n    results.push({ id, score, document: doc! })\n    resultIDs.add(id)\n\n    // reached the limit, break the loop\n    if (count >= offset + limit) {\n      break\n    }\n  }\n\n  return results\n}\n\nasync function fetchDocuments(\n  orama: Orama,\n  uniqueDocsArray: [string, number][],\n  offset: number,\n  limit: number,\n): Promise<Result[]> {\n  const docs = orama.data.docs\n\n  const results: Result[] = Array.from({\n    length: limit,\n  })\n\n  const resultIDs: Set<string> = new Set()\n\n  // We already have the list of ALL the document IDs containing the search terms.\n  // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n  // to provide pagination capabilities to the search.\n  for (let i = offset; i < limit + offset; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      break\n    }\n\n    const [id, score] = idAndScore\n\n    if (!resultIDs.has(id)) {\n      // We retrieve the full document only AFTER making sure that we really want it.\n      // We never retrieve the full document preventively.\n      const fullDoc = await orama.documentsStore.get(docs, id)\n      results[i] = { id, score, document: fullDoc! }\n      resultIDs.add(id)\n    }\n  }\n  return results\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}