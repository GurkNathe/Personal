{"ast":null,"code":"/**\n * Inspired by:\n * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340\n */function _boundedLevenshtein(a, b, tolerance) {\n  // the strings are the same\n  if (a === b) {\n    return 0;\n  }\n  // a should be the shortest string\n  const swap = a;\n  if (a.length > b.length) {\n    a = b;\n    b = swap;\n  }\n  let lenA = a.length;\n  let lenB = b.length;\n  // ignore common suffix\n  // note: `~-` decreases by a unit in a bitwise fashion\n  while (lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)) {\n    lenA--;\n    lenB--;\n  }\n  // early return when the smallest string is empty\n  if (!lenA) {\n    return lenB > tolerance ? -1 : lenB;\n  }\n  // ignore common prefix\n  let startIdx = 0;\n  while (startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)) {\n    startIdx++;\n  }\n  lenA -= startIdx;\n  lenB -= startIdx;\n  // early return when the smallest string is empty\n  if (lenA === 0) {\n    return lenB > tolerance ? -1 : lenB;\n  }\n  const delta = lenB - lenA;\n  if (tolerance > lenB) {\n    tolerance = lenB;\n  } else if (delta > tolerance) {\n    return -1;\n  }\n  let i = 0;\n  const row = [];\n  const characterCodeCache = [];\n  while (i < tolerance) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i);\n    row[i] = ++i;\n  }\n  while (i < lenB) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i);\n    row[i++] = tolerance + 1;\n  }\n  const offset = tolerance - delta;\n  const haveMax = tolerance < lenB;\n  let jStart = 0;\n  let jEnd = tolerance;\n  let current = 0;\n  let left = 0;\n  let above = 0;\n  let charA = 0;\n  let j = 0;\n  // Starting the nested loops\n  for (i = 0; i < lenA; i++) {\n    left = i;\n    current = i + 1;\n    charA = a.charCodeAt(startIdx + i);\n    jStart += i > offset ? 1 : 0;\n    jEnd += jEnd < lenB ? 1 : 0;\n    for (j = jStart; j < jEnd; j++) {\n      above = current;\n      current = left;\n      left = row[j];\n      if (charA !== characterCodeCache[j]) {\n        // insert current\n        if (left < current) {\n          current = left;\n        }\n        // delete current\n        if (above < current) {\n          current = above;\n        }\n        current++;\n      }\n      row[j] = current;\n    }\n    if (haveMax && row[i + delta] > tolerance) {\n      return -1;\n    }\n  }\n  return current <= tolerance ? current : -1;\n}\n/**\n * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance\n * is greater than the given tolerance.\n * It assumes that:\n * - tolerance >= ||a| - |b|| >= 0\n */\nexport async function boundedLevenshtein(a, b, tolerance) {\n  const distance = _boundedLevenshtein(a, b, tolerance);\n  return {\n    distance,\n    isBounded: distance >= 0\n  };\n}\n// This is only used internally, keep in sync with the previous one\nexport function syncBoundedLevenshtein(a, b, tolerance) {\n  const distance = _boundedLevenshtein(a, b, tolerance);\n  return {\n    distance,\n    isBounded: distance >= 0\n  };\n}\nexport function levenshtein(a, b) {\n  /* c8 ignore next 3 */if (!a.length) {\n    return b.length;\n  }\n  /* c8 ignore next 3 */\n  if (!b.length) {\n    return a.length;\n  }\n  const swap = a;\n  if (a.length > b.length) {\n    a = b;\n    b = swap;\n  }\n  const row = Array.from({\n    length: a.length + 1\n  }, (_, i) => i);\n  let val = 0;\n  for (let i = 1; i <= b.length; i++) {\n    let prev = i;\n    for (let j = 1; j <= a.length; j++) {\n      if (b[i - 1] === a[j - 1]) {\n        val = row[j - 1];\n      } else {\n        val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));\n      }\n      row[j - 1] = prev;\n      prev = val;\n    }\n    row[a.length] = prev;\n  }\n  return row[a.length];\n}","map":{"version":3,"names":["_boundedLevenshtein","a","b","tolerance","swap","length","lenA","lenB","charCodeAt","startIdx","delta","i","row","characterCodeCache","offset","haveMax","jStart","jEnd","current","left","above","charA","j","boundedLevenshtein","distance","isBounded","syncBoundedLevenshtein","levenshtein","Array","from","_","val","prev","Math","min"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/components/levenshtein.ts"],"sourcesContent":["export type BoundedMetric = {\n  isBounded: boolean\n  distance: number\n}\n\n/**\n * Inspired by:\n * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340\n */\nfunction _boundedLevenshtein(a: string, b: string, tolerance: number): number {\n  // the strings are the same\n  if (a === b) {\n    return 0\n  }\n\n  // a should be the shortest string\n  const swap = a\n  if (a.length > b.length) {\n    a = b\n    b = swap\n  }\n\n  let lenA = a.length\n  let lenB = b.length\n\n  // ignore common suffix\n  // note: `~-` decreases by a unit in a bitwise fashion\n  while (lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)) {\n    lenA--\n    lenB--\n  }\n\n  // early return when the smallest string is empty\n  if (!lenA) {\n    return lenB > tolerance ? -1 : lenB\n  }\n\n  // ignore common prefix\n  let startIdx = 0\n  while (startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)) {\n    startIdx++\n  }\n  lenA -= startIdx\n  lenB -= startIdx\n\n  // early return when the smallest string is empty\n  if (lenA === 0) {\n    return lenB > tolerance ? -1 : lenB\n  }\n\n  const delta = lenB - lenA\n\n  if (tolerance > lenB) {\n    tolerance = lenB\n  } else if (delta > tolerance) {\n    return -1\n  }\n\n  let i = 0\n  const row = []\n  const characterCodeCache = []\n\n  while (i < tolerance) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i)\n    row[i] = ++i\n  }\n\n  while (i < lenB) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i)\n    row[i++] = tolerance + 1\n  }\n\n  const offset = tolerance - delta\n  const haveMax = tolerance < lenB\n\n  let jStart = 0\n  let jEnd = tolerance\n\n  let current = 0\n  let left = 0\n  let above = 0\n  let charA = 0\n  let j = 0\n\n  // Starting the nested loops\n  for (i = 0; i < lenA; i++) {\n    left = i\n    current = i + 1\n\n    charA = a.charCodeAt(startIdx + i)\n    jStart += i > offset ? 1 : 0\n    jEnd += jEnd < lenB ? 1 : 0\n\n    for (j = jStart; j < jEnd; j++) {\n      above = current\n\n      current = left\n      left = row[j]\n\n      if (charA !== characterCodeCache[j]) {\n        // insert current\n        if (left < current) {\n          current = left\n        }\n\n        // delete current\n        if (above < current) {\n          current = above\n        }\n\n        current++\n      }\n\n      row[j] = current\n    }\n\n    if (haveMax && row[i + delta] > tolerance) {\n      return -1\n    }\n  }\n\n  return current <= tolerance ? current : -1\n}\n\n/**\n * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance\n * is greater than the given tolerance.\n * It assumes that:\n * - tolerance >= ||a| - |b|| >= 0\n */\nexport async function boundedLevenshtein(a: string, b: string, tolerance: number): Promise<BoundedMetric> {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0,\n  }\n}\n\n// This is only used internally, keep in sync with the previous one\nexport function syncBoundedLevenshtein(a: string, b: string, tolerance: number): BoundedMetric {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0,\n  }\n}\n\nexport function levenshtein(a: string, b: string): number {\n  /* c8 ignore next 3 */\n  if (!a.length) {\n    return b.length\n  }\n\n  /* c8 ignore next 3 */\n  if (!b.length) {\n    return a.length\n  }\n\n  const swap = a\n  if (a.length > b.length) {\n    a = b\n    b = swap\n  }\n\n  const row = Array.from({ length: a.length + 1 }, (_, i) => i)\n  let val = 0\n\n  for (let i = 1; i <= b.length; i++) {\n    let prev = i\n\n    for (let j = 1; j <= a.length; j++) {\n      if (b[i - 1] === a[j - 1]) {\n        val = row[j - 1]\n      } else {\n        val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1))\n      }\n\n      row[j - 1] = prev\n      prev = val\n    }\n    row[a.length] = prev\n  }\n\n  return row[a.length]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}