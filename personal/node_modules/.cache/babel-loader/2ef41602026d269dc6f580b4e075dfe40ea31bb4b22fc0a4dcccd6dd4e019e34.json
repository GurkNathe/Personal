{"ast":null,"code":"var escapeForXML = require('./escapeForXML');\nvar Stream = require('stream').Stream;\nvar DEFAULT_INDENT = '    ';\nfunction xml(input, options) {\n  if (typeof options !== 'object') {\n    options = {\n      indent: options\n    };\n  }\n  var stream = options.stream ? new Stream() : null,\n    output = \"\",\n    interrupted = false,\n    indent = !options.indent ? '' : options.indent === true ? DEFAULT_INDENT : options.indent,\n    instant = true;\n  function delay(func) {\n    if (!instant) {\n      func();\n    } else {\n      process.nextTick(func);\n    }\n  }\n  function append(interrupt, out) {\n    if (out !== undefined) {\n      output += out;\n    }\n    if (interrupt && !interrupted) {\n      stream = stream || new Stream();\n      interrupted = true;\n    }\n    if (interrupt && interrupted) {\n      var data = output;\n      delay(function () {\n        stream.emit('data', data);\n      });\n      output = \"\";\n    }\n  }\n  function add(value, last) {\n    format(append, resolve(value, indent, indent ? 1 : 0), last);\n  }\n  function end() {\n    if (stream) {\n      var data = output;\n      delay(function () {\n        stream.emit('data', data);\n        stream.emit('end');\n        stream.readable = false;\n        stream.emit('close');\n      });\n    }\n  }\n  function addXmlDeclaration(declaration) {\n    var encoding = declaration.encoding || 'UTF-8',\n      attr = {\n        version: '1.0',\n        encoding: encoding\n      };\n    if (declaration.standalone) {\n      attr.standalone = declaration.standalone;\n    }\n    add({\n      '?xml': {\n        _attr: attr\n      }\n    });\n    output = output.replace('/>', '?>');\n  }\n\n  // disable delay delayed\n  delay(function () {\n    instant = false;\n  });\n  if (options.declaration) {\n    addXmlDeclaration(options.declaration);\n  }\n  if (input && input.forEach) {\n    input.forEach(function (value, i) {\n      var last;\n      if (i + 1 === input.length) last = end;\n      add(value, last);\n    });\n  } else {\n    add(input, end);\n  }\n  if (stream) {\n    stream.readable = true;\n    return stream;\n  }\n  return output;\n}\nfunction element( /*input, …*/\n) {\n  var input = Array.prototype.slice.call(arguments),\n    self = {\n      _elem: resolve(input)\n    };\n  self.push = function (input) {\n    if (!this.append) {\n      throw new Error(\"not assigned to a parent!\");\n    }\n    var that = this;\n    var indent = this._elem.indent;\n    format(this.append, resolve(input, indent, this._elem.icount + (indent ? 1 : 0)), function () {\n      that.append(true);\n    });\n  };\n  self.close = function (input) {\n    if (input !== undefined) {\n      this.push(input);\n    }\n    if (this.end) {\n      this.end();\n    }\n  };\n  return self;\n}\nfunction create_indent(character, count) {\n  return new Array(count || 0).join(character || '');\n}\nfunction resolve(data, indent, indent_count) {\n  indent_count = indent_count || 0;\n  var indent_spaces = create_indent(indent, indent_count);\n  var name;\n  var values = data;\n  var interrupt = false;\n  if (typeof data === 'object') {\n    var keys = Object.keys(data);\n    name = keys[0];\n    values = data[name];\n    if (values && values._elem) {\n      values._elem.name = name;\n      values._elem.icount = indent_count;\n      values._elem.indent = indent;\n      values._elem.indents = indent_spaces;\n      values._elem.interrupt = values;\n      return values._elem;\n    }\n  }\n  var attributes = [],\n    content = [];\n  var isStringContent;\n  function get_attributes(obj) {\n    var keys = Object.keys(obj);\n    keys.forEach(function (key) {\n      attributes.push(attribute(key, obj[key]));\n    });\n  }\n  switch (typeof values) {\n    case 'object':\n      if (values === null) break;\n      if (values._attr) {\n        get_attributes(values._attr);\n      }\n      if (values._cdata) {\n        content.push(('<![CDATA[' + values._cdata).replace(/\\]\\]>/g, ']]]]><![CDATA[>') + ']]>');\n      }\n      if (values.forEach) {\n        isStringContent = false;\n        content.push('');\n        values.forEach(function (value) {\n          if (typeof value == 'object') {\n            var _name = Object.keys(value)[0];\n            if (_name == '_attr') {\n              get_attributes(value._attr);\n            } else {\n              content.push(resolve(value, indent, indent_count + 1));\n            }\n          } else {\n            //string\n            content.pop();\n            isStringContent = true;\n            content.push(escapeForXML(value));\n          }\n        });\n        if (!isStringContent) {\n          content.push('');\n        }\n      }\n      break;\n    default:\n      //string\n      content.push(escapeForXML(values));\n  }\n  return {\n    name: name,\n    interrupt: interrupt,\n    attributes: attributes,\n    content: content,\n    icount: indent_count,\n    indents: indent_spaces,\n    indent: indent\n  };\n}\nfunction format(append, elem, end) {\n  if (typeof elem != 'object') {\n    return append(false, elem);\n  }\n  var len = elem.interrupt ? 1 : elem.content.length;\n  function proceed() {\n    while (elem.content.length) {\n      var value = elem.content.shift();\n      if (value === undefined) continue;\n      if (interrupt(value)) return;\n      format(append, value);\n    }\n    append(false, (len > 1 ? elem.indents : '') + (elem.name ? '</' + elem.name + '>' : '') + (elem.indent && !end ? '\\n' : ''));\n    if (end) {\n      end();\n    }\n  }\n  function interrupt(value) {\n    if (value.interrupt) {\n      value.interrupt.append = append;\n      value.interrupt.end = proceed;\n      value.interrupt = false;\n      append(true);\n      return true;\n    }\n    return false;\n  }\n  append(false, elem.indents + (elem.name ? '<' + elem.name : '') + (elem.attributes.length ? ' ' + elem.attributes.join(' ') : '') + (len ? elem.name ? '>' : '' : elem.name ? '/>' : '') + (elem.indent && len > 1 ? '\\n' : ''));\n  if (!len) {\n    return append(false, elem.indent ? '\\n' : '');\n  }\n  if (!interrupt(elem)) {\n    proceed();\n  }\n}\nfunction attribute(key, value) {\n  return key + '=' + '\"' + escapeForXML(value) + '\"';\n}\nmodule.exports = xml;\nmodule.exports.element = module.exports.Element = element;","map":{"version":3,"names":["escapeForXML","require","Stream","DEFAULT_INDENT","xml","input","options","indent","stream","output","interrupted","instant","delay","func","process","nextTick","append","interrupt","out","undefined","data","emit","add","value","last","format","resolve","end","readable","addXmlDeclaration","declaration","encoding","attr","version","standalone","_attr","replace","forEach","i","length","element","Array","prototype","slice","call","arguments","self","_elem","push","Error","that","icount","close","create_indent","character","count","join","indent_count","indent_spaces","name","values","keys","Object","indents","attributes","content","isStringContent","get_attributes","obj","key","attribute","_cdata","_name","pop","elem","len","proceed","shift","module","exports","Element"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/xml@1.0.1/node_modules/xml/lib/xml.js"],"sourcesContent":["var escapeForXML = require('./escapeForXML');\nvar Stream = require('stream').Stream;\n\nvar DEFAULT_INDENT = '    ';\n\nfunction xml(input, options) {\n\n    if (typeof options !== 'object') {\n        options = {\n            indent: options\n        };\n    }\n\n    var stream      = options.stream ? new Stream() : null,\n        output      = \"\",\n        interrupted = false,\n        indent      = !options.indent ? ''\n                        : options.indent === true ? DEFAULT_INDENT\n                            : options.indent,\n        instant     = true;\n\n\n    function delay (func) {\n        if (!instant) {\n            func();\n        } else {\n            process.nextTick(func);\n        }\n    }\n\n    function append (interrupt, out) {\n        if (out !== undefined) {\n            output += out;\n        }\n        if (interrupt && !interrupted) {\n            stream = stream || new Stream();\n            interrupted = true;\n        }\n        if (interrupt && interrupted) {\n            var data = output;\n            delay(function () { stream.emit('data', data) });\n            output = \"\";\n        }\n    }\n\n    function add (value, last) {\n        format(append, resolve(value, indent, indent ? 1 : 0), last);\n    }\n\n    function end() {\n        if (stream) {\n            var data = output;\n            delay(function () {\n              stream.emit('data', data);\n              stream.emit('end');\n              stream.readable = false;\n              stream.emit('close');\n            });\n        }\n    }\n\n    function addXmlDeclaration(declaration) {\n        var encoding = declaration.encoding || 'UTF-8',\n            attr =  { version: '1.0', encoding: encoding };\n\n        if (declaration.standalone) {\n            attr.standalone = declaration.standalone\n        }\n\n        add({'?xml': { _attr: attr } });\n        output = output.replace('/>', '?>');\n    }\n\n    // disable delay delayed\n    delay(function () { instant = false });\n\n    if (options.declaration) {\n        addXmlDeclaration(options.declaration);\n    }\n\n    if (input && input.forEach) {\n        input.forEach(function (value, i) {\n            var last;\n            if (i + 1 === input.length)\n                last = end;\n            add(value, last);\n        });\n    } else {\n        add(input, end);\n    }\n\n    if (stream) {\n        stream.readable = true;\n        return stream;\n    }\n    return output;\n}\n\nfunction element (/*input, …*/) {\n    var input = Array.prototype.slice.call(arguments),\n        self = {\n            _elem:  resolve(input)\n        };\n\n    self.push = function (input) {\n        if (!this.append) {\n            throw new Error(\"not assigned to a parent!\");\n        }\n        var that = this;\n        var indent = this._elem.indent;\n        format(this.append, resolve(\n            input, indent, this._elem.icount + (indent ? 1 : 0)),\n            function () { that.append(true) });\n    };\n\n    self.close = function (input) {\n        if (input !== undefined) {\n            this.push(input);\n        }\n        if (this.end) {\n            this.end();\n        }\n    };\n\n    return self;\n}\n\nfunction create_indent(character, count) {\n    return (new Array(count || 0).join(character || ''))\n}\n\nfunction resolve(data, indent, indent_count) {\n    indent_count = indent_count || 0;\n    var indent_spaces = create_indent(indent, indent_count);\n    var name;\n    var values = data;\n    var interrupt = false;\n\n    if (typeof data === 'object') {\n        var keys = Object.keys(data);\n        name = keys[0];\n        values = data[name];\n\n        if (values && values._elem) {\n            values._elem.name = name;\n            values._elem.icount = indent_count;\n            values._elem.indent = indent;\n            values._elem.indents = indent_spaces;\n            values._elem.interrupt = values;\n            return values._elem;\n        }\n    }\n\n    var attributes = [],\n        content = [];\n\n    var isStringContent;\n\n    function get_attributes(obj){\n        var keys = Object.keys(obj);\n        keys.forEach(function(key){\n            attributes.push(attribute(key, obj[key]));\n        });\n    }\n\n    switch(typeof values) {\n        case 'object':\n            if (values === null) break;\n\n            if (values._attr) {\n                get_attributes(values._attr);\n            }\n\n            if (values._cdata) {\n                content.push(\n                    ('<![CDATA[' + values._cdata).replace(/\\]\\]>/g, ']]]]><![CDATA[>') + ']]>'\n                );\n            }\n\n            if (values.forEach) {\n                isStringContent = false;\n                content.push('');\n                values.forEach(function(value) {\n                    if (typeof value == 'object') {\n                        var _name = Object.keys(value)[0];\n\n                        if (_name == '_attr') {\n                            get_attributes(value._attr);\n                        } else {\n                            content.push(resolve(\n                                value, indent, indent_count + 1));\n                        }\n                    } else {\n                        //string\n                        content.pop();\n                        isStringContent=true;\n                        content.push(escapeForXML(value));\n                    }\n\n                });\n                if (!isStringContent) {\n                    content.push('');\n                }\n            }\n        break;\n\n        default:\n            //string\n            content.push(escapeForXML(values));\n\n    }\n\n    return {\n        name:       name,\n        interrupt:  interrupt,\n        attributes: attributes,\n        content:    content,\n        icount:     indent_count,\n        indents:    indent_spaces,\n        indent:     indent\n    };\n}\n\nfunction format(append, elem, end) {\n\n    if (typeof elem != 'object') {\n        return append(false, elem);\n    }\n\n    var len = elem.interrupt ? 1 : elem.content.length;\n\n    function proceed () {\n        while (elem.content.length) {\n            var value = elem.content.shift();\n\n            if (value === undefined) continue;\n            if (interrupt(value)) return;\n\n            format(append, value);\n        }\n\n        append(false, (len > 1 ? elem.indents : '')\n            + (elem.name ? '</' + elem.name + '>' : '')\n            + (elem.indent && !end ? '\\n' : ''));\n\n        if (end) {\n            end();\n        }\n    }\n\n    function interrupt(value) {\n       if (value.interrupt) {\n           value.interrupt.append = append;\n           value.interrupt.end = proceed;\n           value.interrupt = false;\n           append(true);\n           return true;\n       }\n       return false;\n    }\n\n    append(false, elem.indents\n        + (elem.name ? '<' + elem.name : '')\n        + (elem.attributes.length ? ' ' + elem.attributes.join(' ') : '')\n        + (len ? (elem.name ? '>' : '') : (elem.name ? '/>' : ''))\n        + (elem.indent && len > 1 ? '\\n' : ''));\n\n    if (!len) {\n        return append(false, elem.indent ? '\\n' : '');\n    }\n\n    if (!interrupt(elem)) {\n        proceed();\n    }\n}\n\nfunction attribute(key, value) {\n    return key + '=' + '\"' + escapeForXML(value) + '\"';\n}\n\nmodule.exports = xml;\nmodule.exports.element = module.exports.Element = element;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}