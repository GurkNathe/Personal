{"ast":null,"code":"import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nvar mergeBufferGeometries = function mergeBufferGeometries(geometries, useGroups) {\n  var isIndexed = geometries[0].index !== null;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  var attributes = {};\n  var morphAttributes = {};\n  var morphTargetsRelative = geometries[0].morphTargetsRelative;\n  var mergedGeometry = new BufferGeometry();\n  var offset = 0;\n  geometries.forEach(function (geom, i) {\n    var attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n      return null;\n    }\n    for (var name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n      return null;\n    }\n    for (var _name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(_name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n        return null;\n      }\n      if (morphAttributes[_name] === void 0) morphAttributes[_name] = [];\n      morphAttributes[_name].push(geom.morphAttributes[_name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      var count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    var indexOffset = 0;\n    var mergedIndex = [];\n    geometries.forEach(function (geom) {\n      var index = geom.index;\n      for (var j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (var name in attributes) {\n    var mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (var _name2 in morphAttributes) {\n    var numMorphTargets = morphAttributes[_name2][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[_name2] = [];\n    for (var i = 0; i < numMorphTargets; ++i) {\n      var morphAttributesToMerge = [];\n      for (var j = 0; j < morphAttributes[_name2].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[_name2][j][i]);\n      }\n      var mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + _name2 + \" morphAttribute.\");\n        return null;\n      }\n      mergedGeometry.morphAttributes[_name2].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nvar mergeBufferAttributes = function mergeBufferAttributes(attributes) {\n  var TypedArray = void 0;\n  var itemSize = void 0;\n  var normalized = void 0;\n  var arrayLength = 0;\n  attributes.forEach(function (attr) {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n      return null;\n    }\n    if (itemSize === void 0) itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n      return null;\n    }\n    if (normalized === void 0) normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n    attributes.forEach(function (attr) {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nvar interleaveAttributes = function interleaveAttributes(attributes) {\n  var TypedArray = void 0;\n  var arrayLength = 0;\n  var stride = 0;\n  for (var i = 0, l = attributes.length; i < l; ++i) {\n    var attribute = attributes[i];\n    if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  var offset = 0;\n  var res = [];\n  var getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  var setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (var j = 0, _l = attributes.length; j < _l; j++) {\n    var _attribute = attributes[j];\n    var itemSize = _attribute.itemSize;\n    var count = _attribute.count;\n    var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, _attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (var c = 0; c < count; c++) {\n      for (var k = 0; k < itemSize; k++) {\n        var set = getWithKey(iba, setters[k]);\n        var get = getWithKey(_attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  var mem = 0;\n  for (var name in geometry.attributes) {\n    var attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  var indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  var hashToIndex = {};\n  var indices = geometry.getIndex();\n  var positions = geometry.getAttribute(\"position\");\n  var vertexCount = indices ? indices.count : positions.count;\n  var nextIndex = 0;\n  var attributeNames = Object.keys(geometry.attributes);\n  var attrArrays = {};\n  var morphAttrsArrays = {};\n  var newIndices = [];\n  var getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (var i = 0, l = attributeNames.length; i < l; i++) {\n    var name = attributeNames[i];\n    attrArrays[name] = [];\n    var morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(function () {\n        return [];\n      });\n    }\n  }\n  var decimalShift = Math.log10(1 / tolerance);\n  var shiftMultiplier = Math.pow(10, decimalShift);\n  for (var _i = 0; _i < vertexCount; _i++) {\n    var index = indices ? indices.getX(_i) : _i;\n    var hash = \"\";\n    for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {\n      var _name3 = attributeNames[j];\n      var attribute = geometry.getAttribute(_name3);\n      var itemSize = attribute.itemSize;\n      for (var k = 0; k < itemSize; k++) {\n        hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (var _j = 0, _l3 = attributeNames.length; _j < _l3; _j++) {\n        var _name4 = attributeNames[_j];\n        var _attribute2 = geometry.getAttribute(_name4);\n        var _morphAttr = geometry.morphAttributes[_name4];\n        var _itemSize = _attribute2.itemSize;\n        var newarray = attrArrays[_name4];\n        var newMorphArrays = morphAttrsArrays[_name4];\n        for (var _k = 0; _k < _itemSize; _k++) {\n          var getterFunc = getters[_k];\n          newarray.push(_attribute2[getterFunc](index));\n          if (_morphAttr) {\n            for (var m = 0, ml = _morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(_morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  var result = geometry.clone();\n  for (var _i2 = 0, _l4 = attributeNames.length; _i2 < _l4; _i2++) {\n    var _name5 = attributeNames[_i2];\n    var oldAttribute = geometry.getAttribute(_name5);\n    var buffer = new oldAttribute.array.constructor(attrArrays[_name5]);\n    var _attribute3 = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(_name5, _attribute3);\n    if (_name5 in morphAttrsArrays) {\n      for (var _j2 = 0; _j2 < morphAttrsArrays[_name5].length; _j2++) {\n        var oldMorphAttribute = geometry.morphAttributes[_name5][_j2];\n        var buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[_name5][_j2]);\n        var morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[_name5][_j2] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    var index = geometry.getIndex();\n    if (index === null) {\n      var indices = [];\n      var position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (var i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n        return geometry;\n      }\n    }\n    var numberOfTriangles = index.count - 2;\n    var newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (var _i3 = 1; _i3 <= numberOfTriangles; _i3++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(_i3));\n          newIndices.push(index.getX(_i3 + 1));\n        }\n      } else {\n        for (var _i4 = 0; _i4 < numberOfTriangles; _i4++) {\n          if (_i4 % 2 === 0) {\n            newIndices.push(index.getX(_i4));\n            newIndices.push(index.getX(_i4 + 1));\n            newIndices.push(index.getX(_i4 + 2));\n          } else {\n            newIndices.push(index.getX(_i4 + 2));\n            newIndices.push(index.getX(_i4 + 1));\n            newIndices.push(index.getX(_i4));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    var newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  var _vA = new Vector3();\n  var _vB = new Vector3();\n  var _vC = new Vector3();\n  var _tempA = new Vector3();\n  var _tempB = new Vector3();\n  var _tempC = new Vector3();\n  var _morphA = new Vector3();\n  var _morphB = new Vector3();\n  var _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    var morphInfluences = object2.morphTargetInfluences;\n    if (\n    // @ts-ignore\n    material2.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (var i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        var influence = morphInfluences[i2];\n        var morph = morphAttribute[i2];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  var geometry = object.geometry;\n  var material = object.material;\n  var a, b, c;\n  var index = geometry.index;\n  var positionAttribute = geometry.attributes.position;\n  var morphPosition = geometry.morphAttributes.position;\n  var morphTargetsRelative = geometry.morphTargetsRelative;\n  var normalAttribute = geometry.attributes.normal;\n  var morphNormal = geometry.morphAttributes.position;\n  var groups = geometry.groups;\n  var drawRange = geometry.drawRange;\n  var i, j, il, jl;\n  var group, groupMaterial;\n  var start, end;\n  var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry) {\n  var creaseAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.PI / 3;\n  var creaseDot = Math.cos(creaseAngle);\n  var hashMultiplier = (1 + 1e-10) * 100;\n  var verts = [new Vector3(), new Vector3(), new Vector3()];\n  var tempVec1 = new Vector3();\n  var tempVec2 = new Vector3();\n  var tempNorm = new Vector3();\n  var tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    var x = ~~(v.x * hashMultiplier);\n    var y = ~~(v.y * hashMultiplier);\n    var z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n  var resultGeometry = geometry.toNonIndexed();\n  var posAttr = resultGeometry.attributes.position;\n  var vertexMap = {};\n  for (var i = 0, l = posAttr.count / 3; i < l; i++) {\n    var i3 = 3 * i;\n    var a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    var b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    var c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    var normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (var n = 0; n < 3; n++) {\n      var vert = verts[n];\n      var hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  var normalArray = new Float32Array(posAttr.count * 3);\n  var normAttr = new BufferAttribute(normalArray, 3, false);\n  for (var _i5 = 0, _l5 = posAttr.count / 3; _i5 < _l5; _i5++) {\n    var _i6 = 3 * _i5;\n    var _a = verts[0].fromBufferAttribute(posAttr, _i6 + 0);\n    var _b = verts[1].fromBufferAttribute(posAttr, _i6 + 1);\n    var _c = verts[2].fromBufferAttribute(posAttr, _i6 + 2);\n    tempVec1.subVectors(_c, _b);\n    tempVec2.subVectors(_a, _b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (var _n = 0; _n < 3; _n++) {\n      var _vert = verts[_n];\n      var _hash = hashVertex(_vert);\n      var otherNormals = vertexMap[_hash];\n      tempNorm2.set(0, 0, 0);\n      for (var k = 0, lk = otherNormals.length; k < lk; k++) {\n        var otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(_i6 + _n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toCreasedNormals, toTrianglesDrawMode };","map":{"version":3,"names":["BufferGeometry","BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","Vector3","Float32BufferAttribute","getWithKey","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","forEach","geom","i","attributesCount","console","error","name","has","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","length","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attr","array","constructor","set","interleaveAttributes","stride","l","attribute","interleavedBuffer","res","getters","setters","iba","c","k","get","estimateBytesUsed","geometry","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","arguments","undefined","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","concat","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","buffer2","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","object2","material2","morphTargetsRelative2","a2","b2","c2","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","i2","il2","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","material","a","b","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","il","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute","toCreasedNormals","creaseAngle","PI","creaseDot","cos","hashMultiplier","verts","tempVec1","tempVec2","tempNorm","tempNorm2","hashVertex","v","resultGeometry","toNonIndexed","posAttr","vertexMap","i3","subVectors","crossVectors","normalize","n","vert","normalArray","normAttr","otherNormals","lk","otherNorm","dot","setXYZ"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/utils/BufferGeometryUtils.js"],"sourcesContent":["import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.toNonIndexed();\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}