{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide } from \"three\";\nvar isCubeTexture = function isCubeTexture(def) {\n  return def && def.isCubeTexture;\n};\nvar GroundProjectedEnv = /*#__PURE__*/function (_Mesh) {\n  _inherits(GroundProjectedEnv, _Mesh);\n  var _super = _createSuper(GroundProjectedEnv);\n  function GroundProjectedEnv(texture, options) {\n    _classCallCheck(this, GroundProjectedEnv);\n    var _a, _b;\n    var isCubeMap = isCubeTexture(texture);\n    var w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n    var cubeSize = w / 4;\n    var _lodMax = Math.floor(Math.log2(cubeSize));\n    var _cubeSize = Math.pow(2, _lodMax);\n    var width = 3 * Math.max(_cubeSize, 16 * 7);\n    var height = 4 * _cubeSize;\n    var defines = [isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\", \"#define CUBEUV_TEXEL_WIDTH \".concat(1 / width), \"#define CUBEUV_TEXEL_HEIGHT \".concat(1 / height), \"#define CUBEUV_MAX_MIP \".concat(_lodMax, \".0\")];\n    var vertexShader = /* glsl */\"\\n        varying vec3 vWorldPosition;\\n        void main() \\n        {\\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\\n            vWorldPosition = worldPosition.xyz;\\n            \\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\\n        \";\n    var fragmentShader = defines.join(\"\\n\") + /* glsl */\"\\n        #define ENVMAP_TYPE_CUBE_UV\\n        varying vec3 vWorldPosition;\\n        uniform float radius;\\n        uniform float height;\\n        uniform float angle;\\n        #ifdef ENVMAP_TYPE_CUBE\\n            uniform samplerCube map;\\n        #else\\n            uniform sampler2D map;\\n        #endif\\n        // From: https://www.shadertoy.com/view/4tsBD7\\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \\n        {\\n            float d = dot ( rd, n );\\n            \\n            if( d > 0.0 ) { return 1e6; }\\n            \\n            vec3  o = ro - c;\\n            float t = - dot( n, o ) / d;\\n            vec3  q = o + rd * t;\\n            \\n            return ( dot( q, q ) < r * r ) ? t : 1e6;\\n        }\\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \\n        {\\n            vec3 oc = ro - ce;\\n            float b = dot( oc, rd );\\n            float c = dot( oc, oc ) - ra * ra;\\n            float h = b * b - c;\\n            \\n            if( h < 0.0 ) { return -1.0; }\\n            \\n            h = sqrt( h );\\n            \\n            return - b + h;\\n        }\\n        vec3 project() \\n        {\\n            vec3 p = normalize( vWorldPosition );\\n            vec3 camPos = cameraPosition;\\n            camPos.y -= height;\\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\\n            if( intersection > 0.0 ) {\\n                \\n                vec3 h = vec3( 0.0, - height, 0.0 );\\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\\n            } else {\\n                p = vec3( 0.0, 1.0, 0.0 );\\n            }\\n            return p;\\n        }\\n        #include <common>\\n        #include <cube_uv_reflection_fragment>\\n        void main() \\n        {\\n            vec3 projectedWorldPosition = project();\\n            \\n            #ifdef ENVMAP_TYPE_CUBE\\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\\n            #else\\n                vec3 direction = normalize( projectedWorldPosition );\\n                vec2 uv = equirectUv( direction );\\n                vec3 outcolor = texture2D( map, uv ).rgb;\\n            #endif\\n            gl_FragColor = vec4( outcolor, 1.0 );\\n            #include <tonemapping_fragment>\\n            #include <encodings_fragment>\\n        }\\n        \";\n    var uniforms = {\n      map: {\n        value: texture\n      },\n      height: {\n        value: (options == null ? void 0 : options.height) || 15\n      },\n      radius: {\n        value: (options == null ? void 0 : options.radius) || 100\n      }\n    };\n    var geometry = new IcosahedronGeometry(1, 16);\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      fragmentShader: fragmentShader,\n      vertexShader: vertexShader,\n      side: DoubleSide\n    });\n    return _super.call(this, geometry, material);\n  }\n  _createClass(GroundProjectedEnv, [{\n    key: \"radius\",\n    get: function get() {\n      return this.material.uniforms.radius.value;\n    },\n    set: function set(radius) {\n      this.material.uniforms.radius.value = radius;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.material.uniforms.height.value;\n    },\n    set: function set(height) {\n      this.material.uniforms.height.value = height;\n    }\n  }]);\n  return GroundProjectedEnv;\n}(Mesh);\nexport { GroundProjectedEnv };","map":{"version":3,"names":["Mesh","IcosahedronGeometry","ShaderMaterial","DoubleSide","isCubeTexture","def","GroundProjectedEnv","_Mesh","_inherits","_super","_createSuper","texture","options","_classCallCheck","_a","_b","isCubeMap","w","image","width","cubeSize","_lodMax","Math","floor","log2","_cubeSize","pow","max","height","defines","concat","vertexShader","fragmentShader","join","uniforms","map","value","radius","geometry","material","side","call","_createClass","key","get","set"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/objects/GroundProjectedEnv.js"],"sourcesContent":["import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide } from \"three\";\nconst isCubeTexture = (def) => def && def.isCubeTexture;\nclass GroundProjectedEnv extends Mesh {\n  constructor(texture, options) {\n    var _a, _b;\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [\n      isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n      `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n    ];\n    const vertexShader = (\n      /* glsl */\n      `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    );\n    const fragmentShader = defines.join(\"\\n\") + /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n        }\n        `;\n    const uniforms = {\n      map: { value: texture },\n      height: { value: (options == null ? void 0 : options.height) || 15 },\n      radius: { value: (options == null ? void 0 : options.radius) || 100 }\n    };\n    const geometry = new IcosahedronGeometry(1, 16);\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide\n    });\n    super(geometry, material);\n  }\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n}\nexport {\n  GroundProjectedEnv\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}