{"ast":null,"code":"import _defineProperty from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, Scene, WebGLRenderer, Texture, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping, Color, MathUtils, Vector3, CompressedTexture, RGBAFormat, DoubleSide, REVISION, BufferAttribute, PropertyBinding, InterpolateDiscrete, Matrix4, InterpolateLinear } from \"three\";\nvar _renderer;\nvar fullscreenQuadGeometry;\nvar fullscreenQuadMaterial;\nvar fullscreenQuad;\nfunction decompress(texture) {\n  var maxTextureSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new ShaderMaterial({\n    uniforms: {\n      blitTexture: new Uniform(texture)\n    },\n    vertexShader: /* glsl */\"\\n        varying vec2 vUv;\\n        void main(){\\n            vUv = uv;\\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\\n        }\\n      \",\n    fragmentShader: /* glsl */\"\\n          uniform sampler2D blitTexture; \\n          varying vec2 vUv;\\n\\n          void main(){ \\n              gl_FragColor = vec4(vUv.xy, 0, 1);\\n              \\n              #ifdef IS_SRGB\\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\\n              #else\\n              gl_FragColor = texture2D( blitTexture, vUv);\\n              #endif\\n          }\\n      \"\n  });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  var _camera = new PerspectiveCamera();\n  var _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({\n      antialias: false\n    });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  var readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nvar KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\"byte\", \"byte normalized\", \"unsigned byte\", \"unsigned byte normalized\", \"short\", \"short normalized\", \"unsigned short\", \"unsigned short normalized\"],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, onError, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n  }, {\n    key: \"parseAsync\",\n    value: function parseAsync(input, options) {\n      var scope = this;\n      return new Promise(function (resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }]);\n  return GLTFExporter;\n}();\nvar WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nvar DEFAULT_SPECULAR_COLOR = new Color();\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 1179937895;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 1313821514;\nvar GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  var output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (var i = start; i < start + count; i++) {\n    for (var a = 0; a < attribute.itemSize; a++) {\n      var value = void 0;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer) {\n  var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    var array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise(function (resolve) {\n      return canvas.toBlob(resolve, mimeType);\n    });\n  }\n  var quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality\n  });\n}\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */new Map(),\n      attributes: /* @__PURE__ */new Map(),\n      attributesNormalized: /* @__PURE__ */new Map(),\n      materials: /* @__PURE__ */new Map(),\n      textures: /* @__PURE__ */new Map(),\n      images: /* @__PURE__ */new Map()\n    };\n  }\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"write\",\n    value: function () {\n      var _write = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input, onDone) {\n        var options,\n          writer,\n          buffers,\n          json,\n          extensionsUsed,\n          extensionsRequired,\n          blob,\n          extensionsUsedList,\n          extensionsRequiredList,\n          reader,\n          _reader,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              this.options = Object.assign({\n                // default options\n                binary: false,\n                trs: false,\n                onlyVisible: true,\n                maxTextureSize: Infinity,\n                animations: [],\n                includeCustomExtensions: false\n              }, options);\n              if (this.options.animations.length > 0) {\n                this.options.trs = true;\n              }\n              this.processInput(input);\n              _context.next = 6;\n              return Promise.all(this.pending);\n            case 6:\n              writer = this;\n              buffers = writer.buffers;\n              json = writer.json;\n              options = writer.options;\n              extensionsUsed = writer.extensionsUsed;\n              extensionsRequired = writer.extensionsRequired;\n              blob = new Blob(buffers, {\n                type: \"application/octet-stream\"\n              });\n              extensionsUsedList = Object.keys(extensionsUsed);\n              extensionsRequiredList = Object.keys(extensionsRequired);\n              if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n              if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n              if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n              if (options.binary === true) {\n                reader = new FileReader();\n                reader.readAsArrayBuffer(blob);\n                reader.onloadend = function () {\n                  var binaryChunk = getPaddedArrayBuffer(reader.result);\n                  var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                  binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n                  binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n                  var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n                  var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                  jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n                  jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n                  var header = new ArrayBuffer(GLB_HEADER_BYTES);\n                  var headerView = new DataView(header);\n                  headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n                  headerView.setUint32(4, GLB_VERSION, true);\n                  var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n                  headerView.setUint32(8, totalByteLength, true);\n                  var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                    type: \"application/octet-stream\"\n                  });\n                  var glbReader = new FileReader();\n                  glbReader.readAsArrayBuffer(glbBlob);\n                  glbReader.onloadend = function () {\n                    onDone(glbReader.result);\n                  };\n                };\n              } else {\n                if (json.buffers && json.buffers.length > 0) {\n                  _reader = new FileReader();\n                  _reader.readAsDataURL(blob);\n                  _reader.onloadend = function () {\n                    var base64data = _reader.result;\n                    json.buffers[0].uri = base64data;\n                    onDone(json);\n                  };\n                } else {\n                  onDone(json);\n                }\n              }\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function write(_x, _x2) {\n        return _write.apply(this, arguments);\n      }\n      return write;\n    }()\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === void 0) objectDef.extensions = {};\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n          delete json.gltfExtensions;\n        }\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n    /**\n     * Returns ids for buffer attributes.\n     * @param  {Object} object\n     * @return {Integer}\n     */\n  }, {\n    key: \"getUID\",\n    value: function getUID(attribute) {\n      var isRelativeCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.uids.has(attribute) === false) {\n        var uids2 = /* @__PURE__ */new Map();\n        uids2.set(true, this.uid++);\n        uids2.set(false, this.uid++);\n        this.uids.set(attribute, uids2);\n      }\n      var uids = this.uids.get(attribute);\n      return uids.get(isRelativeCopy);\n    }\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n      for (var i = 0, il = normal.count; i < il; i++) {\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;\n      }\n      return true;\n    }\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          v.setX(1);\n        } else {\n          v.normalize();\n        }\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n        this.extensionsUsed[\"KHR_texture_transform\"] = true;\n      }\n    }\n  }, {\n    key: \"buildMetalRoughTexture\",\n    value: function buildMetalRoughTexture(metalnessMap, roughnessMap) {\n      if (metalnessMap === roughnessMap) return metalnessMap;\n      function getEncodingConversion(map) {\n        if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n          return function SRGBToLinear(c) {\n            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n          };\n        }\n        return function LinearToLinear(c) {\n          return c;\n        };\n      }\n      console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n      if (metalnessMap instanceof CompressedTexture) {\n        metalnessMap = decompress(metalnessMap);\n      }\n      if (roughnessMap instanceof CompressedTexture) {\n        roughnessMap = decompress(roughnessMap);\n      }\n      var metalness = metalnessMap ? metalnessMap.image : null;\n      var roughness = roughnessMap ? roughnessMap.image : null;\n      var width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n      var height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n      var canvas = getCanvas();\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext(\"2d\");\n      context.fillStyle = \"#00ffff\";\n      context.fillRect(0, 0, width, height);\n      var composite = context.getImageData(0, 0, width, height);\n      if (metalness) {\n        context.drawImage(metalness, 0, 0, width, height);\n        var convert = getEncodingConversion(metalnessMap);\n        var data = context.getImageData(0, 0, width, height).data;\n        for (var i = 2; i < data.length; i += 4) {\n          composite.data[i] = convert(data[i] / 256) * 256;\n        }\n      }\n      if (roughness) {\n        context.drawImage(roughness, 0, 0, width, height);\n        var _convert = getEncodingConversion(roughnessMap);\n        var _data = context.getImageData(0, 0, width, height).data;\n        for (var _i = 1; _i < _data.length; _i += 4) {\n          composite.data[_i] = _convert(_data[_i] / 256) * 256;\n        }\n      }\n      context.putImageData(composite, 0, 0);\n      var reference = metalnessMap || roughnessMap;\n      var texture = reference.clone();\n      texture.source = new Texture(canvas).source;\n      if (\"colorSpace\" in texture) texture.colorSpace = \"\";else texture.encoding = 3e3;\n      texture.channel = (metalnessMap || roughnessMap).channel;\n      if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n        console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n      }\n      return texture;\n    }\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }];\n      buffers.push(buffer);\n      return 0;\n    }\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      var componentSize;\n      switch (componentType) {\n        case WEBGL_CONSTANTS.BYTE:\n        case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n          componentSize = 1;\n          break;\n        case WEBGL_CONSTANTS.SHORT:\n        case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n          componentSize = 2;\n          break;\n        default:\n          componentSize = 4;\n      }\n      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n            if (attribute.normalized === true) {\n              value = MathUtils.normalize(value, attribute.array);\n            }\n          }\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.INT) {\n            dataView.setInt32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n            dataView.setInt16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n            dataView.setInt8(offset, value);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n          offset += componentSize;\n        }\n      }\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== void 0) bufferViewDef.target = target;\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef);\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(function (resolve) {\n        var reader = new FileReader();\n        reader.readAsArrayBuffer(blob);\n        reader.onloadend = function () {\n          var buffer = getPaddedArrayBuffer(reader.result);\n          var bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        };\n      });\n    }\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var json = this.json;\n      var types = {\n        1: \"SCALAR\",\n        2: \"VEC2\",\n        3: \"VEC3\",\n        4: \"VEC4\",\n        9: \"MAT3\",\n        16: \"MAT4\"\n      };\n      var componentType;\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Int32Array) {\n        componentType = WEBGL_CONSTANTS.INT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Int16Array) {\n        componentType = WEBGL_CONSTANTS.SHORT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Int8Array) {\n        componentType = WEBGL_CONSTANTS.BYTE;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name);\n      }\n      if (start === void 0) start = 0;\n      if (count === void 0) count = attribute.count;\n      if (count === 0) return null;\n      var minMax = getMinMax(attribute, start, count);\n      var bufferViewTarget;\n      if (geometry !== void 0) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n      var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      var accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (RGBAFormat)\n     * @param  {Boolean} flipY before writing out the image\n     * @param  {String} mimeType export format\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var mimeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"image/png\";\n      if (image !== null) {\n        var writer = this;\n        var cache = writer.cache;\n        var json = writer.json;\n        var options = writer.options;\n        var pending = writer.pending;\n        if (!cache.images.has(image)) cache.images.set(image, {});\n        var cachedImages = cache.images.get(image);\n        var key = mimeType + \":flipY/\" + flipY.toString();\n        if (cachedImages[key] !== void 0) return cachedImages[key];\n        if (!json.images) json.images = [];\n        var imageDef = {\n          mimeType: mimeType\n        };\n        var canvas = getCanvas();\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext(\"2d\");\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n        if (image.data !== void 0) {\n          if (format !== RGBAFormat) {\n            console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n          }\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n          }\n          var data = new Uint8ClampedArray(image.height * image.width * 4);\n          for (var i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        } else {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        }\n        if (options.binary === true) {\n          pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n            return writer.processBufferViewImage(blob);\n          }).then(function (bufferViewIndex) {\n            imageDef.bufferView = bufferViewIndex;\n          }));\n        } else {\n          if (canvas.toDataURL !== void 0) {\n            imageDef.uri = canvas.toDataURL(mimeType);\n          } else {\n            pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n              return new FileReader().readAsDataURL(blob);\n            }).then(function (dataURL) {\n              imageDef.uri = dataURL;\n            }));\n          }\n        }\n        var index = json.images.push(imageDef) - 1;\n        cachedImages[key] = index;\n        return index;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n      }\n    }\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var writer = this;\n      var options = writer.options;\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      if (map instanceof CompressedTexture) {\n        map = decompress(map, options.maxTextureSize);\n      }\n      var mimeType = map.userData.mimeType;\n      if (mimeType === \"image/webp\") mimeType = \"image/png\";\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY, mimeType)\n      };\n      if (map.name) textureDef.name = map.name;\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n      if (material.isShaderMaterial) {\n        console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n        return null;\n      }\n      if (!json.materials) json.materials = [];\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n      }\n      var color = material.color.toArray().concat([material.opacity]);\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      }\n      if (material.metalnessMap || material.roughnessMap) {\n        var metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n        var metalRoughMapDef = {\n          index: this.processTexture(metalRoughTexture),\n          channel: metalRoughTexture.channel\n        };\n        this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      }\n      if (material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map),\n          texCoord: material.map.channel\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n      if (material.emissive) {\n        var emissive = material.emissive;\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = material.emissive.toArray();\n        }\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap),\n            texCoord: material.emissiveMap.channel\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      }\n      if (material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap),\n          texCoord: material.normalMap.channel\n        };\n        if (material.normalScale && material.normalScale.x !== 1) {\n          normalMapDef.scale = material.normalScale.x;\n        }\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      }\n      if (material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: material.aoMap.channel\n        };\n        if (material.aoMapIntensity !== 1) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      }\n      if (material.transparent) {\n        materialDef.alphaMode = \"BLEND\";\n      } else {\n        if (material.alphaTest > 0) {\n          materialDef.alphaMode = \"MASK\";\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      }\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== \"\") materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var _nameConversion;\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n      var meshCacheKey = meshCacheKeyParts.join(\":\");\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode;\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = [];\n      var nameConversion = (_nameConversion = {\n        uv: \"TEXCOORD_0\"\n      }, _defineProperty(_nameConversion, REVISION.replace(/\\D+/g, \"\") >= 152 ? \"uv1\" : \"uv2\", \"TEXCOORD_1\"), _defineProperty(_nameConversion, \"color\", \"COLOR_0\"), _defineProperty(_nameConversion, \"skinWeight\", \"WEIGHTS_0\"), _defineProperty(_nameConversion, \"skinIndex\", \"JOINTS_0\"), _nameConversion);\n      var originalNormal = geometry.getAttribute(\"normal\");\n      if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n        geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n      }\n      var modifiedAttribute = null;\n      for (var attributeName in geometry.attributes) {\n        if (attributeName.slice(0, 5) === \"morph\") continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = \"_\" + attributeName;\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        }\n        modifiedAttribute = null;\n        var array = attribute.array;\n        if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n        var accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n        if (accessor !== null) {\n          if (!attributeName.startsWith(\"_\")) {\n            this.detectMeshQuantization(attributeName, attribute);\n          }\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n      if (originalNormal !== void 0) geometry.setAttribute(\"normal\", originalNormal);\n      if (Object.keys(attributes).length === 0) return null;\n      if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n        if (mesh.morphTargetDictionary !== void 0) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n        for (var _i2 = 0; _i2 < mesh.morphTargetInfluences.length; ++_i2) {\n          var target = {};\n          var warned = false;\n          for (var _attributeName in geometry.morphAttributes) {\n            if (_attributeName !== \"position\" && _attributeName !== \"normal\") {\n              if (!warned) {\n                console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n                warned = true;\n              }\n              continue;\n            }\n            var _attribute = geometry.morphAttributes[_attributeName][_i2];\n            var gltfAttributeName = _attributeName.toUpperCase();\n            var baseAttribute = geometry.attributes[_attributeName];\n            if (cache.attributes.has(this.getUID(_attribute, true))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute, true));\n              continue;\n            }\n            var relativeAttribute = _attribute.clone();\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                for (var a = 0; a < _attribute.itemSize; a++) {\n                  if (a === 0) relativeAttribute.setX(j, _attribute.getX(j) - baseAttribute.getX(j));\n                  if (a === 1) relativeAttribute.setY(j, _attribute.getY(j) - baseAttribute.getY(j));\n                  if (a === 2) relativeAttribute.setZ(j, _attribute.getZ(j) - baseAttribute.getZ(j));\n                  if (a === 3) relativeAttribute.setW(j, _attribute.getW(j) - baseAttribute.getW(j));\n                }\n              }\n            }\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n          }\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i2]);\n          if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[_i2]);\n        }\n        meshDef.weights = weights;\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: void 0,\n        count: void 0\n      }];\n      for (var _i3 = 0, il = groups.length; _i3 < il; _i3++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n          if (groups[_i3].start !== void 0 || groups[_i3].count !== void 0) {\n            cacheKey += \":\" + groups[_i3].start + \":\" + groups[_i3].count;\n          }\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i3].start, groups[_i3].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n          if (primitive.indices === null) delete primitive.indices;\n        }\n        var material = this.processMaterial(materials[groups[_i3].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n    /**\n     * If a vertex attribute with a\n     * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n     * is used, it is checked whether it is a valid data type according to the\n     * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n     * extension.\n     * In this case the extension is automatically added to the list of used extensions.\n     *\n     * @param {string} attributeName\n     * @param {THREE.BufferAttribute} attribute\n     */\n  }, {\n    key: \"detectMeshQuantization\",\n    value: function detectMeshQuantization(attributeName, attribute) {\n      if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n      var attrType = void 0;\n      switch (attribute.array.constructor) {\n        case Int8Array:\n          attrType = \"byte\";\n          break;\n        case Uint8Array:\n          attrType = \"unsigned byte\";\n          break;\n        case Int16Array:\n          attrType = \"short\";\n          break;\n        case Uint16Array:\n          attrType = \"unsigned short\";\n          break;\n        default:\n          return;\n      }\n      if (attribute.normalized) attrType += \" normalized\";\n      var attrNamePrefix = attributeName.split(\"_\", 1)[0];\n      if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n        this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n        this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n      }\n    }\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? \"orthographic\" : \"perspective\"\n      };\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      }\n      if (camera.name !== \"\") cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n        if (trackBinding.objectName === \"bones\") {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = void 0;\n          }\n        }\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n        var interpolation = void 0;\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = \"CUBICSPLINE\";\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = \"STEP\";\n        } else {\n          interpolation = \"LINEAR\";\n        }\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n      json.animations.push({\n        name: clip.name || \"clip_\" + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      var node = json.nodes[nodeMap.get(object)];\n      var skeleton = object.skeleton;\n      if (skeleton === void 0) return null;\n      var rootJoint = object.skeleton.bones[0];\n      if (rootJoint === void 0) return null;\n      var joints = [];\n      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      var temporaryBoneInverse = new Matrix4();\n      for (var i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n      if (json.skins === void 0) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      var skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    }\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      }\n      if (object.name !== \"\") nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n      if (object.isMesh || object.isLine || object.isPoints) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n      if (object.isSkinnedMesh) this.skins.push(object);\n      if (object.children.length > 0) {\n        var children = [];\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex2 = this.processNode(child);\n            if (nodeIndex2 !== null) children.push(nodeIndex2);\n          }\n        }\n        if (children.length > 0) nodeDef.children = children;\n      }\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n      var sceneDef = {};\n      if (scene.name !== \"\") sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = \"AuxScene\";\n      for (var i = 0; i < objects.length; i++) {\n        scene.children.push(objects[i]);\n      }\n      this.processScene(scene);\n    }\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n      var objectsWithoutScene = [];\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n      for (var _i4 = 0; _i4 < this.skins.length; ++_i4) {\n        this.processSkin(this.skins[_i4]);\n      }\n      for (var _i5 = 0; _i5 < options.animations.length; ++_i5) {\n        this.processAnimation(options.animations[_i5], input[0]);\n      }\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  }]);\n  return GLTFWriter;\n}();\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n        return;\n      }\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n      if (light.isDirectionalLight) {\n        lightDef.type = \"directional\";\n      } else if (light.isPointLight) {\n        lightDef.type = \"point\";\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = \"spot\";\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n      if (light.decay !== void 0 && light.decay !== 2) {\n        console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\");\n      }\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");\n      }\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n      var lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }]);\n  return GLTFLightExtension;\n}();\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n  return GLTFMaterialsUnlitExtension;\n}();\nvar GLTFMaterialsClearcoatExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsClearcoatExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsClearcoatExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  _createClass(GLTFMaterialsClearcoatExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.clearcoatFactor = material.clearcoat;\n      if (material.clearcoatMap) {\n        var clearcoatMapDef = {\n          index: writer.processTexture(material.clearcoatMap),\n          texCoord: material.clearcoatMap.channel\n        };\n        writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n        extensionDef.clearcoatTexture = clearcoatMapDef;\n      }\n      extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n      if (material.clearcoatRoughnessMap) {\n        var clearcoatRoughnessMapDef = {\n          index: writer.processTexture(material.clearcoatRoughnessMap),\n          texCoord: material.clearcoatRoughnessMap.channel\n        };\n        writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n        extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n      }\n      if (material.clearcoatNormalMap) {\n        var clearcoatNormalMapDef = {\n          index: writer.processTexture(material.clearcoatNormalMap),\n          texCoord: material.clearcoatNormalMap.channel\n        };\n        writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n        extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsClearcoatExtension;\n}();\nvar GLTFMaterialsIridescenceExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIridescenceExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIridescenceExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  _createClass(GLTFMaterialsIridescenceExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.iridescenceFactor = material.iridescence;\n      if (material.iridescenceMap) {\n        var iridescenceMapDef = {\n          index: writer.processTexture(material.iridescenceMap),\n          texCoord: material.iridescenceMap.channel\n        };\n        writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n        extensionDef.iridescenceTexture = iridescenceMapDef;\n      }\n      extensionDef.iridescenceIor = material.iridescenceIOR;\n      extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n      extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n      if (material.iridescenceThicknessMap) {\n        var iridescenceThicknessMapDef = {\n          index: writer.processTexture(material.iridescenceThicknessMap),\n          texCoord: material.iridescenceThicknessMap.channel\n        };\n        writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n        extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsIridescenceExtension;\n}();\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap),\n          texCoord: material.transmissionMap.channel\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsTransmissionExtension;\n}();\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thicknessFactor = material.thickness;\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap),\n          texCoord: material.thicknessMap.channel\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor = material.attenuationColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsVolumeExtension;\n}();\nvar GLTFMaterialsIorExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIorExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIorExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  _createClass(GLTFMaterialsIorExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.ior = material.ior;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsIorExtension;\n}();\nvar GLTFMaterialsSpecularExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSpecularExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSpecularExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  _createClass(GLTFMaterialsSpecularExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.specularIntensityMap) {\n        var specularIntensityMapDef = {\n          index: writer.processTexture(material.specularIntensityMap),\n          texCoord: material.specularIntensityMap.channel\n        };\n        writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n        extensionDef.specularTexture = specularIntensityMapDef;\n      }\n      if (material.specularColorMap) {\n        var specularColorMapDef = {\n          index: writer.processTexture(material.specularColorMap),\n          texCoord: material.specularColorMap.channel\n        };\n        writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n        extensionDef.specularColorTexture = specularColorMapDef;\n      }\n      extensionDef.specularFactor = material.specularIntensity;\n      extensionDef.specularColorFactor = material.specularColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsSpecularExtension;\n}();\nvar GLTFMaterialsSheenExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSheenExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSheenExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  _createClass(GLTFMaterialsSheenExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.sheenRoughnessMap) {\n        var sheenRoughnessMapDef = {\n          index: writer.processTexture(material.sheenRoughnessMap),\n          texCoord: material.sheenRoughnessMap.channel\n        };\n        writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n        extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n      }\n      if (material.sheenColorMap) {\n        var sheenColorMapDef = {\n          index: writer.processTexture(material.sheenColorMap),\n          texCoord: material.sheenColorMap.channel\n        };\n        writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n        extensionDef.sheenColorTexture = sheenColorMapDef;\n      }\n      extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n      extensionDef.sheenColorFactor = material.sheenColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsSheenExtension;\n}();\nvar GLTFMaterialsAnisotropyExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsAnisotropyExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsAnisotropyExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  _createClass(GLTFMaterialsAnisotropyExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.anisotropyMap) {\n        var anisotropyMapDef = {\n          index: writer.processTexture(material.anisotropyMap)\n        };\n        writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n        extensionDef.anisotropyTexture = anisotropyMapDef;\n      }\n      extensionDef.anisotropyStrength = material.anisotropy;\n      extensionDef.anisotropyRotation = material.anisotropyRotation;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsAnisotropyExtension;\n}();\nvar GLTFMaterialsEmissiveStrengthExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsEmissiveStrengthExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsEmissiveStrengthExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  _createClass(GLTFMaterialsEmissiveStrengthExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.emissiveStrength = material.emissiveIntensity;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsEmissiveStrengthExtension;\n}();\nGLTFExporter.Utils = {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 1e-3;\n    var valueSize = track.getValueSize();\n    var times = new track.TimeBufferType(track.times.length + 1);\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i6 = 0; _i6 < track.times.length; _i6++) {\n        if (Math.abs(track.times[_i6] - time) < tolerance) return _i6;\n        if (track.times[_i6] < time && track.times[_i6 + 1] > time) {\n          times.set(track.times.slice(0, _i6 + 1), 0);\n          times[_i6 + 1] = time;\n          times.set(track.times.slice(_i6 + 1), _i6 + 2);\n          values.set(track.values.slice(0, (_i6 + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i6 + 1) * valueSize);\n          values.set(track.values.slice((_i6 + 1) * valueSize), (_i6 + 2) * valueSize);\n          index = _i6 + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n      var mergedTrack = void 0;\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      }\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport { GLTFExporter };","map":{"version":3,"names":["PlaneGeometry","ShaderMaterial","Uniform","Mesh","PerspectiveCamera","Scene","WebGLRenderer","Texture","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","Color","MathUtils","Vector3","CompressedTexture","RGBAFormat","DoubleSide","REVISION","BufferAttribute","PropertyBinding","InterpolateDiscrete","Matrix4","InterpolateLinear","_renderer","fullscreenQuadGeometry","fullscreenQuadMaterial","fullscreenQuad","decompress","texture","maxTextureSize","arguments","length","undefined","Infinity","renderer","uniforms","blitTexture","vertexShader","fragmentShader","value","defines","IS_SRGB","colorSpace","encoding","needsUpdate","frustrumCulled","_camera","_scene","add","antialias","setSize","Math","min","image","width","height","clear","render","readableTexture","domElement","minFilter","magFilter","wrapS","wrapT","name","dispose","KHR_mesh_quantization_ExtraAttrTypes","POSITION","NORMAL","TANGENT","TEXCOORD","GLTFExporter","_classCallCheck","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","_createClass","key","callback","indexOf","push","unregister","splice","parse","input","onDone","onError","options","GLTFWriter","plugins","i","il","setPlugins","write","catch","parseAsync","scope","Promise","resolve","reject","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","DEFAULT_SPECULAR_COLOR","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","array","getX","getY","getZ","getW","normalized","normalize","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","toBlob","quality","convertToBlob","type","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","extensionsRequired","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","_write","_asyncToGenerator","_regeneratorRuntime","mark","_callee","blob","extensionsUsedList","extensionsRequiredList","reader","_reader","_args","wrap","_callee$","_context","prev","next","Object","assign","binary","trs","onlyVisible","animations","includeCustomExtensions","processInput","all","Blob","keys","size","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","stop","_x","_x2","apply","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","console","warn","message","getUID","isRelativeCopy","has","uids2","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","setXYZ","applyTextureTransform","mapDef","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTexture","metalnessMap","roughnessMap","getEncodingConversion","map","SRGBToLinear","c","pow","LinearToLinear","metalness","roughness","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","convert","data","putImageData","reference","source","channel","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","dataView","setFloat32","setInt32","setInt16","setUint16","setInt8","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","processAccessor","geometry","types","constructor","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","Error","minMax","bufferViewTarget","bufferView","accessorDef","accessors","processImage","format","flipY","cachedImages","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","then","bufferViewIndex","toDataURL","dataURL","processSampler","samplers","samplerDef","processTexture","textureDef","sampler","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","texCoord","baseColorTexture","emissive","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","_nameConversion","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","uv","_defineProperty","replace","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","slice","toUpperCase","validVertexAttributes","test","accessor","startsWith","detectMeshQuantization","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setY","setZ","setW","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","attrType","attrNamePrefix","split","includes","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skinIndex","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex2","writeNode","nodeIndex","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isMeshPhysicalMaterial","clearcoat","extensionDef","clearcoatFactor","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","iridescence","iridescenceFactor","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","ior","specularIntensity","specularColor","equals","specularIntensityMap","specularColorTexture","specularIntensityMapDef","specularTexture","specularColorMap","specularColorMapDef","specularFactor","specularColorFactor","sheen","sheenRoughnessMap","sheenRoughnessMapDef","sheenRoughnessTexture","sheenColorMap","sheenColorMapDef","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenColorFactor","sheenColor","anisotropy","anisotropyMap","anisotropyMapDef","anisotropyTexture","anisotropyStrength","anisotropyRotation","emissiveIntensity","emissiveStrength","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/exporters/GLTFExporter.js"],"sourcesContent":["import { PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, Scene, WebGLRenderer, Texture, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping, Color, MathUtils, Vector3, CompressedTexture, RGBAFormat, DoubleSide, REVISION, BufferAttribute, PropertyBinding, InterpolateDiscrete, Matrix4, InterpolateLinear } from \"three\";\nlet _renderer;\nlet fullscreenQuadGeometry;\nlet fullscreenQuadMaterial;\nlet fullscreenQuad;\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry)\n    fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: (\n        /* glsl */\n        `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `\n      )\n    });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  const _camera = new PerspectiveCamera();\n  const _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  const readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    \"byte\",\n    \"byte normalized\",\n    \"unsigned byte\",\n    \"unsigned byte normalized\",\n    \"short\",\n    \"short normalized\",\n    \"unsigned short\",\n    \"unsigned short normalized\"\n  ],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n    this.register(function(writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options).catch(onError);\n  }\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n}\nconst WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nconst DEFAULT_SPECULAR_COLOR = new Color();\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 1179937895;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 1313821514;\nconst GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function(element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0)\n          value = attribute.getX(i);\n        else if (a === 1)\n          value = attribute.getY(i);\n        else if (a === 2)\n          value = attribute.getZ(i);\n        else if (a === 3)\n          value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality\n  });\n}\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */ new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */ new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */ new Map(),\n      attributes: /* @__PURE__ */ new Map(),\n      attributesNormalized: /* @__PURE__ */ new Map(),\n      materials: /* @__PURE__ */ new Map(),\n      textures: /* @__PURE__ */ new Map(),\n      images: /* @__PURE__ */ new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      },\n      options\n    );\n    if (this.options.animations.length > 0) {\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n    const blob = new Blob(buffers, { type: \"application/octet-stream\" });\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0)\n      json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0)\n      json.extensionsRequired = extensionsRequiredList;\n    if (json.buffers && json.buffers.length > 0)\n      json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function() {\n        const binaryChunk = getPaddedArrayBuffer(reader.result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: \"application/octet-stream\"\n        });\n        const glbReader = new FileReader();\n        glbReader.readAsArrayBuffer(glbBlob);\n        glbReader.onloadend = function() {\n          onDone(glbReader.result);\n        };\n      };\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = function() {\n          const base64data = reader.result;\n          json.buffers[0].uri = base64data;\n          onDone(json);\n        };\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0)\n      return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === void 0)\n          objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0)\n        objectDef.extras = json;\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message\n      );\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids2 = /* @__PURE__ */ new Map();\n      uids2.set(true, this.uid++);\n      uids2.set(false, this.uid++);\n      this.uids.set(attribute, uids2);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        v.setX(1);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n      this.extensionsUsed[\"KHR_texture_transform\"] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap)\n      return metalnessMap;\n    function getEncodingConversion(map) {\n      if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    context.fillStyle = \"#00ffff\";\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Texture(canvas).source;\n    if (\"colorSpace\" in texture)\n      texture.colorSpace = \"\";\n    else\n      texture.encoding = 3e3;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n    }\n    return texture;\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers)\n      json.buffers = [{ byteLength: 0 }];\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0)\n            value = attribute.getX(i);\n          else if (a === 1)\n            value = attribute.getY(i);\n          else if (a === 2)\n            value = attribute.getZ(i);\n          else if (a === 3)\n            value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength\n    };\n    if (target !== void 0)\n      bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    return new Promise(function(resolve) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function() {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let componentType;\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\n        \"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name\n      );\n    }\n    if (start === void 0)\n      start = 0;\n    if (count === void 0)\n      count = attribute.count;\n    if (count === 0)\n      return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n    if (geometry !== void 0) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType,\n      count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true)\n      accessorDef.normalized = true;\n    if (!json.accessors)\n      json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = \"image/png\") {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image))\n        cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + \":flipY/\" + flipY.toString();\n      if (cachedImages[key] !== void 0)\n        return cachedImages[key];\n      if (!json.images)\n        json.images = [];\n      const imageDef = { mimeType };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext(\"2d\");\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== void 0) {\n        if (format !== RGBAFormat) {\n          console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType).then((blob) => writer.processBufferViewImage(blob)).then((bufferViewIndex) => {\n            imageDef.bufferView = bufferViewIndex;\n          })\n        );\n      } else {\n        if (canvas.toDataURL !== void 0) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType).then((blob) => new FileReader().readAsDataURL(blob)).then((dataURL) => {\n              imageDef.uri = dataURL;\n            })\n          );\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n    }\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers)\n      json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map))\n      return cache.textures.get(map);\n    if (!json.textures)\n      json.textures = [];\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === \"image/webp\")\n      mimeType = \"image/png\";\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name)\n      textureDef.name = map.name;\n    this._invokeAll(function(ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material))\n      return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n      return null;\n    }\n    if (!json.materials)\n      json.materials = [];\n    const materialDef = { pbrMetallicRoughness: {} };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    }\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n    if (material.transparent) {\n      materialDef.alphaMode = \"BLEND\";\n    } else {\n      if (material.alphaTest > 0) {\n        materialDef.alphaMode = \"MASK\";\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n    if (material.side === DoubleSide)\n      materialDef.doubleSided = true;\n    if (material.name !== \"\")\n      materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function(ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(\":\");\n    if (cache.meshes.has(meshCacheKey))\n      return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n    const nameConversion = {\n      uv: \"TEXCOORD_0\",\n      [REVISION.replace(/\\D+/g, \"\") >= 152 ? \"uv1\" : \"uv2\"]: \"TEXCOORD_1\",\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    };\n    const originalNormal = geometry.getAttribute(\"normal\");\n    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n      geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n    }\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      if (attributeName.slice(0, 5) === \"morph\")\n        continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName))\n        attributeName = \"_\" + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith(\"_\")) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== void 0)\n      geometry.setAttribute(\"normal\", originalNormal);\n    if (Object.keys(attributes).length === 0)\n      return null;\n    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== void 0) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          if (attributeName !== \"position\" && attributeName !== \"normal\") {\n            if (!warned) {\n              console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0)\n                  relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1)\n                  relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2)\n                  relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3)\n                  relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== void 0)\n          targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0)\n      return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode,\n        attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0)\n        primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== void 0 || groups[i].count !== void 0) {\n          cacheKey += \":\" + groups[i].start + \":\" + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null)\n          delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null)\n        primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes)\n      json.meshes = [];\n    this._invokeAll(function(ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION])\n      return;\n    let attrType = void 0;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = \"byte\";\n        break;\n      case Uint8Array:\n        attrType = \"unsigned byte\";\n        break;\n      case Int16Array:\n        attrType = \"short\";\n        break;\n      case Uint16Array:\n        attrType = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized)\n      attrType += \" normalized\";\n    const attrNamePrefix = attributeName.split(\"_\", 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras)\n      json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? \"orthographic\" : \"perspective\"\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n    if (camera.name !== \"\")\n      cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations)\n      json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === \"bones\") {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = void 0;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = \"CUBICSPLINE\";\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = \"STEP\";\n      } else {\n        interpolation = \"LINEAR\";\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || \"clip_\" + json.animations.length,\n      samplers,\n      channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === void 0)\n      return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === void 0)\n      return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === void 0)\n      json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes)\n      json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n    if (object.name !== \"\")\n      nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null)\n        nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh)\n      this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex2 = this.processNode(child);\n          if (nodeIndex2 !== null)\n            children.push(nodeIndex2);\n        }\n      }\n      if (children.length > 0)\n        nodeDef.children = children;\n    }\n    this._invokeAll(function(ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== \"\")\n      sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null)\n          nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0)\n      sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = \"AuxScene\";\n    for (let i = 0; i < objects.length; i++) {\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function(ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0)\n      this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function(ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight)\n      return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name)\n      lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = \"directional\";\n    } else if (light.isPointLight) {\n      lightDef.type = \"point\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = \"spot\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== void 0 && light.decay !== 2) {\n      console.warn(\n        \"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\"\n      );\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn(\n        \"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\"\n      );\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = { lights: [] };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = { light: lights.length - 1 };\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nGLTFExporter.Utils = {\n  insertKeyframe: function(track, time) {\n    const tolerance = 1e-3;\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance)\n        return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance)\n          return i;\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function(clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n      let mergedTrack;\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport {\n  GLTFExporter\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}