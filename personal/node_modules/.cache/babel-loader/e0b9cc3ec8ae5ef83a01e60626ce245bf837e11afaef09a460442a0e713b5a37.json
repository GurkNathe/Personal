{"ast":null,"code":"import _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _possibleConstructorReturn from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _assertThisInitialized from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Vector4, Color, Vector2, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping } from \"three\";\nimport { Reflector } from \"./Reflector.js\";\nimport { Refractor } from \"./Refractor.js\";\nvar _Water2 = /*#__PURE__*/function (_Mesh) {\n  _inherits(_Water2, _Mesh);\n  var _super = _createSuper(_Water2);\n  function _Water2(geometry) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, _Water2);\n    _this = _super.call(this, geometry);\n    _this.isWater = true;\n    _this.type = \"Water\";\n    var scope = _assertThisInitialized(_this);\n    var color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var flowDirection = options.flowDirection || new Vector2(1, 0);\n    var flowSpeed = options.flowSpeed || 0.03;\n    var reflectivity = options.reflectivity || 0.02;\n    var scale = options.scale || 1;\n    var shader = options.shader || _Water2.WaterShader;\n    var encoding = options.encoding !== void 0 ? options.encoding : 3e3;\n    var flowMap = options.flowMap || void 0;\n    var normalMap0 = options.normalMap0;\n    var normalMap1 = options.normalMap1;\n    var cycle = 0.15;\n    var halfCycle = cycle * 0.5;\n    var textureMatrix = new Matrix4();\n    var clock = new Clock();\n    if (Reflector === void 0) {\n      console.error(\"THREE.Water: Required component Reflector not found.\");\n      return _possibleConstructorReturn(_this);\n    }\n    if (Refractor === void 0) {\n      console.error(\"THREE.Water: Required component Refractor not found.\");\n      return _possibleConstructorReturn(_this);\n    }\n    var reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    var refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false;\n    _this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n    if (flowMap !== void 0) {\n      _this.material.defines.USE_FLOWMAP = \"\";\n      _this.material.uniforms[\"tFlowMap\"] = {\n        type: \"t\",\n        value: flowMap\n      };\n    } else {\n      _this.material.uniforms[\"flowDirection\"] = {\n        type: \"v2\",\n        value: flowDirection\n      };\n    }\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    _this.material.uniforms[\"tReflectionMap\"].value = reflector.getRenderTarget().texture;\n    _this.material.uniforms[\"tRefractionMap\"].value = refractor.getRenderTarget().texture;\n    _this.material.uniforms[\"tNormalMap0\"].value = normalMap0;\n    _this.material.uniforms[\"tNormalMap1\"].value = normalMap1;\n    _this.material.uniforms[\"color\"].value = color;\n    _this.material.uniforms[\"reflectivity\"].value = reflectivity;\n    _this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    _this.material.uniforms[\"config\"].value.x = 0;\n    _this.material.uniforms[\"config\"].value.y = halfCycle;\n    _this.material.uniforms[\"config\"].value.z = halfCycle;\n    _this.material.uniforms[\"config\"].value.w = scale;\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function updateFlow() {\n      var delta = clock.getDelta();\n      var config = scope.material.uniforms[\"config\"];\n      config.value.x += flowSpeed * delta;\n      config.value.y = config.value.x + halfCycle;\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    }\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n    return _this;\n  }\n  return _createClass(_Water2);\n}(Mesh);\nvar Water2 = _Water2;\n__publicField(Water2, \"WaterShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    reflectivity: {\n      value: 0\n    },\n    tReflectionMap: {\n      value: null\n    },\n    tRefractionMap: {\n      value: null\n    },\n    tNormalMap0: {\n      value: null\n    },\n    tNormalMap1: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    config: {\n      value: /* @__PURE__ */new Vector4()\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\t\\t\\tvCoord = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\tvToEye = cameraPosition - worldPosition.xyz;\\n\\n\\t\\t\\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\\n\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tuniform sampler2D tReflectionMap;\\n\\t\\tuniform sampler2D tRefractionMap;\\n\\t\\tuniform sampler2D tNormalMap0;\\n\\t\\tuniform sampler2D tNormalMap1;\\n\\n\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\tuniform sampler2D tFlowMap;\\n\\t\\t#else\\n\\t\\t\\tuniform vec2 flowDirection;\\n\\t\\t#endif\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform float reflectivity;\\n\\t\\tuniform vec4 config;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tfloat flowMapOffset0 = config.x;\\n\\t\\t\\tfloat flowMapOffset1 = config.y;\\n\\t\\t\\tfloat halfCycle = config.z;\\n\\t\\t\\tfloat scale = config.w;\\n\\n\\t\\t\\tvec3 toEye = normalize( vToEye );\\n\\n\\t\\t\\t// determine flow direction\\n\\t\\t\\tvec2 flow;\\n\\t\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\t\\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\\n\\t\\t\\t#else\\n\\t\\t\\t\\tflow = flowDirection;\\n\\t\\t\\t#endif\\n\\t\\t\\tflow.x *= - 1.0;\\n\\n\\t\\t\\t// sample normal maps (distort uvs with flowdata)\\n\\t\\t\\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\\n\\t\\t\\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\\n\\n\\t\\t\\t// linear interpolate to get the final normal color\\n\\t\\t\\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\\n\\t\\t\\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\\n\\n\\t\\t\\t// calculate normal vector\\n\\t\\t\\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n\\n\\t\\t\\t// calculate the fresnel term to blend reflection and refraction maps\\n\\t\\t\\tfloat theta = max( dot( toEye, normal ), 0.0 );\\n\\t\\t\\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\n\\n\\t\\t\\t// calculate final uv coords\\n\\t\\t\\tvec3 coord = vCoord.xyz / vCoord.w;\\n\\t\\t\\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\\n\\n\\t\\t\\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\\n\\t\\t\\tvec4 refractColor = texture2D( tRefractionMap, uv );\\n\\n\\t\\t\\t// multiply water color with the mix of both textures\\n\\t\\t\\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t#include <fog_fragment>\\n\\n\\t\\t}\"\n});\nexport { Water2 };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","Vector4","Color","Vector2","Matrix4","Clock","ShaderMaterial","UniformsUtils","UniformsLib","RepeatWrapping","Reflector","Refractor","_Water2","_Mesh","_inherits","_super","_createSuper","geometry","_this","options","arguments","length","undefined","_classCallCheck","call","isWater","type","scope","_assertThisInitialized","color","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","flowMap","normalMap0","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","_possibleConstructorReturn","reflector","refractor","matrixAutoUpdate","material","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","_createClass","Water2","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/objects/Water2.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Vector4, Color, Vector2, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping } from \"three\";\nimport { Reflector } from \"./Reflector.js\";\nimport { Refractor } from \"./Refractor.js\";\nconst _Water2 = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isWater = true;\n    this.type = \"Water\";\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\n    const flowSpeed = options.flowSpeed || 0.03;\n    const reflectivity = options.reflectivity || 0.02;\n    const scale = options.scale || 1;\n    const shader = options.shader || _Water2.WaterShader;\n    const encoding = options.encoding !== void 0 ? options.encoding : 3e3;\n    const flowMap = options.flowMap || void 0;\n    const normalMap0 = options.normalMap0;\n    const normalMap1 = options.normalMap1;\n    const cycle = 0.15;\n    const halfCycle = cycle * 0.5;\n    const textureMatrix = new Matrix4();\n    const clock = new Clock();\n    if (Reflector === void 0) {\n      console.error(\"THREE.Water: Required component Reflector not found.\");\n      return;\n    }\n    if (Refractor === void 0) {\n      console.error(\"THREE.Water: Required component Refractor not found.\");\n      return;\n    }\n    const reflector = new Reflector(geometry, {\n      textureWidth,\n      textureHeight,\n      clipBias,\n      encoding\n    });\n    const refractor = new Refractor(geometry, {\n      textureWidth,\n      textureHeight,\n      clipBias,\n      encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false;\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n    if (flowMap !== void 0) {\n      this.material.defines.USE_FLOWMAP = \"\";\n      this.material.uniforms[\"tFlowMap\"] = {\n        type: \"t\",\n        value: flowMap\n      };\n    } else {\n      this.material.uniforms[\"flowDirection\"] = {\n        type: \"v2\",\n        value: flowDirection\n      };\n    }\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    this.material.uniforms[\"tReflectionMap\"].value = reflector.getRenderTarget().texture;\n    this.material.uniforms[\"tRefractionMap\"].value = refractor.getRenderTarget().texture;\n    this.material.uniforms[\"tNormalMap0\"].value = normalMap0;\n    this.material.uniforms[\"tNormalMap1\"].value = normalMap1;\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"reflectivity\"].value = reflectivity;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material.uniforms[\"config\"].value.x = 0;\n    this.material.uniforms[\"config\"].value.y = halfCycle;\n    this.material.uniforms[\"config\"].value.z = halfCycle;\n    this.material.uniforms[\"config\"].value.w = scale;\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function updateFlow() {\n      const delta = clock.getDelta();\n      const config = scope.material.uniforms[\"config\"];\n      config.value.x += flowSpeed * delta;\n      config.value.y = config.value.x + halfCycle;\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    }\n    this.onBeforeRender = function(renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n  }\n};\nlet Water2 = _Water2;\n__publicField(Water2, \"WaterShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    reflectivity: {\n      value: 0\n    },\n    tReflectionMap: {\n      value: null\n    },\n    tRefractionMap: {\n      value: null\n    },\n    tNormalMap0: {\n      value: null\n    },\n    tNormalMap1: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    config: {\n      value: /* @__PURE__ */ new Vector4()\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Water2\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}