{"ast":null,"code":"var FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2\n    },\n    mFresnelScale: {\n      value: 1\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: [\"uniform float mRefractionRatio;\", \"uniform float mFresnelBias;\", \"uniform float mFresnelScale;\", \"uniform float mFresnelPower;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\", \"\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\", \"\tvec3 I = worldPosition.xyz - cameraPosition;\", \"\tvReflect = reflect( I, worldNormal );\", \"\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\", \"\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\", \"\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\", \"\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\", \"\tgl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform samplerCube tCube;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\", \"\tvec4 refractedColor = vec4( 1.0 );\", \"\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\", \"\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\", \"\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\", \"\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\", \"}\"].join(\"\\n\")\n};\nexport { FresnelShader };","map":{"version":3,"names":["FresnelShader","uniforms","mRefractionRatio","value","mFresnelBias","mFresnelPower","mFresnelScale","tCube","vertexShader","join","fragmentShader"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/shaders/FresnelShader.js"],"sourcesContent":["const FresnelShader = {\n  uniforms: {\n    mRefractionRatio: { value: 1.02 },\n    mFresnelBias: { value: 0.1 },\n    mFresnelPower: { value: 2 },\n    mFresnelScale: { value: 1 },\n    tCube: { value: null }\n  },\n  vertexShader: [\n    \"uniform float mRefractionRatio;\",\n    \"uniform float mFresnelBias;\",\n    \"uniform float mFresnelScale;\",\n    \"uniform float mFresnelPower;\",\n    \"varying vec3 vReflect;\",\n    \"varying vec3 vRefract[3];\",\n    \"varying float vReflectionFactor;\",\n    \"void main() {\",\n    \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n    \"\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n    \"\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\n    \"\tvec3 I = worldPosition.xyz - cameraPosition;\",\n    \"\tvReflect = reflect( I, worldNormal );\",\n    \"\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\",\n    \"\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\",\n    \"\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\",\n    \"\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\",\n    \"\tgl_Position = projectionMatrix * mvPosition;\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform samplerCube tCube;\",\n    \"varying vec3 vReflect;\",\n    \"varying vec3 vRefract[3];\",\n    \"varying float vReflectionFactor;\",\n    \"void main() {\",\n    \"\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n    \"\tvec4 refractedColor = vec4( 1.0 );\",\n    \"\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\n    \"\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\n    \"\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\n    \"\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  FresnelShader\n};\n"],"mappings":"AAAA,IAAMA,aAAa,GAAG;EACpBC,QAAQ,EAAE;IACRC,gBAAgB,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IACjCC,YAAY,EAAE;MAAED,KAAK,EAAE;IAAI,CAAC;IAC5BE,aAAa,EAAE;MAAEF,KAAK,EAAE;IAAE,CAAC;IAC3BG,aAAa,EAAE;MAAEH,KAAK,EAAE;IAAE,CAAC;IAC3BI,KAAK,EAAE;MAAEJ,KAAK,EAAE;IAAK;EACvB,CAAC;EACDK,YAAY,EAAE,CACZ,iCAAiC,EACjC,6BAA6B,EAC7B,8BAA8B,EAC9B,8BAA8B,EAC9B,wBAAwB,EACxB,2BAA2B,EAC3B,kCAAkC,EAClC,eAAe,EACf,6DAA6D,EAC7D,4DAA4D,EAC5D,+GAA+G,EAC/G,+CAA+C,EAC/C,wCAAwC,EACxC,0EAA0E,EAC1E,iFAAiF,EACjF,iFAAiF,EACjF,qHAAqH,EACrH,+CAA+C,EAC/C,GAAG,CACJ,CAACC,IAAI,CAAC,IAAI,CAAC;EACZC,cAAc,EAAE,CACd,4BAA4B,EAC5B,wBAAwB,EACxB,2BAA2B,EAC3B,kCAAkC,EAClC,eAAe,EACf,gFAAgF,EAChF,qCAAqC,EACrC,qFAAqF,EACrF,qFAAqF,EACrF,qFAAqF,EACrF,8FAA8F,EAC9F,GAAG,CACJ,CAACD,IAAI,CAAC,IAAI;AACb,CAAC;AACD,SACET,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}