{"ast":null,"code":"import { Vector2 } from \"three\";\nvar BokehShader2 = {\n  uniforms: {\n    textureWidth: {\n      value: 1\n    },\n    textureHeight: {\n      value: 1\n    },\n    focalDepth: {\n      value: 1\n    },\n    focalLength: {\n      value: 24\n    },\n    fstop: {\n      value: 0.9\n    },\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    maxblur: {\n      value: 1\n    },\n    showFocus: {\n      value: 0\n    },\n    manualdof: {\n      value: 0\n    },\n    vignetting: {\n      value: 0\n    },\n    depthblur: {\n      value: 0\n    },\n    threshold: {\n      value: 0.5\n    },\n    gain: {\n      value: 2\n    },\n    bias: {\n      value: 0.5\n    },\n    fringe: {\n      value: 0.7\n    },\n    znear: {\n      value: 0.1\n    },\n    zfar: {\n      value: 100\n    },\n    noise: {\n      value: 1\n    },\n    dithering: {\n      value: 1e-4\n    },\n    pentagon: {\n      value: 0\n    },\n    shaderFocus: {\n      value: 1\n    },\n    focusCoords: {\n      value: /* @__PURE__ */new Vector2()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"varying vec2 vUv;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"uniform float textureWidth;\", \"uniform float textureHeight;\", \"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\", \"uniform float focalLength; //focal length in mm\", \"uniform float fstop; //f-stop value\", \"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\", \"/*\", \"make sure that these two values are the same for your camera, otherwise distances will be wrong.\", \"*/\", \"uniform float znear; // camera clipping start\", \"uniform float zfar; // camera clipping end\", \"//------------------------------------------\", \"//user variables\", \"const int samples = SAMPLES; //samples on the first ring\", \"const int rings = RINGS; //ring count\", \"const int maxringsamples = rings * samples;\", \"uniform bool manualdof; // manual dof calculation\", \"float ndofstart = 1.0; // near dof blur start\", \"float ndofdist = 2.0; // near dof blur falloff distance\", \"float fdofstart = 1.0; // far dof blur start\", \"float fdofdist = 3.0; // far dof blur falloff distance\", \"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\", \"uniform bool vignetting; // use optical lens vignetting\", \"float vignout = 1.3; // vignetting outer border\", \"float vignin = 0.0; // vignetting inner border\", \"float vignfade = 22.0; // f-stops till vignete fades\", \"uniform bool shaderFocus;\", \"// disable if you use external focalDepth value\", \"uniform vec2 focusCoords;\", \"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\", \"// if center of screen use vec2(0.5, 0.5);\", \"uniform float maxblur;\", \"//clamp value of max blur (0.0 = no blur, 1.0 default)\", \"uniform float threshold; // highlight threshold;\", \"uniform float gain; // highlight gain;\", \"uniform float bias; // bokeh edge bias\", \"uniform float fringe; // bokeh chromatic aberration / fringing\", \"uniform bool noise; //use noise instead of pattern for sample dithering\", \"uniform float dithering;\", \"uniform bool depthblur; // blur the depth buffer\", \"float dbsize = 1.25; // depth blur size\", \"/*\", \"next part is experimental\", \"not looking good with small sample and ring count\", \"looks okay starting from samples = 4, rings = 4\", \"*/\", \"uniform bool pentagon; //use pentagon as bokeh shape?\", \"float feather = 0.4; //pentagon shape feather\", \"//------------------------------------------\", \"float penta(vec2 coords) {\", \"\t//pentagonal shape\", \"\tfloat scale = float(rings) - 1.3;\", \"\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\", \"\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\", \"\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\", \"\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\", \"\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\", \"\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\", \"\tvec4  one = vec4( 1.0 );\", \"\tvec4 P = vec4((coords),vec2(scale, scale));\", \"\tvec4 dist = vec4(0.0);\", \"\tfloat inorout = -4.0;\", \"\tdist.x = dot( P, HS0 );\", \"\tdist.y = dot( P, HS1 );\", \"\tdist.z = dot( P, HS2 );\", \"\tdist.w = dot( P, HS3 );\", \"\tdist = smoothstep( -feather, feather, dist );\", \"\tinorout += dot( dist, one );\", \"\tdist.x = dot( P, HS4 );\", \"\tdist.y = HS5.w - abs( P.z );\", \"\tdist = smoothstep( -feather, feather, dist );\", \"\tinorout += dist.x;\", \"\treturn clamp( inorout, 0.0, 1.0 );\", \"}\", \"float bdepth(vec2 coords) {\", \"\t// Depth buffer blur\", \"\tfloat d = 0.0;\", \"\tfloat kernel[9];\", \"\tvec2 offset[9];\", \"\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\", \"\toffset[0] = vec2(-wh.x,-wh.y);\", \"\toffset[1] = vec2( 0.0, -wh.y);\", \"\toffset[2] = vec2( wh.x -wh.y);\", \"\toffset[3] = vec2(-wh.x,  0.0);\", \"\toffset[4] = vec2( 0.0,   0.0);\", \"\toffset[5] = vec2( wh.x,  0.0);\", \"\toffset[6] = vec2(-wh.x, wh.y);\", \"\toffset[7] = vec2( 0.0,  wh.y);\", \"\toffset[8] = vec2( wh.x, wh.y);\", \"\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\", \"\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\", \"\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\", \"\tfor( int i=0; i<9; i++ ) {\", \"\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\", \"\t\td += tmp * kernel[i];\", \"\t}\", \"\treturn d;\", \"}\", \"vec3 color(vec2 coords,float blur) {\", \"\t//processing the sample\", \"\tvec3 col = vec3(0.0);\", \"\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\", \"\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\", \"\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\", \"\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\", \"\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\", \"\tfloat lum = dot(col.rgb, lumcoeff);\", \"\tfloat thresh = max((lum-threshold)*gain, 0.0);\", \"\treturn col+mix(vec3(0.0),col,thresh*blur);\", \"}\", \"vec3 debugFocus(vec3 col, float blur, float depth) {\", \"\tfloat edge = 0.002*depth; //distance based edge smoothing\", \"\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\", \"\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\", \"\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\", \"\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\", \"\treturn col;\", \"}\", \"float linearize(float depth) {\", \"\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\", \"}\", \"float vignette() {\", \"\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\", \"\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\", \"\treturn clamp(dist,0.0,1.0);\", \"}\", \"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\", \"\tfloat rings2 = float(rings);\", \"\tfloat step = PI*2.0 / float(ringsamples);\", \"\tfloat pw = cos(j*step)*i;\", \"\tfloat ph = sin(j*step)*i;\", \"\tfloat p = 1.0;\", \"\tif (pentagon) {\", \"\t\tp = penta(vec2(pw,ph));\", \"\t}\", \"\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\", \"\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\", \"}\", \"void main() {\", \"\t//scene depth calculation\", \"\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\", \"\t// Blur depth?\", \"\tif ( depthblur ) {\", \"\t\tdepth = linearize(bdepth(vUv.xy));\", \"\t}\", \"\t//focal plane calculation\", \"\tfloat fDepth = focalDepth;\", \"\tif (shaderFocus) {\", \"\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\", \"\t}\", \"\t// dof blur factor calculation\", \"\tfloat blur = 0.0;\", \"\tif (manualdof) {\", \"\t\tfloat a = depth-fDepth; // Focal plane\", \"\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\", \"\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\", \"\t\tblur = (a>0.0) ? b : c;\", \"\t} else {\", \"\t\tfloat f = focalLength; // focal length in mm\", \"\t\tfloat d = fDepth*1000.0; // focal plane in mm\", \"\t\tfloat o = depth*1000.0; // depth in mm\", \"\t\tfloat a = (o*f)/(o-f);\", \"\t\tfloat b = (d*f)/(d-f);\", \"\t\tfloat c = (d-f)/(d*fstop*CoC);\", \"\t\tblur = abs(a-b)*c;\", \"\t}\", \"\tblur = clamp(blur,0.0,1.0);\", \"\t// calculation of pattern for dithering\", \"\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\", \"\t// getting blur x and y step factor\", \"\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\", \"\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\", \"\t// calculation of final color\", \"\tvec3 col = vec3(0.0);\", \"\tif(blur < 0.05) {\", \"\t\t//some optimization thingy\", \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\", \"\t} else {\", \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\", \"\t\tfloat s = 1.0;\", \"\t\tint ringsamples;\", \"\t\tfor (int i = 1; i <= rings; i++) {\", \"\t\t\t/*unboxstart*/\", \"\t\t\tringsamples = i * samples;\", \"\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\", \"\t\t\t\tif (j >= ringsamples) break;\", \"\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\", \"\t\t\t}\", \"\t\t\t/*unboxend*/\", \"\t\t}\", \"\t\tcol /= s; //divide by sample count\", \"\t}\", \"\tif (showFocus) {\", \"\t\tcol = debugFocus(col, blur, depth);\", \"\t}\", \"\tif (vignetting) {\", \"\t\tcol *= vignette();\", \"\t}\", \"\tgl_FragColor.rgb = col;\", \"\tgl_FragColor.a = 1.0;\", \"} \"].join(\"\\n\")\n};\nvar BokehDepthShader = {\n  uniforms: {\n    mNear: {\n      value: 1\n    },\n    mFar: {\n      value: 1e3\n    }\n  },\n  vertexShader: [\"varying float vViewZDepth;\", \"void main() {\", \"\t#include <begin_vertex>\", \"\t#include <project_vertex>\", \"\tvViewZDepth = - mvPosition.z;\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform float mNear;\", \"uniform float mFar;\", \"varying float vViewZDepth;\", \"void main() {\", \"\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\", \"\tgl_FragColor = vec4( vec3( color ), 1.0 );\", \"} \"].join(\"\\n\")\n};\nexport { BokehDepthShader, BokehShader2 };","map":{"version":3,"names":["Vector2","BokehShader2","uniforms","textureWidth","value","textureHeight","focalDepth","focalLength","fstop","tColor","tDepth","maxblur","showFocus","manualdof","vignetting","depthblur","threshold","gain","bias","fringe","znear","zfar","noise","dithering","pentagon","shaderFocus","focusCoords","vertexShader","join","fragmentShader","BokehDepthShader","mNear","mFar"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/shaders/BokehShader2.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst BokehShader2 = {\n  uniforms: {\n    textureWidth: { value: 1 },\n    textureHeight: { value: 1 },\n    focalDepth: { value: 1 },\n    focalLength: { value: 24 },\n    fstop: { value: 0.9 },\n    tColor: { value: null },\n    tDepth: { value: null },\n    maxblur: { value: 1 },\n    showFocus: { value: 0 },\n    manualdof: { value: 0 },\n    vignetting: { value: 0 },\n    depthblur: { value: 0 },\n    threshold: { value: 0.5 },\n    gain: { value: 2 },\n    bias: { value: 0.5 },\n    fringe: { value: 0.7 },\n    znear: { value: 0.1 },\n    zfar: { value: 100 },\n    noise: { value: 1 },\n    dithering: { value: 1e-4 },\n    pentagon: { value: 0 },\n    shaderFocus: { value: 1 },\n    focusCoords: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#include <common>\",\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tColor;\",\n    \"uniform sampler2D tDepth;\",\n    \"uniform float textureWidth;\",\n    \"uniform float textureHeight;\",\n    \"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\",\n    \"uniform float focalLength; //focal length in mm\",\n    \"uniform float fstop; //f-stop value\",\n    \"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\",\n    \"/*\",\n    \"make sure that these two values are the same for your camera, otherwise distances will be wrong.\",\n    \"*/\",\n    \"uniform float znear; // camera clipping start\",\n    \"uniform float zfar; // camera clipping end\",\n    \"//------------------------------------------\",\n    \"//user variables\",\n    \"const int samples = SAMPLES; //samples on the first ring\",\n    \"const int rings = RINGS; //ring count\",\n    \"const int maxringsamples = rings * samples;\",\n    \"uniform bool manualdof; // manual dof calculation\",\n    \"float ndofstart = 1.0; // near dof blur start\",\n    \"float ndofdist = 2.0; // near dof blur falloff distance\",\n    \"float fdofstart = 1.0; // far dof blur start\",\n    \"float fdofdist = 3.0; // far dof blur falloff distance\",\n    \"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\",\n    \"uniform bool vignetting; // use optical lens vignetting\",\n    \"float vignout = 1.3; // vignetting outer border\",\n    \"float vignin = 0.0; // vignetting inner border\",\n    \"float vignfade = 22.0; // f-stops till vignete fades\",\n    \"uniform bool shaderFocus;\",\n    \"// disable if you use external focalDepth value\",\n    \"uniform vec2 focusCoords;\",\n    \"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\",\n    \"// if center of screen use vec2(0.5, 0.5);\",\n    \"uniform float maxblur;\",\n    \"//clamp value of max blur (0.0 = no blur, 1.0 default)\",\n    \"uniform float threshold; // highlight threshold;\",\n    \"uniform float gain; // highlight gain;\",\n    \"uniform float bias; // bokeh edge bias\",\n    \"uniform float fringe; // bokeh chromatic aberration / fringing\",\n    \"uniform bool noise; //use noise instead of pattern for sample dithering\",\n    \"uniform float dithering;\",\n    \"uniform bool depthblur; // blur the depth buffer\",\n    \"float dbsize = 1.25; // depth blur size\",\n    \"/*\",\n    \"next part is experimental\",\n    \"not looking good with small sample and ring count\",\n    \"looks okay starting from samples = 4, rings = 4\",\n    \"*/\",\n    \"uniform bool pentagon; //use pentagon as bokeh shape?\",\n    \"float feather = 0.4; //pentagon shape feather\",\n    \"//------------------------------------------\",\n    \"float penta(vec2 coords) {\",\n    \"\t//pentagonal shape\",\n    \"\tfloat scale = float(rings) - 1.3;\",\n    \"\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\",\n    \"\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\",\n    \"\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\",\n    \"\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\",\n    \"\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\",\n    \"\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\",\n    \"\tvec4  one = vec4( 1.0 );\",\n    \"\tvec4 P = vec4((coords),vec2(scale, scale));\",\n    \"\tvec4 dist = vec4(0.0);\",\n    \"\tfloat inorout = -4.0;\",\n    \"\tdist.x = dot( P, HS0 );\",\n    \"\tdist.y = dot( P, HS1 );\",\n    \"\tdist.z = dot( P, HS2 );\",\n    \"\tdist.w = dot( P, HS3 );\",\n    \"\tdist = smoothstep( -feather, feather, dist );\",\n    \"\tinorout += dot( dist, one );\",\n    \"\tdist.x = dot( P, HS4 );\",\n    \"\tdist.y = HS5.w - abs( P.z );\",\n    \"\tdist = smoothstep( -feather, feather, dist );\",\n    \"\tinorout += dist.x;\",\n    \"\treturn clamp( inorout, 0.0, 1.0 );\",\n    \"}\",\n    \"float bdepth(vec2 coords) {\",\n    \"\t// Depth buffer blur\",\n    \"\tfloat d = 0.0;\",\n    \"\tfloat kernel[9];\",\n    \"\tvec2 offset[9];\",\n    \"\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\",\n    \"\toffset[0] = vec2(-wh.x,-wh.y);\",\n    \"\toffset[1] = vec2( 0.0, -wh.y);\",\n    \"\toffset[2] = vec2( wh.x -wh.y);\",\n    \"\toffset[3] = vec2(-wh.x,  0.0);\",\n    \"\toffset[4] = vec2( 0.0,   0.0);\",\n    \"\toffset[5] = vec2( wh.x,  0.0);\",\n    \"\toffset[6] = vec2(-wh.x, wh.y);\",\n    \"\toffset[7] = vec2( 0.0,  wh.y);\",\n    \"\toffset[8] = vec2( wh.x, wh.y);\",\n    \"\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\",\n    \"\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\",\n    \"\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\",\n    \"\tfor( int i=0; i<9; i++ ) {\",\n    \"\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\",\n    \"\t\td += tmp * kernel[i];\",\n    \"\t}\",\n    \"\treturn d;\",\n    \"}\",\n    \"vec3 color(vec2 coords,float blur) {\",\n    \"\t//processing the sample\",\n    \"\tvec3 col = vec3(0.0);\",\n    \"\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\",\n    \"\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\",\n    \"\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\",\n    \"\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\",\n    \"\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\",\n    \"\tfloat lum = dot(col.rgb, lumcoeff);\",\n    \"\tfloat thresh = max((lum-threshold)*gain, 0.0);\",\n    \"\treturn col+mix(vec3(0.0),col,thresh*blur);\",\n    \"}\",\n    \"vec3 debugFocus(vec3 col, float blur, float depth) {\",\n    \"\tfloat edge = 0.002*depth; //distance based edge smoothing\",\n    \"\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\",\n    \"\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\",\n    \"\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\",\n    \"\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\",\n    \"\treturn col;\",\n    \"}\",\n    \"float linearize(float depth) {\",\n    \"\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\",\n    \"}\",\n    \"float vignette() {\",\n    \"\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\",\n    \"\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\",\n    \"\treturn clamp(dist,0.0,1.0);\",\n    \"}\",\n    \"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\",\n    \"\tfloat rings2 = float(rings);\",\n    \"\tfloat step = PI*2.0 / float(ringsamples);\",\n    \"\tfloat pw = cos(j*step)*i;\",\n    \"\tfloat ph = sin(j*step)*i;\",\n    \"\tfloat p = 1.0;\",\n    \"\tif (pentagon) {\",\n    \"\t\tp = penta(vec2(pw,ph));\",\n    \"\t}\",\n    \"\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\",\n    \"\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\",\n    \"}\",\n    \"void main() {\",\n    \"\t//scene depth calculation\",\n    \"\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\",\n    \"\t// Blur depth?\",\n    \"\tif ( depthblur ) {\",\n    \"\t\tdepth = linearize(bdepth(vUv.xy));\",\n    \"\t}\",\n    \"\t//focal plane calculation\",\n    \"\tfloat fDepth = focalDepth;\",\n    \"\tif (shaderFocus) {\",\n    \"\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\",\n    \"\t}\",\n    \"\t// dof blur factor calculation\",\n    \"\tfloat blur = 0.0;\",\n    \"\tif (manualdof) {\",\n    \"\t\tfloat a = depth-fDepth; // Focal plane\",\n    \"\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\",\n    \"\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\",\n    \"\t\tblur = (a>0.0) ? b : c;\",\n    \"\t} else {\",\n    \"\t\tfloat f = focalLength; // focal length in mm\",\n    \"\t\tfloat d = fDepth*1000.0; // focal plane in mm\",\n    \"\t\tfloat o = depth*1000.0; // depth in mm\",\n    \"\t\tfloat a = (o*f)/(o-f);\",\n    \"\t\tfloat b = (d*f)/(d-f);\",\n    \"\t\tfloat c = (d-f)/(d*fstop*CoC);\",\n    \"\t\tblur = abs(a-b)*c;\",\n    \"\t}\",\n    \"\tblur = clamp(blur,0.0,1.0);\",\n    \"\t// calculation of pattern for dithering\",\n    \"\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\",\n    \"\t// getting blur x and y step factor\",\n    \"\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\",\n    \"\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\",\n    \"\t// calculation of final color\",\n    \"\tvec3 col = vec3(0.0);\",\n    \"\tif(blur < 0.05) {\",\n    \"\t\t//some optimization thingy\",\n    \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\",\n    \"\t} else {\",\n    \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\",\n    \"\t\tfloat s = 1.0;\",\n    \"\t\tint ringsamples;\",\n    \"\t\tfor (int i = 1; i <= rings; i++) {\",\n    \"\t\t\t/*unboxstart*/\",\n    \"\t\t\tringsamples = i * samples;\",\n    \"\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\",\n    \"\t\t\t\tif (j >= ringsamples) break;\",\n    \"\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\",\n    \"\t\t\t}\",\n    \"\t\t\t/*unboxend*/\",\n    \"\t\t}\",\n    \"\t\tcol /= s; //divide by sample count\",\n    \"\t}\",\n    \"\tif (showFocus) {\",\n    \"\t\tcol = debugFocus(col, blur, depth);\",\n    \"\t}\",\n    \"\tif (vignetting) {\",\n    \"\t\tcol *= vignette();\",\n    \"\t}\",\n    \"\tgl_FragColor.rgb = col;\",\n    \"\tgl_FragColor.a = 1.0;\",\n    \"} \"\n  ].join(\"\\n\")\n};\nconst BokehDepthShader = {\n  uniforms: {\n    mNear: { value: 1 },\n    mFar: { value: 1e3 }\n  },\n  vertexShader: [\n    \"varying float vViewZDepth;\",\n    \"void main() {\",\n    \"\t#include <begin_vertex>\",\n    \"\t#include <project_vertex>\",\n    \"\tvViewZDepth = - mvPosition.z;\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform float mNear;\",\n    \"uniform float mFar;\",\n    \"varying float vViewZDepth;\",\n    \"void main() {\",\n    \"\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\",\n    \"\tgl_FragColor = vec4( vec3( color ), 1.0 );\",\n    \"} \"\n  ].join(\"\\n\")\n};\nexport {\n  BokehDepthShader,\n  BokehShader2\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}