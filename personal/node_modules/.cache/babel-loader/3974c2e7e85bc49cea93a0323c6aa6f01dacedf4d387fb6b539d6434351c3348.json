{"ast":null,"code":"import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper } from \"three\";\nfunction retarget(target, source) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */new Map();\n  const cloneLookup = /* @__PURE__ */new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = {\n  retarget,\n  retargetClip,\n  clone\n};\nexport { SkeletonUtils };","map":{"version":3,"names":["Vector3","Quaternion","Matrix4","AnimationMixer","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","SkeletonHelper","retarget","target","source","options","arguments","length","undefined","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","preserveMatrix","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","pose","i","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","update","time","j","times","Float32Array","values","sub","toArray","uncacheAction","sourceLookup","Map","cloneLookup","clone2","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","Array","isArray","a","b","callback","SkeletonUtils"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/utils/SkeletonUtils.js"],"sourcesContent":["import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper } from \"three\";\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(), quat = new Quaternion(), scale = new Vector3(), bindBoneMatrix = new Matrix4(), relativeMatrix = new Matrix4(), globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || { bone };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new VectorKeyframeTrack(\n            \".bones[\" + boneData.bone.name + \"].position\",\n            boneData.pos.times,\n            boneData.pos.values\n          )\n        );\n      }\n      convertedTracks.push(\n        new QuaternionKeyframeTrack(\n          \".bones[\" + boneData.bone.name + \"].quaternion\",\n          boneData.quat.times,\n          boneData.quat.values\n        )\n      );\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */ new Map();\n  const cloneLookup = /* @__PURE__ */ new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function(node) {\n    if (!node.isSkinnedMesh)\n      return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name)\n      return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = { retarget, retargetClip, clone };\nexport {\n  SkeletonUtils\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}