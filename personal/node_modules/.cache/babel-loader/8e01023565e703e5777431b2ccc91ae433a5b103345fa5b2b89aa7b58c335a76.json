{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { Parser } from \"mmd-parser\";\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null;\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath;\n    return this;\n  }\n  // Load MMD assets as Three.js Object\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    const modelExtension = this._extractExtension(url).toLowerCase();\n    if (modelExtension !== \"pmd\" && modelExtension !== \"pmx\") {\n      if (onError) onError(new Error(\"THREE.MMDLoader: Unknown model file extension .\" + modelExtension + \".\"));\n      return;\n    }\n    this[modelExtension === \"pmd\" ? \"loadPMD\" : \"loadPMX\"](url, function (data) {\n      onLoad(builder.build(data, resourcePath, onProgress, onError));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder;\n    this.loadVMD(url, function (vmd) {\n      onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this;\n    this.load(modelUrl, function (mesh) {\n      scope.loadAnimation(vmdUrl, mesh, function (animation) {\n        onLoad({\n          mesh,\n          animation\n        });\n      }, onProgress, onError);\n    }, onProgress, onError);\n  }\n  // Load MMD assets as Object data parsed by MMDParser\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmd(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmx(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url];\n    const vmds = [];\n    const vmdNum = urls.length;\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(urls[i], function (buffer) {\n        vmds.push(parser.parseVmd(buffer, true));\n        if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n      }, onProgress, onError);\n    }\n  }\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(isUnicode ? void 0 : \"text/plain; charset=shift_jis\").setPath(this.animationPath).setResponseType(\"text\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n      onLoad(parser.parseVpd(text, true));\n    }, onProgress, onError);\n  }\n  // private methods\n  _extractExtension(url) {\n    const index = url.lastIndexOf(\".\");\n    return index < 0 ? \"\" : url.slice(index + 1);\n  }\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser();\n    }\n    return this.parser;\n  }\n}\nconst DEFAULT_TOON_TEXTURES = [\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\"];\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = \"anonymous\";\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data);\n    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n    const mesh = new SkinnedMesh(geometry, material);\n    const skeleton = new Skeleton(initBones(mesh));\n    mesh.bind(skeleton);\n    return mesh;\n  }\n}\nfunction initBones(mesh) {\n  const geometry = mesh.geometry;\n  const bones = [];\n  if (geometry && geometry.bones !== void 0) {\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      const bone = new Bone();\n      bones.push(bone);\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== void 0) bone.scale.fromArray(gbone.scl);\n    }\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {\n        bones[gbone.parent].add(bones[i]);\n      } else {\n        mesh.add(bones[i]);\n      }\n    }\n  }\n  mesh.updateMatrixWorld(true);\n  return bones;\n}\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    const positions = [];\n    const uvs = [];\n    const normals = [];\n    const indices = [];\n    const groups = [];\n    const bones = [];\n    const skinIndices = [];\n    const skinWeights = [];\n    const morphTargets = [];\n    const morphPositions = [];\n    const iks = [];\n    const grants = [];\n    const rigidBodies = [];\n    const constraints = [];\n    let offset = 0;\n    const boneTypeTable = {};\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i];\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j]);\n      }\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j]);\n      }\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j]);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0);\n      }\n    }\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i];\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j]);\n      }\n    }\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3\n      });\n      offset += material.faceCount;\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i];\n      let value = boneTypeTable[body.boneIndex];\n      value = value === void 0 ? body.type : Math.max(body.type, value);\n      boneTypeTable[body.boneIndex] = value;\n    }\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i];\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== void 0 ? boneTypeTable[i] : -1\n      };\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0];\n        bone.pos[1] -= data.bones[bone.parent].position[1];\n        bone.pos[2] -= data.bones[bone.parent].position[2];\n      }\n      bones.push(bone);\n    }\n    if (data.metadata.format === \"pmd\") {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i];\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (data.bones[link.index].name.indexOf(\"ひざ\") >= 0) {\n            link.limitation = new Vector3(1, 0, 0);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik;\n        if (ik === void 0) continue;\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (ik.links[j].angleLimitation === 1) {\n            const rotationMin = ik.links[j].lowerLimitationAngle;\n            const rotationMax = ik.links[j].upperLimitationAngle;\n            const tmp1 = -rotationMax[0];\n            const tmp2 = -rotationMax[1];\n            rotationMax[0] = -rotationMin[0];\n            rotationMax[1] = -rotationMin[1];\n            rotationMin[0] = tmp1;\n            rotationMin[1] = tmp2;\n            link.rotationMin = new Vector3().fromArray(rotationMin);\n            link.rotationMax = new Vector3().fromArray(rotationMax);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n        bones[i].ik = param;\n      }\n    }\n    if (data.metadata.format === \"pmx\") {\n      let traverse = function (entry) {\n        if (entry.param) {\n          grants.push(entry.param);\n          bones[entry.param.index].grant = entry.param;\n        }\n        entry.visited = true;\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i];\n          if (!child.visited) traverse(child);\n        }\n      };\n      const grantEntryMap = {};\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i];\n        const grant = boneData.grant;\n        if (grant === void 0) continue;\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass\n        };\n        grantEntryMap[i] = {\n          parent: null,\n          children: [],\n          param,\n          visited: false\n        };\n      }\n      const rootEntry = {\n        parent: null,\n        children: [],\n        param: null,\n        visited: false\n      };\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex];\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n        grantEntry.parent = parentGrantEntry;\n        parentGrantEntry.children.push(grantEntry);\n      }\n      traverse(rootEntry);\n    }\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i];\n        let index;\n        if (data.metadata.format === \"pmd\") {\n          index = data.morphs[0].elements[element.index].index;\n        } else {\n          index = element.index;\n        }\n        attribute.array[index * 3 + 0] += element.position[0] * ratio;\n        attribute.array[index * 3 + 1] += element.position[1] * ratio;\n        attribute.array[index * 3 + 2] += element.position[2] * ratio;\n      }\n    }\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i];\n      const params = {\n        name: morph.name\n      };\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n      attribute.name = morph.name;\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j];\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1);\n        }\n      } else {\n        if (morph.type === 0) {\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index];\n            const ratio = morph.elements[j].ratio;\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio);\n            } else {}\n          }\n        } else if (morph.type === 1) {\n          updateAttributes(attribute, morph, 1);\n        } else if (morph.type === 2) {} else if (morph.type === 3) {} else if (morph.type === 4) {} else if (morph.type === 5) {} else if (morph.type === 6) {} else if (morph.type === 7) {} else if (morph.type === 8) {}\n      }\n      morphTargets.push(params);\n      morphPositions.push(attribute);\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i];\n      const params = {};\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key];\n      }\n      if (data.metadata.format === \"pmx\") {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex];\n          params.position[0] -= bone.position[0];\n          params.position[1] -= bone.position[1];\n          params.position[2] -= bone.position[2];\n        }\n      }\n      rigidBodies.push(params);\n    }\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i];\n      const params = {};\n      for (const key in constraint) {\n        params[key] = constraint[key];\n      }\n      const bodyA = rigidBodies[params.rigidBodyIndex1];\n      const bodyB = rigidBodies[params.rigidBodyIndex2];\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n          bodyB.type = 1;\n        }\n      }\n      constraints.push(params);\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    geometry.setAttribute(\"skinIndex\", new Uint16BufferAttribute(skinIndices, 4));\n    geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeights, 4));\n    geometry.setIndex(indices);\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i);\n    }\n    geometry.bones = bones;\n    geometry.morphTargets = morphTargets;\n    geometry.morphAttributes.position = morphPositions;\n    geometry.morphTargetsRelative = false;\n    geometry.userData.MMD = {\n      bones,\n      iks,\n      grants,\n      rigidBodies,\n      constraints,\n      format: data.metadata.format\n    };\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n}\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null;\n    this.crossOrigin = \"anonymous\";\n    this.resourcePath = void 0;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n  build(data, geometry) {\n    const materials = [];\n    const textures = {};\n    this.textureLoader.setCrossOrigin(this.crossOrigin);\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      const params = {\n        userData: {}\n      };\n      if (material.name !== void 0) params.name = material.name;\n      params.color = new Color().fromArray(material.diffuse);\n      params.opacity = material.diffuse[3];\n      params.emissive = new Color().fromArray(material.ambient);\n      params.transparent = params.opacity !== 1;\n      params.skinning = geometry.bones.length > 0 ? true : false;\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n      params.fog = true;\n      params.blending = CustomBlending;\n      params.blendSrc = SrcAlphaFactor;\n      params.blendDst = OneMinusSrcAlphaFactor;\n      params.blendSrcAlpha = SrcAlphaFactor;\n      params.blendDstAlpha = DstAlphaFactor;\n      if (data.metadata.format === \"pmx\" && (material.flag & 1) === 1) {\n        params.side = DoubleSide;\n      } else {\n        params.side = params.opacity === 1 ? FrontSide : DoubleSide;\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (material.fileName) {\n          const fileName = material.fileName;\n          const fileNames = fileName.split(\"*\");\n          params.map = this._loadTexture(fileNames[0], textures);\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase();\n            params.envMap = this._loadTexture(fileNames[1], textures);\n            params.combine = extension === \".sph\" ? MultiplyOperation : AddOperation;\n          }\n        }\n        const toonFileName = material.toonIndex === -1 ? \"toon00.bmp\" : data.toonTextures[material.toonIndex].fileName;\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 3e-3 : 0,\n          color: [0, 0, 0],\n          alpha: 1,\n          visible: material.edgeFlag === 1\n        };\n      } else {\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n        }\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n        }\n        let toonFileName, isDefaultToon;\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = \"toon\" + (\"0\" + (material.toonIndex + 1)).slice(-2) + \".bmp\";\n          isDefaultToon = true;\n        } else {\n          toonFileName = data.textures[material.toonIndex];\n          isDefaultToon = false;\n        }\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300,\n          // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 16) !== 0 && material.edgeSize > 0\n        };\n      }\n      if (params.map !== void 0) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i);\n        }\n        params.emissive.multiplyScalar(0.2);\n      }\n      materials.push(new MeshToonMaterial(params));\n    }\n    if (data.metadata.format === \"pmx\") {\n      let checkAlphaMorph = function (elements, materials2) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i];\n          if (element.index === -1) continue;\n          const material = materials2[element.index];\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true;\n          }\n        }\n      };\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i];\n        const elements = morph.elements;\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index];\n            if (morph2.type !== 8) continue;\n            checkAlphaMorph(morph2.elements, materials);\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials);\n        }\n      }\n    }\n    return materials;\n  }\n  // private methods\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === void 0) {\n        throw new Error(\"THREE.MMDLoader: Import TGALoader\");\n      }\n      this.tgaLoader = new TGALoader(this.manager);\n    }\n    return this.tgaLoader;\n  }\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false;\n    return /toon(10|0[0-9])\\.bmp/.test(name);\n  }\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {};\n    const scope = this;\n    let fullPath;\n    if (params.isDefaultToonTexture === true) {\n      let index;\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n      } catch (e) {\n        console.warn(\"THREE.MMDLoader: \" + filePath + \" seems like a not right default texture path. Using toon00.bmp instead.\");\n        index = 0;\n      }\n      fullPath = DEFAULT_TOON_TEXTURES[index];\n    } else {\n      fullPath = this.resourcePath + filePath;\n    }\n    if (textures[fullPath] !== void 0) return textures[fullPath];\n    let loader = this.manager.getHandler(fullPath);\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === \".tga\" ? this._getTGALoader() : this.textureLoader;\n    }\n    const texture = loader.load(fullPath, function (t) {\n      if (params.isToonTexture === true) {\n        t.image = scope._getRotatedImage(t.image);\n        t.magFilter = NearestFilter;\n        t.minFilter = NearestFilter;\n      }\n      t.flipY = false;\n      t.wrapS = RepeatWrapping;\n      t.wrapT = RepeatWrapping;\n      for (let i = 0; i < texture.readyCallbacks.length; i++) {\n        texture.readyCallbacks[i](texture);\n      }\n      delete texture.readyCallbacks;\n    }, onProgress, onError);\n    texture.readyCallbacks = [];\n    textures[fullPath] = texture;\n    return texture;\n  }\n  _getRotatedImage(image) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const width = image.width;\n    const height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    context.clearRect(0, 0, width, height);\n    context.translate(width / 2, height / 2);\n    context.rotate(0.5 * Math.PI);\n    context.translate(-width / 2, -height / 2);\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, width, height);\n  }\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      function createImageData(image) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n      }\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width;\n        const height = image.height;\n        const data = image.data;\n        const threshold = 253;\n        if (data.length / (width * height) !== 4) return false;\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = {\n            x: 0,\n            y: 0\n          };\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j];\n            const uv = {\n              x: uvs[index * 2 + 0],\n              y: uvs[index * 2 + 1]\n            };\n            if (getAlphaByUv(image, uv) < threshold) return true;\n            centerUV.x += uv.x;\n            centerUV.y += uv.y;\n          }\n          centerUV.x /= 3;\n          centerUV.y /= 3;\n          if (getAlphaByUv(image, centerUV) < threshold) return true;\n        }\n        return false;\n      }\n      function getAlphaByUv(image, uv) {\n        const width = image.width;\n        const height = image.height;\n        let x = Math.round(uv.x * width) % width;\n        let y = Math.round(uv.y * height) % height;\n        if (x < 0) x += width;\n        if (y < 0) y += height;\n        const index = y * width + x;\n        return image.data[index * 4 + 3];\n      }\n      const imageData = texture.image.data !== void 0 ? texture.image : createImageData(texture.image);\n      const group = geometry.groups[groupIndex];\n      if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n        map.transparent = true;\n      }\n    });\n  }\n}\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i]);\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127);\n      array.push(interpolation[index + 8] / 127);\n      array.push(interpolation[index + 4] / 127);\n      array.push(interpolation[index + 12] / 127);\n    }\n    const tracks = [];\n    const motions = {};\n    const bones = mesh.skeleton.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true;\n    }\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i];\n      const boneName = motion.boneName;\n      if (boneNameDictionary[boneName] === void 0) continue;\n      motions[boneName] = motions[boneName] || [];\n      motions[boneName].push(motion);\n    }\n    for (const key in motions) {\n      const array = motions[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const positions = [];\n      const rotations = [];\n      const pInterpolations = [];\n      const rInterpolations = [];\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30;\n        const position = array[i].position;\n        const rotation = array[i].rotation;\n        const interpolation = array[i].interpolation;\n        times.push(time);\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j]);\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j);\n        pushInterpolation(rInterpolations, interpolation, 3);\n      }\n      const targetName = \".bones[\" + key + \"]\";\n      tracks.push(this._createTrack(targetName + \".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack(targetName + \".quaternion\", QuaternionKeyframeTrack, times, rotations, rInterpolations));\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = [];\n    const morphs = {};\n    const morphTargetDictionary = mesh.morphTargetDictionary;\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i];\n      const morphName = morph.morphName;\n      if (morphTargetDictionary[morphName] === void 0) continue;\n      morphs[morphName] = morphs[morphName] || [];\n      morphs[morphName].push(morph);\n    }\n    for (const key in morphs) {\n      const array = morphs[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const values = [];\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30);\n        values.push(array[i].weight);\n      }\n      tracks.push(new NumberKeyframeTrack(\".morphTargetInfluences[\" + morphTargetDictionary[key] + \"]\", times, values));\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x);\n      array.push(vec.y);\n      array.push(vec.z);\n    }\n    function pushQuaternion(array, q) {\n      array.push(q.x);\n      array.push(q.y);\n      array.push(q.z);\n      array.push(q.w);\n    }\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127);\n      array.push(interpolation[index * 4 + 1] / 127);\n      array.push(interpolation[index * 4 + 2] / 127);\n      array.push(interpolation[index * 4 + 3] / 127);\n    }\n    const cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum;\n    });\n    const times = [];\n    const centers = [];\n    const quaternions = [];\n    const positions = [];\n    const fovs = [];\n    const cInterpolations = [];\n    const qInterpolations = [];\n    const pInterpolations = [];\n    const fInterpolations = [];\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const position = new Vector3();\n    const center = new Vector3();\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i];\n      const time = motion.frameNum / 30;\n      const pos = motion.position;\n      const rot = motion.rotation;\n      const distance = motion.distance;\n      const fov = motion.fov;\n      const interpolation = motion.interpolation;\n      times.push(time);\n      position.set(0, 0, -distance);\n      center.set(pos[0], pos[1], pos[2]);\n      euler.set(-rot[0], -rot[1], -rot[2]);\n      quaternion.setFromEuler(euler);\n      position.add(center);\n      position.applyQuaternion(quaternion);\n      pushVector3(centers, center);\n      pushQuaternion(quaternions, quaternion);\n      pushVector3(positions, position);\n      fovs.push(fov);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j);\n      }\n      pushInterpolation(qInterpolations, interpolation, 3);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4);\n      }\n      pushInterpolation(fInterpolations, interpolation, 5);\n    }\n    const tracks = [];\n    tracks.push(this._createTrack(\"target.position\", VectorKeyframeTrack, times, centers, cInterpolations));\n    tracks.push(this._createTrack(\".quaternion\", QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n    tracks.push(this._createTrack(\".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n    tracks.push(this._createTrack(\".fov\", NumberKeyframeTrack, times, fovs, fInterpolations));\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  // private method\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    if (times.length > 2) {\n      times = times.slice();\n      values = values.slice();\n      interpolations = interpolations.slice();\n      const stride = values.length / times.length;\n      const interpolateStride = interpolations.length / times.length;\n      let index = 1;\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n            index++;\n            break;\n          }\n        }\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex];\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i];\n          }\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n          }\n        }\n      }\n      times.length = index + 1;\n      values.length = (index + 1) * stride;\n      interpolations.length = (index + 1) * interpolateStride;\n    }\n    const track = new typedKeyframeTrack(node, times, values);\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n    };\n    return track;\n  }\n}\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const params = this.interpolationParams;\n    const offset1 = i1 * stride;\n    const offset0 = offset1 - stride;\n    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t - t0) / (t1 - t0);\n    if (stride === 4) {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n    } else if (stride === 3) {\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0];\n        const x2 = params[i1 * 12 + i * 4 + 1];\n        const y1 = params[i1 * 12 + i * 4 + 2];\n        const y2 = params[i1 * 12 + i * 4 + 3];\n        const ratio = this._calculate(x1, x2, y1, y2, weight1);\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n      }\n    } else {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n    }\n    return result;\n  }\n  _calculate(x1, x2, y1, y2, x) {\n    let c = 0.5;\n    let t = c;\n    let s = 1 - t;\n    const loop = 15;\n    const eps = 1e-5;\n    const math = Math;\n    let sst3, stt3, ttt;\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3 * s * s * t;\n      stt3 = 3 * s * t * t;\n      ttt = t * t * t;\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x;\n      if (math.abs(ft) < eps) break;\n      c /= 2;\n      t += ft < 0 ? c : -c;\n      s = 1 - t;\n    }\n    return sst3 * y1 + stt3 * y2 + ttt;\n  }\n}\nexport { MMDLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","SkinnedMesh","Skeleton","Bone","Vector3","Float32BufferAttribute","BufferGeometry","Uint16BufferAttribute","TextureLoader","Color","CustomBlending","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","DoubleSide","FrontSide","MultiplyOperation","AddOperation","MeshToonMaterial","NearestFilter","RepeatWrapping","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","NumberKeyframeTrack","Quaternion","Euler","Interpolant","TGALoader","Parser","MMDLoader","constructor","manager","loader","parser","meshBuilder","MeshBuilder","animationBuilder","AnimationBuilder","setAnimationPath","animationPath","load","url","onLoad","onProgress","onError","builder","setCrossOrigin","crossOrigin","resourcePath","path","extractUrlBase","modelExtension","_extractExtension","toLowerCase","Error","data","build","loadAnimation","object","loadVMD","vmd","isCamera","buildCameraAnimation","loadWithAnimation","modelUrl","vmdUrl","scope","mesh","animation","loadPMD","_getParser","setMimeType","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parsePmd","loadPMX","parsePmx","urls","Array","isArray","vmds","vmdNum","length","i","il","push","parseVmd","mergeVmds","loadVPD","isUnicode","text","parseVpd","index","lastIndexOf","slice","DEFAULT_TOON_TEXTURES","geometryBuilder","GeometryBuilder","materialBuilder","MaterialBuilder","geometry","material","setResourcePath","skeleton","initBones","bind","bones","gbone","bone","name","position","fromArray","pos","quaternion","rotq","scl","scale","parent","add","updateMatrixWorld","positions","uvs","normals","indices","groups","skinIndices","skinWeights","morphTargets","morphPositions","iks","grants","rigidBodies","constraints","offset","boneTypeTable","metadata","vertexCount","v","vertices","j","jl","normal","uv","faceCount","face","faces","materialCount","materials","count","rigidBodyCount","body","value","boneIndex","type","Math","max","boneCount","boneData","transformationClass","parentIndex","rigidBodyType","format","ikCount","ik","param","target","effector","iteration","maxAngle","links","link","enabled","indexOf","limitation","angleLimitation","rotationMin","lowerLimitationAngle","rotationMax","upperLimitationAngle","tmp1","tmp2","traverse","entry","grant","visited","children","child","grantEntryMap","ratio","isLocal","affectRotation","affectPosition","rootEntry","grantEntry","parentGrantEntry","updateAttributes","attribute","morph","elementCount","element","elements","morphs","array","morphCount","params","morph2","rigidBody","key","constraintCount","constraint","bodyA","rigidBodyIndex1","bodyB","rigidBodyIndex2","setAttribute","setIndex","addGroup","morphAttributes","morphTargetsRelative","userData","MMD","computeBoundingSphere","textureLoader","tgaLoader","textures","color","diffuse","opacity","emissive","ambient","transparent","skinning","fog","blending","blendSrc","blendDst","blendSrcAlpha","blendDstAlpha","flag","side","fileName","fileNames","split","map","_loadTexture","extension","envMap","combine","toonFileName","toonIndex","toonTextures","gradientMap","isToonTexture","isDefaultToonTexture","_isDefaultToonTexture","outlineParameters","thickness","edgeFlag","alpha","visible","textureIndex","envTextureIndex","envFlag","isDefaultToon","toonFlag","edgeSize","edgeColor","_checkImageTransparency","multiplyScalar","checkAlphaMorph","materials2","_getTGALoader","test","filePath","fullPath","parseInt","match","e","console","warn","getHandler","texture","t","image","_getRotatedImage","magFilter","minFilter","flipY","wrapS","wrapT","readyCallbacks","canvas","document","createElement","context","getContext","width","height","clearRect","translate","rotate","PI","drawImage","getImageData","groupIndex","createImageData","detectImageTransparency","threshold","centerUV","x","y","getAlphaByUv","round","imageData","group","attributes","start","tracks","buildSkeletalAnimation","tracks2","buildMorphAnimation","pushInterpolation","interpolation","motions","boneNameDictionary","motionCount","motion","boneName","sort","a","b","frameNum","times","rotations","pInterpolations","rInterpolations","basePosition","getBoneByName","toArray","time","rotation","targetName","_createTrack","morphTargetDictionary","morphName","values","weight","pushVector3","vec","z","pushQuaternion","q","w","cameras","centers","quaternions","fovs","cInterpolations","qInterpolations","fInterpolations","euler","center","rot","distance","fov","set","setFromEuler","applyQuaternion","node","typedKeyframeTrack","interpolations","stride","interpolateStride","aheadIndex","endIndex","track","createInterpolant","InterpolantFactoryMethodCubicBezier","result","CubicBezierInterpolation","getValueSize","Float32Array","parameterPositions","sampleValues","sampleSize","resultBuffer","interpolationParams","interpolate_","i1","t0","t1","valueSize","offset1","offset0","weight1","x1","x2","y1","y2","_calculate","slerpFlat","c","s","loop","eps","math","sst3","stt3","ttt","ft","abs"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/MMDLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { Parser } from \"mmd-parser\";\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null;\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath;\n    return this;\n  }\n  // Load MMD assets as Three.js Object\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    const modelExtension = this._extractExtension(url).toLowerCase();\n    if (modelExtension !== \"pmd\" && modelExtension !== \"pmx\") {\n      if (onError)\n        onError(new Error(\"THREE.MMDLoader: Unknown model file extension .\" + modelExtension + \".\"));\n      return;\n    }\n    this[modelExtension === \"pmd\" ? \"loadPMD\" : \"loadPMX\"](\n      url,\n      function(data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder;\n    this.loadVMD(\n      url,\n      function(vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this;\n    this.load(\n      modelUrl,\n      function(mesh) {\n        scope.loadAnimation(\n          vmdUrl,\n          mesh,\n          function(animation) {\n            onLoad({\n              mesh,\n              animation\n            });\n          },\n          onProgress,\n          onError\n        );\n      },\n      onProgress,\n      onError\n    );\n  }\n  // Load MMD assets as Object data parsed by MMDParser\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(\n      url,\n      function(buffer) {\n        onLoad(parser.parsePmd(buffer, true));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(\n      url,\n      function(buffer) {\n        onLoad(parser.parsePmx(buffer, true));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url];\n    const vmds = [];\n    const vmdNum = urls.length;\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(\n        urls[i],\n        function(buffer) {\n          vmds.push(parser.parseVmd(buffer, true));\n          if (vmds.length === vmdNum)\n            onLoad(parser.mergeVmds(vmds));\n        },\n        onProgress,\n        onError\n      );\n    }\n  }\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(isUnicode ? void 0 : \"text/plain; charset=shift_jis\").setPath(this.animationPath).setResponseType(\"text\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(\n      url,\n      function(text) {\n        onLoad(parser.parseVpd(text, true));\n      },\n      onProgress,\n      onError\n    );\n  }\n  // private methods\n  _extractExtension(url) {\n    const index = url.lastIndexOf(\".\");\n    return index < 0 ? \"\" : url.slice(index + 1);\n  }\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser();\n    }\n    return this.parser;\n  }\n}\nconst DEFAULT_TOON_TEXTURES = [\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\"\n];\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = \"anonymous\";\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data);\n    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n    const mesh = new SkinnedMesh(geometry, material);\n    const skeleton = new Skeleton(initBones(mesh));\n    mesh.bind(skeleton);\n    return mesh;\n  }\n}\nfunction initBones(mesh) {\n  const geometry = mesh.geometry;\n  const bones = [];\n  if (geometry && geometry.bones !== void 0) {\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      const bone = new Bone();\n      bones.push(bone);\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== void 0)\n        bone.scale.fromArray(gbone.scl);\n    }\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {\n        bones[gbone.parent].add(bones[i]);\n      } else {\n        mesh.add(bones[i]);\n      }\n    }\n  }\n  mesh.updateMatrixWorld(true);\n  return bones;\n}\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    const positions = [];\n    const uvs = [];\n    const normals = [];\n    const indices = [];\n    const groups = [];\n    const bones = [];\n    const skinIndices = [];\n    const skinWeights = [];\n    const morphTargets = [];\n    const morphPositions = [];\n    const iks = [];\n    const grants = [];\n    const rigidBodies = [];\n    const constraints = [];\n    let offset = 0;\n    const boneTypeTable = {};\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i];\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j]);\n      }\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j]);\n      }\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j]);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0);\n      }\n    }\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i];\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j]);\n      }\n    }\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3\n      });\n      offset += material.faceCount;\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i];\n      let value = boneTypeTable[body.boneIndex];\n      value = value === void 0 ? body.type : Math.max(body.type, value);\n      boneTypeTable[body.boneIndex] = value;\n    }\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i];\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== void 0 ? boneTypeTable[i] : -1\n      };\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0];\n        bone.pos[1] -= data.bones[bone.parent].position[1];\n        bone.pos[2] -= data.bones[bone.parent].position[2];\n      }\n      bones.push(bone);\n    }\n    if (data.metadata.format === \"pmd\") {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i];\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (data.bones[link.index].name.indexOf(\"ひざ\") >= 0) {\n            link.limitation = new Vector3(1, 0, 0);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik;\n        if (ik === void 0)\n          continue;\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (ik.links[j].angleLimitation === 1) {\n            const rotationMin = ik.links[j].lowerLimitationAngle;\n            const rotationMax = ik.links[j].upperLimitationAngle;\n            const tmp1 = -rotationMax[0];\n            const tmp2 = -rotationMax[1];\n            rotationMax[0] = -rotationMin[0];\n            rotationMax[1] = -rotationMin[1];\n            rotationMin[0] = tmp1;\n            rotationMin[1] = tmp2;\n            link.rotationMin = new Vector3().fromArray(rotationMin);\n            link.rotationMax = new Vector3().fromArray(rotationMax);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n        bones[i].ik = param;\n      }\n    }\n    if (data.metadata.format === \"pmx\") {\n      let traverse = function(entry) {\n        if (entry.param) {\n          grants.push(entry.param);\n          bones[entry.param.index].grant = entry.param;\n        }\n        entry.visited = true;\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i];\n          if (!child.visited)\n            traverse(child);\n        }\n      };\n      const grantEntryMap = {};\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i];\n        const grant = boneData.grant;\n        if (grant === void 0)\n          continue;\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass\n        };\n        grantEntryMap[i] = { parent: null, children: [], param, visited: false };\n      }\n      const rootEntry = { parent: null, children: [], param: null, visited: false };\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex];\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n        grantEntry.parent = parentGrantEntry;\n        parentGrantEntry.children.push(grantEntry);\n      }\n      traverse(rootEntry);\n    }\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i];\n        let index;\n        if (data.metadata.format === \"pmd\") {\n          index = data.morphs[0].elements[element.index].index;\n        } else {\n          index = element.index;\n        }\n        attribute.array[index * 3 + 0] += element.position[0] * ratio;\n        attribute.array[index * 3 + 1] += element.position[1] * ratio;\n        attribute.array[index * 3 + 2] += element.position[2] * ratio;\n      }\n    }\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i];\n      const params = { name: morph.name };\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n      attribute.name = morph.name;\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j];\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1);\n        }\n      } else {\n        if (morph.type === 0) {\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index];\n            const ratio = morph.elements[j].ratio;\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio);\n            } else {\n            }\n          }\n        } else if (morph.type === 1) {\n          updateAttributes(attribute, morph, 1);\n        } else if (morph.type === 2) {\n        } else if (morph.type === 3) {\n        } else if (morph.type === 4) {\n        } else if (morph.type === 5) {\n        } else if (morph.type === 6) {\n        } else if (morph.type === 7) {\n        } else if (morph.type === 8) {\n        }\n      }\n      morphTargets.push(params);\n      morphPositions.push(attribute);\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i];\n      const params = {};\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key];\n      }\n      if (data.metadata.format === \"pmx\") {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex];\n          params.position[0] -= bone.position[0];\n          params.position[1] -= bone.position[1];\n          params.position[2] -= bone.position[2];\n        }\n      }\n      rigidBodies.push(params);\n    }\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i];\n      const params = {};\n      for (const key in constraint) {\n        params[key] = constraint[key];\n      }\n      const bodyA = rigidBodies[params.rigidBodyIndex1];\n      const bodyB = rigidBodies[params.rigidBodyIndex2];\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n          bodyB.type = 1;\n        }\n      }\n      constraints.push(params);\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    geometry.setAttribute(\"skinIndex\", new Uint16BufferAttribute(skinIndices, 4));\n    geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeights, 4));\n    geometry.setIndex(indices);\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i);\n    }\n    geometry.bones = bones;\n    geometry.morphTargets = morphTargets;\n    geometry.morphAttributes.position = morphPositions;\n    geometry.morphTargetsRelative = false;\n    geometry.userData.MMD = {\n      bones,\n      iks,\n      grants,\n      rigidBodies,\n      constraints,\n      format: data.metadata.format\n    };\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n}\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null;\n    this.crossOrigin = \"anonymous\";\n    this.resourcePath = void 0;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n  build(data, geometry) {\n    const materials = [];\n    const textures = {};\n    this.textureLoader.setCrossOrigin(this.crossOrigin);\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      const params = { userData: {} };\n      if (material.name !== void 0)\n        params.name = material.name;\n      params.color = new Color().fromArray(material.diffuse);\n      params.opacity = material.diffuse[3];\n      params.emissive = new Color().fromArray(material.ambient);\n      params.transparent = params.opacity !== 1;\n      params.skinning = geometry.bones.length > 0 ? true : false;\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n      params.fog = true;\n      params.blending = CustomBlending;\n      params.blendSrc = SrcAlphaFactor;\n      params.blendDst = OneMinusSrcAlphaFactor;\n      params.blendSrcAlpha = SrcAlphaFactor;\n      params.blendDstAlpha = DstAlphaFactor;\n      if (data.metadata.format === \"pmx\" && (material.flag & 1) === 1) {\n        params.side = DoubleSide;\n      } else {\n        params.side = params.opacity === 1 ? FrontSide : DoubleSide;\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (material.fileName) {\n          const fileName = material.fileName;\n          const fileNames = fileName.split(\"*\");\n          params.map = this._loadTexture(fileNames[0], textures);\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase();\n            params.envMap = this._loadTexture(fileNames[1], textures);\n            params.combine = extension === \".sph\" ? MultiplyOperation : AddOperation;\n          }\n        }\n        const toonFileName = material.toonIndex === -1 ? \"toon00.bmp\" : data.toonTextures[material.toonIndex].fileName;\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 3e-3 : 0,\n          color: [0, 0, 0],\n          alpha: 1,\n          visible: material.edgeFlag === 1\n        };\n      } else {\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n        }\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n        }\n        let toonFileName, isDefaultToon;\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = \"toon\" + (\"0\" + (material.toonIndex + 1)).slice(-2) + \".bmp\";\n          isDefaultToon = true;\n        } else {\n          toonFileName = data.textures[material.toonIndex];\n          isDefaultToon = false;\n        }\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300,\n          // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 16) !== 0 && material.edgeSize > 0\n        };\n      }\n      if (params.map !== void 0) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i);\n        }\n        params.emissive.multiplyScalar(0.2);\n      }\n      materials.push(new MeshToonMaterial(params));\n    }\n    if (data.metadata.format === \"pmx\") {\n      let checkAlphaMorph = function(elements, materials2) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i];\n          if (element.index === -1)\n            continue;\n          const material = materials2[element.index];\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true;\n          }\n        }\n      };\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i];\n        const elements = morph.elements;\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index];\n            if (morph2.type !== 8)\n              continue;\n            checkAlphaMorph(morph2.elements, materials);\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials);\n        }\n      }\n    }\n    return materials;\n  }\n  // private methods\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === void 0) {\n        throw new Error(\"THREE.MMDLoader: Import TGALoader\");\n      }\n      this.tgaLoader = new TGALoader(this.manager);\n    }\n    return this.tgaLoader;\n  }\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10)\n      return false;\n    return /toon(10|0[0-9])\\.bmp/.test(name);\n  }\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {};\n    const scope = this;\n    let fullPath;\n    if (params.isDefaultToonTexture === true) {\n      let index;\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n      } catch (e) {\n        console.warn(\n          \"THREE.MMDLoader: \" + filePath + \" seems like a not right default texture path. Using toon00.bmp instead.\"\n        );\n        index = 0;\n      }\n      fullPath = DEFAULT_TOON_TEXTURES[index];\n    } else {\n      fullPath = this.resourcePath + filePath;\n    }\n    if (textures[fullPath] !== void 0)\n      return textures[fullPath];\n    let loader = this.manager.getHandler(fullPath);\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === \".tga\" ? this._getTGALoader() : this.textureLoader;\n    }\n    const texture = loader.load(\n      fullPath,\n      function(t) {\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image);\n          t.magFilter = NearestFilter;\n          t.minFilter = NearestFilter;\n        }\n        t.flipY = false;\n        t.wrapS = RepeatWrapping;\n        t.wrapT = RepeatWrapping;\n        for (let i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture);\n        }\n        delete texture.readyCallbacks;\n      },\n      onProgress,\n      onError\n    );\n    texture.readyCallbacks = [];\n    textures[fullPath] = texture;\n    return texture;\n  }\n  _getRotatedImage(image) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const width = image.width;\n    const height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    context.clearRect(0, 0, width, height);\n    context.translate(width / 2, height / 2);\n    context.rotate(0.5 * Math.PI);\n    context.translate(-width / 2, -height / 2);\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, width, height);\n  }\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function(texture) {\n      function createImageData(image) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n      }\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width;\n        const height = image.height;\n        const data = image.data;\n        const threshold = 253;\n        if (data.length / (width * height) !== 4)\n          return false;\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = { x: 0, y: 0 };\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j];\n            const uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] };\n            if (getAlphaByUv(image, uv) < threshold)\n              return true;\n            centerUV.x += uv.x;\n            centerUV.y += uv.y;\n          }\n          centerUV.x /= 3;\n          centerUV.y /= 3;\n          if (getAlphaByUv(image, centerUV) < threshold)\n            return true;\n        }\n        return false;\n      }\n      function getAlphaByUv(image, uv) {\n        const width = image.width;\n        const height = image.height;\n        let x = Math.round(uv.x * width) % width;\n        let y = Math.round(uv.y * height) % height;\n        if (x < 0)\n          x += width;\n        if (y < 0)\n          y += height;\n        const index = y * width + x;\n        return image.data[index * 4 + 3];\n      }\n      const imageData = texture.image.data !== void 0 ? texture.image : createImageData(texture.image);\n      const group = geometry.groups[groupIndex];\n      if (detectImageTransparency(\n        imageData,\n        geometry.attributes.uv.array,\n        geometry.index.array.slice(group.start, group.start + group.count)\n      )) {\n        map.transparent = true;\n      }\n    });\n  }\n}\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i]);\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127);\n      array.push(interpolation[index + 8] / 127);\n      array.push(interpolation[index + 4] / 127);\n      array.push(interpolation[index + 12] / 127);\n    }\n    const tracks = [];\n    const motions = {};\n    const bones = mesh.skeleton.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true;\n    }\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i];\n      const boneName = motion.boneName;\n      if (boneNameDictionary[boneName] === void 0)\n        continue;\n      motions[boneName] = motions[boneName] || [];\n      motions[boneName].push(motion);\n    }\n    for (const key in motions) {\n      const array = motions[key];\n      array.sort(function(a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const positions = [];\n      const rotations = [];\n      const pInterpolations = [];\n      const rInterpolations = [];\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30;\n        const position = array[i].position;\n        const rotation = array[i].rotation;\n        const interpolation = array[i].interpolation;\n        times.push(time);\n        for (let j = 0; j < 3; j++)\n          positions.push(basePosition[j] + position[j]);\n        for (let j = 0; j < 4; j++)\n          rotations.push(rotation[j]);\n        for (let j = 0; j < 3; j++)\n          pushInterpolation(pInterpolations, interpolation, j);\n        pushInterpolation(rInterpolations, interpolation, 3);\n      }\n      const targetName = \".bones[\" + key + \"]\";\n      tracks.push(this._createTrack(targetName + \".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(\n        this._createTrack(targetName + \".quaternion\", QuaternionKeyframeTrack, times, rotations, rInterpolations)\n      );\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = [];\n    const morphs = {};\n    const morphTargetDictionary = mesh.morphTargetDictionary;\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i];\n      const morphName = morph.morphName;\n      if (morphTargetDictionary[morphName] === void 0)\n        continue;\n      morphs[morphName] = morphs[morphName] || [];\n      morphs[morphName].push(morph);\n    }\n    for (const key in morphs) {\n      const array = morphs[key];\n      array.sort(function(a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const values = [];\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30);\n        values.push(array[i].weight);\n      }\n      tracks.push(new NumberKeyframeTrack(\".morphTargetInfluences[\" + morphTargetDictionary[key] + \"]\", times, values));\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x);\n      array.push(vec.y);\n      array.push(vec.z);\n    }\n    function pushQuaternion(array, q) {\n      array.push(q.x);\n      array.push(q.y);\n      array.push(q.z);\n      array.push(q.w);\n    }\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127);\n      array.push(interpolation[index * 4 + 1] / 127);\n      array.push(interpolation[index * 4 + 2] / 127);\n      array.push(interpolation[index * 4 + 3] / 127);\n    }\n    const cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();\n    cameras.sort(function(a, b) {\n      return a.frameNum - b.frameNum;\n    });\n    const times = [];\n    const centers = [];\n    const quaternions = [];\n    const positions = [];\n    const fovs = [];\n    const cInterpolations = [];\n    const qInterpolations = [];\n    const pInterpolations = [];\n    const fInterpolations = [];\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const position = new Vector3();\n    const center = new Vector3();\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i];\n      const time = motion.frameNum / 30;\n      const pos = motion.position;\n      const rot = motion.rotation;\n      const distance = motion.distance;\n      const fov = motion.fov;\n      const interpolation = motion.interpolation;\n      times.push(time);\n      position.set(0, 0, -distance);\n      center.set(pos[0], pos[1], pos[2]);\n      euler.set(-rot[0], -rot[1], -rot[2]);\n      quaternion.setFromEuler(euler);\n      position.add(center);\n      position.applyQuaternion(quaternion);\n      pushVector3(centers, center);\n      pushQuaternion(quaternions, quaternion);\n      pushVector3(positions, position);\n      fovs.push(fov);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j);\n      }\n      pushInterpolation(qInterpolations, interpolation, 3);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4);\n      }\n      pushInterpolation(fInterpolations, interpolation, 5);\n    }\n    const tracks = [];\n    tracks.push(this._createTrack(\"target.position\", VectorKeyframeTrack, times, centers, cInterpolations));\n    tracks.push(this._createTrack(\".quaternion\", QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n    tracks.push(this._createTrack(\".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n    tracks.push(this._createTrack(\".fov\", NumberKeyframeTrack, times, fovs, fInterpolations));\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  // private method\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    if (times.length > 2) {\n      times = times.slice();\n      values = values.slice();\n      interpolations = interpolations.slice();\n      const stride = values.length / times.length;\n      const interpolateStride = interpolations.length / times.length;\n      let index = 1;\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n            index++;\n            break;\n          }\n        }\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex];\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i];\n          }\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n          }\n        }\n      }\n      times.length = index + 1;\n      values.length = (index + 1) * stride;\n      interpolations.length = (index + 1) * interpolateStride;\n    }\n    const track = new typedKeyframeTrack(node, times, values);\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(\n        this.times,\n        this.values,\n        this.getValueSize(),\n        result,\n        new Float32Array(interpolations)\n      );\n    };\n    return track;\n  }\n}\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const params = this.interpolationParams;\n    const offset1 = i1 * stride;\n    const offset0 = offset1 - stride;\n    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t - t0) / (t1 - t0);\n    if (stride === 4) {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n    } else if (stride === 3) {\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0];\n        const x2 = params[i1 * 12 + i * 4 + 1];\n        const y1 = params[i1 * 12 + i * 4 + 2];\n        const y2 = params[i1 * 12 + i * 4 + 3];\n        const ratio = this._calculate(x1, x2, y1, y2, weight1);\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n      }\n    } else {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n    }\n    return result;\n  }\n  _calculate(x1, x2, y1, y2, x) {\n    let c = 0.5;\n    let t = c;\n    let s = 1 - t;\n    const loop = 15;\n    const eps = 1e-5;\n    const math = Math;\n    let sst3, stt3, ttt;\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3 * s * s * t;\n      stt3 = 3 * s * t * t;\n      ttt = t * t * t;\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x;\n      if (math.abs(ft) < eps)\n        break;\n      c /= 2;\n      t += ft < 0 ? c : -c;\n      s = 1 - t;\n    }\n    return sst3 * y1 + stt3 * y2 + ttt;\n  }\n}\nexport {\n  MMDLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}