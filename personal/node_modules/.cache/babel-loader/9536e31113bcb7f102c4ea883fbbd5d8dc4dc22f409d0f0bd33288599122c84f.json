{"ast":null,"code":"import { syncBoundedLevenshtein } from '../components/levenshtein.js';\nimport { getOwnProperty } from '../utils.js';\nexport class Node {\n  constructor(key, subWord, end) {\n    this.k = key;\n    this.s = subWord;\n    this.e = end;\n  }\n  // Node children\n  c = {};\n  // Node documents\n  d = [];\n  // Node word\n  w = '';\n  toJSON() {\n    return {\n      w: this.w,\n      s: this.s,\n      c: this.c,\n      d: this.d,\n      e: this.e\n    };\n  }\n}\nfunction updateParent(node, parent) {\n  node.w = parent.w + node.s;\n}\nfunction addDocument(node, docID) {\n  node.d.push(docID);\n}\nfunction removeDocument(node, docID) {\n  const index = node.d.indexOf(docID);\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false;\n  }\n  node.d.splice(index, 1);\n  return true;\n}\nfunction findAllWords(node, output, term, exact, tolerance) {\n  if (node.e) {\n    const {\n      w,\n      d: docIDs\n    } = node;\n    if (exact && w !== term) {\n      return {};\n    }\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, w) == null) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - w.length);\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n          output[w] = [];\n        }\n      } else {\n        // prevent default tolerance not set\n        output[w] = [];\n      }\n    }\n    // check if _output[w] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n      const docs = new Set(output[w]);\n      const docIDsLength = docIDs.length;\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i]);\n      }\n      output[w] = Array.from(docs);\n    }\n  }\n  // recursively search the children\n  for (const character of Object.keys(node.c)) {\n    findAllWords(node.c[character], output, term, exact, tolerance);\n  }\n  return output;\n}\nfunction getCommonPrefix(a, b) {\n  let commonPrefix = '';\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix;\n    }\n    commonPrefix += a[i];\n  }\n  return commonPrefix;\n}\nexport function create(end = false, subWord = '', key = '') {\n  return new Node(key, subWord, end);\n}\nexport function insert(root, word, docId) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i];\n    const wordAtIndex = word.substring(i);\n    const rootChildCurrentChar = root.c[currentCharacter];\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.s;\n      const edgeLabelLength = edgeLabel.length;\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);\n      const commonPrefixLength = commonPrefix.length;\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId);\n        rootChildCurrentChar.e = true;\n        return;\n      }\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        ;\n        newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        const newNodeChild = newNode.c[edgeLabelAtCommonPrefix];\n        newNodeChild.s = edgeLabel.substring(commonPrefixLength);\n        newNodeChild.k = edgeLabelAtCommonPrefix;\n        root.c[currentCharacter] = newNode;\n        updateParent(newNode, root);\n        updateParent(newNodeChild, newNode);\n        addDocument(newNode, docId);\n        return;\n      }\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter);\n        inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        root.c[currentCharacter] = inbetweenNode;\n        const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix];\n        inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength);\n        inbetweenNodeChild.k = edgeLabelAtCommonPrefix;\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);\n        addDocument(newNode, docId);\n        inbetweenNode.c[wordAtCommonPrefix] = newNode;\n        updateParent(inbetweenNode, root);\n        updateParent(newNode, inbetweenNode);\n        updateParent(inbetweenNodeChild, inbetweenNode);\n        return;\n      }\n      // skip to the next divergent character\n      i += edgeLabelLength - 1;\n      // navigate in the child node\n      root = rootChildCurrentChar;\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter);\n      addDocument(newNode, docId);\n      root.c[currentCharacter] = newNode;\n      updateParent(newNode, root);\n      return;\n    }\n  }\n}\nfunction _findLevenshtein(node, term, index, tolerance, originalTolerance, output) {\n  if (tolerance < 0) {\n    return;\n  }\n  if (node.e) {\n    const {\n      w,\n      d: docIDs\n    } = node;\n    if (w) {\n      const difference = Math.abs(term.length - w.length);\n      if (difference <= originalTolerance && syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n        output[w] = [];\n      }\n      if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n        const docs = new Set(output[w]);\n        const docIDsLength = docIDs.length;\n        for (let i = 0; i < docIDsLength; i++) {\n          docs.add(docIDs[i]);\n        }\n        output[w] = Array.from(docs);\n      }\n    }\n  }\n  if (index >= term.length) {\n    return;\n  }\n  // Match current character without consuming tolerance\n  if (term[index] in node.c) {\n    _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output);\n  }\n  // If tolerance is still available, consider other branches:\n  // 1. Deletion (skip the current term character)\n  _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output);\n  // 2. Insertion (skip the current tree node character)\n  for (const character in node.c) {\n    _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output);\n  }\n  // 3. Substitution (skip both current term character and tree node character)\n  for (const character in node.c) {\n    if (character !== term[index]) {\n      _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output);\n    }\n  }\n}\nexport function find(root, {\n  term,\n  exact,\n  tolerance\n}) {\n  // Find the closest node to the term\n  // Use `if` condition because tolerance `0` is supposed to match only prefix.\n  // (allows infinite insertions at end, which is against normal levenshtein logic).\n  // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n  if (tolerance && !exact) {\n    const output = {};\n    tolerance = tolerance || 0;\n    _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output);\n    return output;\n  } else {\n    for (let i = 0; i < term.length; i++) {\n      const character = term[i];\n      if (character in root.c) {\n        const rootChildCurrentChar = root.c[character];\n        const edgeLabel = rootChildCurrentChar.s;\n        const termSubstring = term.substring(i);\n        // find the common prefix between two words ex: prime and primate = prim\n        const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n        const commonPrefixLength = commonPrefix.length;\n        // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n        // if the common prefix is equal to the term means it is contained in the node\n        if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n          // if tolerance is set we take the current node as the closest\n          if (tolerance) break;\n          return {};\n        }\n        // skip the subword length and check the next divergent character\n        i += rootChildCurrentChar.s.length - 1;\n        // navigate into the child node\n        root = rootChildCurrentChar;\n      } else {\n        return {};\n      }\n    }\n    const output = {};\n    // found the closest node we recursively search through children\n    findAllWords(root, output, term, exact, tolerance);\n    return output;\n  }\n}\nexport function contains(root, term) {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.c) {\n      const rootChildrenChar = root.c[character];\n      const edgeLabel = rootChildrenChar.s;\n      const termSubstring = term.substring(i);\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      const commonPrefixLength = commonPrefix.length;\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false;\n      }\n      i += rootChildrenChar.s.length - 1;\n      root = rootChildrenChar;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nexport function removeWord(root, term) {\n  if (!term) {\n    return false;\n  }\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    const parent = root;\n    if (character in root.c) {\n      i += root.c[character].s.length - 1;\n      root = root.c[character];\n      if (Object.keys(root.c).length === 0) {\n        delete parent.c[root.k];\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nexport function removeDocumentByWord(root, term, docID, exact = true) {\n  if (!term) {\n    return true;\n  }\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.c) {\n      const rootChildCurrentChar = root.c[character];\n      i += rootChildCurrentChar.s.length - 1;\n      root = rootChildCurrentChar;\n      if (exact && root.w !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID);\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["syncBoundedLevenshtein","getOwnProperty","Node","constructor","key","subWord","end","k","s","e","c","d","w","toJSON","updateParent","node","parent","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","docs","Set","docIDsLength","i","add","Array","from","character","Object","keys","getCommonPrefix","a","b","commonPrefix","len","min","create","insert","root","word","docId","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","_findLevenshtein","originalTolerance","find","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getOwnProperty } from '../utils.js'\n\nexport class Node {\n  constructor (key: string, subWord: string, end: boolean) {\n    this.k = key\n    this.s = subWord\n    this.e = end\n  }\n\n  // Node key\n  public k: string\n  // Node subword\n  public s: string\n  // Node children\n  public c: Record<string, Node> = {}\n  // Node documents\n  public d: InternalDocumentID[] = []\n  // Node end\n  public e: boolean\n  // Node word\n  public w = ''\n\n  public toJSON (): object {\n    return {\n      w: this.w,\n      s: this.s,\n      c: this.c,\n      d: this.d,\n      e: this.e\n    }\n  }\n}\n\ninterface FindParams {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, InternalDocumentID[]>\n\nfunction updateParent (node: Node, parent: Node): void {\n  node.w = parent.w + node.s\n}\n\nfunction addDocument (node: Node, docID: InternalDocumentID): void {\n  node.d.push(docID)\n}\n\nfunction removeDocument (node: Node, docID: InternalDocumentID): boolean {\n  const index = node.d.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.d.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords (node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.e) {\n    const { w, d: docIDs } = node\n\n    if (exact && w !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, w) == null) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - w.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n          output[w] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[w] = []\n      }\n    }\n\n    // check if _output[w] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if ((getOwnProperty(output, w) != null) && (docIDs.length > 0)) {\n      const docs = new Set(output[w])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[w] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.c)) {\n    findAllWords(node.c[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix (a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create (end = false, subWord = '', key = ''): Node {\n  return new Node(key, subWord, end)\n}\n\nexport function insert (root: Node, word: string, docId: InternalDocumentID) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.c[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.s\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.e = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.c[edgeLabelAtCommonPrefix]\n        newNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.k = edgeLabelAtCommonPrefix\n\n        root.c[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.c[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.k = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.c[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.c[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nfunction _findLevenshtein (\n  node: Node,\n  term: string,\n  index: number,\n  tolerance: number,\n  originalTolerance: number,\n  output: FindResult\n) {\n  if (tolerance < 0) {\n    return\n  }\n\n  if (node.e) {\n    const { w, d: docIDs } = node\n    if (w) {\n      const difference = Math.abs(term.length - w.length)\n      if (difference <= originalTolerance && syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n        output[w] = []\n      }\n      if ((getOwnProperty(output, w) != null) && (docIDs.length > 0)) {\n        const docs = new Set(output[w])\n\n        const docIDsLength = docIDs.length\n        for (let i = 0; i < docIDsLength; i++) {\n          docs.add(docIDs[i])\n        }\n        output[w] = Array.from(docs)\n      }\n    }\n  }\n\n  if (index >= term.length) {\n    return\n  }\n\n  // Match current character without consuming tolerance\n  if (term[index] in node.c) {\n    _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output)\n  }\n\n  // If tolerance is still available, consider other branches:\n  // 1. Deletion (skip the current term character)\n  _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output)\n\n  // 2. Insertion (skip the current tree node character)\n  for (const character in node.c) {\n    _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output)\n  }\n\n  // 3. Substitution (skip both current term character and tree node character)\n  for (const character in node.c) {\n    if (character !== term[index]) {\n      _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output)\n    }\n  }\n}\n\nexport function find (root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // Find the closest node to the term\n\n  // Use `if` condition because tolerance `0` is supposed to match only prefix.\n  // (allows infinite insertions at end, which is against normal levenshtein logic).\n  // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n  if (tolerance && !exact) {\n    const output: FindResult = {}\n    tolerance = tolerance || 0\n    _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output)\n    return output\n  } else {\n    for (let i = 0; i < term.length; i++) {\n      const character = term[i]\n      if (character in root.c) {\n        const rootChildCurrentChar = root.c[character]\n        const edgeLabel = rootChildCurrentChar.s\n        const termSubstring = term.substring(i)\n\n        // find the common prefix between two words ex: prime and primate = prim\n        const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n        const commonPrefixLength = commonPrefix.length\n        // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n        // if the common prefix is equal to the term means it is contained in the node\n        if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n          // if tolerance is set we take the current node as the closest\n          if (tolerance) break\n          return {}\n        }\n\n        // skip the subword length and check the next divergent character\n        i += rootChildCurrentChar.s.length - 1\n        // navigate into the child node\n        root = rootChildCurrentChar\n      } else {\n        return {}\n      }\n    }\n\n    const output: FindResult = {}\n    // found the closest node we recursively search through children\n    findAllWords(root, output, term, exact, tolerance)\n\n    return output\n  }\n}\n\nexport function contains (root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.c) {\n      const rootChildrenChar = root.c[character]\n      const edgeLabel = rootChildrenChar.s\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.s.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord (root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.c) {\n      i += root.c[character].s.length - 1\n      root = root.c[character]\n\n      if (Object.keys(root.c).length === 0) {\n        delete parent.c[root.k]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord (root: Node, term: string, docID: InternalDocumentID, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.c) {\n      const rootChildCurrentChar = root.c[character]\n      i += rootChildCurrentChar.s.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.w !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}