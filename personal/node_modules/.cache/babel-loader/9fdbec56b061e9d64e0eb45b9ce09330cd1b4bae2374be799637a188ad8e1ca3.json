{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nvar EdgeSplitModifier = /*#__PURE__*/_createClass(function EdgeSplitModifier() {\n  var _this = this;\n  _classCallCheck(this, EdgeSplitModifier);\n  __publicField(this, \"A\", new Vector3());\n  __publicField(this, \"B\", new Vector3());\n  __publicField(this, \"C\", new Vector3());\n  __publicField(this, \"positions\", []);\n  __publicField(this, \"normals\", new Float32Array());\n  __publicField(this, \"indexes\", []);\n  __publicField(this, \"pointToIndexMap\", []);\n  __publicField(this, \"splitIndexes\", []);\n  __publicField(this, \"oldNormals\", []);\n  __publicField(this, \"computeNormals\", function () {\n    _this.normals = new Float32Array(_this.indexes.length * 3);\n    for (var i = 0; i < _this.indexes.length; i += 3) {\n      var index = _this.indexes[i];\n      _this.A.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n      index = _this.indexes[i + 1];\n      _this.B.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n      index = _this.indexes[i + 2];\n      _this.C.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n      _this.C.sub(_this.B);\n      _this.A.sub(_this.B);\n      var normal = _this.C.cross(_this.A).normalize();\n      for (var j = 0; j < 3; j++) {\n        _this.normals[3 * (i + j)] = normal.x;\n        _this.normals[3 * (i + j) + 1] = normal.y;\n        _this.normals[3 * (i + j) + 2] = normal.z;\n      }\n    }\n  });\n  __publicField(this, \"mapPositionsToIndexes\", function () {\n    _this.pointToIndexMap = Array(_this.positions.length / 3);\n    for (var i = 0; i < _this.indexes.length; i++) {\n      var index = _this.indexes[i];\n      if (_this.pointToIndexMap[index] == null) {\n        _this.pointToIndexMap[index] = [];\n      }\n      _this.pointToIndexMap[index].push(i);\n    }\n  });\n  __publicField(this, \"edgeSplitToGroups\", function (indexes, cutOff, firstIndex) {\n    _this.A.set(_this.normals[3 * firstIndex], _this.normals[3 * firstIndex + 1], _this.normals[3 * firstIndex + 2]).normalize();\n    var result = {\n      splitGroup: [],\n      currentGroup: [firstIndex]\n    };\n    var _iterator = _createForOfIteratorHelper(indexes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var j = _step.value;\n        if (j !== firstIndex) {\n          _this.B.set(_this.normals[3 * j], _this.normals[3 * j + 1], _this.normals[3 * j + 2]).normalize();\n          if (_this.B.dot(_this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  });\n  __publicField(this, \"edgeSplit\", function (indexes, cutOff) {\n    var original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (indexes.length === 0) return;\n    var groupResults = [];\n    var _iterator2 = _createForOfIteratorHelper(indexes),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var index = _step2.value;\n        groupResults.push(_this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var result = groupResults[0];\n    for (var _i = 0, _groupResults = groupResults; _i < _groupResults.length; _i++) {\n      var groupResult = _groupResults[_i];\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult;\n      }\n    }\n    if (original != null) {\n      _this.splitIndexes.push({\n        original: original,\n        indexes: result.currentGroup\n      });\n    }\n    if (result.splitGroup.length) {\n      _this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n    }\n  });\n  __publicField(this, \"modify\", function (geometry, cutOffAngle) {\n    var tryKeepNormals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var hadNormals = false;\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n      if (tryKeepNormals === true && geometry.index !== null) {\n        _this.oldNormals = geometry.attributes.normal.array;\n      }\n      geometry.deleteAttribute(\"normal\");\n    }\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === void 0) {\n        throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n      }\n      geometry = mergeVertices(geometry);\n    }\n    _this.indexes = geometry.index.array;\n    _this.positions = geometry.getAttribute(\"position\").array;\n    _this.computeNormals();\n    _this.mapPositionsToIndexes();\n    _this.splitIndexes = [];\n    var _iterator3 = _createForOfIteratorHelper(_this.pointToIndexMap),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var vertexIndexes = _step3.value;\n        _this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var newAttributes = {};\n    for (var _i2 = 0, _Object$keys = Object.keys(geometry.attributes); _i2 < _Object$keys.length; _i2++) {\n      var name = _Object$keys[_i2];\n      var oldAttribute = geometry.attributes[name];\n      var newArray = new oldAttribute.array.constructor((_this.indexes.length + _this.splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n    var newIndexes = new Uint32Array(_this.indexes.length);\n    newIndexes.set(_this.indexes);\n    for (var i = 0; i < _this.splitIndexes.length; i++) {\n      var split = _this.splitIndexes[i];\n      var index = _this.indexes[split.original];\n      for (var _i3 = 0, _Object$values = Object.values(newAttributes); _i3 < _Object$values.length; _i3++) {\n        var attribute = _Object$values[_i3];\n        for (var j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(_this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n      var _iterator4 = _createForOfIteratorHelper(split.indexes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _j = _step4.value;\n          newIndexes[_j] = _this.indexes.length + i;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n    for (var _i4 = 0, _Object$keys2 = Object.keys(newAttributes); _i4 < _Object$keys2.length; _i4++) {\n      var _name = _Object$keys2[_i4];\n      geometry.setAttribute(_name, newAttributes[_name]);\n    }\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n      if (_this.oldNormals !== null) {\n        var changedNormals = new Array(_this.oldNormals.length / 3).fill(false);\n        var _iterator5 = _createForOfIteratorHelper(_this.splitIndexes),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var splitData = _step5.value;\n            changedNormals[splitData.original] = true;\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        for (var _i5 = 0; _i5 < changedNormals.length; _i5++) {\n          if (changedNormals[_i5] === false) {\n            for (var _j2 = 0; _j2 < 3; _j2++) {\n              geometry.attributes.normal.array[3 * _i5 + _j2] = _this.oldNormals[3 * _i5 + _j2];\n            }\n          }\n        }\n      }\n    }\n    return geometry;\n  });\n});\nexport { EdgeSplitModifier };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Vector3","BufferAttribute","BufferGeometry","BufferGeometryUtils","mergeVertices","EdgeSplitModifier","_createClass","_this","_classCallCheck","Float32Array","normals","indexes","length","i","index","A","set","positions","B","C","sub","normal","cross","normalize","j","x","y","z","pointToIndexMap","Array","push","cutOff","firstIndex","result","splitGroup","currentGroup","_iterator","_createForOfIteratorHelper","_step","s","n","done","dot","err","e","f","original","arguments","undefined","groupResults","_iterator2","_step2","edgeSplitToGroups","_i","_groupResults","groupResult","splitIndexes","edgeSplit","geometry","cutOffAngle","tryKeepNormals","hadNormals","attributes","clone","oldNormals","array","deleteAttribute","getAttribute","computeNormals","mapPositionsToIndexes","_iterator3","_step3","vertexIndexes","Math","cos","newAttributes","_i2","_Object$keys","keys","name","oldAttribute","newArray","constructor","itemSize","normalized","newIndexes","Uint32Array","split","_i3","_Object$values","values","attribute","_iterator4","_step4","setIndex","_i4","_Object$keys2","setAttribute","computeVertexNormals","changedNormals","fill","_iterator5","_step5","splitData"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/modifiers/EdgeSplitModifier.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nclass EdgeSplitModifier {\n  constructor() {\n    __publicField(this, \"A\", new Vector3());\n    __publicField(this, \"B\", new Vector3());\n    __publicField(this, \"C\", new Vector3());\n    __publicField(this, \"positions\", []);\n    __publicField(this, \"normals\", new Float32Array());\n    __publicField(this, \"indexes\", []);\n    __publicField(this, \"pointToIndexMap\", []);\n    __publicField(this, \"splitIndexes\", []);\n    __publicField(this, \"oldNormals\", []);\n    __publicField(this, \"computeNormals\", () => {\n      this.normals = new Float32Array(this.indexes.length * 3);\n      for (let i = 0; i < this.indexes.length; i += 3) {\n        let index = this.indexes[i];\n        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 1];\n        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 2];\n        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        this.C.sub(this.B);\n        this.A.sub(this.B);\n        const normal = this.C.cross(this.A).normalize();\n        for (let j = 0; j < 3; j++) {\n          this.normals[3 * (i + j)] = normal.x;\n          this.normals[3 * (i + j) + 1] = normal.y;\n          this.normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    });\n    __publicField(this, \"mapPositionsToIndexes\", () => {\n      this.pointToIndexMap = Array(this.positions.length / 3);\n      for (let i = 0; i < this.indexes.length; i++) {\n        const index = this.indexes[i];\n        if (this.pointToIndexMap[index] == null) {\n          this.pointToIndexMap[index] = [];\n        }\n        this.pointToIndexMap[index].push(i);\n      }\n    });\n    __publicField(this, \"edgeSplitToGroups\", (indexes, cutOff, firstIndex) => {\n      this.A.set(\n        this.normals[3 * firstIndex],\n        this.normals[3 * firstIndex + 1],\n        this.normals[3 * firstIndex + 2]\n      ).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (let j of indexes) {\n        if (j !== firstIndex) {\n          this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();\n          if (this.B.dot(this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"edgeSplit\", (indexes, cutOff, original = null) => {\n      if (indexes.length === 0)\n        return;\n      const groupResults = [];\n      for (let index of indexes) {\n        groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (let groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        this.splitIndexes.push({\n          original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    });\n    __publicField(this, \"modify\", (geometry, cutOffAngle, tryKeepNormals = true) => {\n      let hadNormals = false;\n      if (geometry.attributes.normal) {\n        hadNormals = true;\n        geometry = geometry.clone();\n        if (tryKeepNormals === true && geometry.index !== null) {\n          this.oldNormals = geometry.attributes.normal.array;\n        }\n        geometry.deleteAttribute(\"normal\");\n      }\n      if (geometry.index == null) {\n        if (BufferGeometryUtils === void 0) {\n          throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n        }\n        geometry = mergeVertices(geometry);\n      }\n      this.indexes = geometry.index.array;\n      this.positions = geometry.getAttribute(\"position\").array;\n      this.computeNormals();\n      this.mapPositionsToIndexes();\n      this.splitIndexes = [];\n      for (let vertexIndexes of this.pointToIndexMap) {\n        this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n      const newAttributes = {};\n      for (let name of Object.keys(geometry.attributes)) {\n        const oldAttribute = geometry.attributes[name];\n        const newArray = new oldAttribute.array.constructor(\n          (this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize\n        );\n        newArray.set(oldAttribute.array);\n        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n      }\n      const newIndexes = new Uint32Array(this.indexes.length);\n      newIndexes.set(this.indexes);\n      for (let i = 0; i < this.splitIndexes.length; i++) {\n        const split = this.splitIndexes[i];\n        const index = this.indexes[split.original];\n        for (let attribute of Object.values(newAttributes)) {\n          for (let j = 0; j < attribute.itemSize; j++) {\n            attribute.array[(this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n          }\n        }\n        for (let j of split.indexes) {\n          newIndexes[j] = this.indexes.length + i;\n        }\n      }\n      geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(newIndexes, 1));\n      for (let name of Object.keys(newAttributes)) {\n        geometry.setAttribute(name, newAttributes[name]);\n      }\n      if (hadNormals) {\n        geometry.computeVertexNormals();\n        if (this.oldNormals !== null) {\n          const changedNormals = new Array(this.oldNormals.length / 3).fill(false);\n          for (let splitData of this.splitIndexes)\n            changedNormals[splitData.original] = true;\n          for (let i = 0; i < changedNormals.length; i++) {\n            if (changedNormals[i] === false) {\n              for (let j = 0; j < 3; j++) {\n                geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j];\n              }\n            }\n          }\n        }\n      }\n      return geometry;\n    });\n  }\n}\nexport {\n  EdgeSplitModifier\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}