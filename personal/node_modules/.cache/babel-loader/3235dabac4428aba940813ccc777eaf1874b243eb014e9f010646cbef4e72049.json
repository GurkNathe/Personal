{"ast":null,"code":"import { syncBoundedLevenshtein } from '../components/levenshtein.js';\nimport { getOwnProperty, syncUniqueId } from '../utils.js';\n/* c8 ignore next 5 */\nfunction serialize() {\n  var word = this.word,\n    subWord = this.subWord,\n    children = this.children,\n    docs = this.docs,\n    end = this.end;\n  return {\n    word: word,\n    subWord: subWord,\n    children: children,\n    docs: docs,\n    end: end\n  };\n}\nfunction updateParent(node, parent) {\n  node.parent = parent.id;\n  node.word = parent.word + node.subWord;\n}\nfunction addDocument(node, docID) {\n  node.docs.push(docID);\n}\nfunction removeDocument(node, docID) {\n  var index = node.docs.indexOf(docID);\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false;\n  }\n  node.docs.splice(index, 1);\n  return true;\n}\nfunction findAllWords(node, output, term, exact, tolerance) {\n  if (node.end) {\n    var word = node.word,\n      docIDs = node.docs;\n    if (exact && word !== term) {\n      return {};\n    }\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        var difference = Math.abs(term.length - word.length);\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = [];\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = [];\n      }\n    }\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      var docs = new Set(output[word]);\n      var docIDsLength = docIDs.length;\n      for (var i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i]);\n      }\n      output[word] = Array.from(docs);\n    }\n  }\n  // recursively search the children\n  for (var _i = 0, _Object$keys = Object.keys(node.children); _i < _Object$keys.length; _i++) {\n    var character = _Object$keys[_i];\n    findAllWords(node.children[character], output, term, exact, tolerance);\n  }\n  return output;\n}\nfunction getCommonPrefix(a, b) {\n  var commonPrefix = '';\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix;\n    }\n    commonPrefix += a[i];\n  }\n  return commonPrefix;\n}\nexport function create() {\n  var end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var subWord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var node = {\n    id: syncUniqueId(),\n    key: key,\n    subWord: subWord,\n    parent: null,\n    children: {},\n    docs: [],\n    end: end,\n    word: ''\n  };\n  Object.defineProperty(node, 'toJSON', {\n    value: serialize\n  });\n  return node;\n}\nexport function insert(root, word, docId) {\n  for (var i = 0; i < word.length; i++) {\n    var currentCharacter = word[i];\n    var wordAtIndex = word.substring(i);\n    var rootChildCurrentChar = root.children[currentCharacter];\n    if (rootChildCurrentChar) {\n      var edgeLabel = rootChildCurrentChar.subWord;\n      var edgeLabelLength = edgeLabel.length;\n      var commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);\n      var commonPrefixLength = commonPrefix.length;\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId);\n        rootChildCurrentChar.end = true;\n        return;\n      }\n      var edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        var newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        ;\n\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        var newNodeChild = newNode.children[edgeLabelAtCommonPrefix];\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength);\n        newNodeChild.key = edgeLabelAtCommonPrefix;\n        root.children[currentCharacter] = newNode;\n        updateParent(newNode, root);\n        updateParent(newNodeChild, newNode);\n        addDocument(newNode, docId);\n        return;\n      }\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        var inbetweenNode = create(false, commonPrefix, currentCharacter);\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        root.children[currentCharacter] = inbetweenNode;\n        var inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix];\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength);\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix;\n        var wordAtCommonPrefix = wordAtIndex[commonPrefixLength];\n        var _newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);\n        addDocument(_newNode, docId);\n        inbetweenNode.children[wordAtCommonPrefix] = _newNode;\n        updateParent(inbetweenNode, root);\n        updateParent(_newNode, inbetweenNode);\n        updateParent(inbetweenNodeChild, inbetweenNode);\n        return;\n      }\n      // skip to the next divergent character\n      i += edgeLabelLength - 1;\n      // navigate in the child node\n      root = rootChildCurrentChar;\n    } else {\n      // if the node for the current character doesn't exist create new node\n      var _newNode2 = create(true, wordAtIndex, currentCharacter);\n      addDocument(_newNode2, docId);\n      root.children[currentCharacter] = _newNode2;\n      updateParent(_newNode2, root);\n      return;\n    }\n  }\n}\nexport function find(root, _ref) {\n  var term = _ref.term,\n    exact = _ref.exact,\n    tolerance = _ref.tolerance;\n  // find the closest node to the term\n  for (var i = 0; i < term.length; i++) {\n    var character = term[i];\n    if (character in root.children) {\n      var rootChildCurrentChar = root.children[character];\n      var edgeLabel = rootChildCurrentChar.subWord;\n      var termSubstring = term.substring(i);\n      // find the common prefix between two words ex: prime and primate = prim\n      var commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      var commonPrefixLength = commonPrefix.length;\n      // if the common prefix lenght is equal to edgeLabel lenght (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break;\n        return {};\n      }\n      // skip the subword lenght and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1;\n      // navigate into the child node\n      root = rootChildCurrentChar;\n    } else {\n      return {};\n    }\n  }\n  var output = {};\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance);\n  return output;\n}\nexport function contains(root, term) {\n  for (var i = 0; i < term.length; i++) {\n    var character = term[i];\n    if (character in root.children) {\n      var rootChildrenChar = root.children[character];\n      var edgeLabel = rootChildrenChar.subWord;\n      var termSubstring = term.substring(i);\n      var commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      var commonPrefixLength = commonPrefix.length;\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false;\n      }\n      i += rootChildrenChar.subWord.length - 1;\n      root = rootChildrenChar;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nexport function removeWord(root, term) {\n  if (!term) {\n    return false;\n  }\n  for (var i = 0; i < term.length; i++) {\n    var character = term[i];\n    var parent = root;\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1;\n      root = root.children[character];\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key];\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nexport function removeDocumentByWord(root, term, docID) {\n  var exact = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (!term) {\n    return true;\n  }\n  for (var i = 0; i < term.length; i++) {\n    var character = term[i];\n    if (character in root.children) {\n      var rootChildCurrentChar = root.children[character];\n      i += rootChildCurrentChar.subWord.length - 1;\n      root = rootChildCurrentChar;\n      if (exact && root.word !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID);\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["syncBoundedLevenshtein","getOwnProperty","syncUniqueId","serialize","word","subWord","children","docs","end","updateParent","node","parent","id","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","Set","docIDsLength","i","add","Array","from","_i","_Object$keys","Object","keys","character","getCommonPrefix","a","b","commonPrefix","len","min","create","arguments","undefined","key","defineProperty","value","insert","root","docId","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","find","_ref","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { Nullable } from '../types.js'\nimport { getOwnProperty, syncUniqueId } from '../utils.js'\n\nexport interface Node {\n  id: string\n  key: string\n  subWord: string\n  parent: Nullable<string>\n  children: Record<string, Node>\n  docs: string[]\n  end: boolean\n  word: string\n}\n\ntype FindParams = {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, string[]>\n\n/* c8 ignore next 5 */\nfunction serialize(this: Node): object {\n  const { word, subWord, children, docs, end } = this\n\n  return { word, subWord, children, docs, end }\n}\n\nfunction updateParent(node: Node, parent: Node): void {\n  node.parent = parent.id\n  node.word = parent.word + node.subWord\n}\n\nfunction addDocument(node: Node, docID: string): void {\n  node.docs.push(docID)\n}\n\nfunction removeDocument(node: Node, docID: string): boolean {\n  const index = node.docs.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.docs.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords(node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.end) {\n    const { word, docs: docIDs } = node\n\n    if (exact && word !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - word.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = []\n      }\n    }\n\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      const docs = new Set(output[word])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[word] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.children)) {\n    findAllWords(node.children[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix(a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create(end = false, subWord = '', key = ''): Node {\n  const node = {\n    id: syncUniqueId(),\n    key,\n    subWord,\n    parent: null,\n    children: {},\n    docs: [],\n    end,\n    word: '',\n  }\n\n  Object.defineProperty(node, 'toJSON', { value: serialize })\n  return node\n}\n\nexport function insert(root: Node, word: string, docId: string) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.children[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.subWord\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.end = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix]\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.key = edgeLabelAtCommonPrefix\n\n        root.children[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.children[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.children[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.children[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nexport function find(root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // find the closest node to the term\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      const edgeLabel = rootChildCurrentChar.subWord\n      const termSubstring = term.substring(i)\n\n      // find the common prefix between two words ex: prime and primate = prim\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n      // if the common prefix lenght is equal to edgeLabel lenght (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break\n        return {}\n      }\n\n      // skip the subword lenght and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1\n      // navigate into the child node\n      root = rootChildCurrentChar\n    } else {\n      return {}\n    }\n  }\n\n  const output: FindResult = {}\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance)\n\n  return output\n}\n\nexport function contains(root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.children) {\n      const rootChildrenChar = root.children[character]\n      const edgeLabel = rootChildrenChar.subWord\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.subWord.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord(root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1\n      root = root.children[character]\n\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord(root: Node, term: string, docID: string, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      i += rootChildCurrentChar.subWord.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.word !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}