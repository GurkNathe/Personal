{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, ShapePath, Vector2, Path, Matrix3, Vector3, ShapeUtils, Box2, Shape, BufferGeometry, Float32BufferAttribute } from \"three\";\nvar SVGLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(SVGLoader, _Loader);\n  var _super = _createSuper(SVGLoader);\n  function SVGLoader(manager) {\n    var _this;\n    _classCallCheck(this, SVGLoader);\n    _this = _super.call(this, manager);\n    _this.defaultDPI = 90;\n    _this.defaultUnit = \"px\";\n    return _this;\n  }\n  _createClass(SVGLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var scope = this;\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return;\n        var transform = getNodeTransform(node);\n        var traverseChildNodes = true;\n        var path = null;\n        switch (node.nodeName) {\n          case \"svg\":\n            break;\n          case \"style\":\n            parseCSSStylesheet(node);\n            break;\n          case \"g\":\n            style = parseStyle(node, style);\n            break;\n          case \"path\":\n            style = parseStyle(node, style);\n            if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n            break;\n          case \"rect\":\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n          case \"polygon\":\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n          case \"polyline\":\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n          case \"circle\":\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n          case \"ellipse\":\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n          case \"line\":\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n          case \"defs\":\n            traverseChildNodes = false;\n            break;\n          case \"mask\":\n            traverseChildNodes = false;\n            break;\n          case \"use\":\n            style = parseStyle(node, style);\n            var usedNodeId = node.href.baseVal.substring(1);\n            var usedNode = node.viewportElement.getElementById(usedNodeId);\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n            break;\n          default:\n        }\n        if (path) {\n          if (style.fill !== void 0 && style.fill !== \"none\") {\n            path.color.setStyle(style.fill);\n          }\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = {\n            node: node,\n            style: style\n          };\n        }\n        if (traverseChildNodes) {\n          var nodes = node.childNodes;\n          for (var i = 0; i < nodes.length; i++) {\n            parseNode(nodes[i], style);\n          }\n        }\n        if (transform) {\n          transformStack.pop();\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n      function parsePathNode(node) {\n        var path = new ShapePath();\n        var point = new Vector2();\n        var control = new Vector2();\n        var firstPoint = new Vector2();\n        var isFirstPoint = true;\n        var doSetFirstPoint = false;\n        var d = node.getAttribute(\"d\");\n        var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n        for (var i = 0, l = commands.length; i < l; i++) {\n          var command = commands[i];\n          var type = command.charAt(0);\n          var data2 = command.substr(1).trim();\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n          var numbers = void 0;\n          switch (type) {\n            case \"M\":\n              numbers = parseFloats(data2);\n              for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0) firstPoint.copy(point);\n              }\n              break;\n            case \"H\":\n              numbers = parseFloats(data2);\n              for (var _j = 0, _jl = numbers.length; _j < _jl; _j++) {\n                point.x = numbers[_j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"V\":\n              numbers = parseFloats(data2);\n              for (var _j2 = 0, _jl2 = numbers.length; _j2 < _jl2; _j2++) {\n                point.y = numbers[_j2];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j2 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"L\":\n              numbers = parseFloats(data2);\n              for (var _j3 = 0, _jl3 = numbers.length; _j3 < _jl3; _j3 += 2) {\n                point.x = numbers[_j3 + 0];\n                point.y = numbers[_j3 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j3 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"C\":\n              numbers = parseFloats(data2);\n              for (var _j4 = 0, _jl4 = numbers.length; _j4 < _jl4; _j4 += 6) {\n                path.bezierCurveTo(numbers[_j4 + 0], numbers[_j4 + 1], numbers[_j4 + 2], numbers[_j4 + 3], numbers[_j4 + 4], numbers[_j4 + 5]);\n                control.x = numbers[_j4 + 2];\n                control.y = numbers[_j4 + 3];\n                point.x = numbers[_j4 + 4];\n                point.y = numbers[_j4 + 5];\n                if (_j4 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"S\":\n              numbers = parseFloats(data2);\n              for (var _j5 = 0, _jl5 = numbers.length; _j5 < _jl5; _j5 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[_j5 + 0], numbers[_j5 + 1], numbers[_j5 + 2], numbers[_j5 + 3]);\n                control.x = numbers[_j5 + 0];\n                control.y = numbers[_j5 + 1];\n                point.x = numbers[_j5 + 2];\n                point.y = numbers[_j5 + 3];\n                if (_j5 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"Q\":\n              numbers = parseFloats(data2);\n              for (var _j6 = 0, _jl6 = numbers.length; _j6 < _jl6; _j6 += 4) {\n                path.quadraticCurveTo(numbers[_j6 + 0], numbers[_j6 + 1], numbers[_j6 + 2], numbers[_j6 + 3]);\n                control.x = numbers[_j6 + 0];\n                control.y = numbers[_j6 + 1];\n                point.x = numbers[_j6 + 2];\n                point.y = numbers[_j6 + 3];\n                if (_j6 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"T\":\n              numbers = parseFloats(data2);\n              for (var _j7 = 0, _jl7 = numbers.length; _j7 < _jl7; _j7 += 2) {\n                var rx = getReflection(point.x, control.x);\n                var ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[_j7 + 0], numbers[_j7 + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[_j7 + 0];\n                point.y = numbers[_j7 + 1];\n                if (_j7 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"A\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (var _j8 = 0, _jl8 = numbers.length; _j8 < _jl8; _j8 += 7) {\n                if (numbers[_j8 + 5] == point.x && numbers[_j8 + 6] == point.y) continue;\n                var start = point.clone();\n                point.x = numbers[_j8 + 5];\n                point.y = numbers[_j8 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j8], numbers[_j8 + 1], numbers[_j8 + 2], numbers[_j8 + 3], numbers[_j8 + 4], start, point);\n                if (_j8 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"m\":\n              numbers = parseFloats(data2);\n              for (var _j9 = 0, _jl9 = numbers.length; _j9 < _jl9; _j9 += 2) {\n                point.x += numbers[_j9 + 0];\n                point.y += numbers[_j9 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (_j9 === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (_j9 === 0) firstPoint.copy(point);\n              }\n              break;\n            case \"h\":\n              numbers = parseFloats(data2);\n              for (var _j10 = 0, _jl10 = numbers.length; _j10 < _jl10; _j10++) {\n                point.x += numbers[_j10];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j10 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"v\":\n              numbers = parseFloats(data2);\n              for (var _j11 = 0, _jl11 = numbers.length; _j11 < _jl11; _j11++) {\n                point.y += numbers[_j11];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j11 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"l\":\n              numbers = parseFloats(data2);\n              for (var _j12 = 0, _jl12 = numbers.length; _j12 < _jl12; _j12 += 2) {\n                point.x += numbers[_j12 + 0];\n                point.y += numbers[_j12 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j12 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"c\":\n              numbers = parseFloats(data2);\n              for (var _j13 = 0, _jl13 = numbers.length; _j13 < _jl13; _j13 += 6) {\n                path.bezierCurveTo(point.x + numbers[_j13 + 0], point.y + numbers[_j13 + 1], point.x + numbers[_j13 + 2], point.y + numbers[_j13 + 3], point.x + numbers[_j13 + 4], point.y + numbers[_j13 + 5]);\n                control.x = point.x + numbers[_j13 + 2];\n                control.y = point.y + numbers[_j13 + 3];\n                point.x += numbers[_j13 + 4];\n                point.y += numbers[_j13 + 5];\n                if (_j13 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"s\":\n              numbers = parseFloats(data2);\n              for (var _j14 = 0, _jl14 = numbers.length; _j14 < _jl14; _j14 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[_j14 + 0], point.y + numbers[_j14 + 1], point.x + numbers[_j14 + 2], point.y + numbers[_j14 + 3]);\n                control.x = point.x + numbers[_j14 + 0];\n                control.y = point.y + numbers[_j14 + 1];\n                point.x += numbers[_j14 + 2];\n                point.y += numbers[_j14 + 3];\n                if (_j14 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"q\":\n              numbers = parseFloats(data2);\n              for (var _j15 = 0, _jl15 = numbers.length; _j15 < _jl15; _j15 += 4) {\n                path.quadraticCurveTo(point.x + numbers[_j15 + 0], point.y + numbers[_j15 + 1], point.x + numbers[_j15 + 2], point.y + numbers[_j15 + 3]);\n                control.x = point.x + numbers[_j15 + 0];\n                control.y = point.y + numbers[_j15 + 1];\n                point.x += numbers[_j15 + 2];\n                point.y += numbers[_j15 + 3];\n                if (_j15 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"t\":\n              numbers = parseFloats(data2);\n              for (var _j16 = 0, _jl16 = numbers.length; _j16 < _jl16; _j16 += 2) {\n                var _rx = getReflection(point.x, control.x);\n                var _ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(_rx, _ry, point.x + numbers[_j16 + 0], point.y + numbers[_j16 + 1]);\n                control.x = _rx;\n                control.y = _ry;\n                point.x = point.x + numbers[_j16 + 0];\n                point.y = point.y + numbers[_j16 + 1];\n                if (_j16 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"a\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (var _j17 = 0, _jl17 = numbers.length; _j17 < _jl17; _j17 += 7) {\n                if (numbers[_j17 + 5] == 0 && numbers[_j17 + 6] == 0) continue;\n                var _start = point.clone();\n                point.x += numbers[_j17 + 5];\n                point.y += numbers[_j17 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j17], numbers[_j17 + 1], numbers[_j17 + 2], numbers[_j17 + 3], numbers[_j17 + 4], _start, point);\n                if (_j17 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"Z\":\n            case \"z\":\n              path.currentPath.autoClose = true;\n              if (path.currentPath.curves.length > 0) {\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n              break;\n            default:\n              console.warn(command);\n          }\n          doSetFirstPoint = false;\n        }\n        return path;\n      }\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n        for (var i = 0; i < node.sheet.cssRules.length; i++) {\n          var stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1) continue;\n          var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(function (i2) {\n            return i2.trim();\n          });\n          for (var j = 0; j < selectorList.length; j++) {\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n          }\n        }\n      }\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          path.lineTo(end.x, end.y);\n          return;\n        }\n        x_axis_rotation = x_axis_rotation * Math.PI / 180;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var dx2 = (start.x - end.x) / 2;\n        var dy2 = (start.y - end.y) / 2;\n        var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n        var rxs = rx * rx;\n        var rys = ry * ry;\n        var x1ps = x1p * x1p;\n        var y1ps = y1p * y1p;\n        var cr = x1ps / rxs + y1ps / rys;\n        if (cr > 1) {\n          var s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n        var dq = rxs * y1ps + rys * x1ps;\n        var pq = (rxs * rys - dq) / dq;\n        var q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag) q = -q;\n        var cxp = q * rx * y1p / ry;\n        var cyp = -q * ry * x1p / rx;\n        var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n        var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n      function svgAngle(ux, uy, vx, vy) {\n        var dot = ux * vx + uy * vy;\n        var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        var ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n        if (ux * vy - uy * vx < 0) ang = -ang;\n        return ang;\n      }\n      function parseRectNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n        var rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n        var ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n        var w = parseFloatWithUnits(node.getAttribute(\"width\"));\n        var h = parseFloatWithUnits(node.getAttribute(\"height\"));\n        var bci = 1 - 0.551915024494;\n        var path = new ShapePath();\n        path.moveTo(x + rx, y);\n        path.lineTo(x + w - rx, y);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n        }\n        path.lineTo(x + w, y + h - ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n        }\n        path.lineTo(x + rx, y + h);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n        }\n        path.lineTo(x, y + ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n        }\n        return path;\n      }\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseCircleNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        var r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n        var subpath = new Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseEllipseNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        var rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n        var ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n        var subpath = new Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseLineNode(node) {\n        var x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n        var y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n        var x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n        var y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n        var path = new ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseStyle(node, style) {\n        style = Object.assign({}, style);\n        var stylesheetStyles = {};\n        if (node.hasAttribute(\"class\")) {\n          var classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map(function (i) {\n            return i.trim();\n          });\n          for (var i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n          }\n        }\n        if (node.hasAttribute(\"id\")) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n        }\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === void 0) {\n            adjustFunction = function copy(v) {\n              if (v.startsWith(\"url\")) console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n              return v;\n            };\n          }\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== \"\") style[jsName] = adjustFunction(node.style[svgName]);\n        }\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n        addStyle(\"fill\", \"fill\");\n        addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n        addStyle(\"fill-rule\", \"fillRule\");\n        addStyle(\"opacity\", \"opacity\", clamp);\n        addStyle(\"stroke\", \"stroke\");\n        addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n        addStyle(\"stroke-width\", \"strokeWidth\", positive);\n        addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n        addStyle(\"stroke-linecap\", \"strokeLineCap\");\n        addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n        addStyle(\"visibility\", \"visibility\");\n        return style;\n      }\n      function getReflection(a, b) {\n        return a - (b - a);\n      }\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== \"string\") {\n          throw new TypeError(\"Invalid input: \" + typeof input);\n        }\n        var RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        };\n        var SEP = 0;\n        var INT = 1;\n        var FLOAT = 2;\n        var EXP = 3;\n        var state = SEP;\n        var seenComma = true;\n        var number = \"\",\n          exponent = \"\";\n        var result = [];\n        function throwSyntaxError(current2, i, partial) {\n          var error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n          error.partial = partial;\n          throw error;\n        }\n        function newNumber() {\n          if (number !== \"\") {\n            if (exponent === \"\") result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n          number = \"\";\n          exponent = \"\";\n        }\n        var current;\n        var length = input.length;\n        for (var i = 0; i < length; i++) {\n          current = input[i];\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          }\n          if (state === SEP) {\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            }\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            }\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n              seenComma = true;\n            }\n          }\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n            if (RE.SIGN.test(current)) {\n              if (exponent === \"\") {\n                exponent += current;\n                continue;\n              }\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          }\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        newNumber();\n        return result;\n      }\n      var units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n      var unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n      function parseFloatWithUnits(string) {\n        var theUnit = \"px\";\n        if (typeof string === \"string\" || string instanceof String) {\n          for (var i = 0, n = units.length; i < n; i++) {\n            var u = units[i];\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n        var scale = void 0;\n        if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n          scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n          if (scale < 0) {\n            scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n          }\n        }\n        return scale * parseFloat(string);\n      }\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n          return null;\n        }\n        var transform = parseNodeTransform(node);\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n      function parseNodeTransform(node) {\n        var transform = new Matrix3();\n        var currentTransform2 = tempTransform0;\n        if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n          var tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n          var ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n          transform.translate(tx, ty);\n        }\n        if (node.hasAttribute(\"transform\")) {\n          var transformsTexts = node.getAttribute(\"transform\").split(\")\");\n          for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            var transformText = transformsTexts[tIndex].trim();\n            if (transformText === \"\") continue;\n            var openParPos = transformText.indexOf(\"(\");\n            var closeParPos = transformText.length;\n            if (openParPos > 0 && openParPos < closeParPos) {\n              var transformType = transformText.substr(0, openParPos);\n              var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n              currentTransform2.identity();\n              switch (transformType) {\n                case \"translate\":\n                  if (array.length >= 1) {\n                    var _tx = array[0];\n                    var _ty = _tx;\n                    if (array.length >= 2) {\n                      _ty = array[1];\n                    }\n                    currentTransform2.translate(_tx, _ty);\n                  }\n                  break;\n                case \"rotate\":\n                  if (array.length >= 1) {\n                    var angle = 0;\n                    var cx = 0;\n                    var cy = 0;\n                    angle = -array[0] * Math.PI / 180;\n                    if (array.length >= 3) {\n                      cx = array[1];\n                      cy = array[2];\n                    }\n                    tempTransform1.identity().translate(-cx, -cy);\n                    tempTransform2.identity().rotate(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.identity().translate(cx, cy);\n                    currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n                  break;\n                case \"scale\":\n                  if (array.length >= 1) {\n                    var scaleX = array[0];\n                    var scaleY = scaleX;\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n                    currentTransform2.scale(scaleX, scaleY);\n                  }\n                  break;\n                case \"skewX\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"skewY\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"matrix\":\n                  if (array.length === 6) {\n                    currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n                  break;\n              }\n            }\n            transform.premultiply(currentTransform2);\n          }\n        }\n        return transform;\n      }\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n        var isRotated = isTransformRotated(m);\n        var subPaths = path.subPaths;\n        for (var i = 0, n = subPaths.length; i < n; i++) {\n          var subPath = subPaths[i];\n          var curves = subPath.curves;\n          for (var j = 0; j < curves.length; j++) {\n            var curve = curves[j];\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              if (isRotated) {\n                console.warn(\"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\");\n              }\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              curve.xRadius *= getTransformScaleX(m);\n              curve.yRadius *= getTransformScaleY(m);\n            }\n          }\n        }\n      }\n      function isTransformRotated(m) {\n        return m.elements[1] !== 0 || m.elements[3] !== 0;\n      }\n      function getTransformScaleX(m) {\n        var te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n      function getTransformScaleY(m) {\n        var te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      }\n      var paths = [];\n      var stylesheets = {};\n      var transformStack = [];\n      var tempTransform0 = new Matrix3();\n      var tempTransform1 = new Matrix3();\n      var tempTransform2 = new Matrix3();\n      var tempTransform3 = new Matrix3();\n      var tempV2 = new Vector2();\n      var tempV3 = new Vector3();\n      var currentTransform = new Matrix3();\n      var xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n      parseNode(xml.documentElement, {\n        fill: \"#000\",\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: \"miter\",\n        strokeLineCap: \"butt\",\n        strokeMiterLimit: 4\n      });\n      var data = {\n        paths: paths,\n        xml: xml.documentElement\n      };\n      return data;\n    }\n  }], [{\n    key: \"createShapes\",\n    value: function createShapes(shapePath) {\n      var BIGNUMBER = 999999999;\n      var IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      var classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        var x1 = a0.x;\n        var x2 = a1.x;\n        var x3 = b0.x;\n        var x4 = b1.x;\n        var y1 = a0.y;\n        var y2 = a1.y;\n        var y3 = b0.y;\n        var y4 = b1.y;\n        var nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        var nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        var t1 = nom1 / denom;\n        var t2 = nom2 / denom;\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          for (var i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var point = i === 0 ? b0 : b1;\n              return {\n                x: point.x,\n                y: point.y,\n                t: classifyResult.t\n              };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              var x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              var y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return {\n                x: x,\n                y: y,\n                t: classifyResult.t\n              };\n            }\n          }\n          return null;\n        } else {\n          for (var _i = 0; _i < 2; _i++) {\n            classifyPoint(_i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var _point = _i === 0 ? b0 : b1;\n              return {\n                x: _point.x,\n                y: _point.y,\n                t: classifyResult.t\n              };\n            }\n          }\n          var _x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n          var _y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n          return {\n            x: _x,\n            y: _y,\n            t: t1\n          };\n        }\n      }\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        var ax = edgeEnd.x - edgeStart.x;\n        var ay = edgeEnd.y - edgeStart.y;\n        var bx = p.x - edgeStart.x;\n        var by = p.y - edgeStart.y;\n        var sa = ax * by - bx * ay;\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n        var t;\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n      function getIntersections(path1, path2) {\n        var intersectionsRaw = [];\n        var intersections = [];\n        for (var index = 1; index < path1.length; index++) {\n          var path1EdgeStart = path1[index - 1];\n          var path1EdgeEnd = path1[index];\n          var _loop = function _loop() {\n            var path2EdgeStart = path2[index2 - 1];\n            var path2EdgeEnd = path2[index2];\n            var intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n            if (intersection !== null && intersectionsRaw.find(function (i) {\n              return i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON;\n            }) === void 0) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new Vector2(intersection.x, intersection.y));\n            }\n          };\n          for (var index2 = 1; index2 < path2.length; index2++) {\n            _loop();\n          }\n        }\n        return intersections;\n      }\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        var center = new Vector2();\n        boundingBox.getCenter(center);\n        var allIntersections = [];\n        paths.forEach(function (path) {\n          if (path.boundingBox.containsPoint(center)) {\n            var intersections = getIntersections(scanline, path.points);\n            intersections.forEach(function (p) {\n              allIntersections.push({\n                identifier: path.identifier,\n                isCW: path.isCW,\n                point: p\n              });\n            });\n          }\n        });\n        allIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n      function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n        if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n          _fillRule = \"nonzero\";\n        }\n        var centerBoundingBox = new Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        var scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n        var scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        var baseIntersections = [];\n        var otherIntersections = [];\n        scanlineIntersections.forEach(function (i2) {\n          if (i2.identifier === simplePath.identifier) {\n            baseIntersections.push(i2);\n          } else {\n            otherIntersections.push(i2);\n          }\n        });\n        var firstXOfPath = baseIntersections[0].point.x;\n        var stack = [];\n        var i = 0;\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n          i++;\n        }\n        stack.push(simplePath.identifier);\n        if (_fillRule === \"evenodd\") {\n          var isHole = stack.length % 2 === 0 ? true : false;\n          var isHoleFor = stack[stack.length - 2];\n          return {\n            identifier: simplePath.identifier,\n            isHole: isHole,\n            for: isHoleFor\n          };\n        } else if (_fillRule === \"nonzero\") {\n          var _isHole = true;\n          var _isHoleFor = null;\n          var lastCWValue = null;\n          for (var i2 = 0; i2 < stack.length; i2++) {\n            var identifier2 = stack[i2];\n            if (_isHole) {\n              lastCWValue = allPaths[identifier2].isCW;\n              _isHole = false;\n              _isHoleFor = identifier2;\n            } else if (lastCWValue !== allPaths[identifier2].isCW) {\n              lastCWValue = allPaths[identifier2].isCW;\n              _isHole = true;\n            }\n          }\n          return {\n            identifier: simplePath.identifier,\n            isHole: _isHole,\n            for: _isHoleFor\n          };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      }\n      var identifier = 0;\n      var scanlineMinX = BIGNUMBER;\n      var scanlineMaxX = -BIGNUMBER;\n      var simplePaths = shapePath.subPaths.map(function (p) {\n        var points = p.getPoints();\n        var maxY = -BIGNUMBER;\n        var minY = BIGNUMBER;\n        var maxX = -BIGNUMBER;\n        var minX = BIGNUMBER;\n        for (var i = 0; i < points.length; i++) {\n          var p2 = points[i];\n          if (p2.y > maxY) {\n            maxY = p2.y;\n          }\n          if (p2.y < minY) {\n            minY = p2.y;\n          }\n          if (p2.x > maxX) {\n            maxX = p2.x;\n          }\n          if (p2.x < minX) {\n            minX = p2.x;\n          }\n        }\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n        return {\n          curves: p.curves,\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: identifier++,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter(function (sp) {\n        return sp.points.length > 1;\n      });\n      var isAHole = simplePaths.map(function (p) {\n        return isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule);\n      });\n      var shapesToReturn = [];\n      simplePaths.forEach(function (p) {\n        var amIAHole = isAHole[p.identifier];\n        if (!amIAHole.isHole) {\n          var shape = new Shape();\n          shape.curves = p.curves;\n          var holes = isAHole.filter(function (h) {\n            return h.isHole && h.for === p.identifier;\n          });\n          holes.forEach(function (h) {\n            var hole = simplePaths[h.identifier];\n            var path = new Path();\n            path.curves = hole.curves;\n            shape.holes.push(path);\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n  }, {\n    key: \"getStrokeStyle\",\n    value: function getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      width = width !== void 0 ? width : 1;\n      color = color !== void 0 ? color : \"#000\";\n      lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n      lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n      miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n  }, {\n    key: \"pointsToStroke\",\n    value: function pointsToStroke(points, style, arcDivisions, minDistance) {\n      var vertices = [];\n      var normals = [];\n      var uvs = [];\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n      var geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n  }, {\n    key: \"pointsToStrokeWithBuffers\",\n    value: function pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      var tempV2_1 = new Vector2();\n      var tempV2_2 = new Vector2();\n      var tempV2_3 = new Vector2();\n      var tempV2_4 = new Vector2();\n      var tempV2_5 = new Vector2();\n      var tempV2_6 = new Vector2();\n      var tempV2_7 = new Vector2();\n      var lastPointL = new Vector2();\n      var lastPointR = new Vector2();\n      var point0L = new Vector2();\n      var point0R = new Vector2();\n      var currentPointL = new Vector2();\n      var currentPointR = new Vector2();\n      var nextPointL = new Vector2();\n      var nextPointR = new Vector2();\n      var innerPoint = new Vector2();\n      var outerPoint = new Vector2();\n      arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n      minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n      vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n      points = removeDuplicatedPoints(points);\n      var numPoints = points.length;\n      if (numPoints < 2) return 0;\n      var isClosed = points[0].equals(points[numPoints - 1]);\n      var currentPoint;\n      var previousPoint = points[0];\n      var nextPoint;\n      var strokeWidth2 = style.strokeWidth / 2;\n      var deltaU = 1 / (numPoints - 1);\n      var u0 = 0,\n        u1;\n      var innerSideModified;\n      var joinIsOnLeftSide;\n      var isMiter;\n      var initialJoinIsOnLeftSide = false;\n      var numVertices = 0;\n      var currentCoordinate = vertexOffset * 3;\n      var currentCoordinateUV = vertexOffset * 2;\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n      for (var iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint];\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            nextPoint = points[1];\n          } else {\n            nextPoint = void 0;\n          }\n        } else {\n          nextPoint = points[iPoint + 1];\n        }\n        var normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n        if (nextPoint !== void 0) {\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          var dot = Math.abs(normal1.dot(tempV2_3));\n          if (dot !== 0) {\n            var miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            var miterLength2 = tempV2_5.length();\n            var segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            var segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext);\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              makeSegmentTriangles();\n            }\n            switch (style.strokeLineJoin) {\n              case \"bevel\":\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n              case \"round\":\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n                break;\n              case \"miter\":\n              case \"miter-clip\":\n              default:\n                var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n                if (miterFraction < 1) {\n                  if (style.strokeLineJoin !== \"miter-clip\") {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                  isMiter = true;\n                }\n                break;\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n        if (!isClosed && iPoint === numPoints - 1) {\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        }\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n      if (!isClosed) {\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        var lastOuter = outerPoint;\n        var lastInner = innerPoint;\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n      return numVertices;\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n          currentCoordinate += 3;\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n        numVertices += 3;\n      }\n      function makeCircularSector(center, p1, p2, u, v) {\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        var angle = Math.PI;\n        var dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n        for (var i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 1);\n        addVertex(currentPointR, u1, 0);\n      }\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          }\n        } else {\n          if (joinIsOnLeftSide2) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n        switch (style.strokeLineCap) {\n          case \"round\":\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n            break;\n          case \"square\":\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              var vl = vertices.length;\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_3.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n            break;\n          case \"butt\":\n          default:\n            break;\n        }\n      }\n      function removeDuplicatedPoints(points2) {\n        var dupPoints = false;\n        for (var i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n        if (!dupPoints) return points2;\n        var newPoints = [];\n        newPoints.push(points2[0]);\n        for (var _i2 = 1, _n = points2.length - 1; _i2 < _n; _i2++) {\n          if (points2[_i2].distanceTo(points2[_i2 + 1]) >= minDistance) {\n            newPoints.push(points2[_i2]);\n          }\n        }\n        newPoints.push(points2[points2.length - 1]);\n        return newPoints;\n      }\n    }\n  }]);\n  return SVGLoader;\n}(Loader);\nexport { SVGLoader };","map":{"version":3,"names":["Loader","FileLoader","ShapePath","Vector2","Path","Matrix3","Vector3","ShapeUtils","Box2","Shape","BufferGeometry","Float32BufferAttribute","SVGLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","defaultDPI","defaultUnit","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","traverseChildNodes","nodeName","parseCSSStylesheet","parseStyle","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","usedNodeId","href","baseVal","substring","usedNode","viewportElement","getElementById","warn","fill","color","setStyle","transformPath","currentTransform","paths","push","userData","nodes","childNodes","i","length","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data2","substr","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","i2","stylesheets","Object","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","bci","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","v","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current2","partial","SyntaxError","newNumber","Number","pow","current","Array","isArray","includes","test","units","unitConversion","mm","cm","in","pt","pc","px","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","currentTransform2","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","xRadius","getTransformScaleX","yRadius","getTransformScaleY","elements","te","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","data","createShapes","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","_loop","path2EdgeStart","index2","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","isHoleTo","simplePath","allPaths","scanlineMinX2","scanlineMaxX2","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","identifier2","scanlineMinX","scanlineMaxX","simplePaths","getPoints","maxY","minY","maxX","minX","p2","isClockWise","sp","isAHole","fillRule","shapesToReturn","amIAHole","shape","holes","hole","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","u1","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","position","il","rotateAround","joinIsOnLeftSide2","innerSideModified2","addVectors","vl","points2","dupPoints","distanceTo","newPoints"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/SVGLoader.js"],"sourcesContent":["import { Loader, FileLoader, ShapePath, Vector2, Path, Matrix3, Vector3, ShapeUtils, Box2, Shape, BufferGeometry, Float32BufferAttribute } from \"three\";\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.defaultDPI = 90;\n    this.defaultUnit = \"px\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text) {\n    const scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1)\n        return;\n      const transform = getNodeTransform(node);\n      let traverseChildNodes = true;\n      let path = null;\n      switch (node.nodeName) {\n        case \"svg\":\n          break;\n        case \"style\":\n          parseCSSStylesheet(node);\n          break;\n        case \"g\":\n          style = parseStyle(node, style);\n          break;\n        case \"path\":\n          style = parseStyle(node, style);\n          if (node.hasAttribute(\"d\"))\n            path = parsePathNode(node);\n          break;\n        case \"rect\":\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case \"polygon\":\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case \"polyline\":\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case \"circle\":\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case \"ellipse\":\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case \"line\":\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case \"defs\":\n          traverseChildNodes = false;\n          break;\n        case \"mask\":\n          traverseChildNodes = false;\n          break;\n        case \"use\":\n          style = parseStyle(node, style);\n          const usedNodeId = node.href.baseVal.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n          break;\n        default:\n      }\n      if (path) {\n        if (style.fill !== void 0 && style.fill !== \"none\") {\n          path.color.setStyle(style.fill);\n        }\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = { node, style };\n      }\n      if (traverseChildNodes) {\n        const nodes = node.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          parseNode(nodes[i], style);\n        }\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute(\"d\");\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data2 = command.substr(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        let numbers;\n        switch (type) {\n          case \"M\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"H\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"V\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"L\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"C\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                numbers[j + 5]\n              );\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"S\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3]\n              );\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"T\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"A\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)\n                continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"m\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"h\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"v\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"l\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"c\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5]\n              );\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"s\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"t\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"a\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0)\n                continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Z\":\n          case \"z\":\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        }\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)\n        return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1)\n          continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180;\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n      const dx2 = (start.x - end.x) / 2;\n      const dy2 = (start.y - end.y) / 2;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n      const cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag)\n        q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx;\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n      if (ux * vy - uy * vx < 0)\n        ang = -ang;\n      return ang;\n    }\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n      const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n      const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n      const bci = 1 - 0.551915024494;\n      const path = new ShapePath();\n      path.moveTo(x + rx, y);\n      path.lineTo(x + w - rx, y);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n      }\n      path.lineTo(x + w, y + h - ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n      }\n      path.lineTo(x + rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n      }\n      path.lineTo(x, y + ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseStyle(node, style) {\n      style = Object.assign({}, style);\n      let stylesheetStyles = {};\n      if (node.hasAttribute(\"class\")) {\n        const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((i) => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute(\"id\")) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === void 0) {\n          adjustFunction = function copy(v) {\n            if (v.startsWith(\"url\"))\n              console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n            return v;\n          };\n        }\n        if (node.hasAttribute(svgName))\n          style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName])\n          style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== \"\")\n          style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle(\"fill\", \"fill\");\n      addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n      addStyle(\"fill-rule\", \"fillRule\");\n      addStyle(\"opacity\", \"opacity\", clamp);\n      addStyle(\"stroke\", \"stroke\");\n      addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n      addStyle(\"stroke-width\", \"strokeWidth\", positive);\n      addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n      addStyle(\"stroke-linecap\", \"strokeLineCap\");\n      addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n      addStyle(\"visibility\", \"visibility\");\n      return style;\n    }\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Invalid input: \" + typeof input);\n      }\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      };\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = \"\", exponent = \"\";\n      const result = [];\n      function throwSyntaxError(current2, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n        error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== \"\") {\n          if (exponent === \"\")\n            result.push(Number(number));\n          else\n            result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = \"\";\n        exponent = \"\";\n      }\n      let current;\n      const length = input.length;\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n        if (state === SEP) {\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        }\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === \"\") {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n      newNumber();\n      return result;\n    }\n    const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      let theUnit = \"px\";\n      if (typeof string === \"string\" || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      let scale = void 0;\n      if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n        scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    }\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n        return null;\n      }\n      const transform = parseNodeTransform(node);\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform2 = tempTransform0;\n      if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n        const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n        const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n        transform.translate(tx, ty);\n      }\n      if (node.hasAttribute(\"transform\")) {\n        const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === \"\")\n            continue;\n          const openParPos = transformText.indexOf(\"(\");\n          const closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.substr(0, openParPos);\n            const array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform2.identity();\n            switch (transformType) {\n              case \"translate\":\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = tx;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform2.translate(tx, ty);\n                }\n                break;\n              case \"rotate\":\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n                  angle = -array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    cx = array[1];\n                    cy = array[2];\n                  }\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case \"scale\":\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform2.scale(scaleX, scaleY);\n                }\n                break;\n              case \"skewX\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"skewY\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"matrix\":\n                if (array.length === 6) {\n                  currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform2);\n        }\n      }\n      return transform;\n    }\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n      const isRotated = isTransformRotated(m);\n      const subPaths = path.subPaths;\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn(\"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\");\n            }\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    }\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    const tempV2 = new Vector2();\n    const tempV3 = new Vector3();\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n    parseNode(xml.documentElement, {\n      fill: \"#000\",\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: \"miter\",\n      strokeLineCap: \"butt\",\n      strokeMiterLimit: 4\n    });\n    const data = { paths, xml: xml.documentElement };\n    return data;\n  }\n  static createShapes(shapePath) {\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return { x, y, t: classifyResult.t };\n          }\n        }\n        return null;\n      } else {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          }\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return { x, y, t: t1 };\n      }\n    }\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n      let t;\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n          if (intersection !== null && intersectionsRaw.find(\n            (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON\n          ) === void 0) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n      return intersections;\n    }\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach((path) => {\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach((p) => {\n            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n      if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n        _fillRule = \"nonzero\";\n      }\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach((i2) => {\n        if (i2.identifier === simplePath.identifier) {\n          baseIntersections.push(i2);\n        } else {\n          otherIntersections.push(i2);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x;\n      const stack = [];\n      let i = 0;\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n        i++;\n      }\n      stack.push(simplePath.identifier);\n      if (_fillRule === \"evenodd\") {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else if (_fillRule === \"nonzero\") {\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n        for (let i2 = 0; i2 < stack.length; i2++) {\n          const identifier2 = stack[i2];\n          if (isHole) {\n            lastCWValue = allPaths[identifier2].isCW;\n            isHole = false;\n            isHoleFor = identifier2;\n          } else if (lastCWValue !== allPaths[identifier2].isCW) {\n            lastCWValue = allPaths[identifier2].isCW;\n            isHole = true;\n          }\n        }\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    }\n    let identifier = 0;\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n      for (let i = 0; i < points.length; i++) {\n        const p2 = points[i];\n        if (p2.y > maxY) {\n          maxY = p2.y;\n        }\n        if (p2.y < minY) {\n          minY = p2.y;\n        }\n        if (p2.x > maxX) {\n          maxX = p2.x;\n        }\n        if (p2.x < minX) {\n          minX = p2.x;\n        }\n      }\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n      return {\n        curves: p.curves,\n        points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: identifier++,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);\n    const isAHole = simplePaths.map(\n      (p) => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule)\n    );\n    const shapesToReturn = [];\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier];\n      if (!amIAHole.isHole) {\n        const shape = new Shape();\n        shape.curves = p.curves;\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);\n        holes.forEach((h) => {\n          const hole = simplePaths[h.identifier];\n          const path = new Path();\n          path.curves = hole.curves;\n          shape.holes.push(path);\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    width = width !== void 0 ? width : 1;\n    color = color !== void 0 ? color : \"#000\";\n    lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n    lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n    miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n    minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2)\n      return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0, u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          nextPoint = points[1];\n        } else {\n          nextPoint = void 0;\n        }\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== void 0) {\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1)\n          initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n        if (dot !== 0) {\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case \"bevel\":\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case \"round\":\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                if (style.strokeLineJoin !== \"miter-clip\") {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                if (innerSideModified) {\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n      } else {\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices;\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1)\n        angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        if (joinIsOnLeftSide2) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n      switch (style.strokeLineCap) {\n        case \"round\":\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case \"square\":\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length;\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n        case \"butt\":\n        default:\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points2) {\n      let dupPoints = false;\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints)\n        return points2;\n      const newPoints = [];\n      newPoints.push(points2[0]);\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n          newPoints.push(points2[i]);\n        }\n      }\n      newPoints.push(points2[points2.length - 1]);\n      return newPoints;\n    }\n  }\n}\nexport {\n  SVGLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}