{"ast":null,"code":"import _regeneratorRuntime from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { getNested } from '../utils.js';\nfunction sortingPredicate() {\n  var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'desc';\n  var a = arguments.length > 1 ? arguments[1] : undefined;\n  var b = arguments.length > 2 ? arguments[2] : undefined;\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1];\n  } else {\n    return b[1] - a[1];\n  }\n}\nexport function getFacets(_x, _x2, _x3) {\n  return _getFacets.apply(this, arguments);\n}\nfunction _getFacets() {\n  _getFacets = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(orama, results, facetsConfig) {\n    var facets, allIDs, allDocs, facetKeys, properties, _i, _facetKeys, facet, values, ranges, tmp, _iterator2, _step2, range, allDocsLength, i, doc, _iterator3, _step3, _facet, facetValue, propertyType, _ranges, alreadyInsertedValues, _ranges2, _iterator4, _step4, v, _alreadyInsertedValues, innerType, _iterator5, _step5, _v, _loop, _i2, _facetKeys2;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          facets = {};\n          allIDs = results.map(function (_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 1),\n              id = _ref3[0];\n            return id;\n          });\n          _context2.next = 4;\n          return orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n        case 4:\n          allDocs = _context2.sent;\n          facetKeys = Object.keys(facetsConfig);\n          _context2.next = 8;\n          return orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n        case 8:\n          properties = _context2.sent;\n          for (_i = 0, _facetKeys = facetKeys; _i < _facetKeys.length; _i++) {\n            facet = _facetKeys[_i];\n            values = {}; // Hack to guarantee the same order of ranges as specified by the user\n            // TODO: Revisit this once components land\n            if (properties[facet] === 'number') {\n              ranges = facetsConfig[facet].ranges;\n              tmp = [];\n              _iterator2 = _createForOfIteratorHelper(ranges);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  range = _step2.value;\n                  tmp.push([\"\".concat(range.from, \"-\").concat(range.to), 0]);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              values = Object.fromEntries(tmp);\n            }\n            facets[facet] = {\n              count: 0,\n              values: values\n            };\n          }\n          allDocsLength = allDocs.length;\n          i = 0;\n        case 12:\n          if (!(i < allDocsLength)) {\n            _context2.next = 59;\n            break;\n          }\n          doc = allDocs[i];\n          _iterator3 = _createForOfIteratorHelper(facetKeys);\n          _context2.prev = 15;\n          _iterator3.s();\n        case 17:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 48;\n            break;\n          }\n          _facet = _step3.value;\n          if (!_facet.includes('.')) {\n            _context2.next = 25;\n            break;\n          }\n          _context2.next = 22;\n          return getNested(doc, _facet);\n        case 22:\n          _context2.t0 = _context2.sent;\n          _context2.next = 26;\n          break;\n        case 25:\n          _context2.t0 = doc[_facet];\n        case 26:\n          facetValue = _context2.t0;\n          propertyType = properties[_facet];\n          _context2.t1 = propertyType;\n          _context2.next = _context2.t1 === 'number' ? 31 : _context2.t1 === 'number[]' ? 34 : _context2.t1 === 'boolean' ? 39 : _context2.t1 === 'string' ? 39 : _context2.t1 === 'boolean[]' ? 41 : _context2.t1 === 'string[]' ? 41 : 46;\n          break;\n        case 31:\n          _ranges = facetsConfig[_facet].ranges;\n          calculateNumberFacet(_ranges, facets[_facet].values, facetValue);\n          return _context2.abrupt(\"break\", 46);\n        case 34:\n          alreadyInsertedValues = new Set();\n          _ranges2 = facetsConfig[_facet].ranges;\n          _iterator4 = _createForOfIteratorHelper(facetValue);\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              v = _step4.value;\n              calculateNumberFacet(_ranges2, facets[_facet].values, v, alreadyInsertedValues);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          return _context2.abrupt(\"break\", 46);\n        case 39:\n          calculateBooleanOrStringFacet(facets[_facet].values, facetValue, propertyType);\n          return _context2.abrupt(\"break\", 46);\n        case 41:\n          _alreadyInsertedValues = new Set();\n          innerType = propertyType === 'boolean[]' ? 'boolean' : 'string';\n          _iterator5 = _createForOfIteratorHelper(facetValue);\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              _v = _step5.value;\n              calculateBooleanOrStringFacet(facets[_facet].values, _v, innerType, _alreadyInsertedValues);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          return _context2.abrupt(\"break\", 46);\n        case 46:\n          _context2.next = 17;\n          break;\n        case 48:\n          _context2.next = 53;\n          break;\n        case 50:\n          _context2.prev = 50;\n          _context2.t2 = _context2[\"catch\"](15);\n          _iterator3.e(_context2.t2);\n        case 53:\n          _context2.prev = 53;\n          _iterator3.f();\n          return _context2.finish(53);\n        case 56:\n          i++;\n          _context2.next = 12;\n          break;\n        case 59:\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var facet, _stringFacetDefinitio, _stringFacetDefinitio2, stringFacetDefinition;\n            return _regeneratorRuntime().wrap(function _loop$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  facet = _facetKeys2[_i2];\n                  // Count the number of values for each facet\n                  facets[facet].count = Object.keys(facets[facet].values).length;\n                  // Sort only string-based facets\n                  if (properties[facet] === 'string') {\n                    stringFacetDefinition = facetsConfig;\n                    facets[facet].values = Object.fromEntries(Object.entries(facets[facet].values).sort(function (a, b) {\n                      return sortingPredicate(stringFacetDefinition.sort, a, b);\n                    }).slice((_stringFacetDefinitio = stringFacetDefinition.offset) !== null && _stringFacetDefinitio !== void 0 ? _stringFacetDefinitio : 0, (_stringFacetDefinitio2 = stringFacetDefinition.limit) !== null && _stringFacetDefinitio2 !== void 0 ? _stringFacetDefinitio2 : 10));\n                  }\n                case 3:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _loop);\n          });\n          _i2 = 0, _facetKeys2 = facetKeys;\n        case 61:\n          if (!(_i2 < _facetKeys2.length)) {\n            _context2.next = 66;\n            break;\n          }\n          return _context2.delegateYield(_loop(), \"t3\", 63);\n        case 63:\n          _i2++;\n          _context2.next = 61;\n          break;\n        case 66:\n          return _context2.abrupt(\"return\", facets);\n        case 67:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[15, 50, 53, 56]]);\n  }));\n  return _getFacets.apply(this, arguments);\n}\nfunction calculateNumberFacet(ranges, values, facetValue, alreadyInsertedValues) {\n  var _iterator = _createForOfIteratorHelper(ranges),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var range = _step.value;\n      var value = \"\".concat(range.from, \"-\").concat(range.to);\n      if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n        continue;\n      }\n      if (facetValue >= range.from && facetValue <= range.to) {\n        if (values[value] === undefined) {\n          values[value] = 1;\n        } else {\n          values[value]++;\n          if (alreadyInsertedValues) {\n            alreadyInsertedValues.add(value);\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction calculateBooleanOrStringFacet(values, facetValue, propertyType, alreadyInsertedValues) {\n  var _ref, _values$value;\n  // String or boolean based facets\n  var value = (_ref = facetValue === null || facetValue === void 0 ? void 0 : facetValue.toString()) !== null && _ref !== void 0 ? _ref : propertyType === 'boolean' ? 'false' : '';\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return;\n  }\n  values[value] = ((_values$value = values[value]) !== null && _values$value !== void 0 ? _values$value : 0) + 1;\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value);\n  }\n}","map":{"version":3,"names":["getNested","sortingPredicate","order","arguments","length","undefined","a","b","toLowerCase","getFacets","_x","_x2","_x3","_getFacets","apply","_asyncToGenerator","_regeneratorRuntime","mark","_callee","orama","results","facetsConfig","facets","allIDs","allDocs","facetKeys","properties","_i","_facetKeys","facet","values","ranges","tmp","_iterator2","_step2","range","allDocsLength","i","doc","_iterator3","_step3","_facet","facetValue","propertyType","_ranges","alreadyInsertedValues","_ranges2","_iterator4","_step4","v","_alreadyInsertedValues","innerType","_iterator5","_step5","_v","_loop","_i2","_facetKeys2","wrap","_callee$","_context2","prev","next","map","_ref2","_ref3","_slicedToArray","id","documentsStore","getMultiple","data","docs","sent","Object","keys","index","getSearchablePropertiesWithTypes","_createForOfIteratorHelper","s","n","done","value","push","concat","from","to","err","e","f","fromEntries","count","includes","t0","t1","calculateNumberFacet","abrupt","Set","calculateBooleanOrStringFacet","t2","finish","_stringFacetDefinitio","_stringFacetDefinitio2","stringFacetDefinition","_loop$","_context","entries","sort","slice","offset","limit","stop","delegateYield","_iterator","_step","has","add","_ref","_values$value","toString"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/components/facets.ts"],"sourcesContent":["import type {\n  FacetResult,\n  FacetSorting,\n  FacetsParams,\n  NumberFacetDefinition,\n  Orama,\n  Schema,\n  SearchableValue,\n  StringFacetDefinition,\n  TokenScore,\n} from '../types.js'\nimport { getNested } from '../utils.js'\n\nfunction sortingPredicate(order: FacetSorting = 'desc', a: [string, number], b: [string, number]) {\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1]\n  } else {\n    return b[1] - a[1]\n  }\n}\n\nexport async function getFacets<S extends Schema>(\n  orama: Orama<{ Schema: S }>,\n  results: TokenScore[],\n  facetsConfig: FacetsParams,\n): Promise<FacetResult> {\n  const facets: FacetResult = {}\n  const allIDs = results.map(([id]) => id)\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const facetKeys = Object.keys(facetsConfig!)\n\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n\n  for (const facet of facetKeys) {\n    let values = {}\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const { ranges } = facetsConfig[facet] as NumberFacetDefinition\n      const tmp = []\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0])\n      }\n      values = Object.fromEntries(tmp)\n    }\n\n    facets[facet] = {\n      count: 0,\n      values,\n    }\n  }\n\n  const allDocsLength = allDocs.length\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i]\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? (await getNested<string>(doc!, facet))!\n        : (doc![facet] as SearchableValue)\n\n      const propertyType = properties[facet]\n      switch (propertyType) {\n        case 'number': {\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          calculateNumberFacet(ranges, facets[facet].values, facetValue as number)\n          break\n        }\n        case 'number[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          for (const v of facetValue as Array<number>) {\n            calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues)\n          }\n          break\n        }\n        case 'boolean':\n        case 'string': {\n          calculateBooleanOrStringFacet(facets[facet].values, facetValue as string | boolean, propertyType)\n          break\n        }\n        case 'boolean[]':\n        case 'string[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string'\n          for (const v of facetValue as Array<string | boolean>) {\n            calculateBooleanOrStringFacet(facets[facet].values, v, innerType, alreadyInsertedValues)\n          }\n          break\n        }\n      }\n    }\n  }\n\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length\n\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig as StringFacetDefinition\n\n      facets[facet].values = Object.fromEntries(\n        Object.entries(facets[facet].values)\n          .sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b))\n          .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10),\n      )\n    }\n  }\n\n  return facets\n}\n\nfunction calculateNumberFacet(\n  ranges: NumberFacetDefinition['ranges'],\n  values: Record<string, number>,\n  facetValue: number,\n  alreadyInsertedValues?: Set<string>,\n) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue\n    }\n\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1\n      } else {\n        values[value]++\n\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value)\n        }\n      }\n    }\n  }\n}\n\nfunction calculateBooleanOrStringFacet(\n  values: Record<string, number>,\n  facetValue: string | boolean,\n  propertyType: 'string' | 'boolean',\n  alreadyInsertedValues?: Set<string>,\n) {\n  // String or boolean based facets\n  const value = facetValue?.toString() ?? (propertyType === 'boolean' ? 'false' : '')\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return\n  }\n  values[value] = (values[value] ?? 0) + 1\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}