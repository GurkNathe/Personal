{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, MeshPhongMaterial, Color, Group, Float32BufferAttribute, BufferGeometry, Mesh } from \"three\";\nimport { unzipSync } from \"fflate\";\nclass AMFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    function loadDocument(data2) {\n      let view = new DataView(data2);\n      const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));\n      if (magic === \"PK\") {\n        let zip = null;\n        let file = null;\n        console.log(\"THREE.AMFLoader: Loading Zip\");\n        try {\n          zip = unzipSync(new Uint8Array(data2));\n        } catch (e) {\n          if (e instanceof ReferenceError) {\n            console.log(\"THREE.AMFLoader: fflate missing and file is compressed.\");\n            return null;\n          }\n        }\n        for (file in zip) {\n          if (file.toLowerCase().substr(-4) === \".amf\") {\n            break;\n          }\n        }\n        console.log(\"THREE.AMFLoader: Trying to load file asset: \" + file);\n        view = new DataView(zip[file].buffer);\n      }\n      const fileText = LoaderUtils.decodeText(view);\n      const xmlData2 = new DOMParser().parseFromString(fileText, \"application/xml\");\n      if (xmlData2.documentElement.nodeName.toLowerCase() !== \"amf\") {\n        console.log(\"THREE.AMFLoader: Error loading AMF - no AMF document found.\");\n        return null;\n      }\n      return xmlData2;\n    }\n    function loadDocumentScale(node) {\n      let scale = 1;\n      let unit = \"millimeter\";\n      if (node.documentElement.attributes.unit !== void 0) {\n        unit = node.documentElement.attributes.unit.value.toLowerCase();\n      }\n      const scaleUnits = {\n        millimeter: 1,\n        inch: 25.4,\n        feet: 304.8,\n        meter: 1e3,\n        micron: 1e-3\n      };\n      if (scaleUnits[unit] !== void 0) {\n        scale = scaleUnits[unit];\n      }\n      console.log(\"THREE.AMFLoader: Unit scale: \" + scale);\n      return scale;\n    }\n    function loadMaterials(node) {\n      let matName = \"AMF Material\";\n      const matId = node.attributes.id.textContent;\n      let color = {\n        r: 1,\n        g: 1,\n        b: 1,\n        a: 1\n      };\n      let loadedMaterial = null;\n      for (let i2 = 0; i2 < node.childNodes.length; i2++) {\n        const matChildEl = node.childNodes[i2];\n        if (matChildEl.nodeName === \"metadata\" && matChildEl.attributes.type !== void 0) {\n          if (matChildEl.attributes.type.value === \"name\") {\n            matName = matChildEl.textContent;\n          }\n        } else if (matChildEl.nodeName === \"color\") {\n          color = loadColor(matChildEl);\n        }\n      }\n      loadedMaterial = new MeshPhongMaterial({\n        flatShading: true,\n        color: new Color(color.r, color.g, color.b),\n        name: matName\n      });\n      if (color.a !== 1) {\n        loadedMaterial.transparent = true;\n        loadedMaterial.opacity = color.a;\n      }\n      return {\n        id: matId,\n        material: loadedMaterial\n      };\n    }\n    function loadColor(node) {\n      const color = {\n        r: 1,\n        g: 1,\n        b: 1,\n        a: 1\n      };\n      for (let i2 = 0; i2 < node.childNodes.length; i2++) {\n        const matColor = node.childNodes[i2];\n        if (matColor.nodeName === \"r\") {\n          color.r = matColor.textContent;\n        } else if (matColor.nodeName === \"g\") {\n          color.g = matColor.textContent;\n        } else if (matColor.nodeName === \"b\") {\n          color.b = matColor.textContent;\n        } else if (matColor.nodeName === \"a\") {\n          color.a = matColor.textContent;\n        }\n      }\n      return color;\n    }\n    function loadMeshVolume(node) {\n      const volume = {\n        name: \"\",\n        triangles: [],\n        materialid: null\n      };\n      let currVolumeNode = node.firstElementChild;\n      if (node.attributes.materialid !== void 0) {\n        volume.materialId = node.attributes.materialid.nodeValue;\n      }\n      while (currVolumeNode) {\n        if (currVolumeNode.nodeName === \"metadata\") {\n          if (currVolumeNode.attributes.type !== void 0) {\n            if (currVolumeNode.attributes.type.value === \"name\") {\n              volume.name = currVolumeNode.textContent;\n            }\n          }\n        } else if (currVolumeNode.nodeName === \"triangle\") {\n          const v1 = currVolumeNode.getElementsByTagName(\"v1\")[0].textContent;\n          const v2 = currVolumeNode.getElementsByTagName(\"v2\")[0].textContent;\n          const v3 = currVolumeNode.getElementsByTagName(\"v3\")[0].textContent;\n          volume.triangles.push(v1, v2, v3);\n        }\n        currVolumeNode = currVolumeNode.nextElementSibling;\n      }\n      return volume;\n    }\n    function loadMeshVertices(node) {\n      const vertArray = [];\n      const normalArray = [];\n      let currVerticesNode = node.firstElementChild;\n      while (currVerticesNode) {\n        if (currVerticesNode.nodeName === \"vertex\") {\n          let vNode = currVerticesNode.firstElementChild;\n          while (vNode) {\n            if (vNode.nodeName === \"coordinates\") {\n              const x = vNode.getElementsByTagName(\"x\")[0].textContent;\n              const y = vNode.getElementsByTagName(\"y\")[0].textContent;\n              const z = vNode.getElementsByTagName(\"z\")[0].textContent;\n              vertArray.push(x, y, z);\n            } else if (vNode.nodeName === \"normal\") {\n              const nx = vNode.getElementsByTagName(\"nx\")[0].textContent;\n              const ny = vNode.getElementsByTagName(\"ny\")[0].textContent;\n              const nz = vNode.getElementsByTagName(\"nz\")[0].textContent;\n              normalArray.push(nx, ny, nz);\n            }\n            vNode = vNode.nextElementSibling;\n          }\n        }\n        currVerticesNode = currVerticesNode.nextElementSibling;\n      }\n      return {\n        vertices: vertArray,\n        normals: normalArray\n      };\n    }\n    function loadObject(node) {\n      const objId = node.attributes.id.textContent;\n      const loadedObject = {\n        name: \"amfobject\",\n        meshes: []\n      };\n      let currColor = null;\n      let currObjNode = node.firstElementChild;\n      while (currObjNode) {\n        if (currObjNode.nodeName === \"metadata\") {\n          if (currObjNode.attributes.type !== void 0) {\n            if (currObjNode.attributes.type.value === \"name\") {\n              loadedObject.name = currObjNode.textContent;\n            }\n          }\n        } else if (currObjNode.nodeName === \"color\") {\n          currColor = loadColor(currObjNode);\n        } else if (currObjNode.nodeName === \"mesh\") {\n          let currMeshNode = currObjNode.firstElementChild;\n          const mesh = {\n            vertices: [],\n            normals: [],\n            volumes: [],\n            color: currColor\n          };\n          while (currMeshNode) {\n            if (currMeshNode.nodeName === \"vertices\") {\n              const loadedVertices = loadMeshVertices(currMeshNode);\n              mesh.normals = mesh.normals.concat(loadedVertices.normals);\n              mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);\n            } else if (currMeshNode.nodeName === \"volume\") {\n              mesh.volumes.push(loadMeshVolume(currMeshNode));\n            }\n            currMeshNode = currMeshNode.nextElementSibling;\n          }\n          loadedObject.meshes.push(mesh);\n        }\n        currObjNode = currObjNode.nextElementSibling;\n      }\n      return {\n        id: objId,\n        obj: loadedObject\n      };\n    }\n    const xmlData = loadDocument(data);\n    let amfName = \"\";\n    let amfAuthor = \"\";\n    const amfScale = loadDocumentScale(xmlData);\n    const amfMaterials = {};\n    const amfObjects = {};\n    const childNodes = xmlData.documentElement.childNodes;\n    let i, j;\n    for (i = 0; i < childNodes.length; i++) {\n      const child = childNodes[i];\n      if (child.nodeName === \"metadata\") {\n        if (child.attributes.type !== void 0) {\n          if (child.attributes.type.value === \"name\") {\n            amfName = child.textContent;\n          } else if (child.attributes.type.value === \"author\") {\n            amfAuthor = child.textContent;\n          }\n        }\n      } else if (child.nodeName === \"material\") {\n        const loadedMaterial = loadMaterials(child);\n        amfMaterials[loadedMaterial.id] = loadedMaterial.material;\n      } else if (child.nodeName === \"object\") {\n        const loadedObject = loadObject(child);\n        amfObjects[loadedObject.id] = loadedObject.obj;\n      }\n    }\n    const sceneObject = new Group();\n    const defaultMaterial = new MeshPhongMaterial({\n      color: 11184895,\n      flatShading: true\n    });\n    sceneObject.name = amfName;\n    sceneObject.userData.author = amfAuthor;\n    sceneObject.userData.loader = \"AMF\";\n    for (const id in amfObjects) {\n      const part = amfObjects[id];\n      const meshes = part.meshes;\n      const newObject = new Group();\n      newObject.name = part.name || \"\";\n      for (i = 0; i < meshes.length; i++) {\n        let objDefaultMaterial = defaultMaterial;\n        const mesh = meshes[i];\n        const vertices = new Float32BufferAttribute(mesh.vertices, 3);\n        let normals = null;\n        if (mesh.normals.length) {\n          normals = new Float32BufferAttribute(mesh.normals, 3);\n        }\n        if (mesh.color) {\n          const color = mesh.color;\n          objDefaultMaterial = defaultMaterial.clone();\n          objDefaultMaterial.color = new Color(color.r, color.g, color.b);\n          if (color.a !== 1) {\n            objDefaultMaterial.transparent = true;\n            objDefaultMaterial.opacity = color.a;\n          }\n        }\n        const volumes = mesh.volumes;\n        for (j = 0; j < volumes.length; j++) {\n          const volume = volumes[j];\n          const newGeometry = new BufferGeometry();\n          let material = objDefaultMaterial;\n          newGeometry.setIndex(volume.triangles);\n          newGeometry.setAttribute(\"position\", vertices.clone());\n          if (normals) {\n            newGeometry.setAttribute(\"normal\", normals.clone());\n          }\n          if (amfMaterials[volume.materialId] !== void 0) {\n            material = amfMaterials[volume.materialId];\n          }\n          newGeometry.scale(amfScale, amfScale, amfScale);\n          newObject.add(new Mesh(newGeometry, material.clone()));\n        }\n      }\n      sceneObject.add(newObject);\n    }\n    return sceneObject;\n  }\n}\nexport { AMFLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","MeshPhongMaterial","Color","Group","Float32BufferAttribute","BufferGeometry","Mesh","unzipSync","AMFLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","loadDocument","data2","view","DataView","magic","String","fromCharCode","getUint8","zip","file","log","Uint8Array","ReferenceError","toLowerCase","substr","buffer","fileText","decodeText","xmlData2","DOMParser","parseFromString","documentElement","nodeName","loadDocumentScale","node","scale","unit","attributes","value","scaleUnits","millimeter","inch","feet","meter","micron","loadMaterials","matName","matId","id","textContent","color","r","g","b","a","loadedMaterial","i2","childNodes","length","matChildEl","type","loadColor","flatShading","name","transparent","opacity","material","matColor","loadMeshVolume","volume","triangles","materialid","currVolumeNode","firstElementChild","materialId","nodeValue","v1","getElementsByTagName","v2","v3","push","nextElementSibling","loadMeshVertices","vertArray","normalArray","currVerticesNode","vNode","x","y","z","nx","ny","nz","vertices","normals","loadObject","objId","loadedObject","meshes","currColor","currObjNode","currMeshNode","mesh","volumes","loadedVertices","concat","obj","xmlData","amfName","amfAuthor","amfScale","amfMaterials","amfObjects","i","j","child","sceneObject","defaultMaterial","userData","author","part","newObject","objDefaultMaterial","clone","newGeometry","setIndex","setAttribute","add"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/AMFLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, MeshPhongMaterial, Color, Group, Float32BufferAttribute, BufferGeometry, Mesh } from \"three\";\nimport { unzipSync } from \"fflate\";\nclass AMFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data) {\n    function loadDocument(data2) {\n      let view = new DataView(data2);\n      const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));\n      if (magic === \"PK\") {\n        let zip = null;\n        let file = null;\n        console.log(\"THREE.AMFLoader: Loading Zip\");\n        try {\n          zip = unzipSync(new Uint8Array(data2));\n        } catch (e) {\n          if (e instanceof ReferenceError) {\n            console.log(\"THREE.AMFLoader: fflate missing and file is compressed.\");\n            return null;\n          }\n        }\n        for (file in zip) {\n          if (file.toLowerCase().substr(-4) === \".amf\") {\n            break;\n          }\n        }\n        console.log(\"THREE.AMFLoader: Trying to load file asset: \" + file);\n        view = new DataView(zip[file].buffer);\n      }\n      const fileText = LoaderUtils.decodeText(view);\n      const xmlData2 = new DOMParser().parseFromString(fileText, \"application/xml\");\n      if (xmlData2.documentElement.nodeName.toLowerCase() !== \"amf\") {\n        console.log(\"THREE.AMFLoader: Error loading AMF - no AMF document found.\");\n        return null;\n      }\n      return xmlData2;\n    }\n    function loadDocumentScale(node) {\n      let scale = 1;\n      let unit = \"millimeter\";\n      if (node.documentElement.attributes.unit !== void 0) {\n        unit = node.documentElement.attributes.unit.value.toLowerCase();\n      }\n      const scaleUnits = {\n        millimeter: 1,\n        inch: 25.4,\n        feet: 304.8,\n        meter: 1e3,\n        micron: 1e-3\n      };\n      if (scaleUnits[unit] !== void 0) {\n        scale = scaleUnits[unit];\n      }\n      console.log(\"THREE.AMFLoader: Unit scale: \" + scale);\n      return scale;\n    }\n    function loadMaterials(node) {\n      let matName = \"AMF Material\";\n      const matId = node.attributes.id.textContent;\n      let color = { r: 1, g: 1, b: 1, a: 1 };\n      let loadedMaterial = null;\n      for (let i2 = 0; i2 < node.childNodes.length; i2++) {\n        const matChildEl = node.childNodes[i2];\n        if (matChildEl.nodeName === \"metadata\" && matChildEl.attributes.type !== void 0) {\n          if (matChildEl.attributes.type.value === \"name\") {\n            matName = matChildEl.textContent;\n          }\n        } else if (matChildEl.nodeName === \"color\") {\n          color = loadColor(matChildEl);\n        }\n      }\n      loadedMaterial = new MeshPhongMaterial({\n        flatShading: true,\n        color: new Color(color.r, color.g, color.b),\n        name: matName\n      });\n      if (color.a !== 1) {\n        loadedMaterial.transparent = true;\n        loadedMaterial.opacity = color.a;\n      }\n      return { id: matId, material: loadedMaterial };\n    }\n    function loadColor(node) {\n      const color = { r: 1, g: 1, b: 1, a: 1 };\n      for (let i2 = 0; i2 < node.childNodes.length; i2++) {\n        const matColor = node.childNodes[i2];\n        if (matColor.nodeName === \"r\") {\n          color.r = matColor.textContent;\n        } else if (matColor.nodeName === \"g\") {\n          color.g = matColor.textContent;\n        } else if (matColor.nodeName === \"b\") {\n          color.b = matColor.textContent;\n        } else if (matColor.nodeName === \"a\") {\n          color.a = matColor.textContent;\n        }\n      }\n      return color;\n    }\n    function loadMeshVolume(node) {\n      const volume = { name: \"\", triangles: [], materialid: null };\n      let currVolumeNode = node.firstElementChild;\n      if (node.attributes.materialid !== void 0) {\n        volume.materialId = node.attributes.materialid.nodeValue;\n      }\n      while (currVolumeNode) {\n        if (currVolumeNode.nodeName === \"metadata\") {\n          if (currVolumeNode.attributes.type !== void 0) {\n            if (currVolumeNode.attributes.type.value === \"name\") {\n              volume.name = currVolumeNode.textContent;\n            }\n          }\n        } else if (currVolumeNode.nodeName === \"triangle\") {\n          const v1 = currVolumeNode.getElementsByTagName(\"v1\")[0].textContent;\n          const v2 = currVolumeNode.getElementsByTagName(\"v2\")[0].textContent;\n          const v3 = currVolumeNode.getElementsByTagName(\"v3\")[0].textContent;\n          volume.triangles.push(v1, v2, v3);\n        }\n        currVolumeNode = currVolumeNode.nextElementSibling;\n      }\n      return volume;\n    }\n    function loadMeshVertices(node) {\n      const vertArray = [];\n      const normalArray = [];\n      let currVerticesNode = node.firstElementChild;\n      while (currVerticesNode) {\n        if (currVerticesNode.nodeName === \"vertex\") {\n          let vNode = currVerticesNode.firstElementChild;\n          while (vNode) {\n            if (vNode.nodeName === \"coordinates\") {\n              const x = vNode.getElementsByTagName(\"x\")[0].textContent;\n              const y = vNode.getElementsByTagName(\"y\")[0].textContent;\n              const z = vNode.getElementsByTagName(\"z\")[0].textContent;\n              vertArray.push(x, y, z);\n            } else if (vNode.nodeName === \"normal\") {\n              const nx = vNode.getElementsByTagName(\"nx\")[0].textContent;\n              const ny = vNode.getElementsByTagName(\"ny\")[0].textContent;\n              const nz = vNode.getElementsByTagName(\"nz\")[0].textContent;\n              normalArray.push(nx, ny, nz);\n            }\n            vNode = vNode.nextElementSibling;\n          }\n        }\n        currVerticesNode = currVerticesNode.nextElementSibling;\n      }\n      return { vertices: vertArray, normals: normalArray };\n    }\n    function loadObject(node) {\n      const objId = node.attributes.id.textContent;\n      const loadedObject = { name: \"amfobject\", meshes: [] };\n      let currColor = null;\n      let currObjNode = node.firstElementChild;\n      while (currObjNode) {\n        if (currObjNode.nodeName === \"metadata\") {\n          if (currObjNode.attributes.type !== void 0) {\n            if (currObjNode.attributes.type.value === \"name\") {\n              loadedObject.name = currObjNode.textContent;\n            }\n          }\n        } else if (currObjNode.nodeName === \"color\") {\n          currColor = loadColor(currObjNode);\n        } else if (currObjNode.nodeName === \"mesh\") {\n          let currMeshNode = currObjNode.firstElementChild;\n          const mesh = { vertices: [], normals: [], volumes: [], color: currColor };\n          while (currMeshNode) {\n            if (currMeshNode.nodeName === \"vertices\") {\n              const loadedVertices = loadMeshVertices(currMeshNode);\n              mesh.normals = mesh.normals.concat(loadedVertices.normals);\n              mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);\n            } else if (currMeshNode.nodeName === \"volume\") {\n              mesh.volumes.push(loadMeshVolume(currMeshNode));\n            }\n            currMeshNode = currMeshNode.nextElementSibling;\n          }\n          loadedObject.meshes.push(mesh);\n        }\n        currObjNode = currObjNode.nextElementSibling;\n      }\n      return { id: objId, obj: loadedObject };\n    }\n    const xmlData = loadDocument(data);\n    let amfName = \"\";\n    let amfAuthor = \"\";\n    const amfScale = loadDocumentScale(xmlData);\n    const amfMaterials = {};\n    const amfObjects = {};\n    const childNodes = xmlData.documentElement.childNodes;\n    let i, j;\n    for (i = 0; i < childNodes.length; i++) {\n      const child = childNodes[i];\n      if (child.nodeName === \"metadata\") {\n        if (child.attributes.type !== void 0) {\n          if (child.attributes.type.value === \"name\") {\n            amfName = child.textContent;\n          } else if (child.attributes.type.value === \"author\") {\n            amfAuthor = child.textContent;\n          }\n        }\n      } else if (child.nodeName === \"material\") {\n        const loadedMaterial = loadMaterials(child);\n        amfMaterials[loadedMaterial.id] = loadedMaterial.material;\n      } else if (child.nodeName === \"object\") {\n        const loadedObject = loadObject(child);\n        amfObjects[loadedObject.id] = loadedObject.obj;\n      }\n    }\n    const sceneObject = new Group();\n    const defaultMaterial = new MeshPhongMaterial({ color: 11184895, flatShading: true });\n    sceneObject.name = amfName;\n    sceneObject.userData.author = amfAuthor;\n    sceneObject.userData.loader = \"AMF\";\n    for (const id in amfObjects) {\n      const part = amfObjects[id];\n      const meshes = part.meshes;\n      const newObject = new Group();\n      newObject.name = part.name || \"\";\n      for (i = 0; i < meshes.length; i++) {\n        let objDefaultMaterial = defaultMaterial;\n        const mesh = meshes[i];\n        const vertices = new Float32BufferAttribute(mesh.vertices, 3);\n        let normals = null;\n        if (mesh.normals.length) {\n          normals = new Float32BufferAttribute(mesh.normals, 3);\n        }\n        if (mesh.color) {\n          const color = mesh.color;\n          objDefaultMaterial = defaultMaterial.clone();\n          objDefaultMaterial.color = new Color(color.r, color.g, color.b);\n          if (color.a !== 1) {\n            objDefaultMaterial.transparent = true;\n            objDefaultMaterial.opacity = color.a;\n          }\n        }\n        const volumes = mesh.volumes;\n        for (j = 0; j < volumes.length; j++) {\n          const volume = volumes[j];\n          const newGeometry = new BufferGeometry();\n          let material = objDefaultMaterial;\n          newGeometry.setIndex(volume.triangles);\n          newGeometry.setAttribute(\"position\", vertices.clone());\n          if (normals) {\n            newGeometry.setAttribute(\"normal\", normals.clone());\n          }\n          if (amfMaterials[volume.materialId] !== void 0) {\n            material = amfMaterials[volume.materialId];\n          }\n          newGeometry.scale(amfScale, amfScale, amfScale);\n          newObject.add(new Mesh(newGeometry, material.clone()));\n        }\n      }\n      sceneObject.add(newObject);\n    }\n    return sceneObject;\n  }\n}\nexport {\n  AMFLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}