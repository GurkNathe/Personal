{"ast":null,"code":"import { createError } from '../errors.js';\nimport { isVectorType } from './defaults.js';\nimport { getInternalDocumentId } from './internal-document-id-store.js';\nimport { safeArrayPush } from \"../utils.js\";\nfunction innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {\n  const sorter = {\n    language: orama.tokenizer.language,\n    sharedInternalDocumentStore,\n    enabled: true,\n    isSorted: true,\n    sortableProperties: [],\n    sortablePropertiesWithTypes: {},\n    sorts: {}\n  };\n  for (const [prop, type] of Object.entries(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n    if (sortableDeniedProperties.includes(path)) {\n      continue;\n    }\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path);\n      safeArrayPush(sorter.sortableProperties, ret.sortableProperties);\n      sorter.sorts = {\n        ...sorter.sorts,\n        ...ret.sorts\n      };\n      sorter.sortablePropertiesWithTypes = {\n        ...sorter.sortablePropertiesWithTypes,\n        ...ret.sortablePropertiesWithTypes\n      };\n      continue;\n    }\n    if (!isVectorType(type)) {\n      switch (type) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n          sorter.sortableProperties.push(path);\n          sorter.sortablePropertiesWithTypes[path] = type;\n          sorter.sorts[path] = {\n            docs: new Map(),\n            orderedDocsToRemove: new Map(),\n            orderedDocs: [],\n            type: type\n          };\n          break;\n        case 'enum':\n          continue;\n        case 'enum[]':\n        case 'boolean[]':\n        case 'number[]':\n        case 'string[]':\n          continue;\n        default:\n          throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n      }\n    }\n  }\n  return sorter;\n}\nasync function create(orama, sharedInternalDocumentStore, schema, config) {\n  const isSortEnabled = (config === null || config === void 0 ? void 0 : config.enabled) !== false;\n  if (!isSortEnabled) {\n    return {\n      disabled: true\n    };\n  }\n  return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '');\n}\nasync function insert(sorter, prop, id, value) {\n  if (!sorter.enabled) {\n    return;\n  }\n  sorter.isSorted = false;\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);\n  const s = sorter.sorts[prop];\n  s.docs.set(internalId, s.orderedDocs.length);\n  s.orderedDocs.push([internalId, value]);\n}\nfunction ensureIsSorted(sorter) {\n  if (sorter.isSorted) {\n    return;\n  }\n  if (!sorter.enabled) {\n    return;\n  }\n  const properties = Object.keys(sorter.sorts);\n  for (const prop of properties) {\n    ensurePropertyIsSorted(sorter, prop);\n  }\n  sorter.isSorted = true;\n}\nfunction stringSort(language, value, d) {\n  return value[1].localeCompare(d[1], language);\n}\nfunction numberSort(value, d) {\n  return value[1] - d[1];\n}\nfunction booleanSort(value, d) {\n  return d[1] ? -1 : 1;\n}\nfunction ensurePropertyIsSorted(sorter, prop) {\n  const s = sorter.sorts[prop];\n  let predicate;\n  switch (s.type) {\n    case 'string':\n      predicate = stringSort.bind(null, sorter.language);\n      break;\n    case 'number':\n      predicate = numberSort.bind(null);\n      break;\n    case 'boolean':\n      predicate = booleanSort.bind(null);\n      break;\n  }\n  s.orderedDocs.sort(predicate);\n  // Increment position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length;\n  for (let i = 0; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0];\n    s.docs.set(docId, i);\n  }\n}\nfunction ensureOrderedDocsAreDeleted(sorter) {\n  const properties = Object.keys(sorter.sorts);\n  for (const prop of properties) {\n    ensureOrderedDocsAreDeletedByProperty(sorter, prop);\n  }\n}\nfunction ensureOrderedDocsAreDeletedByProperty(sorter, prop) {\n  const s = sorter.sorts[prop];\n  if (!s.orderedDocsToRemove.size) return;\n  s.orderedDocs = s.orderedDocs.filter(doc => !s.orderedDocsToRemove.has(doc[0]));\n  s.orderedDocsToRemove.clear();\n}\nasync function remove(sorter, prop, id) {\n  if (!sorter.enabled) {\n    return;\n  }\n  const s = sorter.sorts[prop];\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);\n  const index = s.docs.get(internalId);\n  if (!index) return;\n  s.docs.delete(internalId);\n  s.orderedDocsToRemove.set(internalId, true);\n}\nasync function sortBy(sorter, docIds, by) {\n  if (!sorter.enabled) {\n    throw createError('SORT_DISABLED');\n  }\n  const property = by.property;\n  const isDesc = by.order === 'DESC';\n  const s = sorter.sorts[property];\n  if (!s) {\n    throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '));\n  }\n  ensureOrderedDocsAreDeletedByProperty(sorter, property);\n  ensureIsSorted(sorter);\n  docIds.sort((a, b) => {\n    // This sort algorithm works leveraging on\n    // that s.docs is a map of docId -> position\n    // If a document is not indexed, it will be not present in the map\n    const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]));\n    const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]));\n    const isAIndexed = typeof indexOfA !== 'undefined';\n    const isBIndexed = typeof indexOfB !== 'undefined';\n    if (!isAIndexed && !isBIndexed) {\n      return 0;\n    }\n    // unindexed documents are always at the end\n    if (!isAIndexed) {\n      return 1;\n    }\n    if (!isBIndexed) {\n      return -1;\n    }\n    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;\n  });\n  return docIds;\n}\nasync function getSortableProperties(sorter) {\n  if (!sorter.enabled) {\n    return [];\n  }\n  return sorter.sortableProperties;\n}\nasync function getSortablePropertiesWithTypes(sorter) {\n  if (!sorter.enabled) {\n    return {};\n  }\n  return sorter.sortablePropertiesWithTypes;\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n  const rawDocument = raw;\n  if (!rawDocument.enabled) {\n    return {\n      enabled: false\n    };\n  }\n  const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop) => {\n    const {\n      docs,\n      orderedDocs,\n      type\n    } = rawDocument.sorts[prop];\n    acc[prop] = {\n      docs: new Map(Object.entries(docs).map(([k, v]) => [+k, v])),\n      orderedDocsToRemove: new Map(),\n      orderedDocs,\n      type\n    };\n    return acc;\n  }, {});\n  return {\n    sharedInternalDocumentStore,\n    language: rawDocument.language,\n    sortableProperties: rawDocument.sortableProperties,\n    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n    sorts,\n    enabled: true,\n    isSorted: rawDocument.isSorted\n  };\n}\nexport async function save(sorter) {\n  if (!sorter.enabled) {\n    return {\n      enabled: false\n    };\n  }\n  ensureOrderedDocsAreDeleted(sorter);\n  ensureIsSorted(sorter);\n  const sorts = Object.keys(sorter.sorts).reduce((acc, prop) => {\n    const {\n      docs,\n      orderedDocs,\n      type\n    } = sorter.sorts[prop];\n    acc[prop] = {\n      docs: Object.fromEntries(docs.entries()),\n      orderedDocs,\n      type\n    };\n    return acc;\n  }, {});\n  return {\n    language: sorter.language,\n    sortableProperties: sorter.sortableProperties,\n    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n    sorts,\n    enabled: sorter.enabled,\n    isSorted: sorter.isSorted\n  };\n}\nexport async function createSorter() {\n  return {\n    create,\n    insert,\n    remove,\n    save,\n    load,\n    sortBy,\n    getSortableProperties,\n    getSortablePropertiesWithTypes\n  };\n}","map":{"version":3,"names":["createError","isVectorType","getInternalDocumentId","safeArrayPush","innerCreate","orama","sharedInternalDocumentStore","schema","sortableDeniedProperties","prefix","sorter","language","tokenizer","enabled","isSorted","sortableProperties","sortablePropertiesWithTypes","sorts","prop","type","Object","entries","path","includes","Array","isArray","ret","push","docs","Map","orderedDocsToRemove","orderedDocs","create","config","isSortEnabled","disabled","unsortableProperties","insert","id","value","internalId","s","set","length","ensureIsSorted","properties","keys","ensurePropertyIsSorted","stringSort","d","localeCompare","numberSort","booleanSort","predicate","bind","sort","orderedDocsLength","i","docId","ensureOrderedDocsAreDeleted","ensureOrderedDocsAreDeletedByProperty","size","filter","doc","has","clear","remove","index","get","delete","sortBy","docIds","by","property","isDesc","order","join","a","b","indexOfA","indexOfB","isAIndexed","isBIndexed","getSortableProperties","getSortablePropertiesWithTypes","load","raw","rawDocument","reduce","acc","map","k","v","save","fromEntries","createSorter"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/sorter.ts"],"sourcesContent":["import { createError } from '../errors.js';\nimport { AnyOrama, AnySorterStore, ISorter, SearchableType, SortType, SortValue, SorterConfig, SorterParams } from '../types.js';\nimport { isVectorType } from './defaults.js';\nimport {\n  DocumentID,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n  getInternalDocumentId,\n} from './internal-document-id-store.js';\nimport { safeArrayPush } from \"../utils.js\";\n\ninterface PropertySort<K> {\n  docs: Map<InternalDocumentID, number>\n  orderedDocs: [InternalDocumentID, K][]\n  orderedDocsToRemove: Map<InternalDocumentID, boolean>\n  type: SortType\n}\n\ntype SerializablePropertySort<K> = Omit<PropertySort<K>, 'orderedDocsToRemove' | 'docs'> & {\n  docs: Record<string, number>\n}\n\nexport interface Sorter extends AnySorterStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  isSorted: boolean\n  language: string\n  enabled: boolean\n  sortableProperties: string[]\n  sortablePropertiesWithTypes: Record<string, SortType>\n  sorts: Record<string, PropertySort<number | string | boolean>>\n}\n\nfunction innerCreate<T extends AnyOrama>(\n  orama: T,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: T['schema'],\n  sortableDeniedProperties: string[],\n  prefix: string,\n): Sorter {\n  const sorter: Sorter = {\n    language: orama.tokenizer.language,\n    sharedInternalDocumentStore,\n    enabled: true,\n    isSorted: true,\n    sortableProperties: [],\n    sortablePropertiesWithTypes: {},\n    sorts: {},\n  }\n\n  for (const [prop, type] of Object.entries<SearchableType>(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (sortableDeniedProperties.includes(path)) {\n      continue\n    }\n\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path)\n      safeArrayPush(sorter.sortableProperties, ret.sortableProperties);\n      sorter.sorts = {\n        ...sorter.sorts,\n        ...ret.sorts,\n      }\n      sorter.sortablePropertiesWithTypes = {\n        ...sorter.sortablePropertiesWithTypes,\n        ...ret.sortablePropertiesWithTypes,\n      }\n      continue\n    }\n\n    if (!isVectorType(type)) {\n      switch (type) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n          sorter.sortableProperties.push(path)\n          sorter.sortablePropertiesWithTypes[path] = type\n          sorter.sorts[path] = {\n            docs: new Map(),\n            orderedDocsToRemove: new Map(),\n            orderedDocs: [],\n            type: type,\n          }\n          break\n        case 'enum':\n          // We don't allow to sort by enums\n          continue\n        case 'enum[]':\n        case 'boolean[]':\n        case 'number[]':\n        case 'string[]':\n          // We don't allow to sort by arrays\n          continue\n        default:\n          throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path)\n      }\n    }\n  }\n\n  return sorter\n}\n\nasync function create<T extends AnyOrama>(\n  orama: T,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: T['schema'],\n  config?: SorterConfig,\n): Promise<Sorter> {\n  const isSortEnabled = config?.enabled !== false\n  if (!isSortEnabled) {\n    return {\n      disabled: true,\n    } as unknown as Sorter\n  }\n  return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '')\n}\n\nasync function insert(sorter: Sorter, prop: string, id: DocumentID, value: SortValue): Promise<void> {\n  if (!sorter.enabled) {\n    return\n  }\n\n  sorter.isSorted = false\n\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id)\n  const s = sorter.sorts[prop]\n\n  s.docs.set(internalId, s.orderedDocs.length)\n  s.orderedDocs.push([internalId, value])\n}\n\nfunction ensureIsSorted(sorter: Sorter): void {\n  if (sorter.isSorted) {\n    return\n  }\n\n  if (!sorter.enabled) {\n    return\n  }\n\n  const properties = Object.keys(sorter.sorts)\n  for (const prop of properties) {\n    ensurePropertyIsSorted(sorter, prop)\n  }\n\n  sorter.isSorted = true\n}\n\nfunction stringSort(\n  language: string | undefined,\n  value: [InternalDocumentID, SortValue],\n  d: [InternalDocumentID, SortValue],\n): number {\n  return (value[1] as string).localeCompare(d[1] as string, language)\n}\n\nfunction numberSort(value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]): number {\n  return (value[1] as number) - (d[1] as number)\n}\n\nfunction booleanSort(value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]): number {\n  return (d[1] as boolean) ? -1 : 1\n}\n\nfunction ensurePropertyIsSorted(sorter: Sorter, prop: string): void {\n  const s = sorter.sorts[prop]\n\n  let predicate: (value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]) => number\n  switch (s.type) {\n    case 'string':\n      predicate = stringSort.bind(null, sorter.language)\n      break\n    case 'number':\n      predicate = numberSort.bind(null)\n      break\n    case 'boolean':\n      predicate = booleanSort.bind(null)\n      break\n  }\n\n  s.orderedDocs.sort(predicate)\n\n  // Increment position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length\n  for (let i = 0; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0]\n    s.docs.set(docId, i)\n  }\n}\n\nfunction ensureOrderedDocsAreDeleted(sorter: Sorter): void {\n  const properties = Object.keys(sorter.sorts)\n  for (const prop of properties) {\n    ensureOrderedDocsAreDeletedByProperty(sorter, prop)\n  }\n}\n\nfunction ensureOrderedDocsAreDeletedByProperty(sorter: Sorter, prop: string): void {\n  const s = sorter.sorts[prop]\n\n  if (!s.orderedDocsToRemove.size) return\n\n  s.orderedDocs = s.orderedDocs.filter(doc => !s.orderedDocsToRemove.has(doc[0]))\n  s.orderedDocsToRemove.clear()\n}\n\nasync function remove(sorter: Sorter, prop: string, id: DocumentID) {\n  if (!sorter.enabled) {\n    return\n  }\n  const s = sorter.sorts[prop] as PropertySort<SortValue>\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id)\n\n  const index = s.docs.get(internalId)\n\n  if (!index) return\n\n  s.docs.delete(internalId)\n  s.orderedDocsToRemove.set(internalId, true)\n}\n\nasync function sortBy<T extends AnyOrama>(\n  sorter: Sorter,\n  docIds: [DocumentID, number][],\n  by: SorterParams<T>,\n): Promise<[DocumentID, number][]> {\n  if (!sorter.enabled) {\n    throw createError('SORT_DISABLED')\n  }\n\n  const property = by.property\n  const isDesc = by.order === 'DESC'\n\n  const s = sorter.sorts[property]\n  if (!s) {\n    throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '))\n  }\n\n  ensureOrderedDocsAreDeletedByProperty(sorter, property)\n  ensureIsSorted(sorter)\n\n  docIds.sort((a, b) => {\n    // This sort algorithm works leveraging on\n    // that s.docs is a map of docId -> position\n    // If a document is not indexed, it will be not present in the map\n    const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]))\n    const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]))\n    const isAIndexed = typeof indexOfA !== 'undefined'\n    const isBIndexed = typeof indexOfB !== 'undefined'\n\n    if (!isAIndexed && !isBIndexed) {\n      return 0\n    }\n    // unindexed documents are always at the end\n    if (!isAIndexed) {\n      return 1\n    }\n    if (!isBIndexed) {\n      return -1\n    }\n\n    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB\n  })\n\n  return docIds\n}\n\nasync function getSortableProperties(sorter: Sorter): Promise<string[]> {\n  if (!sorter.enabled) {\n    return []\n  }\n\n  return sorter.sortableProperties\n}\n\nasync function getSortablePropertiesWithTypes(sorter: Sorter): Promise<Record<string, SortType>> {\n  if (!sorter.enabled) {\n    return {}\n  }\n\n  return sorter.sortablePropertiesWithTypes\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Sorter> {\n  const rawDocument = raw as Omit<Sorter, 'sorts'> & {\n    sorts: Record<string, SerializablePropertySort<string | number | boolean>>\n  }\n  if (!rawDocument.enabled) {\n    return {\n      enabled: false,\n    } as unknown as Sorter\n  }\n\n  const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop) => {\n    const { docs, orderedDocs, type } = rawDocument.sorts[prop]\n\n    acc[prop] = {\n      docs: new Map(Object.entries(docs).map(([k, v]) => [+k, v])),\n      orderedDocsToRemove: new Map(),\n      orderedDocs,\n      type,\n    }\n\n    return acc\n  }, {} as Record<string, PropertySort<string | number | boolean>>)\n\n  return {\n    sharedInternalDocumentStore,\n    language: rawDocument.language,\n    sortableProperties: rawDocument.sortableProperties,\n    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n    sorts,\n    enabled: true,\n    isSorted: rawDocument.isSorted,\n  }\n}\n\nexport async function save<R = unknown>(sorter: Sorter): Promise<R> {\n  if (!sorter.enabled) {\n    return {\n      enabled: false,\n    } as unknown as R\n  }\n\n  ensureOrderedDocsAreDeleted(sorter)\n  ensureIsSorted(sorter)\n\n  const sorts = Object.keys(sorter.sorts).reduce((acc, prop) => {\n    const { docs, orderedDocs, type } = sorter.sorts[prop]\n\n    acc[prop] = {\n      docs: Object.fromEntries(docs.entries()),\n      orderedDocs,\n      type,\n    }\n\n    return acc\n  }, {} as Record<string, SerializablePropertySort<string | number | boolean>>)\n\n  return {\n    language: sorter.language,\n    sortableProperties: sorter.sortableProperties,\n    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n    sorts,\n    enabled: sorter.enabled,\n    isSorted: sorter.isSorted,\n  } as R\n}\n\nexport async function createSorter(): Promise<ISorter<Sorter>> {\n  return {\n    create,\n    insert,\n    remove,\n    save,\n    load,\n    sortBy,\n    getSortableProperties,\n    getSortablePropertiesWithTypes,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}