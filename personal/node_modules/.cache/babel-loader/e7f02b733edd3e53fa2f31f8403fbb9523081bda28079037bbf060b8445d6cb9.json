{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, MathUtils, Vector3, Quaternion, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, Matrix4, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, RepeatWrapping, ClampToEdgeWrapping, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, Scene, TextureLoader, Euler } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text, path) {\n    function getElementsByTagName(xml2, name) {\n      const array = [];\n      const childNodes = xml2.childNodes;\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text2) {\n      if (text2.length === 0) return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text2) {\n      if (text2.length === 0) return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text2) {\n      if (text2.length === 0) return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text2) {\n      return text2.substring(1);\n    }\n    function generateId() {\n      return \"three_default_\" + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    }\n    function parseAsset(xml2) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n      };\n    }\n    function parseAssetUnit(xml2) {\n      if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n        return parseFloat(xml2.getAttribute(\"meter\"));\n      } else {\n        return 1;\n      }\n    }\n    function parseAssetUpAxis(xml2) {\n      return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n    }\n    function parseLibrary(xml2, libraryName, nodeName, parser) {\n      const library2 = getElementsByTagName(xml2, libraryName)[0];\n      if (library2 !== void 0) {\n        const elements = getElementsByTagName(library2, nodeName);\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    }\n    function getBuild(data, builder) {\n      if (data.build !== void 0) return data.build;\n      data.build = builder(data);\n      return data.build;\n    }\n    function parseAnimation(xml2) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let id;\n        switch (child.nodeName) {\n          case \"source\":\n            id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"sampler\":\n            id = child.getAttribute(\"id\");\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case \"channel\":\n            id = child.getAttribute(\"target\");\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          case \"animation\":\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasChildren === false) {\n        library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n      }\n    }\n    function parseAnimationSampler(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml2) {\n      const data = {};\n      const target = xml2.getAttribute(\"target\");\n      let parts = target.split(\"/\");\n      const id = parts.shift();\n      let sid = parts.shift();\n      const arraySyntax = sid.indexOf(\"(\") !== -1;\n      const memberSyntax = sid.indexOf(\".\") !== -1;\n      if (memberSyntax) {\n        parts = sid.split(\".\");\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        const indices = sid.split(\"(\");\n        sid = indices.shift();\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml2.getAttribute(\"source\"));\n      return data;\n    }\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {};\n      switch (transform) {\n        case \"matrix\":\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === void 0) data[time] = {};\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case \"translate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"rotate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"scale\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = [];\n      for (const time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      }\n      keyframes.sort(ascending);\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes;\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n      }\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l;\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === void 0) {\n          keyframe.value[property] = null;\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    }\n    function parseAnimationClip(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"id\") || \"default\",\n        start: parseFloat(xml2.getAttribute(\"start\") || 0),\n        end: parseFloat(xml2.getAttribute(\"end\") || 0),\n        animations: []\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"instance_animation\":\n            data.animations.push(parseId(child.getAttribute(\"url\")));\n            break;\n        }\n      }\n      library.clips[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations2 = data.animations;\n      for (let i = 0, il = animations2.length; i < il; i++) {\n        const animationTracks = getAnimation(animations2[i]);\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    }\n    function parseController(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"skin\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            data.skin = parseSkin(child);\n            break;\n          case \"morph\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n            break;\n        }\n      }\n      library.controllers[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSkin(xml2) {\n      const data = {\n        sources: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"bind_shape_matrix\":\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case \"source\":\n            const id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"joints\":\n            data.joints = parseJoints(child);\n            break;\n          case \"vertex_weights\":\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            data.inputs[semantic] = {\n              id,\n              offset\n            };\n            break;\n          case \"vcount\":\n            data.vcount = parseInts(child.textContent);\n            break;\n          case \"v\":\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n      if (data.skin !== void 0) {\n        build.skin = buildSkin(data.skin);\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l;\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i];\n        const vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        }\n        vertexSkinData.sort(descending);\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n          if (d !== void 0) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      }\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      }\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name,\n          boneInverse\n        });\n      }\n      return build;\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    }\n    function parseImage(xml2) {\n      const data = {\n        init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n      };\n      library.images[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== void 0) return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      const data = library.images[id];\n      if (data !== void 0) {\n        return getBuild(data, buildImage);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    }\n    function parseEffect(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"profile_COMMON\":\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseEffectProfileCOMMON(xml2) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"newparam\":\n            parseEffectNewparam(child, data);\n            break;\n          case \"technique\":\n            data.technique = parseEffectTechnique(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml2, data) {\n      const sid = xml2.getAttribute(\"sid\");\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"surface\":\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case \"sampler2D\":\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"init_from\":\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"source\":\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"constant\":\n          case \"lambert\":\n          case \"blinn\":\n          case \"phong\":\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"emission\":\n          case \"diffuse\":\n          case \"specular\":\n          case \"bump\":\n          case \"ambient\":\n          case \"shininess\":\n          case \"transparency\":\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case \"transparent\":\n            data[child.nodeName] = {\n              opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"color\":\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case \"float\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"texture\":\n            data[child.nodeName] = {\n              id: child.getAttribute(\"texture\"),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml2) {\n      const data = {\n        technique: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"extra\":\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"repeatU\":\n          case \"repeatV\":\n          case \"offsetU\":\n          case \"offsetV\":\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"wrapU\":\n          case \"wrapV\":\n            if (child.textContent.toUpperCase() === \"TRUE\") {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === \"FALSE\") {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"double_sided\":\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechniqueBump(xml2) {\n      var data = {};\n      for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n        var child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"texture\":\n            data[child.nodeName] = {\n              id: child.getAttribute(\"texture\"),\n              texcoord: child.getAttribute(\"texcoord\"),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    }\n    function parseMaterial(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"instance_effect\":\n            data.url = parseId(child.getAttribute(\"url\"));\n            break;\n        }\n      }\n      library.materials[xml2.getAttribute(\"id\")] = data;\n    }\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case \"tga\":\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n      switch (technique.type) {\n        case \"phong\":\n        case \"blinn\":\n          material = new MeshPhongMaterial();\n          break;\n        case \"lambert\":\n          material = new MeshLambertMaterial();\n          break;\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name || \"\";\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null;\n        if (sampler !== void 0) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n          image = getImage(textureObject.id);\n        }\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n          if (loader !== void 0) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n            if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n              const technique2 = extra.technique;\n              texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n              texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n            return texture;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n      const parameters = technique.parameters;\n      for (const key in parameters) {\n        const parameter = parameters[key];\n        switch (key) {\n          case \"diffuse\":\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n          case \"specular\":\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n          case \"bump\":\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n          case \"ambient\":\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n          case \"shininess\":\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n          case \"emission\":\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      }\n      let transparent = parameters[\"transparent\"];\n      let transparency = parameters[\"transparency\"];\n      if (transparency === void 0 && transparent) {\n        transparency = {\n          float: 1\n        };\n      }\n      if (transparent === void 0 && transparency) {\n        transparent = {\n          opaque: \"A_ONE\",\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        if (transparent.data.texture) {\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n          switch (transparent.opaque) {\n            case \"A_ONE\":\n              material.opacity = color[3] * transparency.float;\n              break;\n            case \"RGB_ZERO\":\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case \"A_ZERO\":\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case \"RGB_ONE\":\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1) material.transparent = true;\n        }\n      }\n      if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n        const techniques = technique.extra.technique;\n        for (const k in techniques) {\n          const v = techniques[k];\n          switch (k) {\n            case \"double_sided\":\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n            case \"bump\":\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    }\n    function parseCamera(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"optics\":\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseCameraOptics(xml2) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"technique_common\":\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"perspective\":\n          case \"orthographic\":\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"xfov\":\n          case \"yfov\":\n          case \"xmag\":\n          case \"ymag\":\n          case \"znear\":\n          case \"zfar\":\n          case \"aspect_ratio\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      let camera;\n      switch (data.optics.technique) {\n        case \"perspective\":\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        case \"orthographic\":\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n          ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n          // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name || \"\";\n      return camera;\n    }\n    function getCamera(id) {\n      const data = library.cameras[id];\n      if (data !== void 0) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    }\n    function parseLight(xml2) {\n      let data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseLightTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"directional\":\n          case \"point\":\n          case \"spot\":\n          case \"ambient\":\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"color\":\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n          case \"falloff_angle\":\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case \"quadratic_attenuation\":\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      let light;\n      switch (data.technique) {\n        case \"directional\":\n          light = new DirectionalLight();\n          break;\n        case \"point\":\n          light = new PointLight();\n          break;\n        case \"spot\":\n          light = new SpotLight();\n          break;\n        case \"ambient\":\n          light = new AmbientLight();\n          break;\n      }\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      const data = library.lights[id];\n      if (data !== void 0) {\n        return getBuild(data, buildLight);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    }\n    function parseGeometry(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml2, \"mesh\")[0];\n      if (mesh === void 0) return;\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        const id = child.getAttribute(\"id\");\n        switch (child.nodeName) {\n          case \"source\":\n            data.sources[id] = parseSource(child);\n            break;\n          case \"vertices\":\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case \"polygons\":\n            console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n            break;\n          case \"lines\":\n          case \"linestrips\":\n          case \"polylist\":\n          case \"triangles\":\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSource(xml2) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"float_array\":\n            data.array = parseFloats(child.textContent);\n            break;\n          case \"Name_array\":\n            data.array = parseStrings(child.textContent);\n            break;\n          case \"technique_common\":\n            const accessor = getElementsByTagName(child, \"accessor\")[0];\n            if (accessor !== void 0) {\n              data.stride = parseInt(accessor.getAttribute(\"stride\"));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml2) {\n      const primitive = {\n        type: xml2.nodeName,\n        material: xml2.getAttribute(\"material\"),\n        count: parseInt(xml2.getAttribute(\"count\")),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            const set = parseInt(child.getAttribute(\"set\"));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id,\n              offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === \"TEXCOORD\") primitive.hasUV = true;\n            break;\n          case \"vcount\":\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case \"p\":\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      const build = {};\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === void 0) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      let count2 = 0;\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count2++;\n        }\n      }\n      if (count2 > 0 && count2 < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0) return {};\n      const groupedPrimitives = groupPrimitives(primitives);\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type];\n        checkUVCoordinates(primitiveType);\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position2 = {\n        array: [],\n        stride: 0\n      };\n      const normal = {\n        array: [],\n        stride: 0\n      };\n      const uv = {\n        array: [],\n        stride: 0\n      };\n      const uv2 = {\n        array: [],\n        stride: 0\n      };\n      const color = {\n        array: [],\n        stride: 0\n      };\n      const skinIndex = {\n        array: [],\n        stride: 4\n      };\n      const skinWeight = {\n        array: [],\n        stride: 4\n      };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs;\n        let count2 = 0;\n        switch (primitive.type) {\n          case \"lines\":\n          case \"linestrips\":\n            count2 = primitive.count * 2;\n            break;\n          case \"triangles\":\n            count2 = primitive.count * 3;\n            break;\n          case \"polylist\":\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count2 += 3;\n                  break;\n                case 4:\n                  count2 += 6;\n                  break;\n                default:\n                  count2 += (vc - 2) * 3;\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n        }\n        geometry.addGroup(start, count2, p);\n        start += count2;\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        }\n        for (const name in inputs) {\n          const input = inputs[name];\n          switch (name) {\n            case \"VERTEX\":\n              for (const key in vertices) {\n                const id = vertices[key];\n                switch (key) {\n                  case \"POSITION\":\n                    const prevLength = position2.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                    position2.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    }\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count3 = (position2.array.length - prevLength) / position2.stride;\n                      for (let i = 0; i < count3; i++) {\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case \"NORMAL\":\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case \"COLOR\":\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD1\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case \"NORMAL\":\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case \"COLOR\":\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD1\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      }\n      if (position2.array.length > 0) {\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n      }\n      if (color.array.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute(\"uv2\", new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n      if (primitive.vcount !== void 0) {\n        let index = 0;\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count2 = vcount[i];\n          if (count2 === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count2 === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count2 > 4) {\n            for (let k = 1, kl = count2 - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count2;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    }\n    function parseKinematicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        joints: {},\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== void 0) return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"joint\":\n            data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n            break;\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml2) {\n      let data;\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"prismatic\":\n          case \"revolute\":\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml2.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case \"limits\":\n            const max = child.getElementsByTagName(\"max\")[0];\n            const min = child.getElementsByTagName(\"min\")[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      }\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      }\n      data.middlePosition = (data.limits.min + data.limits.max) / 2;\n      return data;\n    }\n    function parseKinematicsLink(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        attachments: [],\n        transforms: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"attachment_full\":\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml2) {\n      const data = {\n        joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n        transforms: [],\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml2) {\n      const data = {\n        type: xml2.nodeName\n      };\n      const array = parseFloats(xml2.textContent);\n      switch (data.type) {\n        case \"matrix\":\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case \"translate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n        case \"rotate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    }\n    function parsePhysicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        rigidBodies: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"rigid_body\":\n            data.rigidBodies[child.getAttribute(\"name\")] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n            break;\n        }\n      }\n      library.physicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function parsePhysicsRigidBody(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"inertia\":\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case \"mass\":\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    }\n    function parseKinematicsScene(xml2) {\n      const data = {\n        bindJointAxis: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"bind_joint_axis\":\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml2) {\n      const data = {\n        target: xml2.getAttribute(\"target\").split(\"/\").pop()\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const param = child.getElementsByTagName(\"param\")[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== void 0) return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i];\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          const parentVisualElement = targetElement.parentElement;\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute(\"name\");\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object,\n              transforms: buildTransformList(visualElement),\n              joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            const joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\");\n            } else if (joint.static) {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity();\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i];\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case \"revolute\":\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n                    case \"prismatic\":\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case \"matrix\":\n                      matrix.multiply(transform.obj);\n                      break;\n                    case \"translate\":\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case \"scale\":\n                      matrix.scale(transform.obj);\n                      break;\n                    case \"rotate\":\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array, vector2;\n        switch (child.nodeName) {\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            const matrix2 = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: matrix2\n            });\n            break;\n          case \"translate\":\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2\n            });\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2,\n              angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    }\n    function prepareNodes(xml2) {\n      const elements = xml2.getElementsByTagName(\"node\");\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        if (element.hasAttribute(\"id\") === false) {\n          element.setAttribute(\"id\", generateId());\n        }\n      }\n    }\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n    function parseNode(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        type: xml2.getAttribute(\"type\"),\n        id: xml2.getAttribute(\"id\"),\n        sid: xml2.getAttribute(\"sid\"),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array;\n        switch (child.nodeName) {\n          case \"node\":\n            data.nodes.push(child.getAttribute(\"id\"));\n            parseNode(child);\n            break;\n          case \"instance_camera\":\n            data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_controller\":\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case \"instance_light\":\n            data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_geometry\":\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case \"instance_node\":\n            data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"translate\":\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"extra\":\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn(\"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\", data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml2) {\n      const data = {\n        id: parseId(xml2.getAttribute(\"url\")),\n        materials: {},\n        skeletons: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"bind_material\":\n            const instances = child.getElementsByTagName(\"instance_material\");\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute(\"symbol\");\n              const target = instance.getAttribute(\"target\");\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case \"skeleton\":\n            data.skeletons.push(parseId(child.textContent));\n            break;\n          default:\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data;\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n          for (let j2 = 0; j2 < children.length; j2++) {\n            const child = children[j2];\n            if (child.type === \"JOINT\") {\n              const root2 = getNode(child.id);\n              buildBoneHierarchy(root2, joints, boneData);\n            }\n          }\n        } else {\n          console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n        }\n      }\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      }\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      }\n      const bones = [];\n      const boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse;\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === void 0) {\n            boneInverse = new Matrix4();\n          }\n          boneData.push({\n            bone: object,\n            boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n    function buildNode(data) {\n      const objects = [];\n      const matrix2 = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes;\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      }\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      }\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object2 = newObjects[j];\n          if (object2.isSkinnedMesh) {\n            object2.bind(skeleton, controller.skin.bindMatrix);\n            object2.normalizeSkinWeights();\n          }\n          objects.push(object2);\n        }\n      }\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      }\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i];\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      }\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      let object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === \"JOINT\" ? new Bone() : new Group();\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      object.name = type === \"JOINT\" ? data.sid : data.name;\n      object.matrix.copy(matrix2);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    const fallbackMaterial = new MeshBasicMaterial({\n      color: 16711935\n    });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n        if (id === void 0) {\n          console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n        if (materials.length === 0) {\n          if (type === \"lines\" || type === \"linestrips\") {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        }\n        const skinning = geometry.data.attributes.skinIndex !== void 0;\n        const material = materials.length === 1 ? materials[0] : materials;\n        let object;\n        switch (type) {\n          case \"lines\":\n            object = new LineSegments(geometry.data, material);\n            break;\n          case \"linestrips\":\n            object = new Line(geometry.data, material);\n            break;\n          case \"triangles\":\n          case \"polylist\":\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== void 0;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    }\n    function parseVisualScene(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        children: []\n      };\n      prepareNodes(xml2);\n      const elements = getElementsByTagName(xml2, \"node\");\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== void 0;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    }\n    function parseScene(xml2) {\n      const instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n      return getVisualScene(parseId(instance.getAttribute(\"url\")));\n    }\n    function setupAnimations() {\n      const clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          const tracks = [];\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new AnimationClip(\"default\", -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n    function parserErrorToText(parserError2) {\n      let result = \"\";\n      const stack = [parserError2];\n      while (stack.length) {\n        const node = stack.shift();\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += \"\\n\";\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n      return result.trim();\n    }\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n    const xml = new DOMParser().parseFromString(text, \"application/xml\");\n    const collada = getElementsByTagName(xml, \"COLLADA\")[0];\n    const parserError = xml.getElementsByTagName(\"parsererror\")[0];\n    if (parserError !== void 0) {\n      const errorElement = getElementsByTagName(parserError, \"div\")[0];\n      let errorText;\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n      console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n      return null;\n    }\n    const version = collada.getAttribute(\"version\");\n    console.log(\"THREE.ColladaLoader: File version\", version);\n    const asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    }\n    const animations = [];\n    let kinematics = {};\n    let count = 0;\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n    parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n    parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n    parseLibrary(collada, \"library_images\", \"image\", parseImage);\n    parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n    parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n    parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n    parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n    parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n    parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n    parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n    parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n    parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n    parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n    scene.animations = animations;\n    if (asset.upAxis === \"Z_UP\") {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n        return animations;\n      },\n      kinematics,\n      library,\n      scene\n    };\n  }\n}\nexport { ColladaLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","MathUtils","Vector3","Quaternion","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","Matrix4","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","RepeatWrapping","ClampToEdgeWrapping","Vector2","DoubleSide","FrontSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","Scene","TextureLoader","Euler","TGALoader","ColladaLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml2","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","text2","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library2","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","library","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animations2","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","technique2","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","techniques","k","side","normalScale","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","count2","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","position2","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","count3","setAttribute","pushVector","sourceStride","sourceArray","c","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector2","matrix2","prepareNodes","element","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","j2","root2","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","object2","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError2","result","stack","Node","TEXT_NODE","apply","scene","xml","DOMParser","parseFromString","parserError","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/ColladaLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, MathUtils, Vector3, Quaternion, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, Matrix4, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, RepeatWrapping, ClampToEdgeWrapping, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, Scene, TextureLoader, Euler } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text, path) {\n    function getElementsByTagName(xml2, name) {\n      const array = [];\n      const childNodes = xml2.childNodes;\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text2) {\n      return text2.substring(1);\n    }\n    function generateId() {\n      return \"three_default_\" + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    }\n    function parseAsset(xml2) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n      };\n    }\n    function parseAssetUnit(xml2) {\n      if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n        return parseFloat(xml2.getAttribute(\"meter\"));\n      } else {\n        return 1;\n      }\n    }\n    function parseAssetUpAxis(xml2) {\n      return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n    }\n    function parseLibrary(xml2, libraryName, nodeName, parser) {\n      const library2 = getElementsByTagName(xml2, libraryName)[0];\n      if (library2 !== void 0) {\n        const elements = getElementsByTagName(library2, nodeName);\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    }\n    function getBuild(data, builder) {\n      if (data.build !== void 0)\n        return data.build;\n      data.build = builder(data);\n      return data.build;\n    }\n    function parseAnimation(xml2) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let id;\n        switch (child.nodeName) {\n          case \"source\":\n            id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"sampler\":\n            id = child.getAttribute(\"id\");\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case \"channel\":\n            id = child.getAttribute(\"target\");\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          case \"animation\":\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasChildren === false) {\n        library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n      }\n    }\n    function parseAnimationSampler(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml2) {\n      const data = {};\n      const target = xml2.getAttribute(\"target\");\n      let parts = target.split(\"/\");\n      const id = parts.shift();\n      let sid = parts.shift();\n      const arraySyntax = sid.indexOf(\"(\") !== -1;\n      const memberSyntax = sid.indexOf(\".\") !== -1;\n      if (memberSyntax) {\n        parts = sid.split(\".\");\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        const indices = sid.split(\"(\");\n        sid = indices.shift();\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml2.getAttribute(\"source\"));\n      return data;\n    }\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {};\n      switch (transform) {\n        case \"matrix\":\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === void 0)\n              data[time] = {};\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case \"translate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"rotate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"scale\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = [];\n      for (const time in data) {\n        keyframes.push({ time: parseFloat(time), value: data[time] });\n      }\n      keyframes.sort(ascending);\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes;\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0)\n        tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n      }\n      if (scaleData.length > 0)\n        tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l;\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === void 0) {\n          keyframe.value[property] = null;\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null)\n          return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null)\n          return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    }\n    function parseAnimationClip(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"id\") || \"default\",\n        start: parseFloat(xml2.getAttribute(\"start\") || 0),\n        end: parseFloat(xml2.getAttribute(\"end\") || 0),\n        animations: []\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"instance_animation\":\n            data.animations.push(parseId(child.getAttribute(\"url\")));\n            break;\n        }\n      }\n      library.clips[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations2 = data.animations;\n      for (let i = 0, il = animations2.length; i < il; i++) {\n        const animationTracks = getAnimation(animations2[i]);\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    }\n    function parseController(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"skin\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            data.skin = parseSkin(child);\n            break;\n          case \"morph\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n            break;\n        }\n      }\n      library.controllers[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSkin(xml2) {\n      const data = {\n        sources: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"bind_shape_matrix\":\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case \"source\":\n            const id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"joints\":\n            data.joints = parseJoints(child);\n            break;\n          case \"vertex_weights\":\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            data.inputs[semantic] = { id, offset };\n            break;\n          case \"vcount\":\n            data.vcount = parseInts(child.textContent);\n            break;\n          case \"v\":\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n      if (data.skin !== void 0) {\n        build.skin = buildSkin(data.skin);\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l;\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i];\n        const vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({ index: skinIndex, weight: skinWeight });\n          stride += 2;\n        }\n        vertexSkinData.sort(descending);\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n          if (d !== void 0) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      }\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      }\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({ name, boneInverse });\n      }\n      return build;\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    }\n    function parseImage(xml2) {\n      const data = {\n        init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n      };\n      library.images[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      const data = library.images[id];\n      if (data !== void 0) {\n        return getBuild(data, buildImage);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    }\n    function parseEffect(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"profile_COMMON\":\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseEffectProfileCOMMON(xml2) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"newparam\":\n            parseEffectNewparam(child, data);\n            break;\n          case \"technique\":\n            data.technique = parseEffectTechnique(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml2, data) {\n      const sid = xml2.getAttribute(\"sid\");\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"surface\":\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case \"sampler2D\":\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"init_from\":\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"source\":\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"constant\":\n          case \"lambert\":\n          case \"blinn\":\n          case \"phong\":\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"emission\":\n          case \"diffuse\":\n          case \"specular\":\n          case \"bump\":\n          case \"ambient\":\n          case \"shininess\":\n          case \"transparency\":\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case \"transparent\":\n            data[child.nodeName] = {\n              opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"color\":\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case \"float\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"texture\":\n            data[child.nodeName] = { id: child.getAttribute(\"texture\"), extra: parseEffectParameterTexture(child) };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml2) {\n      const data = {\n        technique: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"extra\":\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"repeatU\":\n          case \"repeatV\":\n          case \"offsetU\":\n          case \"offsetV\":\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"wrapU\":\n          case \"wrapV\":\n            if (child.textContent.toUpperCase() === \"TRUE\") {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === \"FALSE\") {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"double_sided\":\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechniqueBump(xml2) {\n      var data = {};\n      for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n        var child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"texture\":\n            data[child.nodeName] = {\n              id: child.getAttribute(\"texture\"),\n              texcoord: child.getAttribute(\"texcoord\"),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    }\n    function parseMaterial(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"instance_effect\":\n            data.url = parseId(child.getAttribute(\"url\"));\n            break;\n        }\n      }\n      library.materials[xml2.getAttribute(\"id\")] = data;\n    }\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case \"tga\":\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n      switch (technique.type) {\n        case \"phong\":\n        case \"blinn\":\n          material = new MeshPhongMaterial();\n          break;\n        case \"lambert\":\n          material = new MeshLambertMaterial();\n          break;\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name || \"\";\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null;\n        if (sampler !== void 0) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n          image = getImage(textureObject.id);\n        }\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n          if (loader !== void 0) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n            if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n              const technique2 = extra.technique;\n              texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n              texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n            return texture;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n      const parameters = technique.parameters;\n      for (const key in parameters) {\n        const parameter = parameters[key];\n        switch (key) {\n          case \"diffuse\":\n            if (parameter.color)\n              material.color.fromArray(parameter.color);\n            if (parameter.texture)\n              material.map = getTexture(parameter.texture);\n            break;\n          case \"specular\":\n            if (parameter.color && material.specular)\n              material.specular.fromArray(parameter.color);\n            if (parameter.texture)\n              material.specularMap = getTexture(parameter.texture);\n            break;\n          case \"bump\":\n            if (parameter.texture)\n              material.normalMap = getTexture(parameter.texture);\n            break;\n          case \"ambient\":\n            if (parameter.texture)\n              material.lightMap = getTexture(parameter.texture);\n            break;\n          case \"shininess\":\n            if (parameter.float && material.shininess)\n              material.shininess = parameter.float;\n            break;\n          case \"emission\":\n            if (parameter.color && material.emissive)\n              material.emissive.fromArray(parameter.color);\n            if (parameter.texture)\n              material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      }\n      let transparent = parameters[\"transparent\"];\n      let transparency = parameters[\"transparency\"];\n      if (transparency === void 0 && transparent) {\n        transparency = {\n          float: 1\n        };\n      }\n      if (transparent === void 0 && transparency) {\n        transparent = {\n          opaque: \"A_ONE\",\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        if (transparent.data.texture) {\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n          switch (transparent.opaque) {\n            case \"A_ONE\":\n              material.opacity = color[3] * transparency.float;\n              break;\n            case \"RGB_ZERO\":\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case \"A_ZERO\":\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case \"RGB_ONE\":\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1)\n            material.transparent = true;\n        }\n      }\n      if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n        const techniques = technique.extra.technique;\n        for (const k in techniques) {\n          const v = techniques[k];\n          switch (k) {\n            case \"double_sided\":\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n            case \"bump\":\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    }\n    function parseCamera(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"optics\":\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseCameraOptics(xml2) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"technique_common\":\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"perspective\":\n          case \"orthographic\":\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"xfov\":\n          case \"yfov\":\n          case \"xmag\":\n          case \"ymag\":\n          case \"znear\":\n          case \"zfar\":\n          case \"aspect_ratio\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      let camera;\n      switch (data.optics.technique) {\n        case \"perspective\":\n          camera = new PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n        case \"orthographic\":\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n          ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(\n            -xmag,\n            xmag,\n            ymag,\n            -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name || \"\";\n      return camera;\n    }\n    function getCamera(id) {\n      const data = library.cameras[id];\n      if (data !== void 0) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    }\n    function parseLight(xml2) {\n      let data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseLightTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"directional\":\n          case \"point\":\n          case \"spot\":\n          case \"ambient\":\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"color\":\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n          case \"falloff_angle\":\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case \"quadratic_attenuation\":\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      let light;\n      switch (data.technique) {\n        case \"directional\":\n          light = new DirectionalLight();\n          break;\n        case \"point\":\n          light = new PointLight();\n          break;\n        case \"spot\":\n          light = new SpotLight();\n          break;\n        case \"ambient\":\n          light = new AmbientLight();\n          break;\n      }\n      if (data.parameters.color)\n        light.color.copy(data.parameters.color);\n      if (data.parameters.distance)\n        light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      const data = library.lights[id];\n      if (data !== void 0) {\n        return getBuild(data, buildLight);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    }\n    function parseGeometry(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml2, \"mesh\")[0];\n      if (mesh === void 0)\n        return;\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        const id = child.getAttribute(\"id\");\n        switch (child.nodeName) {\n          case \"source\":\n            data.sources[id] = parseSource(child);\n            break;\n          case \"vertices\":\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case \"polygons\":\n            console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n            break;\n          case \"lines\":\n          case \"linestrips\":\n          case \"polylist\":\n          case \"triangles\":\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSource(xml2) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"float_array\":\n            data.array = parseFloats(child.textContent);\n            break;\n          case \"Name_array\":\n            data.array = parseStrings(child.textContent);\n            break;\n          case \"technique_common\":\n            const accessor = getElementsByTagName(child, \"accessor\")[0];\n            if (accessor !== void 0) {\n              data.stride = parseInt(accessor.getAttribute(\"stride\"));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml2) {\n      const primitive = {\n        type: xml2.nodeName,\n        material: xml2.getAttribute(\"material\"),\n        count: parseInt(xml2.getAttribute(\"count\")),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            const set = parseInt(child.getAttribute(\"set\"));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = { id, offset };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === \"TEXCOORD\")\n              primitive.hasUV = true;\n            break;\n          case \"vcount\":\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case \"p\":\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      const build = {};\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === void 0)\n          build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      let count2 = 0;\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count2++;\n        }\n      }\n      if (count2 > 0 && count2 < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0)\n        return {};\n      const groupedPrimitives = groupPrimitives(primitives);\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type];\n        checkUVCoordinates(primitiveType);\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position2 = { array: [], stride: 0 };\n      const normal = { array: [], stride: 0 };\n      const uv = { array: [], stride: 0 };\n      const uv2 = { array: [], stride: 0 };\n      const color = { array: [], stride: 0 };\n      const skinIndex = { array: [], stride: 4 };\n      const skinWeight = { array: [], stride: 4 };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs;\n        let count2 = 0;\n        switch (primitive.type) {\n          case \"lines\":\n          case \"linestrips\":\n            count2 = primitive.count * 2;\n            break;\n          case \"triangles\":\n            count2 = primitive.count * 3;\n            break;\n          case \"polylist\":\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count2 += 3;\n                  break;\n                case 4:\n                  count2 += 6;\n                  break;\n                default:\n                  count2 += (vc - 2) * 3;\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n        }\n        geometry.addGroup(start, count2, p);\n        start += count2;\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        }\n        for (const name in inputs) {\n          const input = inputs[name];\n          switch (name) {\n            case \"VERTEX\":\n              for (const key in vertices) {\n                const id = vertices[key];\n                switch (key) {\n                  case \"POSITION\":\n                    const prevLength = position2.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                    position2.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    }\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count3 = (position2.array.length - prevLength) / position2.stride;\n                      for (let i = 0; i < count3; i++) {\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case \"NORMAL\":\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case \"COLOR\":\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD1\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case \"NORMAL\":\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case \"COLOR\":\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD1\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      }\n      if (position2.array.length > 0) {\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n      }\n      if (color.array.length > 0)\n        geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0)\n        geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0)\n        geometry.setAttribute(\"uv2\", new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n      if (primitive.vcount !== void 0) {\n        let index = 0;\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count2 = vcount[i];\n          if (count2 === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count2 === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count2 > 4) {\n            for (let k = 1, kl = count2 - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count2;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    }\n    function parseKinematicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        joints: {},\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"joint\":\n            data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n            break;\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml2) {\n      let data;\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"prismatic\":\n          case \"revolute\":\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml2.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case \"limits\":\n            const max = child.getElementsByTagName(\"max\")[0];\n            const min = child.getElementsByTagName(\"min\")[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      }\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      }\n      data.middlePosition = (data.limits.min + data.limits.max) / 2;\n      return data;\n    }\n    function parseKinematicsLink(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        attachments: [],\n        transforms: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"attachment_full\":\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml2) {\n      const data = {\n        joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n        transforms: [],\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml2) {\n      const data = {\n        type: xml2.nodeName\n      };\n      const array = parseFloats(xml2.textContent);\n      switch (data.type) {\n        case \"matrix\":\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case \"translate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n        case \"rotate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    }\n    function parsePhysicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        rigidBodies: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"rigid_body\":\n            data.rigidBodies[child.getAttribute(\"name\")] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n            break;\n        }\n      }\n      library.physicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function parsePhysicsRigidBody(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"inertia\":\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case \"mass\":\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    }\n    function parseKinematicsScene(xml2) {\n      const data = {\n        bindJointAxis: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"bind_joint_axis\":\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml2) {\n      const data = {\n        target: xml2.getAttribute(\"target\").split(\"/\").pop()\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const param = child.getElementsByTagName(\"param\")[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === void 0 || kinematicsSceneId === void 0)\n        return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i];\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          const parentVisualElement = targetElement.parentElement;\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute(\"name\");\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function(object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object,\n              transforms: buildTransformList(visualElement),\n              joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function(jointIndex) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function(jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            const joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\n                \"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\"\n              );\n            } else if (joint.static) {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity();\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i];\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case \"revolute\":\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n                    case \"prismatic\":\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case \"matrix\":\n                      matrix.multiply(transform.obj);\n                      break;\n                    case \"translate\":\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case \"scale\":\n                      matrix.scale(transform.obj);\n                      break;\n                    case \"rotate\":\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let array, vector2;\n        switch (child.nodeName) {\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            const matrix2 = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: matrix2\n            });\n            break;\n          case \"translate\":\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2\n            });\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2,\n              angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    }\n    function prepareNodes(xml2) {\n      const elements = xml2.getElementsByTagName(\"node\");\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        if (element.hasAttribute(\"id\") === false) {\n          element.setAttribute(\"id\", generateId());\n        }\n      }\n    }\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n    function parseNode(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        type: xml2.getAttribute(\"type\"),\n        id: xml2.getAttribute(\"id\"),\n        sid: xml2.getAttribute(\"sid\"),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let array;\n        switch (child.nodeName) {\n          case \"node\":\n            data.nodes.push(child.getAttribute(\"id\"));\n            parseNode(child);\n            break;\n          case \"instance_camera\":\n            data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_controller\":\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case \"instance_light\":\n            data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_geometry\":\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case \"instance_node\":\n            data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"translate\":\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"extra\":\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn(\n          \"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\",\n          data.id\n        );\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml2) {\n      const data = {\n        id: parseId(xml2.getAttribute(\"url\")),\n        materials: {},\n        skeletons: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"bind_material\":\n            const instances = child.getElementsByTagName(\"instance_material\");\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute(\"symbol\");\n              const target = instance.getAttribute(\"target\");\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case \"skeleton\":\n            data.skeletons.push(parseId(child.textContent));\n            break;\n          default:\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data;\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n          for (let j2 = 0; j2 < children.length; j2++) {\n            const child = children[j2];\n            if (child.type === \"JOINT\") {\n              const root2 = getNode(child.id);\n              buildBoneHierarchy(root2, joints, boneData);\n            }\n          }\n        } else {\n          console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n        }\n      }\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      }\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      }\n      const bones = [];\n      const boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      root.traverse(function(object) {\n        if (object.isBone === true) {\n          let boneInverse;\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === void 0) {\n            boneInverse = new Matrix4();\n          }\n          boneData.push({ bone: object, boneInverse, processed: false });\n        }\n      });\n    }\n    function buildNode(data) {\n      const objects = [];\n      const matrix2 = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes;\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      }\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      }\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object2 = newObjects[j];\n          if (object2.isSkinnedMesh) {\n            object2.bind(skeleton, controller.skin.bindMatrix);\n            object2.normalizeSkinWeights();\n          }\n          objects.push(object2);\n        }\n      }\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      }\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i];\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      }\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      let object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === \"JOINT\" ? new Bone() : new Group();\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      object.name = type === \"JOINT\" ? data.sid : data.name;\n      object.matrix.copy(matrix2);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    const fallbackMaterial = new MeshBasicMaterial({ color: 16711935 });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n        if (id === void 0) {\n          console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n        if (materials.length === 0) {\n          if (type === \"lines\" || type === \"linestrips\") {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        }\n        const skinning = geometry.data.attributes.skinIndex !== void 0;\n        const material = materials.length === 1 ? materials[0] : materials;\n        let object;\n        switch (type) {\n          case \"lines\":\n            object = new LineSegments(geometry.data, material);\n            break;\n          case \"linestrips\":\n            object = new Line(geometry.data, material);\n            break;\n          case \"triangles\":\n          case \"polylist\":\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== void 0;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    }\n    function parseVisualScene(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        children: []\n      };\n      prepareNodes(xml2);\n      const elements = getElementsByTagName(xml2, \"node\");\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== void 0;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    }\n    function parseScene(xml2) {\n      const instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n      return getVisualScene(parseId(instance.getAttribute(\"url\")));\n    }\n    function setupAnimations() {\n      const clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          const tracks = [];\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new AnimationClip(\"default\", -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n    function parserErrorToText(parserError2) {\n      let result = \"\";\n      const stack = [parserError2];\n      while (stack.length) {\n        const node = stack.shift();\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += \"\\n\";\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n      return result.trim();\n    }\n    if (text.length === 0) {\n      return { scene: new Scene() };\n    }\n    const xml = new DOMParser().parseFromString(text, \"application/xml\");\n    const collada = getElementsByTagName(xml, \"COLLADA\")[0];\n    const parserError = xml.getElementsByTagName(\"parsererror\")[0];\n    if (parserError !== void 0) {\n      const errorElement = getElementsByTagName(parserError, \"div\")[0];\n      let errorText;\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n      console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n      return null;\n    }\n    const version = collada.getAttribute(\"version\");\n    console.log(\"THREE.ColladaLoader: File version\", version);\n    const asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    }\n    const animations = [];\n    let kinematics = {};\n    let count = 0;\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n    parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n    parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n    parseLibrary(collada, \"library_images\", \"image\", parseImage);\n    parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n    parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n    parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n    parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n    parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n    parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n    parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n    parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n    parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n    parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n    scene.animations = animations;\n    if (asset.upAxis === \"Z_UP\") {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n        return animations;\n      },\n      kinematics,\n      library,\n      scene\n    };\n  }\n}\nexport {\n  ColladaLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}