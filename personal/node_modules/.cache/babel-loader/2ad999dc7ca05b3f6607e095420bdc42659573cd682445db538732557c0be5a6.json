{"ast":null,"code":"import { createError } from '../errors.js';\nimport { formatNanoseconds, uniqueId } from '../utils.js';\nexport { getDocumentProperties } from '../utils.js';\nexport async function formatElapsedTime(n) {\n  return {\n    raw: Number(n),\n    formatted: await formatNanoseconds(n)\n  };\n}\nexport async function getDocumentIndexId(doc) {\n  if (doc.id) {\n    if (typeof doc.id !== 'string') {\n      throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);\n    }\n    return doc.id;\n  }\n  return await uniqueId();\n}\nexport async function validateSchema(doc, schema) {\n  for (const [prop, type] of Object.entries(schema)) {\n    const value = doc[prop];\n    if (typeof value === 'undefined') {\n      continue;\n    }\n    if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n      continue;\n    }\n    if (type === 'enum[]' && Array.isArray(value)) {\n      const valueLength = value.length;\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n          return prop + '.' + i;\n        }\n      }\n      continue;\n    }\n    if (isVectorType(type)) {\n      const vectorSize = getVectorSize(type);\n      if (!Array.isArray(value) || value.length !== vectorSize) {\n        throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);\n      }\n      continue;\n    }\n    if (isArrayType(type)) {\n      if (!Array.isArray(value)) {\n        return prop;\n      }\n      const expectedType = getInnerType(type);\n      const valueLength = value.length;\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== expectedType) {\n          return prop + '.' + i;\n        }\n      }\n      continue;\n    }\n    if (typeof type === 'object') {\n      if (!value || typeof value !== 'object') {\n        return prop;\n      }\n      // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n      const subProp = await validateSchema(value, type);\n      if (subProp) {\n        return prop + '.' + subProp;\n      }\n      continue;\n    }\n    if (typeof value !== type) {\n      return prop;\n    }\n  }\n  return undefined;\n}\nconst IS_ARRAY_TYPE = {\n  string: false,\n  number: false,\n  boolean: false,\n  enum: false,\n  'string[]': true,\n  'number[]': true,\n  'boolean[]': true,\n  'enum[]': true\n};\nconst INNER_TYPE = {\n  'string[]': 'string',\n  'number[]': 'number',\n  'boolean[]': 'boolean',\n  'enum[]': 'enum'\n};\nexport function isVectorType(type) {\n  return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type);\n}\nexport function isArrayType(type) {\n  return typeof type === 'string' && IS_ARRAY_TYPE[type];\n}\nexport function getInnerType(type) {\n  return INNER_TYPE[type];\n}\nexport function getVectorSize(type) {\n  const size = Number(type.slice(7, -1));\n  switch (true) {\n    case isNaN(size):\n      throw createError('INVALID_VECTOR_VALUE', type);\n    case size <= 0:\n      throw createError('INVALID_VECTOR_SIZE', type);\n    default:\n      return size;\n  }\n}","map":{"version":3,"names":["createError","formatNanoseconds","uniqueId","getDocumentProperties","formatElapsedTime","n","raw","Number","formatted","getDocumentIndexId","doc","id","validateSchema","schema","prop","type","Object","entries","value","Array","isArray","valueLength","length","i","isVectorType","vectorSize","getVectorSize","isArrayType","expectedType","getInnerType","subProp","undefined","IS_ARRAY_TYPE","string","number","boolean","enum","INNER_TYPE","test","size","slice","isNaN"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/defaults.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport {\n  AnyDocument,\n  AnyOrama,\n  ArraySearchableType,\n  ElapsedTime,\n  ScalarSearchableType,\n  SearchableType,\n  TypedDocument,\n  Vector\n} from '../types.js'\nimport { formatNanoseconds, uniqueId } from '../utils.js'\n\nexport { getDocumentProperties } from '../utils.js'\n\nexport async function formatElapsedTime(n: bigint): Promise<ElapsedTime> {\n  return {\n    raw: Number(n),\n    formatted: await formatNanoseconds(n),\n  }\n}\n\nexport async function getDocumentIndexId(doc: AnyDocument): Promise<string> {\n  if (doc.id) {\n    if (typeof doc.id !== 'string') {\n      throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id)\n    }\n\n    return doc.id\n  }\n\n  return await uniqueId()\n}\n\nexport async function validateSchema<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  doc: ResultDocument,\n  schema: T['schema'],\n): Promise<string | undefined> {\n  for (const [prop, type] of Object.entries(schema)) {\n    const value = doc[prop]\n\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n      continue\n    }\n    if (type === 'enum[]' && Array.isArray(value)) {\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n          return prop + '.' + i\n        }\n      }\n      continue\n    }\n\n    if (isVectorType(type)) {\n      const vectorSize = getVectorSize(type)\n      if (!Array.isArray(value) || value.length !== vectorSize) {\n        throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length)\n      }\n      continue\n    }\n\n    if (isArrayType(type)) {\n      if (!Array.isArray(value)) {\n        return prop\n      }\n      const expectedType = getInnerType(type)\n\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== expectedType) {\n          return prop + '.' + i\n        }\n      }\n\n      continue\n    }\n\n    if (typeof type === 'object') {\n      if (!value || typeof value !== 'object') {\n        return prop\n      }\n\n      // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n      const subProp = await validateSchema(value as ResultDocument, type)\n      if (subProp) {\n        return prop + '.' + subProp\n      }\n      continue\n    }\n\n    if (typeof value !== type) {\n      return prop\n    }\n  }\n\n  return undefined\n}\n\nconst IS_ARRAY_TYPE: Record<SearchableType, boolean> = {\n  string: false,\n  number: false,\n  boolean: false,\n  enum: false,\n  'string[]': true,\n  'number[]': true,\n  'boolean[]': true,\n  'enum[]': true,\n}\n\nconst INNER_TYPE: Record<ArraySearchableType, ScalarSearchableType> = {\n  'string[]': 'string',\n  'number[]': 'number',\n  'boolean[]': 'boolean',\n  'enum[]': 'enum',\n}\n\nexport function isVectorType(type: unknown): type is Vector {\n  return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type)\n}\n\nexport function isArrayType(type: unknown): type is ArraySearchableType {\n  return typeof type === 'string' && IS_ARRAY_TYPE[type]\n}\n\nexport function getInnerType(type: ArraySearchableType): ScalarSearchableType {\n  return INNER_TYPE[type]\n}\n\nexport function getVectorSize(type: string): number {\n  const size = Number(type.slice(7, -1))\n\n  switch (true) {\n    case isNaN(size):\n      throw createError('INVALID_VECTOR_VALUE', type)\n    case size <= 0:\n      throw createError('INVALID_VECTOR_SIZE', type)\n    default:\n      return size\n  }\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ;AAW5B,SAASC,iBAAiB,EAAEC,QAAQ,QAAQ;AAE5C,SAASC,qBAAqB,QAAQ;AAEtC,OAAO,eAAeC,kBAAkBC,CAAS,EAAwB;EACvE,OAAO;IACLC,GAAA,EAAKC,MAAA,CAAOF,CAAA;IACZG,SAAA,EAAW,MAAMP,iBAAA,CAAkBI,CAAA;EACrC;AACF;AAEA,OAAO,eAAeI,mBAAmBC,GAAgB,EAAmB;EAC1E,IAAIA,GAAA,CAAIC,EAAE,EAAE;IACV,IAAI,OAAOD,GAAA,CAAIC,EAAE,KAAK,UAAU;MAC9B,MAAMX,WAAA,CAAY,8BAA8B,OAAOU,GAAA,CAAIC,EAAE;IAC/D;IAEA,OAAOD,GAAA,CAAIC,EAAE;EACf;EAEA,OAAO,MAAMT,QAAA;AACf;AAEA,OAAO,eAAeU,eACpBF,GAAmB,EACnBG,MAAmB,EACU;EAC7B,KAAK,MAAM,CAACC,IAAA,EAAMC,IAAA,CAAK,IAAIC,MAAA,CAAOC,OAAO,CAACJ,MAAA,GAAS;IACjD,MAAMK,KAAA,GAAQR,GAAG,CAACI,IAAA,CAAK;IAEvB,IAAI,OAAOI,KAAA,KAAU,aAAa;MAChC;IACF;IAEA,IAAIH,IAAA,KAAS,WAAW,OAAOG,KAAA,KAAU,YAAY,OAAOA,KAAA,KAAU,QAAO,GAAI;MAC/E;IACF;IACA,IAAIH,IAAA,KAAS,YAAYI,KAAA,CAAMC,OAAO,CAACF,KAAA,GAAQ;MAC7C,MAAMG,WAAA,GAAcH,KAAA,CAAMI,MAAM;MAChC,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,WAAA,EAAaE,CAAA,IAAK;QACpC,IAAI,OAAOL,KAAK,CAACK,CAAA,CAAE,KAAK,YAAY,OAAOL,KAAK,CAACK,CAAA,CAAE,KAAK,UAAU;UAChE,OAAOT,IAAA,GAAO,MAAMS,CAAA;QACtB;MACF;MACA;IACF;IAEA,IAAIC,YAAA,CAAaT,IAAA,GAAO;MACtB,MAAMU,UAAA,GAAaC,aAAA,CAAcX,IAAA;MACjC,IAAI,CAACI,KAAA,CAAMC,OAAO,CAACF,KAAA,KAAUA,KAAA,CAAMI,MAAM,KAAKG,UAAA,EAAY;QACxD,MAAMzB,WAAA,CAAY,wBAAwBc,IAAA,EAAMW,UAAA,EAAYP,KAAA,CAAMI,MAAM;MAC1E;MACA;IACF;IAEA,IAAIK,WAAA,CAAYZ,IAAA,GAAO;MACrB,IAAI,CAACI,KAAA,CAAMC,OAAO,CAACF,KAAA,GAAQ;QACzB,OAAOJ,IAAA;MACT;MACA,MAAMc,YAAA,GAAeC,YAAA,CAAad,IAAA;MAElC,MAAMM,WAAA,GAAcH,KAAA,CAAMI,MAAM;MAChC,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,WAAA,EAAaE,CAAA,IAAK;QACpC,IAAI,OAAOL,KAAK,CAACK,CAAA,CAAE,KAAKK,YAAA,EAAc;UACpC,OAAOd,IAAA,GAAO,MAAMS,CAAA;QACtB;MACF;MAEA;IACF;IAEA,IAAI,OAAOR,IAAA,KAAS,UAAU;MAC5B,IAAI,CAACG,KAAA,IAAS,OAAOA,KAAA,KAAU,UAAU;QACvC,OAAOJ,IAAA;MACT;MAEA;MACA,MAAMgB,OAAA,GAAU,MAAMlB,cAAA,CAAeM,KAAA,EAAyBH,IAAA;MAC9D,IAAIe,OAAA,EAAS;QACX,OAAOhB,IAAA,GAAO,MAAMgB,OAAA;MACtB;MACA;IACF;IAEA,IAAI,OAAOZ,KAAA,KAAUH,IAAA,EAAM;MACzB,OAAOD,IAAA;IACT;EACF;EAEA,OAAOiB,SAAA;AACT;AAEA,MAAMC,aAAA,GAAiD;EACrDC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACbC,OAAA,EAAS,KAAK;EACdC,IAAA,EAAM,KAAK;EACX,YAAY,IAAI;EAChB,YAAY,IAAI;EAChB,aAAa,IAAI;EACjB,UAAU;AACZ;AAEA,MAAMC,UAAA,GAAgE;EACpE,YAAY;EACZ,YAAY;EACZ,aAAa;EACb,UAAU;AACZ;AAEA,OAAO,SAASb,aAAaT,IAAa,EAAkB;EAC1D,OAAO,OAAOA,IAAA,KAAS,YAAY,kBAAkBuB,IAAI,CAACvB,IAAA;AAC5D;AAEA,OAAO,SAASY,YAAYZ,IAAa,EAA+B;EACtE,OAAO,OAAOA,IAAA,KAAS,YAAYiB,aAAa,CAACjB,IAAA,CAAK;AACxD;AAEA,OAAO,SAASc,aAAad,IAAyB,EAAwB;EAC5E,OAAOsB,UAAU,CAACtB,IAAA,CAAK;AACzB;AAEA,OAAO,SAASW,cAAcX,IAAY,EAAU;EAClD,MAAMwB,IAAA,GAAOhC,MAAA,CAAOQ,IAAA,CAAKyB,KAAK,CAAC,GAAG,CAAC;EAEnC,QAAQ,IAAI;IACV,KAAKC,KAAA,CAAMF,IAAA;MACT,MAAMvC,WAAA,CAAY,wBAAwBe,IAAA;IAC5C,KAAKwB,IAAA,IAAQ;MACX,MAAMvC,WAAA,CAAY,uBAAuBe,IAAA;IAC3C;MACE,OAAOwB,IAAA;EACX;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}