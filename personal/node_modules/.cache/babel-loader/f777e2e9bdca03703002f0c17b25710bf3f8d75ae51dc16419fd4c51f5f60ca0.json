{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Bone, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Color, Object3D, MeshPhongMaterial } from \"three\";\nvar AssimpLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(AssimpLoader, _Loader);\n  var _super = _createSuper(AssimpLoader);\n  function AssimpLoader() {\n    _classCallCheck(this, AssimpLoader);\n    return _super.apply(this, arguments);\n  }\n  _createClass(AssimpLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(buffer, path) {\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var Virtulous = {};\n      Virtulous.KeyFrame = /*#__PURE__*/function () {\n        function _class(time, matrix) {\n          _classCallCheck(this, _class);\n          this.time = time;\n          this.matrix = matrix.clone();\n          this.position = new Vector3();\n          this.quaternion = new Quaternion();\n          this.scale = new Vector3(1, 1, 1);\n          this.matrix.decompose(this.position, this.quaternion, this.scale);\n          this.clone = function () {\n            var n = new Virtulous.KeyFrame(this.time, this.matrix);\n            return n;\n          };\n          this.lerp = function (nextKey, time2) {\n            time2 -= this.time;\n            var dist = nextKey.time - this.time;\n            var l = time2 / dist;\n            var l2 = 1 - l;\n            var keypos = this.position;\n            var keyrot = this.quaternion;\n            var key2pos = nextKey.position;\n            var key2rot = nextKey.quaternion;\n            Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n            Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n            Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n            Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n            Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n            return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n          };\n        }\n        return _createClass(_class);\n      }();\n      Virtulous.KeyFrame.tempAniPos = new Vector3();\n      Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n      Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n      Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n      Virtulous.KeyFrameTrack = function () {\n        this.keys = [];\n        this.target = null;\n        this.time = 0;\n        this.length = 0;\n        this._accelTable = {};\n        this.fps = 20;\n        this.addKey = function (key) {\n          this.keys.push(key);\n        };\n        this.init = function () {\n          this.sortKeys();\n          if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n          if (!this.fps) return;\n          for (var j = 0; j < this.length * this.fps; j++) {\n            for (var i = 0; i < this.keys.length; i++) {\n              if (this.keys[i].time == j) {\n                this._accelTable[j] = i;\n                break;\n              } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n                this._accelTable[j] = i;\n                break;\n              }\n            }\n          }\n        };\n        this.parseFromThree = function (data) {\n          var fps = data.fps;\n          this.target = data.node;\n          var track = data.hierarchy[0].keys;\n          for (var i = 0; i < track.length; i++) {\n            this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n          }\n          this.init();\n        };\n        this.parseFromCollada = function (data) {\n          var track = data.keys;\n          var fps = this.fps;\n          for (var i = 0; i < track.length; i++) {\n            this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n          }\n          this.init();\n        };\n        this.sortKeys = function () {\n          this.keys.sort(this.keySortFunc);\n        };\n        this.keySortFunc = function (a, b) {\n          return a.time - b.time;\n        };\n        this.clone = function () {\n          var t = new Virtulous.KeyFrameTrack();\n          t.target = this.target;\n          t.time = this.time;\n          t.length = this.length;\n          for (var i = 0; i < this.keys.length; i++) {\n            t.addKey(this.keys[i].clone());\n          }\n          t.init();\n          return t;\n        };\n        this.reTarget = function (root, compareitor) {\n          if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n          this.target = compareitor(root, this.target);\n        };\n        this.keySearchAccel = function (time) {\n          time *= this.fps;\n          time = Math.floor(time);\n          return this._accelTable[time] || 0;\n        };\n        this.setTime = function (time) {\n          time = Math.abs(time);\n          if (this.length) time = time % this.length + 0.05;\n          var key0 = null;\n          var key1 = null;\n          for (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\n            if (this.keys[i].time == time) {\n              key0 = this.keys[i];\n              key1 = this.keys[i];\n              break;\n            } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n              key0 = this.keys[i];\n              key1 = this.keys[i + 1];\n              break;\n            } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n              key0 = this.keys[i];\n              key1 = this.keys[0].clone();\n              key1.time += this.length + 0.05;\n              break;\n            }\n          }\n          if (key0 && key1 && key0 !== key1) {\n            this.target.matrixAutoUpdate = false;\n            this.target.matrix.copy(key0.lerp(key1, time));\n            this.target.matrixWorldNeedsUpdate = true;\n            return;\n          }\n          if (key0 && key1 && key0 == key1) {\n            this.target.matrixAutoUpdate = false;\n            this.target.matrix.copy(key0.matrix);\n            this.target.matrixWorldNeedsUpdate = true;\n            return;\n          }\n        };\n      };\n      Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n        function find(node, name) {\n          if (node.name == name) return node;\n          for (var i = 0; i < node.children.length; i++) {\n            var r = find(node.children[i], name);\n            if (r) return r;\n          }\n          return null;\n        }\n        return find(root, target.name);\n      };\n      Virtulous.Animation = function () {\n        this.tracks = [];\n        this.length = 0;\n        this.addTrack = function (track) {\n          this.tracks.push(track);\n          this.length = Math.max(track.length, this.length);\n        };\n        this.setTime = function (time) {\n          this.time = time;\n          for (var i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\n        };\n        this.clone = function (target, compareitor) {\n          if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n          var n = new Virtulous.Animation();\n          n.target = target;\n          for (var i = 0; i < this.tracks.length; i++) {\n            var track = this.tracks[i].clone();\n            track.reTarget(target, compareitor);\n            n.addTrack(track);\n          }\n          return n;\n        };\n      };\n      var ASSBIN_CHUNK_AICAMERA = 4660;\n      var ASSBIN_CHUNK_AILIGHT = 4661;\n      var ASSBIN_CHUNK_AITEXTURE = 4662;\n      var ASSBIN_CHUNK_AIMESH = 4663;\n      var ASSBIN_CHUNK_AINODEANIM = 4664;\n      var ASSBIN_CHUNK_AISCENE = 4665;\n      var ASSBIN_CHUNK_AIBONE = 4666;\n      var ASSBIN_CHUNK_AIANIMATION = 4667;\n      var ASSBIN_CHUNK_AINODE = 4668;\n      var ASSBIN_CHUNK_AIMATERIAL = 4669;\n      var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;\n      var ASSBIN_MESH_HAS_POSITIONS = 1;\n      var ASSBIN_MESH_HAS_NORMALS = 2;\n      var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;\n      var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;\n      var ASSBIN_MESH_HAS_COLOR_BASE = 65536;\n      var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n      var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n      //! A directional light source has a well-defined direction\n      //! but is infinitely far away. That's quite a good\n      //! approximation for sun light.\n      var aiLightSource_DIRECTIONAL = 1;\n      //! A point light source has a well-defined position\n      //! in space but no direction - it emits light in all\n      //! directions. A normal bulb is a point light.\n      //! A spot light source emits light in a specific\n      //! angle. It has a position and a direction it is pointing to.\n      //! A good example for a spot light is a light spot in\n      //! sport arenas.\n      var aiLightSource_SPOT = 3;\n      //! The generic light level of the world, including the bounces\n      //! of all other lightsources.\n      //! Typically, there's at most one ambient light in a scene.\n      //! This light type doesn't have a valid position, direction, or\n      //! other properties, just a color.\n      var aiTextureType_DIFFUSE = 1;\n      var aiTextureType_NORMALS = 6;\n      var aiTextureType_OPACITY = 8;\n      var aiTextureType_LIGHTMAP = 10;\n      var BONESPERVERT = 4;\n      function ASSBIN_MESH_HAS_TEXCOORD(n) {\n        return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n      }\n      function ASSBIN_MESH_HAS_COLOR(n) {\n        return ASSBIN_MESH_HAS_COLOR_BASE << n;\n      }\n      function markBones(scene) {\n        for (var i in scene.mMeshes) {\n          var mesh = scene.mMeshes[i];\n          for (var k in mesh.mBones) {\n            var boneNode = scene.findNode(mesh.mBones[k].mName);\n            if (boneNode) boneNode.isBone = true;\n          }\n        }\n      }\n      function cloneTreeToBones(root, scene) {\n        var rootBone = new Bone();\n        rootBone.matrix.copy(root.matrix);\n        rootBone.matrixWorld.copy(root.matrixWorld);\n        rootBone.position.copy(root.position);\n        rootBone.quaternion.copy(root.quaternion);\n        rootBone.scale.copy(root.scale);\n        scene.nodeCount++;\n        rootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n        if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n        scene.nodeToBoneMap[root.name].push(rootBone);\n        for (var i in root.children) {\n          var child = cloneTreeToBones(root.children[i], scene);\n          rootBone.add(child);\n        }\n        return rootBone;\n      }\n      function sortWeights(indexes, weights) {\n        var pairs = [];\n        for (var i = 0; i < indexes.length; i++) {\n          pairs.push({\n            i: indexes[i],\n            w: weights[i]\n          });\n        }\n        pairs.sort(function (a, b) {\n          return b.w - a.w;\n        });\n        while (pairs.length < 4) {\n          pairs.push({\n            i: 0,\n            w: 0\n          });\n        }\n        if (pairs.length > 4) pairs.length = 4;\n        var sum = 0;\n        for (var _i = 0; _i < 4; _i++) {\n          sum += pairs[_i].w * pairs[_i].w;\n        }\n        sum = Math.sqrt(sum);\n        for (var _i2 = 0; _i2 < 4; _i2++) {\n          pairs[_i2].w = pairs[_i2].w / sum;\n          indexes[_i2] = pairs[_i2].i;\n          weights[_i2] = pairs[_i2].w;\n        }\n      }\n      function findMatchingBone(root, name) {\n        if (root.name.indexOf(\"bone_\" + name) == 0) return root;\n        for (var i in root.children) {\n          var ret = findMatchingBone(root.children[i], name);\n          if (ret) return ret;\n        }\n        return void 0;\n      }\n      var aiMesh = /*#__PURE__*/_createClass(function aiMesh() {\n        _classCallCheck(this, aiMesh);\n        this.mPrimitiveTypes = 0;\n        this.mNumVertices = 0;\n        this.mNumFaces = 0;\n        this.mNumBones = 0;\n        this.mMaterialIndex = 0;\n        this.mVertices = [];\n        this.mNormals = [];\n        this.mTangents = [];\n        this.mBitangents = [];\n        this.mColors = [[]];\n        this.mTextureCoords = [[]];\n        this.mFaces = [];\n        this.mBones = [];\n        this.hookupSkeletons = function (scene) {\n          if (this.mBones.length == 0) return;\n          var allBones = [];\n          var offsetMatrix = [];\n          var skeletonRoot = scene.findNode(this.mBones[0].mName);\n          while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n            skeletonRoot = skeletonRoot.mParent;\n          }\n          var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n          var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n          this.threeNode.add(threeSkeletonRootBone);\n          for (var i = 0; i < this.mBones.length; i++) {\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            if (bone) {\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            } else {\n              var skeletonRoot = scene.findNode(this.mBones[i].mName);\n              if (!skeletonRoot) return;\n              var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n              var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n              this.threeNode.add(threeSkeletonRootBone);\n              var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            }\n          }\n          var skeleton = new Skeleton(allBones, offsetMatrix);\n          this.threeNode.bind(skeleton, new Matrix4());\n          this.threeNode.material.skinning = true;\n        };\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode;\n          var geometry = new BufferGeometry();\n          var mat;\n          if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n          geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n          geometry.setAttribute(\"position\", new BufferAttribute(this.mVertexBuffer, 3));\n          if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n            geometry.setAttribute(\"normal\", new BufferAttribute(this.mNormalBuffer, 3));\n          }\n          if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n            geometry.setAttribute(\"color\", new BufferAttribute(this.mColorBuffer, 4));\n          }\n          if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n            geometry.setAttribute(\"uv\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n          }\n          if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n            geometry.setAttribute(\"uv1\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n          }\n          if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n            geometry.setAttribute(\"tangents\", new BufferAttribute(this.mTangentBuffer, 3));\n          }\n          if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n            geometry.setAttribute(\"bitangents\", new BufferAttribute(this.mBitangentBuffer, 3));\n          }\n          if (this.mBones.length > 0) {\n            var weights = [];\n            var bones = [];\n            for (var i = 0; i < this.mBones.length; i++) {\n              for (var j = 0; j < this.mBones[i].mWeights.length; j++) {\n                var weight = this.mBones[i].mWeights[j];\n                if (weight) {\n                  if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                  if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                  weights[weight.mVertexId].push(weight.mWeight);\n                  bones[weight.mVertexId].push(parseInt(i));\n                }\n              }\n            }\n            for (var _i3 in bones) {\n              sortWeights(bones[_i3], weights[_i3]);\n            }\n            var _weights = [];\n            var _bones = [];\n            for (var _i4 = 0; _i4 < weights.length; _i4++) {\n              for (var _j = 0; _j < 4; _j++) {\n                if (weights[_i4] && bones[_i4]) {\n                  _weights.push(weights[_i4][_j]);\n                  _bones.push(bones[_i4][_j]);\n                } else {\n                  _weights.push(0);\n                  _bones.push(0);\n                }\n              }\n            }\n            geometry.setAttribute(\"skinWeight\", new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n            geometry.setAttribute(\"skinIndex\", new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n          }\n          var mesh;\n          if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n          if (this.mBones.length > 0) {\n            mesh = new SkinnedMesh(geometry, mat);\n            mesh.normalizeSkinWeights();\n          }\n          this.threeNode = mesh;\n          return mesh;\n        };\n      });\n      var aiFace = /*#__PURE__*/_createClass(function aiFace() {\n        _classCallCheck(this, aiFace);\n        this.mNumIndices = 0;\n        this.mIndices = [];\n      });\n      var aiVector3D = /*#__PURE__*/_createClass(function aiVector3D() {\n        _classCallCheck(this, aiVector3D);\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.toTHREE = function () {\n          return new Vector3(this.x, this.y, this.z);\n        };\n      });\n      var aiColor3D = /*#__PURE__*/_createClass(function aiColor3D() {\n        _classCallCheck(this, aiColor3D);\n        this.r = 0;\n        this.g = 0;\n        this.b = 0;\n        this.a = 0;\n        this.toTHREE = function () {\n          return new Color(this.r, this.g, this.b);\n        };\n      });\n      var aiQuaternion = /*#__PURE__*/_createClass(function aiQuaternion() {\n        _classCallCheck(this, aiQuaternion);\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n        this.toTHREE = function () {\n          return new Quaternion(this.x, this.y, this.z, this.w);\n        };\n      });\n      var aiVertexWeight = /*#__PURE__*/_createClass(function aiVertexWeight() {\n        _classCallCheck(this, aiVertexWeight);\n        this.mVertexId = 0;\n        this.mWeight = 0;\n      });\n      var aiString = /*#__PURE__*/_createClass(function aiString() {\n        _classCallCheck(this, aiString);\n        this.data = [];\n        this.toString = function () {\n          var str = \"\";\n          this.data.forEach(function (i) {\n            str += String.fromCharCode(i);\n          });\n          return str.replace(/[^\\x20-\\x7E]+/g, \"\");\n        };\n      });\n      var aiVectorKey = /*#__PURE__*/_createClass(function aiVectorKey() {\n        _classCallCheck(this, aiVectorKey);\n        this.mTime = 0;\n        this.mValue = null;\n      });\n      var aiQuatKey = /*#__PURE__*/_createClass(function aiQuatKey() {\n        _classCallCheck(this, aiQuatKey);\n        this.mTime = 0;\n        this.mValue = null;\n      });\n      var aiNode = /*#__PURE__*/_createClass(function aiNode() {\n        _classCallCheck(this, aiNode);\n        this.mName = \"\";\n        this.mTransformation = [];\n        this.mNumChildren = 0;\n        this.mNumMeshes = 0;\n        this.mMeshes = [];\n        this.mChildren = [];\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode;\n          var o = new Object3D();\n          o.name = this.mName;\n          o.matrix = this.mTransformation.toTHREE();\n          for (var i = 0; i < this.mChildren.length; i++) {\n            o.add(this.mChildren[i].toTHREE(scene));\n          }\n          for (var _i5 = 0; _i5 < this.mMeshes.length; _i5++) {\n            o.add(scene.mMeshes[this.mMeshes[_i5]].toTHREE(scene));\n          }\n          this.threeNode = o;\n          o.matrix.decompose(o.position, o.quaternion, o.scale);\n          return o;\n        };\n      });\n      var aiBone = /*#__PURE__*/_createClass(function aiBone() {\n        _classCallCheck(this, aiBone);\n        this.mName = \"\";\n        this.mNumWeights = 0;\n        this.mOffsetMatrix = 0;\n      });\n      var aiMaterialProperty = /*#__PURE__*/_createClass(function aiMaterialProperty() {\n        _classCallCheck(this, aiMaterialProperty);\n        this.mKey = \"\";\n        this.mSemantic = 0;\n        this.mIndex = 0;\n        this.mData = [];\n        this.mDataLength = 0;\n        this.mType = 0;\n        this.dataAsColor = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          var g = reader.getFloat32(4, true);\n          var b = reader.getFloat32(8, true);\n          return new Color(r, g, b);\n        };\n        this.dataAsFloat = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return r;\n        };\n        this.dataAsBool = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return !!r;\n        };\n        this.dataAsString = function () {\n          var s = new aiString();\n          s.data = this.mData;\n          return s.toString();\n        };\n        this.dataAsMap = function () {\n          var s = new aiString();\n          s.data = this.mData;\n          var path2 = s.toString();\n          path2 = path2.replace(/\\\\/g, \"/\");\n          if (path2.indexOf(\"/\") != -1) {\n            path2 = path2.substr(path2.lastIndexOf(\"/\") + 1);\n          }\n          return textureLoader.load(path2);\n        };\n      });\n      var namePropMapping = {\n        \"?mat.name\": \"name\",\n        \"$mat.shadingm\": \"shading\",\n        \"$mat.twosided\": \"twoSided\",\n        \"$mat.wireframe\": \"wireframe\",\n        \"$clr.ambient\": \"ambient\",\n        \"$clr.diffuse\": \"color\",\n        \"$clr.specular\": \"specular\",\n        \"$clr.emissive\": \"emissive\",\n        \"$clr.transparent\": \"transparent\",\n        \"$clr.reflective\": \"reflect\",\n        \"$mat.shininess\": \"shininess\",\n        \"$mat.reflectivity\": \"reflectivity\",\n        \"$mat.refracti\": \"refraction\",\n        \"$tex.file\": \"map\"\n      };\n      var nameTypeMapping = {\n        \"?mat.name\": \"string\",\n        \"$mat.shadingm\": \"bool\",\n        \"$mat.twosided\": \"bool\",\n        \"$mat.wireframe\": \"bool\",\n        \"$clr.ambient\": \"color\",\n        \"$clr.diffuse\": \"color\",\n        \"$clr.specular\": \"color\",\n        \"$clr.emissive\": \"color\",\n        \"$clr.transparent\": \"color\",\n        \"$clr.reflective\": \"color\",\n        \"$mat.shininess\": \"float\",\n        \"$mat.reflectivity\": \"float\",\n        \"$mat.refracti\": \"float\",\n        \"$tex.file\": \"map\"\n      };\n      var aiMaterial = /*#__PURE__*/_createClass(function aiMaterial() {\n        _classCallCheck(this, aiMaterial);\n        this.mNumAllocated = 0;\n        this.mNumProperties = 0;\n        this.mProperties = [];\n        this.toTHREE = function () {\n          var mat = new MeshPhongMaterial();\n          for (var i = 0; i < this.mProperties.length; i++) {\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"float\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"color\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"bool\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"string\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"map\") {\n              var prop = this.mProperties[i];\n              if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n            }\n          }\n          mat.ambient.r = 0.53;\n          mat.ambient.g = 0.53;\n          mat.ambient.b = 0.53;\n          mat.color.r = 1;\n          mat.color.g = 1;\n          mat.color.b = 1;\n          return mat;\n        };\n      });\n      function veclerp(v1, v2, l) {\n        var v = new Vector3();\n        var lm1 = 1 - l;\n        v.x = v1.x * l + v2.x * lm1;\n        v.y = v1.y * l + v2.y * lm1;\n        v.z = v1.z * l + v2.z * lm1;\n        return v;\n      }\n      function quatlerp(q1, q2, l) {\n        return q1.clone().slerp(q2, 1 - l);\n      }\n      function sampleTrack(keys, time, lne, lerp) {\n        if (keys.length == 1) return keys[0].mValue.toTHREE();\n        var dist = Infinity;\n        var key = null;\n        var nextKey = null;\n        for (var i = 0; i < keys.length; i++) {\n          var timeDist = Math.abs(keys[i].mTime - time);\n          if (timeDist < dist && keys[i].mTime <= time) {\n            dist = timeDist;\n            key = keys[i];\n            nextKey = keys[i + 1];\n          }\n        }\n        if (!key) {\n          return null;\n        } else if (nextKey) {\n          var dT = nextKey.mTime - key.mTime;\n          var T = key.mTime - time;\n          var l = T / dT;\n          return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n        } else {\n          nextKey = keys[0].clone();\n          nextKey.mTime += lne;\n          var dT = nextKey.mTime - key.mTime;\n          var T = key.mTime - time;\n          var l = T / dT;\n          return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n        }\n      }\n      var aiNodeAnim = /*#__PURE__*/_createClass(function aiNodeAnim() {\n        _classCallCheck(this, aiNodeAnim);\n        this.mNodeName = \"\";\n        this.mNumPositionKeys = 0;\n        this.mNumRotationKeys = 0;\n        this.mNumScalingKeys = 0;\n        this.mPositionKeys = [];\n        this.mRotationKeys = [];\n        this.mScalingKeys = [];\n        this.mPreState = \"\";\n        this.mPostState = \"\";\n        this.init = function (tps) {\n          if (!tps) tps = 1;\n          function t(t2) {\n            t2.mTime /= tps;\n          }\n          this.mPositionKeys.forEach(t);\n          this.mRotationKeys.forEach(t);\n          this.mScalingKeys.forEach(t);\n        };\n        this.sortKeys = function () {\n          function comp(a, b) {\n            return a.mTime - b.mTime;\n          }\n          this.mPositionKeys.sort(comp);\n          this.mRotationKeys.sort(comp);\n          this.mScalingKeys.sort(comp);\n        };\n        this.getLength = function () {\n          return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n            return a.mTime;\n          })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n            return a.mTime;\n          })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n            return a.mTime;\n          })));\n        };\n        this.toTHREE = function (o) {\n          this.sortKeys();\n          var length = this.getLength();\n          var track = new Virtulous.KeyFrameTrack();\n          for (var i = 0; i < length; i += 0.05) {\n            var matrix = new Matrix4();\n            var time = i;\n            var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n            var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n            var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n            matrix.compose(pos, rotation, scale);\n            var key = new Virtulous.KeyFrame(time, matrix);\n            track.addKey(key);\n          }\n          track.target = o.findNode(this.mNodeName).toTHREE();\n          var tracks = [track];\n          if (o.nodeToBoneMap[this.mNodeName]) {\n            for (var _i6 = 0; _i6 < o.nodeToBoneMap[this.mNodeName].length; _i6++) {\n              var t2 = track.clone();\n              t2.target = o.nodeToBoneMap[this.mNodeName][_i6];\n              tracks.push(t2);\n            }\n          }\n          return tracks;\n        };\n      });\n      var aiAnimation = /*#__PURE__*/_createClass(function aiAnimation() {\n        _classCallCheck(this, aiAnimation);\n        this.mName = \"\";\n        this.mDuration = 0;\n        this.mTicksPerSecond = 0;\n        this.mNumChannels = 0;\n        this.mChannels = [];\n        this.toTHREE = function (root) {\n          var animationHandle = new Virtulous.Animation();\n          for (var i in this.mChannels) {\n            this.mChannels[i].init(this.mTicksPerSecond);\n            var tracks = this.mChannels[i].toTHREE(root);\n            for (var j in tracks) {\n              tracks[j].init();\n              animationHandle.addTrack(tracks[j]);\n            }\n          }\n          animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n            return e.length;\n          }));\n          return animationHandle;\n        };\n      });\n      var aiTexture = /*#__PURE__*/_createClass(function aiTexture() {\n        _classCallCheck(this, aiTexture);\n        this.mWidth = 0;\n        this.mHeight = 0;\n        this.texAchFormatHint = [];\n        this.pcData = [];\n      });\n      var aiLight = /*#__PURE__*/_createClass(function aiLight() {\n        _classCallCheck(this, aiLight);\n        this.mName = \"\";\n        this.mType = 0;\n        this.mAttenuationConstant = 0;\n        this.mAttenuationLinear = 0;\n        this.mAttenuationQuadratic = 0;\n        this.mAngleInnerCone = 0;\n        this.mAngleOuterCone = 0;\n        this.mColorDiffuse = null;\n        this.mColorSpecular = null;\n        this.mColorAmbient = null;\n      });\n      var aiCamera = /*#__PURE__*/_createClass(function aiCamera() {\n        _classCallCheck(this, aiCamera);\n        this.mName = \"\";\n        this.mPosition = null;\n        this.mLookAt = null;\n        this.mUp = null;\n        this.mHorizontalFOV = 0;\n        this.mClipPlaneNear = 0;\n        this.mClipPlaneFar = 0;\n        this.mAspect = 0;\n      });\n      var aiScene = /*#__PURE__*/_createClass(function aiScene() {\n        _classCallCheck(this, aiScene);\n        this.versionMajor = 0;\n        this.versionMinor = 0;\n        this.versionRevision = 0;\n        this.compileFlags = 0;\n        this.mFlags = 0;\n        this.mNumMeshes = 0;\n        this.mNumMaterials = 0;\n        this.mNumAnimations = 0;\n        this.mNumTextures = 0;\n        this.mNumLights = 0;\n        this.mNumCameras = 0;\n        this.mRootNode = null;\n        this.mMeshes = [];\n        this.mMaterials = [];\n        this.mAnimations = [];\n        this.mLights = [];\n        this.mCameras = [];\n        this.nodeToBoneMap = {};\n        this.findNode = function (name, root) {\n          if (!root) {\n            root = this.mRootNode;\n          }\n          if (root.mName == name) {\n            return root;\n          }\n          for (var i = 0; i < root.mChildren.length; i++) {\n            var ret = this.findNode(name, root.mChildren[i]);\n            if (ret) return ret;\n          }\n          return null;\n        };\n        this.toTHREE = function () {\n          this.nodeCount = 0;\n          markBones(this);\n          var o = this.mRootNode.toTHREE(this);\n          for (var i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\n          if (this.mAnimations.length > 0) {\n            var a = this.mAnimations[0].toTHREE(this);\n          }\n          return {\n            object: o,\n            animation: a\n          };\n        };\n      });\n      var aiMatrix4 = /*#__PURE__*/_createClass(function aiMatrix4() {\n        _classCallCheck(this, aiMatrix4);\n        this.elements = [[], [], [], []];\n        this.toTHREE = function () {\n          var m = new Matrix4();\n          for (var i = 0; i < 4; ++i) {\n            for (var i2 = 0; i2 < 4; ++i2) {\n              m.elements[i * 4 + i2] = this.elements[i2][i];\n            }\n          }\n          return m;\n        };\n      });\n      var littleEndian = true;\n      function readFloat(dataview) {\n        var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n        dataview.readOffset += 4;\n        return val;\n      }\n      function Read_double(dataview) {\n        var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n        dataview.readOffset += 8;\n        return val;\n      }\n      function Read_uint8_t(dataview) {\n        var val = dataview.getUint8(dataview.readOffset);\n        dataview.readOffset += 1;\n        return val;\n      }\n      function Read_uint16_t(dataview) {\n        var val = dataview.getUint16(dataview.readOffset, littleEndian);\n        dataview.readOffset += 2;\n        return val;\n      }\n      function Read_unsigned_int(dataview) {\n        var val = dataview.getUint32(dataview.readOffset, littleEndian);\n        dataview.readOffset += 4;\n        return val;\n      }\n      function Read_uint32_t(dataview) {\n        var val = dataview.getUint32(dataview.readOffset, littleEndian);\n        dataview.readOffset += 4;\n        return val;\n      }\n      function Read_aiVector3D(stream) {\n        var v = new aiVector3D();\n        v.x = readFloat(stream);\n        v.y = readFloat(stream);\n        v.z = readFloat(stream);\n        return v;\n      }\n      function Read_aiColor3D(stream) {\n        var c = new aiColor3D();\n        c.r = readFloat(stream);\n        c.g = readFloat(stream);\n        c.b = readFloat(stream);\n        return c;\n      }\n      function Read_aiQuaternion(stream) {\n        var v = new aiQuaternion();\n        v.w = readFloat(stream);\n        v.x = readFloat(stream);\n        v.y = readFloat(stream);\n        v.z = readFloat(stream);\n        return v;\n      }\n      function Read_aiString(stream) {\n        var s = new aiString();\n        var stringlengthbytes = Read_unsigned_int(stream);\n        stream.ReadBytes(s.data, 1, stringlengthbytes);\n        return s.toString();\n      }\n      function Read_aiVertexWeight(stream) {\n        var w = new aiVertexWeight();\n        w.mVertexId = Read_unsigned_int(stream);\n        w.mWeight = readFloat(stream);\n        return w;\n      }\n      function Read_aiMatrix4x4(stream) {\n        var m = new aiMatrix4();\n        for (var i = 0; i < 4; ++i) {\n          for (var i2 = 0; i2 < 4; ++i2) {\n            m.elements[i][i2] = readFloat(stream);\n          }\n        }\n        return m;\n      }\n      function Read_aiVectorKey(stream) {\n        var v = new aiVectorKey();\n        v.mTime = Read_double(stream);\n        v.mValue = Read_aiVector3D(stream);\n        return v;\n      }\n      function Read_aiQuatKey(stream) {\n        var v = new aiQuatKey();\n        v.mTime = Read_double(stream);\n        v.mValue = Read_aiQuaternion(stream);\n        return v;\n      }\n      function ReadArray_aiVertexWeight(stream, data, size) {\n        for (var i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\n      }\n      function ReadArray_aiVectorKey(stream, data, size) {\n        for (var i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\n      }\n      function ReadArray_aiQuatKey(stream, data, size) {\n        for (var i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\n      }\n      function ReadBounds(stream, T, n) {\n        return stream.Seek(sizeof(T) * n, aiOrigin_CUR);\n      }\n      function ai_assert(bool) {\n        if (!bool) throw \"asset failed\";\n      }\n      function ReadBinaryNode(stream, parent, depth) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n        Read_uint32_t(stream);\n        var node = new aiNode();\n        node.mParent = parent;\n        node.mDepth = depth;\n        node.mName = Read_aiString(stream);\n        node.mTransformation = Read_aiMatrix4x4(stream);\n        node.mNumChildren = Read_unsigned_int(stream);\n        node.mNumMeshes = Read_unsigned_int(stream);\n        if (node.mNumMeshes) {\n          node.mMeshes = [];\n          for (var i = 0; i < node.mNumMeshes; ++i) {\n            node.mMeshes[i] = Read_unsigned_int(stream);\n          }\n        }\n        if (node.mNumChildren) {\n          node.mChildren = [];\n          for (var _i7 = 0; _i7 < node.mNumChildren; ++_i7) {\n            var node2 = ReadBinaryNode(stream, node, depth++);\n            node.mChildren[_i7] = node2;\n          }\n        }\n        return node;\n      }\n      function ReadBinaryBone(stream, b) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n        Read_uint32_t(stream);\n        b.mName = Read_aiString(stream);\n        b.mNumWeights = Read_unsigned_int(stream);\n        b.mOffsetMatrix = Read_aiMatrix4x4(stream);\n        if (shortened) {\n          ReadBounds(stream, b.mWeights, b.mNumWeights);\n        } else {\n          b.mWeights = [];\n          ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n        }\n        return b;\n      }\n      function ReadBinaryMesh(stream, mesh) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n        Read_uint32_t(stream);\n        mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n        mesh.mNumVertices = Read_unsigned_int(stream);\n        mesh.mNumFaces = Read_unsigned_int(stream);\n        mesh.mNumBones = Read_unsigned_int(stream);\n        mesh.mMaterialIndex = Read_unsigned_int(stream);\n        mesh.mNumUVComponents = [];\n        var c = Read_unsigned_int(stream);\n        if (c & ASSBIN_MESH_HAS_POSITIONS) {\n          if (shortened) {\n            ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n          } else {\n            mesh.mVertices = [];\n            mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          }\n        }\n        if (c & ASSBIN_MESH_HAS_NORMALS) {\n          if (shortened) {\n            ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n          } else {\n            mesh.mNormals = [];\n            mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          }\n        }\n        if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n          if (shortened) {\n            ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n            ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n          } else {\n            mesh.mTangents = [];\n            mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n            mesh.mBitangents = [];\n            mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          }\n        }\n        for (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n          if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n          if (shortened) {\n            ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n          } else {\n            mesh.mColors[n] = [];\n            mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n            stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n          }\n        }\n        mesh.mTexCoordsBuffers = [];\n        for (var _n = 0; _n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++_n) {\n          if (!(c & ASSBIN_MESH_HAS_TEXCOORD(_n))) break;\n          mesh.mNumUVComponents[_n] = Read_unsigned_int(stream);\n          if (shortened) {\n            ReadBounds(stream, mesh.mTextureCoords[_n], mesh.mNumVertices);\n          } else {\n            mesh.mTextureCoords[_n] = [];\n            mesh.mTexCoordsBuffers[_n] = [];\n            for (var uv = 0; uv < mesh.mNumVertices; uv++) {\n              mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n              mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n              readFloat(stream);\n            }\n          }\n        }\n        if (shortened) {\n          Read_unsigned_int(stream);\n        } else {\n          mesh.mFaces = [];\n          mesh.mIndexArray = [];\n          for (var i = 0; i < mesh.mNumFaces; ++i) {\n            var f = mesh.mFaces[i] = new aiFace();\n            f.mNumIndices = Read_uint16_t(stream);\n            f.mIndices = [];\n            for (var a = 0; a < f.mNumIndices; ++a) {\n              if (mesh.mNumVertices < 1 << 16) {\n                f.mIndices[a] = Read_uint16_t(stream);\n              } else {\n                f.mIndices[a] = Read_unsigned_int(stream);\n              }\n            }\n            if (f.mNumIndices === 3) {\n              mesh.mIndexArray.push(f.mIndices[0]);\n              mesh.mIndexArray.push(f.mIndices[1]);\n              mesh.mIndexArray.push(f.mIndices[2]);\n            } else if (f.mNumIndices === 4) {\n              mesh.mIndexArray.push(f.mIndices[0]);\n              mesh.mIndexArray.push(f.mIndices[1]);\n              mesh.mIndexArray.push(f.mIndices[2]);\n              mesh.mIndexArray.push(f.mIndices[2]);\n              mesh.mIndexArray.push(f.mIndices[3]);\n              mesh.mIndexArray.push(f.mIndices[0]);\n            } else {\n              throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n            }\n          }\n        }\n        if (mesh.mNumBones) {\n          mesh.mBones = [];\n          for (var _a = 0; _a < mesh.mNumBones; ++_a) {\n            mesh.mBones[_a] = new aiBone();\n            ReadBinaryBone(stream, mesh.mBones[_a]);\n          }\n        }\n      }\n      function ReadBinaryMaterialProperty(stream, prop) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n        Read_uint32_t(stream);\n        prop.mKey = Read_aiString(stream);\n        prop.mSemantic = Read_unsigned_int(stream);\n        prop.mIndex = Read_unsigned_int(stream);\n        prop.mDataLength = Read_unsigned_int(stream);\n        prop.mType = Read_unsigned_int(stream);\n        prop.mData = [];\n        stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n      }\n      function ReadBinaryMaterial(stream, mat) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n        Read_uint32_t(stream);\n        mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n        if (mat.mNumProperties) {\n          if (mat.mProperties) {\n            delete mat.mProperties;\n          }\n          mat.mProperties = [];\n          for (var i = 0; i < mat.mNumProperties; ++i) {\n            mat.mProperties[i] = new aiMaterialProperty();\n            ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n          }\n        }\n      }\n      function ReadBinaryNodeAnim(stream, nd) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n        Read_uint32_t(stream);\n        nd.mNodeName = Read_aiString(stream);\n        nd.mNumPositionKeys = Read_unsigned_int(stream);\n        nd.mNumRotationKeys = Read_unsigned_int(stream);\n        nd.mNumScalingKeys = Read_unsigned_int(stream);\n        nd.mPreState = Read_unsigned_int(stream);\n        nd.mPostState = Read_unsigned_int(stream);\n        if (nd.mNumPositionKeys) {\n          if (shortened) {\n            ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n          } else {\n            nd.mPositionKeys = [];\n            ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n          }\n        }\n        if (nd.mNumRotationKeys) {\n          if (shortened) {\n            ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n          } else {\n            nd.mRotationKeys = [];\n            ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n          }\n        }\n        if (nd.mNumScalingKeys) {\n          if (shortened) {\n            ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n          } else {\n            nd.mScalingKeys = [];\n            ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n          }\n        }\n      }\n      function ReadBinaryAnim(stream, anim) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n        Read_uint32_t(stream);\n        anim.mName = Read_aiString(stream);\n        anim.mDuration = Read_double(stream);\n        anim.mTicksPerSecond = Read_double(stream);\n        anim.mNumChannels = Read_unsigned_int(stream);\n        if (anim.mNumChannels) {\n          anim.mChannels = [];\n          for (var a = 0; a < anim.mNumChannels; ++a) {\n            anim.mChannels[a] = new aiNodeAnim();\n            ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n          }\n        }\n      }\n      function ReadBinaryTexture(stream, tex) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n        Read_uint32_t(stream);\n        tex.mWidth = Read_unsigned_int(stream);\n        tex.mHeight = Read_unsigned_int(stream);\n        stream.ReadBytes(tex.achFormatHint, 1, 4);\n        if (!shortened) {\n          if (!tex.mHeight) {\n            tex.pcData = [];\n            stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n          } else {\n            tex.pcData = [];\n            stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n          }\n        }\n      }\n      function ReadBinaryLight(stream, l) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n        Read_uint32_t(stream);\n        l.mName = Read_aiString(stream);\n        l.mType = Read_unsigned_int(stream);\n        if (l.mType != aiLightSource_DIRECTIONAL) {\n          l.mAttenuationConstant = readFloat(stream);\n          l.mAttenuationLinear = readFloat(stream);\n          l.mAttenuationQuadratic = readFloat(stream);\n        }\n        l.mColorDiffuse = Read_aiColor3D(stream);\n        l.mColorSpecular = Read_aiColor3D(stream);\n        l.mColorAmbient = Read_aiColor3D(stream);\n        if (l.mType == aiLightSource_SPOT) {\n          l.mAngleInnerCone = readFloat(stream);\n          l.mAngleOuterCone = readFloat(stream);\n        }\n      }\n      function ReadBinaryCamera(stream, cam) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n        Read_uint32_t(stream);\n        cam.mName = Read_aiString(stream);\n        cam.mPosition = Read_aiVector3D(stream);\n        cam.mLookAt = Read_aiVector3D(stream);\n        cam.mUp = Read_aiVector3D(stream);\n        cam.mHorizontalFOV = readFloat(stream);\n        cam.mClipPlaneNear = readFloat(stream);\n        cam.mClipPlaneFar = readFloat(stream);\n        cam.mAspect = readFloat(stream);\n      }\n      function ReadBinaryScene(stream, scene) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n        Read_uint32_t(stream);\n        scene.mFlags = Read_unsigned_int(stream);\n        scene.mNumMeshes = Read_unsigned_int(stream);\n        scene.mNumMaterials = Read_unsigned_int(stream);\n        scene.mNumAnimations = Read_unsigned_int(stream);\n        scene.mNumTextures = Read_unsigned_int(stream);\n        scene.mNumLights = Read_unsigned_int(stream);\n        scene.mNumCameras = Read_unsigned_int(stream);\n        scene.mRootNode = new aiNode();\n        scene.mRootNode = ReadBinaryNode(stream, null, 0);\n        if (scene.mNumMeshes) {\n          scene.mMeshes = [];\n          for (var i = 0; i < scene.mNumMeshes; ++i) {\n            scene.mMeshes[i] = new aiMesh();\n            ReadBinaryMesh(stream, scene.mMeshes[i]);\n          }\n        }\n        if (scene.mNumMaterials) {\n          scene.mMaterials = [];\n          for (var _i8 = 0; _i8 < scene.mNumMaterials; ++_i8) {\n            scene.mMaterials[_i8] = new aiMaterial();\n            ReadBinaryMaterial(stream, scene.mMaterials[_i8]);\n          }\n        }\n        if (scene.mNumAnimations) {\n          scene.mAnimations = [];\n          for (var _i9 = 0; _i9 < scene.mNumAnimations; ++_i9) {\n            scene.mAnimations[_i9] = new aiAnimation();\n            ReadBinaryAnim(stream, scene.mAnimations[_i9]);\n          }\n        }\n        if (scene.mNumTextures) {\n          scene.mTextures = [];\n          for (var _i10 = 0; _i10 < scene.mNumTextures; ++_i10) {\n            scene.mTextures[_i10] = new aiTexture();\n            ReadBinaryTexture(stream, scene.mTextures[_i10]);\n          }\n        }\n        if (scene.mNumLights) {\n          scene.mLights = [];\n          for (var _i11 = 0; _i11 < scene.mNumLights; ++_i11) {\n            scene.mLights[_i11] = new aiLight();\n            ReadBinaryLight(stream, scene.mLights[_i11]);\n          }\n        }\n        if (scene.mNumCameras) {\n          scene.mCameras = [];\n          for (var _i12 = 0; _i12 < scene.mNumCameras; ++_i12) {\n            scene.mCameras[_i12] = new aiCamera();\n            ReadBinaryCamera(stream, scene.mCameras[_i12]);\n          }\n        }\n      }\n      var aiOrigin_CUR = 0;\n      var aiOrigin_BEG = 1;\n      function extendStream(stream) {\n        stream.readOffset = 0;\n        stream.Seek = function (off, ori) {\n          if (ori == aiOrigin_CUR) {\n            stream.readOffset += off;\n          }\n          if (ori == aiOrigin_BEG) {\n            stream.readOffset = off;\n          }\n        };\n        stream.ReadBytes = function (buff, size, n) {\n          var bytes = size * n;\n          for (var i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\n        };\n        stream.subArray32 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Float32Array(newbuff);\n        };\n        stream.subArrayUint16 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Uint16Array(newbuff);\n        };\n        stream.subArrayUint8 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Uint8Array(newbuff);\n        };\n        stream.subArrayUint32 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Uint32Array(newbuff);\n        };\n      }\n      var shortened, compressed;\n      function InternReadFile(pFiledata) {\n        var pScene = new aiScene();\n        var stream = new DataView(pFiledata);\n        extendStream(stream);\n        stream.Seek(44, aiOrigin_CUR);\n        pScene.versionMajor = Read_unsigned_int(stream);\n        pScene.versionMinor = Read_unsigned_int(stream);\n        pScene.versionRevision = Read_unsigned_int(stream);\n        pScene.compileFlags = Read_unsigned_int(stream);\n        shortened = Read_uint16_t(stream) > 0;\n        compressed = Read_uint16_t(stream) > 0;\n        if (shortened) throw \"Shortened binaries are not supported!\";\n        stream.Seek(256, aiOrigin_CUR);\n        stream.Seek(128, aiOrigin_CUR);\n        stream.Seek(64, aiOrigin_CUR);\n        if (compressed) {\n          var uncompressedSize = Read_uint32_t(stream);\n          var compressedSize = stream.FileSize() - stream.Tell();\n          var compressedData = [];\n          stream.Read(compressedData, 1, compressedSize);\n          var uncompressedData = [];\n          uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);\n          var buff = new ArrayBuffer(uncompressedData);\n          ReadBinaryScene(buff, pScene);\n        } else {\n          ReadBinaryScene(stream, pScene);\n        }\n        return pScene.toTHREE();\n      }\n      return InternReadFile(buffer);\n    }\n  }]);\n  return AssimpLoader;\n}(Loader);\nexport { AssimpLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","TextureLoader","Vector3","Quaternion","Matrix4","Bone","Skeleton","BufferGeometry","MeshLambertMaterial","BufferAttribute","Mesh","SkinnedMesh","Color","Object3D","MeshPhongMaterial","AssimpLoader","_Loader","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","manager","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parse","e","console","error","itemError","textureLoader","resourcePath","setCrossOrigin","crossOrigin","Virtulous","KeyFrame","_class","time","matrix","clone","position","quaternion","scale","decompose","n","lerp","nextKey","time2","dist","l","l2","keypos","keyrot","key2pos","key2rot","tempAniPos","x","y","z","tempAniQuat","set","w","slerp","tempAniMatrix","compose","tempAniScale","KeyFrameTrack","keys","target","length","_accelTable","fps","addKey","push","init","sortKeys","j","i","parseFromThree","data","node","track","hierarchy","targets","parseFromCollada","sort","keySortFunc","a","b","t","reTarget","root","compareitor","TrackTargetNodeNameCompare","keySearchAccel","Math","floor","setTime","abs","key0","key1","matrixAutoUpdate","copy","matrixWorldNeedsUpdate","find","name","children","r","Animation","tracks","addTrack","max","ASSBIN_CHUNK_AICAMERA","ASSBIN_CHUNK_AILIGHT","ASSBIN_CHUNK_AITEXTURE","ASSBIN_CHUNK_AIMESH","ASSBIN_CHUNK_AINODEANIM","ASSBIN_CHUNK_AISCENE","ASSBIN_CHUNK_AIBONE","ASSBIN_CHUNK_AIANIMATION","ASSBIN_CHUNK_AINODE","ASSBIN_CHUNK_AIMATERIAL","ASSBIN_CHUNK_AIMATERIALPROPERTY","ASSBIN_MESH_HAS_POSITIONS","ASSBIN_MESH_HAS_NORMALS","ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS","ASSBIN_MESH_HAS_TEXCOORD_BASE","ASSBIN_MESH_HAS_COLOR_BASE","AI_MAX_NUMBER_OF_COLOR_SETS","AI_MAX_NUMBER_OF_TEXTURECOORDS","aiLightSource_DIRECTIONAL","aiLightSource_SPOT","aiTextureType_DIFFUSE","aiTextureType_NORMALS","aiTextureType_OPACITY","aiTextureType_LIGHTMAP","BONESPERVERT","ASSBIN_MESH_HAS_TEXCOORD","ASSBIN_MESH_HAS_COLOR","markBones","scene","mMeshes","mesh","k","mBones","boneNode","findNode","mName","isBone","cloneTreeToBones","rootBone","matrixWorld","nodeCount","toString","nodeToBoneMap","child","add","sortWeights","indexes","weights","pairs","sum","sqrt","findMatchingBone","indexOf","ret","aiMesh","mPrimitiveTypes","mNumVertices","mNumFaces","mNumBones","mMaterialIndex","mVertices","mNormals","mTangents","mBitangents","mColors","mTextureCoords","mFaces","hookupSkeletons","allBones","offsetMatrix","skeletonRoot","mParent","threeSkeletonRoot","toTHREE","threeSkeletonRootBone","threeNode","bone","tbone","mOffsetMatrix","skeleton","bind","material","skinning","geometry","mat","mMaterials","setIndex","Uint32Array","mIndexArray","setAttribute","mVertexBuffer","mNormalBuffer","mColorBuffer","mTexCoordsBuffers","Float32Array","mTangentBuffer","mBitangentBuffer","bones","mWeights","weight","mVertexId","mWeight","parseInt","_weights","_bones","normalizeSkinWeights","aiFace","mNumIndices","mIndices","aiVector3D","aiColor3D","g","aiQuaternion","aiVertexWeight","aiString","str","forEach","String","fromCharCode","replace","aiVectorKey","mTime","mValue","aiQuatKey","aiNode","mTransformation","mNumChildren","mNumMeshes","mChildren","o","aiBone","mNumWeights","aiMaterialProperty","mKey","mSemantic","mIndex","mData","mDataLength","mType","dataAsColor","array","Uint8Array","reader","DataView","getFloat32","dataAsFloat","dataAsBool","dataAsString","s","dataAsMap","path2","substr","lastIndexOf","namePropMapping","nameTypeMapping","aiMaterial","mNumAllocated","mNumProperties","mProperties","prop","map","normalMap","lightMap","alphaMap","ambient","color","veclerp","v1","v2","v","lm1","quatlerp","q1","q2","sampleTrack","lne","Infinity","timeDist","dT","T","aiNodeAnim","mNodeName","mNumPositionKeys","mNumRotationKeys","mNumScalingKeys","mPositionKeys","mRotationKeys","mScalingKeys","mPreState","mPostState","tps","t2","comp","getLength","pos","rotation","aiAnimation","mDuration","mTicksPerSecond","mNumChannels","mChannels","animationHandle","aiTexture","mWidth","mHeight","texAchFormatHint","pcData","aiLight","mAttenuationConstant","mAttenuationLinear","mAttenuationQuadratic","mAngleInnerCone","mAngleOuterCone","mColorDiffuse","mColorSpecular","mColorAmbient","aiCamera","mPosition","mLookAt","mUp","mHorizontalFOV","mClipPlaneNear","mClipPlaneFar","mAspect","aiScene","versionMajor","versionMinor","versionRevision","compileFlags","mFlags","mNumMaterials","mNumAnimations","mNumTextures","mNumLights","mNumCameras","mRootNode","mAnimations","mLights","mCameras","object","animation","aiMatrix4","elements","m","i2","littleEndian","readFloat","dataview","val","readOffset","Read_double","getFloat64","Read_uint8_t","getUint8","Read_uint16_t","getUint16","Read_unsigned_int","getUint32","Read_uint32_t","Read_aiVector3D","stream","Read_aiColor3D","c","Read_aiQuaternion","Read_aiString","stringlengthbytes","ReadBytes","Read_aiVertexWeight","Read_aiMatrix4x4","Read_aiVectorKey","Read_aiQuatKey","ReadArray_aiVertexWeight","size","ReadArray_aiVectorKey","ReadArray_aiQuatKey","ReadBounds","Seek","sizeof","aiOrigin_CUR","ai_assert","bool","ReadBinaryNode","parent","depth","chunkID","mDepth","node2","ReadBinaryBone","shortened","ReadBinaryMesh","mNumUVComponents","subArray32","uv","f","Error","ReadBinaryMaterialProperty","ReadBinaryMaterial","ReadBinaryNodeAnim","nd","ReadBinaryAnim","anim","ReadBinaryTexture","tex","achFormatHint","ReadBinaryLight","ReadBinaryCamera","cam","ReadBinaryScene","mTextures","aiOrigin_BEG","extendStream","off","ori","buff","bytes","start","end","newbuff","slice","subArrayUint16","Uint16Array","subArrayUint8","subArrayUint32","compressed","InternReadFile","pFiledata","pScene","uncompressedSize","compressedSize","FileSize","Tell","compressedData","Read","uncompressedData","uncompress","ArrayBuffer"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/AssimpLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Bone, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Color, Object3D, MeshPhongMaterial } from \"three\";\nclass AssimpLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(buffer) {\n        try {\n          onLoad(scope.parse(buffer, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n    Virtulous.KeyFrame = class {\n      constructor(time, matrix) {\n        this.time = time;\n        this.matrix = matrix.clone();\n        this.position = new Vector3();\n        this.quaternion = new Quaternion();\n        this.scale = new Vector3(1, 1, 1);\n        this.matrix.decompose(this.position, this.quaternion, this.scale);\n        this.clone = function() {\n          var n = new Virtulous.KeyFrame(this.time, this.matrix);\n          return n;\n        };\n        this.lerp = function(nextKey, time2) {\n          time2 -= this.time;\n          var dist = nextKey.time - this.time;\n          var l = time2 / dist;\n          var l2 = 1 - l;\n          var keypos = this.position;\n          var keyrot = this.quaternion;\n          var key2pos = nextKey.position;\n          var key2rot = nextKey.quaternion;\n          Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n          Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n          Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n          Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n          Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n          return Virtulous.KeyFrame.tempAniMatrix.compose(\n            Virtulous.KeyFrame.tempAniPos,\n            Virtulous.KeyFrame.tempAniQuat,\n            Virtulous.KeyFrame.tempAniScale\n          );\n        };\n      }\n    };\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n    Virtulous.KeyFrameTrack = function() {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n      this.addKey = function(key) {\n        this.keys.push(key);\n      };\n      this.init = function() {\n        this.sortKeys();\n        if (this.keys.length > 0)\n          this.length = this.keys[this.keys.length - 1].time;\n        else\n          this.length = 0;\n        if (!this.fps)\n          return;\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n      this.parseFromThree = function(data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n        this.init();\n      };\n      this.parseFromCollada = function(data) {\n        var track = data.keys;\n        var fps = this.fps;\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n        this.init();\n      };\n      this.sortKeys = function() {\n        this.keys.sort(this.keySortFunc);\n      };\n      this.keySortFunc = function(a, b) {\n        return a.time - b.time;\n      };\n      this.clone = function() {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n        t.init();\n        return t;\n      };\n      this.reTarget = function(root, compareitor) {\n        if (!compareitor)\n          compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n      this.keySearchAccel = function(time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n      this.setTime = function(time) {\n        time = Math.abs(time);\n        if (this.length)\n          time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n    Virtulous.TrackTargetNodeNameCompare = function(root, target) {\n      function find(node, name) {\n        if (node.name == name)\n          return node;\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r)\n            return r;\n        }\n        return null;\n      }\n      return find(root, target.name);\n    };\n    Virtulous.Animation = function() {\n      this.tracks = [];\n      this.length = 0;\n      this.addTrack = function(track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n      this.setTime = function(time) {\n        this.time = time;\n        for (let i = 0; i < this.tracks.length; i++)\n          this.tracks[i].setTime(time);\n      };\n      this.clone = function(target, compareitor) {\n        if (!compareitor)\n          compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n        return n;\n      };\n    };\n    var ASSBIN_CHUNK_AICAMERA = 4660;\n    var ASSBIN_CHUNK_AILIGHT = 4661;\n    var ASSBIN_CHUNK_AITEXTURE = 4662;\n    var ASSBIN_CHUNK_AIMESH = 4663;\n    var ASSBIN_CHUNK_AINODEANIM = 4664;\n    var ASSBIN_CHUNK_AISCENE = 4665;\n    var ASSBIN_CHUNK_AIBONE = 4666;\n    var ASSBIN_CHUNK_AIANIMATION = 4667;\n    var ASSBIN_CHUNK_AINODE = 4668;\n    var ASSBIN_CHUNK_AIMATERIAL = 4669;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;\n    var ASSBIN_MESH_HAS_POSITIONS = 1;\n    var ASSBIN_MESH_HAS_NORMALS = 2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 65536;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n    var aiLightSource_DIRECTIONAL = 1;\n    //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n    var aiLightSource_SPOT = 3;\n    //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    var aiTextureType_DIFFUSE = 1;\n    var aiTextureType_NORMALS = 6;\n    var aiTextureType_OPACITY = 8;\n    var aiTextureType_LIGHTMAP = 10;\n    var BONESPERVERT = 4;\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode)\n            boneNode.isBone = true;\n        }\n      }\n    }\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name])\n        scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n      return rootBone;\n    }\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n      pairs.sort(function(a, b) {\n        return b.w - a.w;\n      });\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n      if (pairs.length > 4)\n        pairs.length = 4;\n      var sum = 0;\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w;\n      }\n      sum = Math.sqrt(sum);\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum;\n        indexes[i] = pairs[i].i;\n        weights[i] = pairs[i].w;\n      }\n    }\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf(\"bone_\" + name) == 0)\n        return root;\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret)\n          return ret;\n      }\n      return void 0;\n    }\n    class aiMesh {\n      constructor() {\n        this.mPrimitiveTypes = 0;\n        this.mNumVertices = 0;\n        this.mNumFaces = 0;\n        this.mNumBones = 0;\n        this.mMaterialIndex = 0;\n        this.mVertices = [];\n        this.mNormals = [];\n        this.mTangents = [];\n        this.mBitangents = [];\n        this.mColors = [[]];\n        this.mTextureCoords = [[]];\n        this.mFaces = [];\n        this.mBones = [];\n        this.hookupSkeletons = function(scene) {\n          if (this.mBones.length == 0)\n            return;\n          var allBones = [];\n          var offsetMatrix = [];\n          var skeletonRoot = scene.findNode(this.mBones[0].mName);\n          while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n            skeletonRoot = skeletonRoot.mParent;\n          }\n          var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n          var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n          this.threeNode.add(threeSkeletonRootBone);\n          for (let i = 0; i < this.mBones.length; i++) {\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            if (bone) {\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            } else {\n              var skeletonRoot = scene.findNode(this.mBones[i].mName);\n              if (!skeletonRoot)\n                return;\n              var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n              var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n              this.threeNode.add(threeSkeletonRootBone);\n              var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            }\n          }\n          var skeleton = new Skeleton(allBones, offsetMatrix);\n          this.threeNode.bind(skeleton, new Matrix4());\n          this.threeNode.material.skinning = true;\n        };\n        this.toTHREE = function(scene) {\n          if (this.threeNode)\n            return this.threeNode;\n          var geometry = new BufferGeometry();\n          var mat;\n          if (scene.mMaterials[this.mMaterialIndex])\n            mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);\n          else\n            mat = new MeshLambertMaterial();\n          geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n          geometry.setAttribute(\"position\", new BufferAttribute(this.mVertexBuffer, 3));\n          if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n            geometry.setAttribute(\"normal\", new BufferAttribute(this.mNormalBuffer, 3));\n          }\n          if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n            geometry.setAttribute(\"color\", new BufferAttribute(this.mColorBuffer, 4));\n          }\n          if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n            geometry.setAttribute(\"uv\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n          }\n          if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n            geometry.setAttribute(\"uv1\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n          }\n          if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n            geometry.setAttribute(\"tangents\", new BufferAttribute(this.mTangentBuffer, 3));\n          }\n          if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n            geometry.setAttribute(\"bitangents\", new BufferAttribute(this.mBitangentBuffer, 3));\n          }\n          if (this.mBones.length > 0) {\n            var weights = [];\n            var bones = [];\n            for (let i = 0; i < this.mBones.length; i++) {\n              for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n                var weight = this.mBones[i].mWeights[j];\n                if (weight) {\n                  if (!weights[weight.mVertexId])\n                    weights[weight.mVertexId] = [];\n                  if (!bones[weight.mVertexId])\n                    bones[weight.mVertexId] = [];\n                  weights[weight.mVertexId].push(weight.mWeight);\n                  bones[weight.mVertexId].push(parseInt(i));\n                }\n              }\n            }\n            for (let i in bones) {\n              sortWeights(bones[i], weights[i]);\n            }\n            var _weights = [];\n            var _bones = [];\n            for (let i = 0; i < weights.length; i++) {\n              for (let j = 0; j < 4; j++) {\n                if (weights[i] && bones[i]) {\n                  _weights.push(weights[i][j]);\n                  _bones.push(bones[i][j]);\n                } else {\n                  _weights.push(0);\n                  _bones.push(0);\n                }\n              }\n            }\n            geometry.setAttribute(\"skinWeight\", new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n            geometry.setAttribute(\"skinIndex\", new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n          }\n          var mesh;\n          if (this.mBones.length == 0)\n            mesh = new Mesh(geometry, mat);\n          if (this.mBones.length > 0) {\n            mesh = new SkinnedMesh(geometry, mat);\n            mesh.normalizeSkinWeights();\n          }\n          this.threeNode = mesh;\n          return mesh;\n        };\n      }\n    }\n    class aiFace {\n      constructor() {\n        this.mNumIndices = 0;\n        this.mIndices = [];\n      }\n    }\n    class aiVector3D {\n      constructor() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.toTHREE = function() {\n          return new Vector3(this.x, this.y, this.z);\n        };\n      }\n    }\n    class aiColor3D {\n      constructor() {\n        this.r = 0;\n        this.g = 0;\n        this.b = 0;\n        this.a = 0;\n        this.toTHREE = function() {\n          return new Color(this.r, this.g, this.b);\n        };\n      }\n    }\n    class aiQuaternion {\n      constructor() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n        this.toTHREE = function() {\n          return new Quaternion(this.x, this.y, this.z, this.w);\n        };\n      }\n    }\n    class aiVertexWeight {\n      constructor() {\n        this.mVertexId = 0;\n        this.mWeight = 0;\n      }\n    }\n    class aiString {\n      constructor() {\n        this.data = [];\n        this.toString = function() {\n          var str = \"\";\n          this.data.forEach(function(i) {\n            str += String.fromCharCode(i);\n          });\n          return str.replace(/[^\\x20-\\x7E]+/g, \"\");\n        };\n      }\n    }\n    class aiVectorKey {\n      constructor() {\n        this.mTime = 0;\n        this.mValue = null;\n      }\n    }\n    class aiQuatKey {\n      constructor() {\n        this.mTime = 0;\n        this.mValue = null;\n      }\n    }\n    class aiNode {\n      constructor() {\n        this.mName = \"\";\n        this.mTransformation = [];\n        this.mNumChildren = 0;\n        this.mNumMeshes = 0;\n        this.mMeshes = [];\n        this.mChildren = [];\n        this.toTHREE = function(scene) {\n          if (this.threeNode)\n            return this.threeNode;\n          var o = new Object3D();\n          o.name = this.mName;\n          o.matrix = this.mTransformation.toTHREE();\n          for (let i = 0; i < this.mChildren.length; i++) {\n            o.add(this.mChildren[i].toTHREE(scene));\n          }\n          for (let i = 0; i < this.mMeshes.length; i++) {\n            o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n          }\n          this.threeNode = o;\n          o.matrix.decompose(o.position, o.quaternion, o.scale);\n          return o;\n        };\n      }\n    }\n    class aiBone {\n      constructor() {\n        this.mName = \"\";\n        this.mNumWeights = 0;\n        this.mOffsetMatrix = 0;\n      }\n    }\n    class aiMaterialProperty {\n      constructor() {\n        this.mKey = \"\";\n        this.mSemantic = 0;\n        this.mIndex = 0;\n        this.mData = [];\n        this.mDataLength = 0;\n        this.mType = 0;\n        this.dataAsColor = function() {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          var g = reader.getFloat32(4, true);\n          var b = reader.getFloat32(8, true);\n          return new Color(r, g, b);\n        };\n        this.dataAsFloat = function() {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return r;\n        };\n        this.dataAsBool = function() {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return !!r;\n        };\n        this.dataAsString = function() {\n          var s = new aiString();\n          s.data = this.mData;\n          return s.toString();\n        };\n        this.dataAsMap = function() {\n          var s = new aiString();\n          s.data = this.mData;\n          var path2 = s.toString();\n          path2 = path2.replace(/\\\\/g, \"/\");\n          if (path2.indexOf(\"/\") != -1) {\n            path2 = path2.substr(path2.lastIndexOf(\"/\") + 1);\n          }\n          return textureLoader.load(path2);\n        };\n      }\n    }\n    var namePropMapping = {\n      \"?mat.name\": \"name\",\n      \"$mat.shadingm\": \"shading\",\n      \"$mat.twosided\": \"twoSided\",\n      \"$mat.wireframe\": \"wireframe\",\n      \"$clr.ambient\": \"ambient\",\n      \"$clr.diffuse\": \"color\",\n      \"$clr.specular\": \"specular\",\n      \"$clr.emissive\": \"emissive\",\n      \"$clr.transparent\": \"transparent\",\n      \"$clr.reflective\": \"reflect\",\n      \"$mat.shininess\": \"shininess\",\n      \"$mat.reflectivity\": \"reflectivity\",\n      \"$mat.refracti\": \"refraction\",\n      \"$tex.file\": \"map\"\n    };\n    var nameTypeMapping = {\n      \"?mat.name\": \"string\",\n      \"$mat.shadingm\": \"bool\",\n      \"$mat.twosided\": \"bool\",\n      \"$mat.wireframe\": \"bool\",\n      \"$clr.ambient\": \"color\",\n      \"$clr.diffuse\": \"color\",\n      \"$clr.specular\": \"color\",\n      \"$clr.emissive\": \"color\",\n      \"$clr.transparent\": \"color\",\n      \"$clr.reflective\": \"color\",\n      \"$mat.shininess\": \"float\",\n      \"$mat.reflectivity\": \"float\",\n      \"$mat.refracti\": \"float\",\n      \"$tex.file\": \"map\"\n    };\n    class aiMaterial {\n      constructor() {\n        this.mNumAllocated = 0;\n        this.mNumProperties = 0;\n        this.mProperties = [];\n        this.toTHREE = function() {\n          var mat = new MeshPhongMaterial();\n          for (let i = 0; i < this.mProperties.length; i++) {\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"float\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"color\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"bool\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"string\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"map\") {\n              var prop = this.mProperties[i];\n              if (prop.mSemantic == aiTextureType_DIFFUSE)\n                mat.map = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_NORMALS)\n                mat.normalMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_LIGHTMAP)\n                mat.lightMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_OPACITY)\n                mat.alphaMap = this.mProperties[i].dataAsMap();\n            }\n          }\n          mat.ambient.r = 0.53;\n          mat.ambient.g = 0.53;\n          mat.ambient.b = 0.53;\n          mat.color.r = 1;\n          mat.color.g = 1;\n          mat.color.b = 1;\n          return mat;\n        };\n      }\n    }\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1)\n        return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n    class aiNodeAnim {\n      constructor() {\n        this.mNodeName = \"\";\n        this.mNumPositionKeys = 0;\n        this.mNumRotationKeys = 0;\n        this.mNumScalingKeys = 0;\n        this.mPositionKeys = [];\n        this.mRotationKeys = [];\n        this.mScalingKeys = [];\n        this.mPreState = \"\";\n        this.mPostState = \"\";\n        this.init = function(tps) {\n          if (!tps)\n            tps = 1;\n          function t(t2) {\n            t2.mTime /= tps;\n          }\n          this.mPositionKeys.forEach(t);\n          this.mRotationKeys.forEach(t);\n          this.mScalingKeys.forEach(t);\n        };\n        this.sortKeys = function() {\n          function comp(a, b) {\n            return a.mTime - b.mTime;\n          }\n          this.mPositionKeys.sort(comp);\n          this.mRotationKeys.sort(comp);\n          this.mScalingKeys.sort(comp);\n        };\n        this.getLength = function() {\n          return Math.max(\n            Math.max.apply(\n              null,\n              this.mPositionKeys.map(function(a) {\n                return a.mTime;\n              })\n            ),\n            Math.max.apply(\n              null,\n              this.mRotationKeys.map(function(a) {\n                return a.mTime;\n              })\n            ),\n            Math.max.apply(\n              null,\n              this.mScalingKeys.map(function(a) {\n                return a.mTime;\n              })\n            )\n          );\n        };\n        this.toTHREE = function(o) {\n          this.sortKeys();\n          var length = this.getLength();\n          var track = new Virtulous.KeyFrameTrack();\n          for (let i = 0; i < length; i += 0.05) {\n            var matrix = new Matrix4();\n            var time = i;\n            var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n            var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n            var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n            matrix.compose(pos, rotation, scale);\n            var key = new Virtulous.KeyFrame(time, matrix);\n            track.addKey(key);\n          }\n          track.target = o.findNode(this.mNodeName).toTHREE();\n          var tracks = [track];\n          if (o.nodeToBoneMap[this.mNodeName]) {\n            for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n              var t2 = track.clone();\n              t2.target = o.nodeToBoneMap[this.mNodeName][i];\n              tracks.push(t2);\n            }\n          }\n          return tracks;\n        };\n      }\n    }\n    class aiAnimation {\n      constructor() {\n        this.mName = \"\";\n        this.mDuration = 0;\n        this.mTicksPerSecond = 0;\n        this.mNumChannels = 0;\n        this.mChannels = [];\n        this.toTHREE = function(root) {\n          var animationHandle = new Virtulous.Animation();\n          for (let i in this.mChannels) {\n            this.mChannels[i].init(this.mTicksPerSecond);\n            var tracks = this.mChannels[i].toTHREE(root);\n            for (let j in tracks) {\n              tracks[j].init();\n              animationHandle.addTrack(tracks[j]);\n            }\n          }\n          animationHandle.length = Math.max.apply(\n            null,\n            animationHandle.tracks.map(function(e) {\n              return e.length;\n            })\n          );\n          return animationHandle;\n        };\n      }\n    }\n    class aiTexture {\n      constructor() {\n        this.mWidth = 0;\n        this.mHeight = 0;\n        this.texAchFormatHint = [];\n        this.pcData = [];\n      }\n    }\n    class aiLight {\n      constructor() {\n        this.mName = \"\";\n        this.mType = 0;\n        this.mAttenuationConstant = 0;\n        this.mAttenuationLinear = 0;\n        this.mAttenuationQuadratic = 0;\n        this.mAngleInnerCone = 0;\n        this.mAngleOuterCone = 0;\n        this.mColorDiffuse = null;\n        this.mColorSpecular = null;\n        this.mColorAmbient = null;\n      }\n    }\n    class aiCamera {\n      constructor() {\n        this.mName = \"\";\n        this.mPosition = null;\n        this.mLookAt = null;\n        this.mUp = null;\n        this.mHorizontalFOV = 0;\n        this.mClipPlaneNear = 0;\n        this.mClipPlaneFar = 0;\n        this.mAspect = 0;\n      }\n    }\n    class aiScene {\n      constructor() {\n        this.versionMajor = 0;\n        this.versionMinor = 0;\n        this.versionRevision = 0;\n        this.compileFlags = 0;\n        this.mFlags = 0;\n        this.mNumMeshes = 0;\n        this.mNumMaterials = 0;\n        this.mNumAnimations = 0;\n        this.mNumTextures = 0;\n        this.mNumLights = 0;\n        this.mNumCameras = 0;\n        this.mRootNode = null;\n        this.mMeshes = [];\n        this.mMaterials = [];\n        this.mAnimations = [];\n        this.mLights = [];\n        this.mCameras = [];\n        this.nodeToBoneMap = {};\n        this.findNode = function(name, root) {\n          if (!root) {\n            root = this.mRootNode;\n          }\n          if (root.mName == name) {\n            return root;\n          }\n          for (let i = 0; i < root.mChildren.length; i++) {\n            var ret = this.findNode(name, root.mChildren[i]);\n            if (ret)\n              return ret;\n          }\n          return null;\n        };\n        this.toTHREE = function() {\n          this.nodeCount = 0;\n          markBones(this);\n          var o = this.mRootNode.toTHREE(this);\n          for (let i in this.mMeshes)\n            this.mMeshes[i].hookupSkeletons(this);\n          if (this.mAnimations.length > 0) {\n            var a = this.mAnimations[0].toTHREE(this);\n          }\n          return { object: o, animation: a };\n        };\n      }\n    }\n    class aiMatrix4 {\n      constructor() {\n        this.elements = [[], [], [], []];\n        this.toTHREE = function() {\n          var m = new Matrix4();\n          for (let i = 0; i < 4; ++i) {\n            for (let i2 = 0; i2 < 4; ++i2) {\n              m.elements[i * 4 + i2] = this.elements[i2][i];\n            }\n          }\n          return m;\n        };\n      }\n    }\n    var littleEndian = true;\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n      return m;\n    }\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++)\n        data[i] = Read_aiVertexWeight(stream);\n    }\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++)\n        data[i] = Read_aiVectorKey(stream);\n    }\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++)\n        data[i] = Read_aiQuatKey(stream);\n    }\n    function ReadBounds(stream, T, n) {\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR);\n    }\n    function ai_assert(bool) {\n      if (!bool)\n        throw \"asset failed\";\n    }\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n      if (node.mNumChildren) {\n        node.mChildren = [];\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[i] = node2;\n        }\n      }\n      return node;\n    }\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream);\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n      return b;\n    }\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = [];\n      var c = Read_unsigned_int(stream);\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n)))\n          break;\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n      mesh.mTexCoordsBuffers = [];\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n)))\n          break;\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n        } else {\n          mesh.mTextureCoords[n] = [];\n          mesh.mTexCoordsBuffers[n] = [];\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            readFloat(stream);\n          }\n        }\n      }\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace();\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      }\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[a]);\n        }\n      }\n    }\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    }\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n        mat.mProperties = [];\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream);\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0);\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      }\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[i]);\n        }\n      }\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[i]);\n        }\n      }\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[i]);\n        }\n      }\n      if (scene.mNumLights) {\n        scene.mLights = [];\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[i]);\n        }\n      }\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[i]);\n        }\n      }\n    }\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n    function extendStream(stream) {\n      stream.readOffset = 0;\n      stream.Seek = function(off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n      stream.ReadBytes = function(buff, size, n) {\n        var bytes = size * n;\n        for (let i = 0; i < bytes; i++)\n          buff[i] = Read_uint8_t(this);\n      };\n      stream.subArray32 = function(start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n      stream.subArrayUint16 = function(start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n      stream.subArrayUint8 = function(start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n      stream.subArrayUint32 = function(start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n    var shortened, compressed;\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR);\n      pScene.versionMajor = Read_unsigned_int(stream);\n      pScene.versionMinor = Read_unsigned_int(stream);\n      pScene.versionRevision = Read_unsigned_int(stream);\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened)\n        throw \"Shortened binaries are not supported!\";\n      stream.Seek(256, aiOrigin_CUR);\n      stream.Seek(128, aiOrigin_CUR);\n      stream.Seek(64, aiOrigin_CUR);\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n      return pScene.toTHREE();\n    }\n    return InternReadFile(buffer);\n  }\n}\nexport {\n  AssimpLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}