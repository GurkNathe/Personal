{"ast":null,"code":"import _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { Color, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from \"three\";\nvar OutlineEffect = /*#__PURE__*/_createClass(function OutlineEffect(renderer) {\n  var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  _classCallCheck(this, OutlineEffect);\n  this.enabled = true;\n  var defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;\n  var defaultColor = new Color().fromArray(parameters.defaultColor !== void 0 ? parameters.defaultColor : [0, 0, 0]);\n  var defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;\n  var defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;\n  var cache = {};\n  var removeThresholdCount = 60;\n  var originalMaterials = {};\n  var originalOnBeforeRenders = {};\n  var uniformsOutline = {\n    outlineThickness: {\n      value: defaultThickness\n    },\n    outlineColor: {\n      value: defaultColor\n    },\n    outlineAlpha: {\n      value: defaultAlpha\n    }\n  };\n  var vertexShader = [\"#include <common>\", \"#include <uv_pars_vertex>\", \"#include <displacementmap_pars_vertex>\", \"#include <fog_pars_vertex>\", \"#include <morphtarget_pars_vertex>\", \"#include <skinning_pars_vertex>\", \"#include <logdepthbuf_pars_vertex>\", \"#include <clipping_planes_pars_vertex>\", \"uniform float outlineThickness;\", \"vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\", \"\tfloat thickness = outlineThickness;\", \"\tconst float ratio = 1.0;\",\n  // TODO: support outline thickness ratio for each vertex\n  \"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\",\n  // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n  \"\tvec4 norm = normalize( pos - pos2 );\", \"\treturn pos + norm * thickness * pos.w * ratio;\", \"}\", \"void main() {\", \"\t#include <uv_vertex>\", \"\t#include <beginnormal_vertex>\", \"\t#include <morphnormal_vertex>\", \"\t#include <skinbase_vertex>\", \"\t#include <skinnormal_vertex>\", \"\t#include <begin_vertex>\", \"\t#include <morphtarget_vertex>\", \"\t#include <skinning_vertex>\", \"\t#include <displacementmap_vertex>\", \"\t#include <project_vertex>\", \"\tvec3 outlineNormal = - objectNormal;\",\n  // the outline material is always rendered with BackSide\n  \"\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\", \"\t#include <logdepthbuf_vertex>\", \"\t#include <clipping_planes_vertex>\", \"\t#include <fog_vertex>\", \"}\"].join(\"\\n\");\n  var fragmentShader = [\"#include <common>\", \"#include <fog_pars_fragment>\", \"#include <logdepthbuf_pars_fragment>\", \"#include <clipping_planes_pars_fragment>\", \"uniform vec3 outlineColor;\", \"uniform float outlineAlpha;\", \"void main() {\", \"\t#include <clipping_planes_fragment>\", \"\t#include <logdepthbuf_fragment>\", \"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\", \"\t#include <tonemapping_fragment>\", \"\t#include <encodings_fragment>\", \"\t#include <fog_fragment>\", \"\t#include <premultiplied_alpha_fragment>\", \"}\"].join(\"\\n\");\n  function createMaterial() {\n    return new ShaderMaterial({\n      type: \"OutlineEffect\",\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"displacementmap\"], uniformsOutline]),\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      side: BackSide\n    });\n  }\n  function getOutlineMaterialFromCache(originalMaterial) {\n    var data = cache[originalMaterial.uuid];\n    if (data === void 0) {\n      data = {\n        material: createMaterial(),\n        used: true,\n        keepAlive: defaultKeepAlive,\n        count: 0\n      };\n      cache[originalMaterial.uuid] = data;\n    }\n    data.used = true;\n    return data.material;\n  }\n  function getOutlineMaterial(originalMaterial) {\n    var outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n    originalMaterials[outlineMaterial.uuid] = originalMaterial;\n    updateOutlineMaterial(outlineMaterial, originalMaterial);\n    return outlineMaterial;\n  }\n  function isCompatible(object) {\n    var geometry = object.geometry;\n    var hasNormals = geometry !== void 0 && geometry.attributes.normal !== void 0;\n    return object.isMesh === true && object.material !== void 0 && hasNormals === true;\n  }\n  function setOutlineMaterial(object) {\n    if (isCompatible(object) === false) return;\n    if (Array.isArray(object.material)) {\n      for (var i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = getOutlineMaterial(object.material[i]);\n      }\n    } else {\n      object.material = getOutlineMaterial(object.material);\n    }\n    originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n    object.onBeforeRender = onBeforeRender;\n  }\n  function restoreOriginalMaterial(object) {\n    if (isCompatible(object) === false) return;\n    if (Array.isArray(object.material)) {\n      for (var i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = originalMaterials[object.material[i].uuid];\n      }\n    } else {\n      object.material = originalMaterials[object.material.uuid];\n    }\n    object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n  }\n  function onBeforeRender(renderer2, scene, camera, geometry, material) {\n    var originalMaterial = originalMaterials[material.uuid];\n    if (originalMaterial === void 0) return;\n    updateUniforms(material, originalMaterial);\n  }\n  function updateUniforms(material, originalMaterial) {\n    var outlineParameters = originalMaterial.userData.outlineParameters;\n    material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n    if (outlineParameters !== void 0) {\n      if (outlineParameters.thickness !== void 0) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n      if (outlineParameters.color !== void 0) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n      if (outlineParameters.alpha !== void 0) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n    }\n    if (originalMaterial.displacementMap) {\n      material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n      material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n      material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n    }\n  }\n  function updateOutlineMaterial(material, originalMaterial) {\n    if (material.name === \"invisible\") return;\n    var outlineParameters = originalMaterial.userData.outlineParameters;\n    material.fog = originalMaterial.fog;\n    material.toneMapped = originalMaterial.toneMapped;\n    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n    material.displacementMap = originalMaterial.displacementMap;\n    if (outlineParameters !== void 0) {\n      if (originalMaterial.visible === false) {\n        material.visible = false;\n      } else {\n        material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;\n      }\n      material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;\n      if (outlineParameters.keepAlive !== void 0) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n    } else {\n      material.transparent = originalMaterial.transparent;\n      material.visible = originalMaterial.visible;\n    }\n    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n    if (originalMaterial.clippingPlanes) {\n      material.clipping = true;\n      material.clippingPlanes = originalMaterial.clippingPlanes;\n      material.clipIntersection = originalMaterial.clipIntersection;\n      material.clipShadows = originalMaterial.clipShadows;\n    }\n    material.version = originalMaterial.version;\n  }\n  function cleanupCache() {\n    var keys;\n    keys = Object.keys(originalMaterials);\n    for (var i = 0, il = keys.length; i < il; i++) {\n      originalMaterials[keys[i]] = void 0;\n    }\n    keys = Object.keys(originalOnBeforeRenders);\n    for (var _i = 0, _il = keys.length; _i < _il; _i++) {\n      originalOnBeforeRenders[keys[_i]] = void 0;\n    }\n    keys = Object.keys(cache);\n    for (var _i2 = 0, _il2 = keys.length; _i2 < _il2; _i2++) {\n      var key = keys[_i2];\n      if (cache[key].used === false) {\n        cache[key].count++;\n        if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n          delete cache[key];\n        }\n      } else {\n        cache[key].used = false;\n        cache[key].count = 0;\n      }\n    }\n  }\n  this.render = function (scene, camera) {\n    if (this.enabled === false) {\n      renderer.render(scene, camera);\n      return;\n    }\n    var currentAutoClear = renderer.autoClear;\n    renderer.autoClear = this.autoClear;\n    renderer.render(scene, camera);\n    renderer.autoClear = currentAutoClear;\n    this.renderOutline(scene, camera);\n  };\n  this.renderOutline = function (scene, camera) {\n    var currentAutoClear = renderer.autoClear;\n    var currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n    var currentSceneBackground = scene.background;\n    var currentShadowMapEnabled = renderer.shadowMap.enabled;\n    scene.matrixWorldAutoUpdate = false;\n    scene.background = null;\n    renderer.autoClear = false;\n    renderer.shadowMap.enabled = false;\n    scene.traverse(setOutlineMaterial);\n    renderer.render(scene, camera);\n    scene.traverse(restoreOriginalMaterial);\n    cleanupCache();\n    scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n    scene.background = currentSceneBackground;\n    renderer.autoClear = currentAutoClear;\n    renderer.shadowMap.enabled = currentShadowMapEnabled;\n  };\n  this.autoClear = renderer.autoClear;\n  this.domElement = renderer.domElement;\n  this.shadowMap = renderer.shadowMap;\n  this.clear = function (color, depth, stencil) {\n    renderer.clear(color, depth, stencil);\n  };\n  this.getPixelRatio = function () {\n    return renderer.getPixelRatio();\n  };\n  this.setPixelRatio = function (value) {\n    renderer.setPixelRatio(value);\n  };\n  this.getSize = function (target) {\n    return renderer.getSize(target);\n  };\n  this.setSize = function (width, height, updateStyle) {\n    renderer.setSize(width, height, updateStyle);\n  };\n  this.setViewport = function (x, y, width, height) {\n    renderer.setViewport(x, y, width, height);\n  };\n  this.setScissor = function (x, y, width, height) {\n    renderer.setScissor(x, y, width, height);\n  };\n  this.setScissorTest = function (boolean) {\n    renderer.setScissorTest(boolean);\n  };\n  this.setRenderTarget = function (renderTarget) {\n    renderer.setRenderTarget(renderTarget);\n  };\n});\nexport { OutlineEffect };","map":{"version":3,"names":["Color","ShaderMaterial","UniformsUtils","UniformsLib","BackSide","OutlineEffect","_createClass","renderer","parameters","arguments","length","undefined","_classCallCheck","enabled","defaultThickness","defaultColor","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","createMaterial","type","uniforms","merge","side","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","used","keepAlive","count","getOutlineMaterial","outlineMaterial","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","onBeforeRender","restoreOriginalMaterial","renderer2","scene","camera","updateUniforms","outlineParameters","userData","opacity","thickness","color","alpha","displacementMap","displacementScale","displacementBias","name","fog","toneMapped","premultipliedAlpha","visible","transparent","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","cleanupCache","keys","Object","key","render","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","matrixWorldAutoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","domElement","clear","depth","stencil","getPixelRatio","setPixelRatio","getSize","target","setSize","width","height","updateStyle","setViewport","x","y","setScissor","setScissorTest","boolean","setRenderTarget","renderTarget"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/effects/OutlineEffect.js"],"sourcesContent":["import { Color, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from \"three\";\nclass OutlineEffect {\n  constructor(renderer, parameters = {}) {\n    this.enabled = true;\n    const defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;\n    const defaultColor = new Color().fromArray(\n      parameters.defaultColor !== void 0 ? parameters.defaultColor : [0, 0, 0]\n    );\n    const defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;\n    const defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;\n    const cache = {};\n    const removeThresholdCount = 60;\n    const originalMaterials = {};\n    const originalOnBeforeRenders = {};\n    const uniformsOutline = {\n      outlineThickness: { value: defaultThickness },\n      outlineColor: { value: defaultColor },\n      outlineAlpha: { value: defaultAlpha }\n    };\n    const vertexShader = [\n      \"#include <common>\",\n      \"#include <uv_pars_vertex>\",\n      \"#include <displacementmap_pars_vertex>\",\n      \"#include <fog_pars_vertex>\",\n      \"#include <morphtarget_pars_vertex>\",\n      \"#include <skinning_pars_vertex>\",\n      \"#include <logdepthbuf_pars_vertex>\",\n      \"#include <clipping_planes_pars_vertex>\",\n      \"uniform float outlineThickness;\",\n      \"vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\",\n      \"\tfloat thickness = outlineThickness;\",\n      \"\tconst float ratio = 1.0;\",\n      // TODO: support outline thickness ratio for each vertex\n      \"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\",\n      // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n      \"\tvec4 norm = normalize( pos - pos2 );\",\n      \"\treturn pos + norm * thickness * pos.w * ratio;\",\n      \"}\",\n      \"void main() {\",\n      \"\t#include <uv_vertex>\",\n      \"\t#include <beginnormal_vertex>\",\n      \"\t#include <morphnormal_vertex>\",\n      \"\t#include <skinbase_vertex>\",\n      \"\t#include <skinnormal_vertex>\",\n      \"\t#include <begin_vertex>\",\n      \"\t#include <morphtarget_vertex>\",\n      \"\t#include <skinning_vertex>\",\n      \"\t#include <displacementmap_vertex>\",\n      \"\t#include <project_vertex>\",\n      \"\tvec3 outlineNormal = - objectNormal;\",\n      // the outline material is always rendered with BackSide\n      \"\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\",\n      \"\t#include <logdepthbuf_vertex>\",\n      \"\t#include <clipping_planes_vertex>\",\n      \"\t#include <fog_vertex>\",\n      \"}\"\n    ].join(\"\\n\");\n    const fragmentShader = [\n      \"#include <common>\",\n      \"#include <fog_pars_fragment>\",\n      \"#include <logdepthbuf_pars_fragment>\",\n      \"#include <clipping_planes_pars_fragment>\",\n      \"uniform vec3 outlineColor;\",\n      \"uniform float outlineAlpha;\",\n      \"void main() {\",\n      \"\t#include <clipping_planes_fragment>\",\n      \"\t#include <logdepthbuf_fragment>\",\n      \"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\",\n      \"\t#include <tonemapping_fragment>\",\n      \"\t#include <encodings_fragment>\",\n      \"\t#include <fog_fragment>\",\n      \"\t#include <premultiplied_alpha_fragment>\",\n      \"}\"\n    ].join(\"\\n\");\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: \"OutlineEffect\",\n        uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"displacementmap\"], uniformsOutline]),\n        vertexShader,\n        fragmentShader,\n        side: BackSide\n      });\n    }\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid];\n      if (data === void 0) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0\n        };\n        cache[originalMaterial.uuid] = data;\n      }\n      data.used = true;\n      return data.material;\n    }\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n      originalMaterials[outlineMaterial.uuid] = originalMaterial;\n      updateOutlineMaterial(outlineMaterial, originalMaterial);\n      return outlineMaterial;\n    }\n    function isCompatible(object) {\n      const geometry = object.geometry;\n      const hasNormals = geometry !== void 0 && geometry.attributes.normal !== void 0;\n      return object.isMesh === true && object.material !== void 0 && hasNormals === true;\n    }\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false)\n        return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i]);\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material);\n      }\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n      object.onBeforeRender = onBeforeRender;\n    }\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false)\n        return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid];\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid];\n      }\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n    }\n    function onBeforeRender(renderer2, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid];\n      if (originalMaterial === void 0)\n        return;\n      updateUniforms(material, originalMaterial);\n    }\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n      if (outlineParameters !== void 0) {\n        if (outlineParameters.thickness !== void 0)\n          material.uniforms.outlineThickness.value = outlineParameters.thickness;\n        if (outlineParameters.color !== void 0)\n          material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n        if (outlineParameters.alpha !== void 0)\n          material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n      }\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n      }\n    }\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === \"invisible\")\n        return;\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.fog = originalMaterial.fog;\n      material.toneMapped = originalMaterial.toneMapped;\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n      material.displacementMap = originalMaterial.displacementMap;\n      if (outlineParameters !== void 0) {\n        if (originalMaterial.visible === false) {\n          material.visible = false;\n        } else {\n          material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;\n        }\n        material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;\n        if (outlineParameters.keepAlive !== void 0)\n          cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      } else {\n        material.transparent = originalMaterial.transparent;\n        material.visible = originalMaterial.visible;\n      }\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false)\n        material.visible = false;\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true;\n        material.clippingPlanes = originalMaterial.clippingPlanes;\n        material.clipIntersection = originalMaterial.clipIntersection;\n        material.clipShadows = originalMaterial.clipShadows;\n      }\n      material.version = originalMaterial.version;\n    }\n    function cleanupCache() {\n      let keys;\n      keys = Object.keys(originalMaterials);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = void 0;\n      }\n      keys = Object.keys(originalOnBeforeRenders);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = void 0;\n      }\n      keys = Object.keys(cache);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i];\n        if (cache[key].used === false) {\n          cache[key].count++;\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key];\n          }\n        } else {\n          cache[key].used = false;\n          cache[key].count = 0;\n        }\n      }\n    }\n    this.render = function(scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera);\n        return;\n      }\n      const currentAutoClear = renderer.autoClear;\n      renderer.autoClear = this.autoClear;\n      renderer.render(scene, camera);\n      renderer.autoClear = currentAutoClear;\n      this.renderOutline(scene, camera);\n    };\n    this.renderOutline = function(scene, camera) {\n      const currentAutoClear = renderer.autoClear;\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n      const currentSceneBackground = scene.background;\n      const currentShadowMapEnabled = renderer.shadowMap.enabled;\n      scene.matrixWorldAutoUpdate = false;\n      scene.background = null;\n      renderer.autoClear = false;\n      renderer.shadowMap.enabled = false;\n      scene.traverse(setOutlineMaterial);\n      renderer.render(scene, camera);\n      scene.traverse(restoreOriginalMaterial);\n      cleanupCache();\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n      scene.background = currentSceneBackground;\n      renderer.autoClear = currentAutoClear;\n      renderer.shadowMap.enabled = currentShadowMapEnabled;\n    };\n    this.autoClear = renderer.autoClear;\n    this.domElement = renderer.domElement;\n    this.shadowMap = renderer.shadowMap;\n    this.clear = function(color, depth, stencil) {\n      renderer.clear(color, depth, stencil);\n    };\n    this.getPixelRatio = function() {\n      return renderer.getPixelRatio();\n    };\n    this.setPixelRatio = function(value) {\n      renderer.setPixelRatio(value);\n    };\n    this.getSize = function(target) {\n      return renderer.getSize(target);\n    };\n    this.setSize = function(width, height, updateStyle) {\n      renderer.setSize(width, height, updateStyle);\n    };\n    this.setViewport = function(x, y, width, height) {\n      renderer.setViewport(x, y, width, height);\n    };\n    this.setScissor = function(x, y, width, height) {\n      renderer.setScissor(x, y, width, height);\n    };\n    this.setScissorTest = function(boolean) {\n      renderer.setScissorTest(boolean);\n    };\n    this.setRenderTarget = function(renderTarget) {\n      renderer.setRenderTarget(renderTarget);\n    };\n  }\n}\nexport {\n  OutlineEffect\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}