{"ast":null,"code":"import { createError } from '../errors.js';\nexport function prioritizeTokenScores(arrays, boost) {\n  let threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let keywordsCount = arguments.length > 3 ? arguments[3] : undefined;\n  if (boost === 0) {\n    throw createError('INVALID_BOOST_VALUE');\n  }\n  const tokenScoresMap = new Map();\n  const tokenKeywordsCountMap = new Map();\n  const mapsLength = arrays.length;\n  for (let i = 0; i < mapsLength; i++) {\n    const arr = arrays[i];\n    const entriesLength = arr.length;\n    for (let j = 0; j < entriesLength; j++) {\n      const [token, score] = arr[j];\n      const boostScore = score * boost;\n      const oldScore = tokenScoresMap.get(token);\n      if (oldScore !== undefined) {\n        tokenScoresMap.set(token, oldScore * 1.5 + boostScore);\n        tokenKeywordsCountMap.set(token, tokenKeywordsCountMap.get(token) + 1);\n      } else {\n        tokenScoresMap.set(token, boostScore);\n        tokenKeywordsCountMap.set(token, 1);\n      }\n    }\n  }\n  const tokenScores = [];\n  for (const tokenScoreEntry of tokenScoresMap.entries()) {\n    tokenScores.push(tokenScoreEntry);\n  }\n  const results = tokenScores.sort((a, b) => b[1] - a[1]);\n  // If threshold is 1, it means we will return all the results with at least one search term,\n  // prioritizig the ones that contains more search terms (fuzzy match)\n  if (threshold === 1) {\n    return results;\n  }\n  // Prepare keywords count tracking for threshold handling\n  const allResults = results.length;\n  const tokenKeywordsCount = [];\n  for (const tokenKeywordsCountEntry of tokenKeywordsCountMap.entries()) {\n    tokenKeywordsCount.push(tokenKeywordsCountEntry);\n  }\n  // Find the index of the last result with all keywords.\n  // Note that since score is multipled by 1.5 any time the token is encountered in results it means\n  // that tokenScores and tokenKeywordsCount should always have the same order.\n  const keywordsPerToken = tokenKeywordsCount.sort((a, b) => b[1] - a[1]);\n  let lastTokenWithAllKeywords = undefined;\n  for (let i = 0; i < allResults; i++) {\n    if (keywordsPerToken[i][1] === keywordsCount) {\n      lastTokenWithAllKeywords = i;\n    } else {\n      break;\n    }\n  }\n  // If no results had all the keywords, either bail out earlier or normalize\n  if (typeof lastTokenWithAllKeywords === 'undefined') {\n    if (threshold === 0) {\n      return [];\n    }\n    lastTokenWithAllKeywords = 0;\n  }\n  // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)\n  if (threshold === 0) {\n    return results.slice(0, lastTokenWithAllKeywords + 1);\n  }\n  // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms\n  // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms\n  // (fuzzy match with a minimum threshold)\n  const thresholdLength = lastTokenWithAllKeywords + Math.ceil(threshold * 100 * (results.length - lastTokenWithAllKeywords) / 100);\n  return results.slice(0, results.length + thresholdLength);\n}\nexport function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, BM25Params) {\n  const {\n    k,\n    b,\n    d\n  } = BM25Params;\n  const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));\n  return idf * (d + tf * (k + 1)) / (tf + k * (1 - b + b * fieldLength / averageFieldLength));\n}","map":{"version":3,"names":["createError","prioritizeTokenScores","arrays","boost","threshold","arguments","length","undefined","keywordsCount","tokenScoresMap","Map","tokenKeywordsCountMap","mapsLength","i","arr","entriesLength","j","token","score","boostScore","oldScore","get","set","tokenScores","tokenScoreEntry","entries","push","results","sort","a","b","allResults","tokenKeywordsCount","tokenKeywordsCountEntry","keywordsPerToken","lastTokenWithAllKeywords","slice","thresholdLength","Math","ceil","BM25","tf","matchingCount","docsCount","fieldLength","averageFieldLength","BM25Params","k","d","idf","log"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/algorithms.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { TokenScore, BM25Params } from '../types.js'\nimport { InternalDocumentID } from './internal-document-id-store.js'\n\nexport function prioritizeTokenScores(\n  arrays: TokenScore[][],\n  boost: number,\n  threshold = 1,\n  keywordsCount: number,\n): TokenScore[] {\n  if (boost === 0) {\n    throw createError('INVALID_BOOST_VALUE')\n  }\n\n  const tokenScoresMap = new Map<InternalDocumentID, number>()\n  const tokenKeywordsCountMap = new Map<InternalDocumentID, number>()\n\n  const mapsLength = arrays.length\n  for (let i = 0; i < mapsLength; i++) {\n    const arr = arrays[i]\n\n    const entriesLength = arr.length\n    for (let j = 0; j < entriesLength; j++) {\n      const [token, score] = arr[j]\n      const boostScore = score * boost\n      const oldScore = tokenScoresMap.get(token)\n\n      if (oldScore !== undefined) {\n        tokenScoresMap.set(token, oldScore * 1.5 + boostScore)\n        tokenKeywordsCountMap.set(token, tokenKeywordsCountMap.get(token)! + 1)\n      } else {\n        tokenScoresMap.set(token, boostScore)\n        tokenKeywordsCountMap.set(token, 1)\n      }\n    }\n  }\n\n  const tokenScores: TokenScore[] = []\n\n  for (const tokenScoreEntry of tokenScoresMap.entries()) {\n    tokenScores.push(tokenScoreEntry)\n  }\n\n  const results = tokenScores.sort((a, b) => b[1] - a[1])\n\n  // If threshold is 1, it means we will return all the results with at least one search term,\n  // prioritizig the ones that contains more search terms (fuzzy match)\n  if (threshold === 1) {\n    return results\n  }\n\n  // Prepare keywords count tracking for threshold handling\n  const allResults = results.length\n  const tokenKeywordsCount: [InternalDocumentID, number][] = []\n\n  for (const tokenKeywordsCountEntry of tokenKeywordsCountMap.entries()) {\n    tokenKeywordsCount.push(tokenKeywordsCountEntry)\n  }\n\n  // Find the index of the last result with all keywords.\n  // Note that since score is multipled by 1.5 any time the token is encountered in results it means\n  // that tokenScores and tokenKeywordsCount should always have the same order.\n  const keywordsPerToken = tokenKeywordsCount.sort((a, b) => b[1] - a[1])\n\n  let lastTokenWithAllKeywords: number | undefined = undefined\n  for (let i = 0; i < allResults; i++) {\n    if (keywordsPerToken[i][1] === keywordsCount) {\n      lastTokenWithAllKeywords = i\n    } else {\n      break\n    }\n  }\n\n  // If no results had all the keywords, either bail out earlier or normalize\n  if (typeof lastTokenWithAllKeywords === 'undefined') {\n    if (threshold === 0) {\n      return []\n    }\n\n    lastTokenWithAllKeywords = 0\n  }\n\n  // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)\n  if (threshold === 0) {\n    return results.slice(0, lastTokenWithAllKeywords + 1)\n  }\n\n  // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms\n  // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms\n  // (fuzzy match with a minimum threshold)\n  const thresholdLength =\n    lastTokenWithAllKeywords + Math.ceil((threshold * 100 * (results.length - lastTokenWithAllKeywords)) / 100)\n\n  return results.slice(0, results.length + thresholdLength)\n}\n\nexport function BM25(\n  tf: number,\n  matchingCount: number,\n  docsCount: number,\n  fieldLength: number,\n  averageFieldLength: number,\n  BM25Params: Required<BM25Params>,\n) {\n  const { k, b, d } = BM25Params\n  const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5))\n  return (idf * (d + tf * (k + 1))) / (tf + k * (1 - b + (b * fieldLength) / averageFieldLength))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}