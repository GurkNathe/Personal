{"ast":null,"code":"import { createError } from '../errors.js';\nimport { getNested } from '../utils.js';\nfunction sortingPredicate() {\n  let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'desc';\n  let a = arguments.length > 1 ? arguments[1] : undefined;\n  let b = arguments.length > 2 ? arguments[2] : undefined;\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1];\n  } else {\n    return b[1] - a[1];\n  }\n}\nexport async function getFacets(orama, results, facetsConfig) {\n  const facets = {};\n  const allIDs = results.map(_ref => {\n    let [id] = _ref;\n    return id;\n  });\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n  const facetKeys = Object.keys(facetsConfig);\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n  for (const facet of facetKeys) {\n    let values = {};\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const {\n        ranges\n      } = facetsConfig[facet];\n      const tmp = [];\n      for (const range of ranges) {\n        tmp.push([\"\".concat(range.from, \"-\").concat(range.to), 0]);\n      }\n      values = Object.fromEntries(tmp);\n    }\n    facets[facet] = {\n      count: 0,\n      values\n    };\n  }\n  const allDocsLength = allDocs.length;\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i];\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.') ? await getNested(doc, facet) : doc[facet];\n      const propertyType = properties[facet];\n      switch (propertyType) {\n        case 'number':\n          {\n            const ranges = facetsConfig[facet].ranges;\n            calculateNumberFacet(ranges, facets[facet].values, facetValue);\n            break;\n          }\n        case 'number[]':\n          {\n            const alreadyInsertedValues = new Set();\n            const ranges = facetsConfig[facet].ranges;\n            for (const v of facetValue) {\n              calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues);\n            }\n            break;\n          }\n        case 'boolean':\n        case 'enum':\n        case 'string':\n          {\n            calculateBooleanStringOrEnumFacet(facets[facet].values, facetValue, propertyType);\n            break;\n          }\n        case 'boolean[]':\n        case 'enum[]':\n        case 'string[]':\n          {\n            const alreadyInsertedValues = new Set();\n            const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string';\n            for (const v of facetValue) {\n              calculateBooleanStringOrEnumFacet(facets[facet].values, v, innerType, alreadyInsertedValues);\n            }\n            break;\n          }\n        default:\n          throw createError('FACET_NOT_SUPPORTED', propertyType);\n      }\n    }\n  }\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length;\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      var _stringFacetDefinitio, _stringFacetDefinitio2;\n      const stringFacetDefinition = facetsConfig;\n      facets[facet].values = Object.fromEntries(Object.entries(facets[facet].values).sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b)).slice((_stringFacetDefinitio = stringFacetDefinition.offset) !== null && _stringFacetDefinitio !== void 0 ? _stringFacetDefinitio : 0, (_stringFacetDefinitio2 = stringFacetDefinition.limit) !== null && _stringFacetDefinitio2 !== void 0 ? _stringFacetDefinitio2 : 10));\n    }\n  }\n  return facets;\n}\nfunction calculateNumberFacet(ranges, values, facetValue, alreadyInsertedValues) {\n  for (const range of ranges) {\n    const value = \"\".concat(range.from, \"-\").concat(range.to);\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue;\n    }\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1;\n      } else {\n        values[value]++;\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value);\n        }\n      }\n    }\n  }\n}\nfunction calculateBooleanStringOrEnumFacet(values, facetValue, propertyType, alreadyInsertedValues) {\n  var _ref2, _values$value;\n  // String or boolean based facets\n  const value = (_ref2 = facetValue === null || facetValue === void 0 ? void 0 : facetValue.toString()) !== null && _ref2 !== void 0 ? _ref2 : propertyType === 'boolean' ? 'false' : '';\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return;\n  }\n  values[value] = ((_values$value = values[value]) !== null && _values$value !== void 0 ? _values$value : 0) + 1;\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value);\n  }\n}","map":{"version":3,"names":["createError","getNested","sortingPredicate","order","arguments","length","undefined","a","b","toLowerCase","getFacets","orama","results","facetsConfig","facets","allIDs","map","_ref","id","allDocs","documentsStore","getMultiple","data","docs","facetKeys","Object","keys","properties","index","getSearchablePropertiesWithTypes","facet","values","ranges","tmp","range","push","concat","from","to","fromEntries","count","allDocsLength","i","doc","facetValue","includes","propertyType","calculateNumberFacet","alreadyInsertedValues","Set","v","calculateBooleanStringOrEnumFacet","innerType","_stringFacetDefinitio","_stringFacetDefinitio2","stringFacetDefinition","entries","sort","slice","offset","limit","value","has","add","_ref2","_values$value","toString"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/facets.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport type {\n  AnyOrama,\n  FacetResult,\n  FacetSorting,\n  FacetsParams,\n  NumberFacetDefinition,\n  SearchableValue,\n  StringFacetDefinition,\n  TokenScore,\n} from '../types.js'\nimport { getNested } from '../utils.js'\n\ntype FacetValue = string | boolean | number\n\nfunction sortingPredicate(order: FacetSorting = 'desc', a: [string, number], b: [string, number]) {\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1]\n  } else {\n    return b[1] - a[1]\n  }\n}\n\nexport async function getFacets<T extends AnyOrama>(\n  orama: T,\n  results: TokenScore[],\n  facetsConfig: FacetsParams<T>,\n): Promise<FacetResult> {\n  const facets: FacetResult = {}\n  const allIDs = results.map(([id]) => id)\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const facetKeys = Object.keys(facetsConfig!)\n\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n\n  for (const facet of facetKeys) {\n    let values = {}\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const { ranges } = facetsConfig[facet] as NumberFacetDefinition\n      const tmp: [string, number][] = []\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0])\n      }\n      values = Object.fromEntries(tmp)\n    }\n\n    facets[facet] = {\n      count: 0,\n      values,\n    }\n  }\n\n  const allDocsLength = allDocs.length\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i]\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? (await getNested<string>(doc!, facet))!\n        : (doc![facet] as SearchableValue)\n\n      const propertyType = properties[facet]\n      switch (propertyType) {\n        case 'number': {\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          calculateNumberFacet(ranges, facets[facet].values, facetValue as number)\n          break\n        }\n        case 'number[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          for (const v of facetValue as Array<number>) {\n            calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues)\n          }\n          break\n        }\n        case 'boolean':\n        case 'enum':\n        case 'string': {\n          calculateBooleanStringOrEnumFacet(facets[facet].values, facetValue as FacetValue, propertyType)\n          break\n        }\n        case 'boolean[]':\n        case 'enum[]':\n        case 'string[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string'\n          for (const v of facetValue as Array<FacetValue>) {\n            calculateBooleanStringOrEnumFacet(facets[facet].values, v, innerType, alreadyInsertedValues)\n          }\n          break\n        }\n        default:\n          throw createError('FACET_NOT_SUPPORTED', propertyType)\n      }\n    }\n  }\n\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length\n\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig as StringFacetDefinition\n\n      facets[facet].values = Object.fromEntries(\n        Object.entries(facets[facet].values)\n          .sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b))\n          .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10),\n      )\n    }\n  }\n\n  return facets\n}\n\nfunction calculateNumberFacet(\n  ranges: NumberFacetDefinition['ranges'],\n  values: Record<string, number>,\n  facetValue: number,\n  alreadyInsertedValues?: Set<string>,\n) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue\n    }\n\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1\n      } else {\n        values[value]++\n\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value)\n        }\n      }\n    }\n  }\n}\n\nfunction calculateBooleanStringOrEnumFacet(\n  values: Record<string, number>,\n  facetValue: FacetValue,\n  propertyType: 'string' | 'boolean' | 'enum',\n  alreadyInsertedValues?: Set<string>,\n) {\n  // String or boolean based facets\n  const value = facetValue?.toString() ?? (propertyType === 'boolean' ? 'false' : '')\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return\n  }\n  values[value] = (values[value] ?? 0) + 1\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value)\n  }\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ;AAW5B,SAASC,SAAS,QAAQ;AAI1B,SAASC,iBAAA,EAAyF;EAAA,IAAxEC,KAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAsB,MAAM;EAAA,IAAEG,CAAmB,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEE,CAAmB,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAC9F,IAAIH,KAAA,CAAMM,WAAW,OAAO,OAAO;IACjC,OAAOF,CAAC,CAAC,EAAE,GAAGC,CAAC,CAAC,EAAE;EACpB,OAAO;IACL,OAAOA,CAAC,CAAC,EAAE,GAAGD,CAAC,CAAC,EAAE;EACpB;AACF;AAEA,OAAO,eAAeG,UACpBC,KAAQ,EACRC,OAAqB,EACrBC,YAA6B,EACP;EACtB,MAAMC,MAAA,GAAsB,CAAC;EAC7B,MAAMC,MAAA,GAASH,OAAA,CAAQI,GAAG,CAACC,IAAA;IAAA,IAAC,CAACC,EAAA,CAAG,GAAAD,IAAA;IAAA,OAAKC,EAAA;EAAA;EACrC,MAAMC,OAAA,GAAU,MAAMR,KAAA,CAAMS,cAAc,CAACC,WAAW,CAACV,KAAA,CAAMW,IAAI,CAACC,IAAI,EAAER,MAAA;EACxE,MAAMS,SAAA,GAAYC,MAAA,CAAOC,IAAI,CAACb,YAAA;EAE9B,MAAMc,UAAA,GAAa,MAAMhB,KAAA,CAAMiB,KAAK,CAACC,gCAAgC,CAAClB,KAAA,CAAMW,IAAI,CAACM,KAAK;EAEtF,KAAK,MAAME,KAAA,IAASN,SAAA,EAAW;IAC7B,IAAIO,MAAA,GAAS,CAAC;IAEd;IACA;IACA,IAAIJ,UAAU,CAACG,KAAA,CAAM,KAAK,UAAU;MAClC,MAAM;QAAEE;MAAM,CAAE,GAAGnB,YAAY,CAACiB,KAAA,CAAM;MACtC,MAAMG,GAAA,GAA0B,EAAE;MAClC,KAAK,MAAMC,KAAA,IAASF,MAAA,EAAQ;QAC1BC,GAAA,CAAIE,IAAI,CAAC,IAAAC,MAAA,CAAIF,KAAA,CAAMG,IAAI,OAAAD,MAAA,CAAIF,KAAA,CAAMI,EAAE,GAAI,EAAE;MAC3C;MACAP,MAAA,GAASN,MAAA,CAAOc,WAAW,CAACN,GAAA;IAC9B;IAEAnB,MAAM,CAACgB,KAAA,CAAM,GAAG;MACdU,KAAA,EAAO;MACPT;IACF;EACF;EAEA,MAAMU,aAAA,GAAgBtB,OAAA,CAAQd,MAAM;EACpC,KAAK,IAAIqC,CAAA,GAAI,GAAGA,CAAA,GAAID,aAAA,EAAeC,CAAA,IAAK;IACtC,MAAMC,GAAA,GAAMxB,OAAO,CAACuB,CAAA,CAAE;IAEtB,KAAK,MAAMZ,KAAA,IAASN,SAAA,EAAW;MAC7B,MAAMoB,UAAA,GAAad,KAAA,CAAMe,QAAQ,CAAC,OAC7B,MAAM5C,SAAA,CAAkB0C,GAAA,EAAMb,KAAA,IAC9Ba,GAAI,CAACb,KAAA,CAAM;MAEhB,MAAMgB,YAAA,GAAenB,UAAU,CAACG,KAAA,CAAM;MACtC,QAAQgB,YAAA;QACN,KAAK;UAAU;YACb,MAAMd,MAAA,GAASnB,YAAa,CAACiB,KAAA,CAAM,CAA2BE,MAAM;YACpEe,oBAAA,CAAqBf,MAAA,EAAQlB,MAAM,CAACgB,KAAA,CAAM,CAACC,MAAM,EAAEa,UAAA;YACnD;UACF;QACA,KAAK;UAAY;YACf,MAAMI,qBAAA,GAAwB,IAAIC,GAAA;YAClC,MAAMjB,MAAA,GAASnB,YAAa,CAACiB,KAAA,CAAM,CAA2BE,MAAM;YACpE,KAAK,MAAMkB,CAAA,IAAKN,UAAA,EAA6B;cAC3CG,oBAAA,CAAqBf,MAAA,EAAQlB,MAAM,CAACgB,KAAA,CAAM,CAACC,MAAM,EAAEmB,CAAA,EAAGF,qBAAA;YACxD;YACA;UACF;QACA,KAAK;QACL,KAAK;QACL,KAAK;UAAU;YACbG,iCAAA,CAAkCrC,MAAM,CAACgB,KAAA,CAAM,CAACC,MAAM,EAAEa,UAAA,EAA0BE,YAAA;YAClF;UACF;QACA,KAAK;QACL,KAAK;QACL,KAAK;UAAY;YACf,MAAME,qBAAA,GAAwB,IAAIC,GAAA;YAClC,MAAMG,SAAA,GAAYN,YAAA,KAAiB,cAAc,YAAY,QAAQ;YACrE,KAAK,MAAMI,CAAA,IAAKN,UAAA,EAAiC;cAC/CO,iCAAA,CAAkCrC,MAAM,CAACgB,KAAA,CAAM,CAACC,MAAM,EAAEmB,CAAA,EAAGE,SAAA,EAAWJ,qBAAA;YACxE;YACA;UACF;QACA;UACE,MAAMhD,WAAA,CAAY,uBAAuB8C,YAAA;MAC7C;IACF;EACF;EAEA,KAAK,MAAMhB,KAAA,IAASN,SAAA,EAAW;IAC7B;IACAV,MAAM,CAACgB,KAAA,CAAM,CAACU,KAAK,GAAGf,MAAA,CAAOC,IAAI,CAACZ,MAAM,CAACgB,KAAA,CAAM,CAACC,MAAM,EAAE1B,MAAM;IAE9D;IACA,IAAIsB,UAAU,CAACG,KAAA,CAAM,KAAK,UAAU;MAAA,IAAAuB,qBAAA,EAAAC,sBAAA;MAClC,MAAMC,qBAAA,GAAwB1C,YAAA;MAE9BC,MAAM,CAACgB,KAAA,CAAM,CAACC,MAAM,GAAGN,MAAA,CAAOc,WAAW,CACvCd,MAAA,CAAO+B,OAAO,CAAC1C,MAAM,CAACgB,KAAA,CAAM,CAACC,MAAM,EAChC0B,IAAI,CAAC,CAAClD,CAAA,EAAGC,CAAA,KAAMN,gBAAA,CAAiBqD,qBAAA,CAAsBE,IAAI,EAAElD,CAAA,EAAGC,CAAA,GAC/DkD,KAAK,EAAAL,qBAAA,GAACE,qBAAA,CAAsBI,MAAM,cAAAN,qBAAA,cAAAA,qBAAA,GAAI,IAAAC,sBAAA,GAAGC,qBAAA,CAAsBK,KAAK,cAAAN,sBAAA,cAAAA,sBAAA,GAAI;IAE/E;EACF;EAEA,OAAOxC,MAAA;AACT;AAEA,SAASiC,qBACPf,MAAuC,EACvCD,MAA8B,EAC9Ba,UAAkB,EAClBI,qBAAmC,EACnC;EACA,KAAK,MAAMd,KAAA,IAASF,MAAA,EAAQ;IAC1B,MAAM6B,KAAA,MAAAzB,MAAA,CAAWF,KAAA,CAAMG,IAAI,OAAAD,MAAA,CAAIF,KAAA,CAAMI,EAAE,CAAE;IACzC,IAAIU,qBAAA,IAAyBA,qBAAA,CAAsBc,GAAG,CAACD,KAAA,GAAQ;MAC7D;IACF;IAEA,IAAIjB,UAAA,IAAcV,KAAA,CAAMG,IAAI,IAAIO,UAAA,IAAcV,KAAA,CAAMI,EAAE,EAAE;MACtD,IAAIP,MAAM,CAAC8B,KAAA,CAAM,KAAKvD,SAAA,EAAW;QAC/ByB,MAAM,CAAC8B,KAAA,CAAM,GAAG;MAClB,OAAO;QACL9B,MAAM,CAAC8B,KAAA,CAAM;QAEb,IAAIb,qBAAA,EAAuB;UACzBA,qBAAA,CAAsBe,GAAG,CAACF,KAAA;QAC5B;MACF;IACF;EACF;AACF;AAEA,SAASV,kCACPpB,MAA8B,EAC9Ba,UAAsB,EACtBE,YAA2C,EAC3CE,qBAAmC,EACnC;EAAA,IAAAgB,KAAA,EAAAC,aAAA;EACA;EACA,MAAMJ,KAAA,IAAAG,KAAA,GAAQpB,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYsB,QAAQ,gBAAAF,KAAA,cAAAA,KAAA,GAAOlB,YAAA,KAAiB,YAAY,UAAU,EAAC;EACjF,IAAIE,qBAAA,IAAyBA,qBAAA,CAAsBc,GAAG,CAACD,KAAA,GAAQ;IAC7D;EACF;EACA9B,MAAM,CAAC8B,KAAA,CAAM,GAAG,EAAAI,aAAA,GAAClC,MAAM,CAAC8B,KAAA,CAAM,cAAAI,aAAA,cAAAA,aAAA,GAAI,KAAK;EACvC,IAAIjB,qBAAA,EAAuB;IACzBA,qBAAA,CAAsBe,GAAG,CAACF,KAAA;EAC5B;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}