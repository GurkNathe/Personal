{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nclass EdgeSplitModifier {\n  constructor() {\n    var _this = this;\n    __publicField(this, \"A\", new Vector3());\n    __publicField(this, \"B\", new Vector3());\n    __publicField(this, \"C\", new Vector3());\n    __publicField(this, \"positions\", []);\n    __publicField(this, \"normals\", new Float32Array());\n    __publicField(this, \"indexes\", []);\n    __publicField(this, \"pointToIndexMap\", []);\n    __publicField(this, \"splitIndexes\", []);\n    __publicField(this, \"oldNormals\", []);\n    __publicField(this, \"computeNormals\", () => {\n      this.normals = new Float32Array(this.indexes.length * 3);\n      for (let i = 0; i < this.indexes.length; i += 3) {\n        let index = this.indexes[i];\n        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 1];\n        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 2];\n        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        this.C.sub(this.B);\n        this.A.sub(this.B);\n        const normal = this.C.cross(this.A).normalize();\n        for (let j = 0; j < 3; j++) {\n          this.normals[3 * (i + j)] = normal.x;\n          this.normals[3 * (i + j) + 1] = normal.y;\n          this.normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    });\n    __publicField(this, \"mapPositionsToIndexes\", () => {\n      this.pointToIndexMap = Array(this.positions.length / 3);\n      for (let i = 0; i < this.indexes.length; i++) {\n        const index = this.indexes[i];\n        if (this.pointToIndexMap[index] == null) {\n          this.pointToIndexMap[index] = [];\n        }\n        this.pointToIndexMap[index].push(i);\n      }\n    });\n    __publicField(this, \"edgeSplitToGroups\", (indexes, cutOff, firstIndex) => {\n      this.A.set(this.normals[3 * firstIndex], this.normals[3 * firstIndex + 1], this.normals[3 * firstIndex + 2]).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (let j of indexes) {\n        if (j !== firstIndex) {\n          this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();\n          if (this.B.dot(this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"edgeSplit\", function (indexes, cutOff) {\n      let original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (indexes.length === 0) return;\n      const groupResults = [];\n      for (let index of indexes) {\n        groupResults.push(_this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (let groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        _this.splitIndexes.push({\n          original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        _this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    });\n    __publicField(this, \"modify\", function (geometry, cutOffAngle) {\n      let tryKeepNormals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      let hadNormals = false;\n      if (geometry.attributes.normal) {\n        hadNormals = true;\n        geometry = geometry.clone();\n        if (tryKeepNormals === true && geometry.index !== null) {\n          _this.oldNormals = geometry.attributes.normal.array;\n        }\n        geometry.deleteAttribute(\"normal\");\n      }\n      if (geometry.index == null) {\n        if (BufferGeometryUtils === void 0) {\n          throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n        }\n        geometry = mergeVertices(geometry);\n      }\n      _this.indexes = geometry.index.array;\n      _this.positions = geometry.getAttribute(\"position\").array;\n      _this.computeNormals();\n      _this.mapPositionsToIndexes();\n      _this.splitIndexes = [];\n      for (let vertexIndexes of _this.pointToIndexMap) {\n        _this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n      const newAttributes = {};\n      for (let name of Object.keys(geometry.attributes)) {\n        const oldAttribute = geometry.attributes[name];\n        const newArray = new oldAttribute.array.constructor((_this.indexes.length + _this.splitIndexes.length) * oldAttribute.itemSize);\n        newArray.set(oldAttribute.array);\n        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n      }\n      const newIndexes = new Uint32Array(_this.indexes.length);\n      newIndexes.set(_this.indexes);\n      for (let i = 0; i < _this.splitIndexes.length; i++) {\n        const split = _this.splitIndexes[i];\n        const index = _this.indexes[split.original];\n        for (let attribute of Object.values(newAttributes)) {\n          for (let j = 0; j < attribute.itemSize; j++) {\n            attribute.array[(_this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n          }\n        }\n        for (let j of split.indexes) {\n          newIndexes[j] = _this.indexes.length + i;\n        }\n      }\n      geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(newIndexes, 1));\n      for (let name of Object.keys(newAttributes)) {\n        geometry.setAttribute(name, newAttributes[name]);\n      }\n      if (hadNormals) {\n        geometry.computeVertexNormals();\n        if (_this.oldNormals !== null) {\n          const changedNormals = new Array(_this.oldNormals.length / 3).fill(false);\n          for (let splitData of _this.splitIndexes) changedNormals[splitData.original] = true;\n          for (let i = 0; i < changedNormals.length; i++) {\n            if (changedNormals[i] === false) {\n              for (let j = 0; j < 3; j++) {\n                geometry.attributes.normal.array[3 * i + j] = _this.oldNormals[3 * i + j];\n              }\n            }\n          }\n        }\n      }\n      return geometry;\n    });\n  }\n}\nexport { EdgeSplitModifier };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Vector3","BufferAttribute","BufferGeometry","BufferGeometryUtils","mergeVertices","EdgeSplitModifier","constructor","_this","Float32Array","normals","indexes","length","i","index","A","set","positions","B","C","sub","normal","cross","normalize","j","x","y","z","pointToIndexMap","Array","push","cutOff","firstIndex","result","splitGroup","currentGroup","dot","original","arguments","undefined","groupResults","edgeSplitToGroups","groupResult","splitIndexes","edgeSplit","geometry","cutOffAngle","tryKeepNormals","hadNormals","attributes","clone","oldNormals","array","deleteAttribute","getAttribute","computeNormals","mapPositionsToIndexes","vertexIndexes","Math","cos","newAttributes","name","keys","oldAttribute","newArray","itemSize","normalized","newIndexes","Uint32Array","split","attribute","values","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/modifiers/EdgeSplitModifier.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nclass EdgeSplitModifier {\n  constructor() {\n    __publicField(this, \"A\", new Vector3());\n    __publicField(this, \"B\", new Vector3());\n    __publicField(this, \"C\", new Vector3());\n    __publicField(this, \"positions\", []);\n    __publicField(this, \"normals\", new Float32Array());\n    __publicField(this, \"indexes\", []);\n    __publicField(this, \"pointToIndexMap\", []);\n    __publicField(this, \"splitIndexes\", []);\n    __publicField(this, \"oldNormals\", []);\n    __publicField(this, \"computeNormals\", () => {\n      this.normals = new Float32Array(this.indexes.length * 3);\n      for (let i = 0; i < this.indexes.length; i += 3) {\n        let index = this.indexes[i];\n        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 1];\n        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 2];\n        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        this.C.sub(this.B);\n        this.A.sub(this.B);\n        const normal = this.C.cross(this.A).normalize();\n        for (let j = 0; j < 3; j++) {\n          this.normals[3 * (i + j)] = normal.x;\n          this.normals[3 * (i + j) + 1] = normal.y;\n          this.normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    });\n    __publicField(this, \"mapPositionsToIndexes\", () => {\n      this.pointToIndexMap = Array(this.positions.length / 3);\n      for (let i = 0; i < this.indexes.length; i++) {\n        const index = this.indexes[i];\n        if (this.pointToIndexMap[index] == null) {\n          this.pointToIndexMap[index] = [];\n        }\n        this.pointToIndexMap[index].push(i);\n      }\n    });\n    __publicField(this, \"edgeSplitToGroups\", (indexes, cutOff, firstIndex) => {\n      this.A.set(\n        this.normals[3 * firstIndex],\n        this.normals[3 * firstIndex + 1],\n        this.normals[3 * firstIndex + 2]\n      ).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (let j of indexes) {\n        if (j !== firstIndex) {\n          this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();\n          if (this.B.dot(this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"edgeSplit\", (indexes, cutOff, original = null) => {\n      if (indexes.length === 0)\n        return;\n      const groupResults = [];\n      for (let index of indexes) {\n        groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (let groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        this.splitIndexes.push({\n          original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    });\n    __publicField(this, \"modify\", (geometry, cutOffAngle, tryKeepNormals = true) => {\n      let hadNormals = false;\n      if (geometry.attributes.normal) {\n        hadNormals = true;\n        geometry = geometry.clone();\n        if (tryKeepNormals === true && geometry.index !== null) {\n          this.oldNormals = geometry.attributes.normal.array;\n        }\n        geometry.deleteAttribute(\"normal\");\n      }\n      if (geometry.index == null) {\n        if (BufferGeometryUtils === void 0) {\n          throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n        }\n        geometry = mergeVertices(geometry);\n      }\n      this.indexes = geometry.index.array;\n      this.positions = geometry.getAttribute(\"position\").array;\n      this.computeNormals();\n      this.mapPositionsToIndexes();\n      this.splitIndexes = [];\n      for (let vertexIndexes of this.pointToIndexMap) {\n        this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n      const newAttributes = {};\n      for (let name of Object.keys(geometry.attributes)) {\n        const oldAttribute = geometry.attributes[name];\n        const newArray = new oldAttribute.array.constructor(\n          (this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize\n        );\n        newArray.set(oldAttribute.array);\n        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n      }\n      const newIndexes = new Uint32Array(this.indexes.length);\n      newIndexes.set(this.indexes);\n      for (let i = 0; i < this.splitIndexes.length; i++) {\n        const split = this.splitIndexes[i];\n        const index = this.indexes[split.original];\n        for (let attribute of Object.values(newAttributes)) {\n          for (let j = 0; j < attribute.itemSize; j++) {\n            attribute.array[(this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n          }\n        }\n        for (let j of split.indexes) {\n          newIndexes[j] = this.indexes.length + i;\n        }\n      }\n      geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(newIndexes, 1));\n      for (let name of Object.keys(newAttributes)) {\n        geometry.setAttribute(name, newAttributes[name]);\n      }\n      if (hadNormals) {\n        geometry.computeVertexNormals();\n        if (this.oldNormals !== null) {\n          const changedNormals = new Array(this.oldNormals.length / 3).fill(false);\n          for (let splitData of this.splitIndexes)\n            changedNormals[splitData.original] = true;\n          for (let i = 0; i < changedNormals.length; i++) {\n            if (changedNormals[i] === false) {\n              for (let j = 0; j < 3; j++) {\n                geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j];\n              }\n            }\n          }\n        }\n      }\n      return geometry;\n    });\n  }\n}\nexport {\n  EdgeSplitModifier\n};\n"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAc;AACrC,IAAIC,eAAe,GAAGA,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAID,GAAG,GAAGJ,SAAS,CAACI,GAAG,EAAEC,GAAG,EAAE;EAAEE,UAAU,EAAE,IAAI;EAAEC,YAAY,EAAE,IAAI;EAAEC,QAAQ,EAAE,IAAI;EAAEH;AAAM,CAAC,CAAC,GAAGF,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;AAC/J,IAAII,aAAa,GAAGA,CAACN,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAK;EACvCH,eAAe,CAACC,GAAG,EAAE,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAG,EAAE,GAAGA,GAAG,EAAEC,KAAK,CAAC;EACrE,OAAOA,KAAK;AACd,CAAC;AACD,SAASK,OAAO,EAAEC,eAAe,EAAEC,cAAc,QAAQ,OAAO;AAChE,OAAO,KAAKC,mBAAmB,MAAM,iCAAiC;AACtE,SAASC,aAAa,QAAQ,iCAAiC;AAC/D,MAAMC,iBAAiB,CAAC;EACtBC,WAAWA,CAAA,EAAG;IAAA,IAAAC,KAAA;IACZR,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,IAAIC,OAAO,CAAC,CAAC,CAAC;IACvCD,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,IAAIC,OAAO,CAAC,CAAC,CAAC;IACvCD,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,IAAIC,OAAO,CAAC,CAAC,CAAC;IACvCD,aAAa,CAAC,IAAI,EAAE,WAAW,EAAE,EAAE,CAAC;IACpCA,aAAa,CAAC,IAAI,EAAE,SAAS,EAAE,IAAIS,YAAY,CAAC,CAAC,CAAC;IAClDT,aAAa,CAAC,IAAI,EAAE,SAAS,EAAE,EAAE,CAAC;IAClCA,aAAa,CAAC,IAAI,EAAE,iBAAiB,EAAE,EAAE,CAAC;IAC1CA,aAAa,CAAC,IAAI,EAAE,cAAc,EAAE,EAAE,CAAC;IACvCA,aAAa,CAAC,IAAI,EAAE,YAAY,EAAE,EAAE,CAAC;IACrCA,aAAa,CAAC,IAAI,EAAE,gBAAgB,EAAE,MAAM;MAC1C,IAAI,CAACU,OAAO,GAAG,IAAID,YAAY,CAAC,IAAI,CAACE,OAAO,CAACC,MAAM,GAAG,CAAC,CAAC;MACxD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACF,OAAO,CAACC,MAAM,EAAEC,CAAC,IAAI,CAAC,EAAE;QAC/C,IAAIC,KAAK,GAAG,IAAI,CAACH,OAAO,CAACE,CAAC,CAAC;QAC3B,IAAI,CAACE,CAAC,CAACC,GAAG,CAAC,IAAI,CAACC,SAAS,CAAC,CAAC,GAAGH,KAAK,CAAC,EAAE,IAAI,CAACG,SAAS,CAAC,CAAC,GAAGH,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,CAACG,SAAS,CAAC,CAAC,GAAGH,KAAK,GAAG,CAAC,CAAC,CAAC;QACnGA,KAAK,GAAG,IAAI,CAACH,OAAO,CAACE,CAAC,GAAG,CAAC,CAAC;QAC3B,IAAI,CAACK,CAAC,CAACF,GAAG,CAAC,IAAI,CAACC,SAAS,CAAC,CAAC,GAAGH,KAAK,CAAC,EAAE,IAAI,CAACG,SAAS,CAAC,CAAC,GAAGH,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,CAACG,SAAS,CAAC,CAAC,GAAGH,KAAK,GAAG,CAAC,CAAC,CAAC;QACnGA,KAAK,GAAG,IAAI,CAACH,OAAO,CAACE,CAAC,GAAG,CAAC,CAAC;QAC3B,IAAI,CAACM,CAAC,CAACH,GAAG,CAAC,IAAI,CAACC,SAAS,CAAC,CAAC,GAAGH,KAAK,CAAC,EAAE,IAAI,CAACG,SAAS,CAAC,CAAC,GAAGH,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,CAACG,SAAS,CAAC,CAAC,GAAGH,KAAK,GAAG,CAAC,CAAC,CAAC;QACnG,IAAI,CAACK,CAAC,CAACC,GAAG,CAAC,IAAI,CAACF,CAAC,CAAC;QAClB,IAAI,CAACH,CAAC,CAACK,GAAG,CAAC,IAAI,CAACF,CAAC,CAAC;QAClB,MAAMG,MAAM,GAAG,IAAI,CAACF,CAAC,CAACG,KAAK,CAAC,IAAI,CAACP,CAAC,CAAC,CAACQ,SAAS,CAAC,CAAC;QAC/C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC1B,IAAI,CAACd,OAAO,CAAC,CAAC,IAAIG,CAAC,GAAGW,CAAC,CAAC,CAAC,GAAGH,MAAM,CAACI,CAAC;UACpC,IAAI,CAACf,OAAO,CAAC,CAAC,IAAIG,CAAC,GAAGW,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGH,MAAM,CAACK,CAAC;UACxC,IAAI,CAAChB,OAAO,CAAC,CAAC,IAAIG,CAAC,GAAGW,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGH,MAAM,CAACM,CAAC;QAC1C;MACF;IACF,CAAC,CAAC;IACF3B,aAAa,CAAC,IAAI,EAAE,uBAAuB,EAAE,MAAM;MACjD,IAAI,CAAC4B,eAAe,GAAGC,KAAK,CAAC,IAAI,CAACZ,SAAS,CAACL,MAAM,GAAG,CAAC,CAAC;MACvD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACF,OAAO,CAACC,MAAM,EAAEC,CAAC,EAAE,EAAE;QAC5C,MAAMC,KAAK,GAAG,IAAI,CAACH,OAAO,CAACE,CAAC,CAAC;QAC7B,IAAI,IAAI,CAACe,eAAe,CAACd,KAAK,CAAC,IAAI,IAAI,EAAE;UACvC,IAAI,CAACc,eAAe,CAACd,KAAK,CAAC,GAAG,EAAE;QAClC;QACA,IAAI,CAACc,eAAe,CAACd,KAAK,CAAC,CAACgB,IAAI,CAACjB,CAAC,CAAC;MACrC;IACF,CAAC,CAAC;IACFb,aAAa,CAAC,IAAI,EAAE,mBAAmB,EAAE,CAACW,OAAO,EAAEoB,MAAM,EAAEC,UAAU,KAAK;MACxE,IAAI,CAACjB,CAAC,CAACC,GAAG,CACR,IAAI,CAACN,OAAO,CAAC,CAAC,GAAGsB,UAAU,CAAC,EAC5B,IAAI,CAACtB,OAAO,CAAC,CAAC,GAAGsB,UAAU,GAAG,CAAC,CAAC,EAChC,IAAI,CAACtB,OAAO,CAAC,CAAC,GAAGsB,UAAU,GAAG,CAAC,CACjC,CAAC,CAACT,SAAS,CAAC,CAAC;MACb,MAAMU,MAAM,GAAG;QACbC,UAAU,EAAE,EAAE;QACdC,YAAY,EAAE,CAACH,UAAU;MAC3B,CAAC;MACD,KAAK,IAAIR,CAAC,IAAIb,OAAO,EAAE;QACrB,IAAIa,CAAC,KAAKQ,UAAU,EAAE;UACpB,IAAI,CAACd,CAAC,CAACF,GAAG,CAAC,IAAI,CAACN,OAAO,CAAC,CAAC,GAAGc,CAAC,CAAC,EAAE,IAAI,CAACd,OAAO,CAAC,CAAC,GAAGc,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAACd,OAAO,CAAC,CAAC,GAAGc,CAAC,GAAG,CAAC,CAAC,CAAC,CAACD,SAAS,CAAC,CAAC;UAC7F,IAAI,IAAI,CAACL,CAAC,CAACkB,GAAG,CAAC,IAAI,CAACrB,CAAC,CAAC,GAAGgB,MAAM,EAAE;YAC/BE,MAAM,CAACC,UAAU,CAACJ,IAAI,CAACN,CAAC,CAAC;UAC3B,CAAC,MAAM;YACLS,MAAM,CAACE,YAAY,CAACL,IAAI,CAACN,CAAC,CAAC;UAC7B;QACF;MACF;MACA,OAAOS,MAAM;IACf,CAAC,CAAC;IACFjC,aAAa,CAAC,IAAI,EAAE,WAAW,EAAE,UAACW,OAAO,EAAEoB,MAAM,EAAsB;MAAA,IAApBM,QAAQ,GAAAC,SAAA,CAAA1B,MAAA,QAAA0B,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;MAChE,IAAI3B,OAAO,CAACC,MAAM,KAAK,CAAC,EACtB;MACF,MAAM4B,YAAY,GAAG,EAAE;MACvB,KAAK,IAAI1B,KAAK,IAAIH,OAAO,EAAE;QACzB6B,YAAY,CAACV,IAAI,CAACtB,KAAI,CAACiC,iBAAiB,CAAC9B,OAAO,EAAEoB,MAAM,EAAEjB,KAAK,CAAC,CAAC;MACnE;MACA,IAAImB,MAAM,GAAGO,YAAY,CAAC,CAAC,CAAC;MAC5B,KAAK,IAAIE,WAAW,IAAIF,YAAY,EAAE;QACpC,IAAIE,WAAW,CAACP,YAAY,CAACvB,MAAM,GAAGqB,MAAM,CAACE,YAAY,CAACvB,MAAM,EAAE;UAChEqB,MAAM,GAAGS,WAAW;QACtB;MACF;MACA,IAAIL,QAAQ,IAAI,IAAI,EAAE;QACpB7B,KAAI,CAACmC,YAAY,CAACb,IAAI,CAAC;UACrBO,QAAQ;UACR1B,OAAO,EAAEsB,MAAM,CAACE;QAClB,CAAC,CAAC;MACJ;MACA,IAAIF,MAAM,CAACC,UAAU,CAACtB,MAAM,EAAE;QAC5BJ,KAAI,CAACoC,SAAS,CAACX,MAAM,CAACC,UAAU,EAAEH,MAAM,EAAEM,QAAQ,IAAIJ,MAAM,CAACE,YAAY,CAAC,CAAC,CAAC,CAAC;MAC/E;IACF,CAAC,CAAC;IACFnC,aAAa,CAAC,IAAI,EAAE,QAAQ,EAAE,UAAC6C,QAAQ,EAAEC,WAAW,EAA4B;MAAA,IAA1BC,cAAc,GAAAT,SAAA,CAAA1B,MAAA,QAAA0B,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;MACzE,IAAIU,UAAU,GAAG,KAAK;MACtB,IAAIH,QAAQ,CAACI,UAAU,CAAC5B,MAAM,EAAE;QAC9B2B,UAAU,GAAG,IAAI;QACjBH,QAAQ,GAAGA,QAAQ,CAACK,KAAK,CAAC,CAAC;QAC3B,IAAIH,cAAc,KAAK,IAAI,IAAIF,QAAQ,CAAC/B,KAAK,KAAK,IAAI,EAAE;UACtDN,KAAI,CAAC2C,UAAU,GAAGN,QAAQ,CAACI,UAAU,CAAC5B,MAAM,CAAC+B,KAAK;QACpD;QACAP,QAAQ,CAACQ,eAAe,CAAC,QAAQ,CAAC;MACpC;MACA,IAAIR,QAAQ,CAAC/B,KAAK,IAAI,IAAI,EAAE;QAC1B,IAAIV,mBAAmB,KAAK,KAAK,CAAC,EAAE;UAClC,MAAM,uDAAuD;QAC/D;QACAyC,QAAQ,GAAGxC,aAAa,CAACwC,QAAQ,CAAC;MACpC;MACArC,KAAI,CAACG,OAAO,GAAGkC,QAAQ,CAAC/B,KAAK,CAACsC,KAAK;MACnC5C,KAAI,CAACS,SAAS,GAAG4B,QAAQ,CAACS,YAAY,CAAC,UAAU,CAAC,CAACF,KAAK;MACxD5C,KAAI,CAAC+C,cAAc,CAAC,CAAC;MACrB/C,KAAI,CAACgD,qBAAqB,CAAC,CAAC;MAC5BhD,KAAI,CAACmC,YAAY,GAAG,EAAE;MACtB,KAAK,IAAIc,aAAa,IAAIjD,KAAI,CAACoB,eAAe,EAAE;QAC9CpB,KAAI,CAACoC,SAAS,CAACa,aAAa,EAAEC,IAAI,CAACC,GAAG,CAACb,WAAW,CAAC,GAAG,IAAI,CAAC;MAC7D;MACA,MAAMc,aAAa,GAAG,CAAC,CAAC;MACxB,KAAK,IAAIC,IAAI,IAAItE,MAAM,CAACuE,IAAI,CAACjB,QAAQ,CAACI,UAAU,CAAC,EAAE;QACjD,MAAMc,YAAY,GAAGlB,QAAQ,CAACI,UAAU,CAACY,IAAI,CAAC;QAC9C,MAAMG,QAAQ,GAAG,IAAID,YAAY,CAACX,KAAK,CAAC7C,WAAW,CACjD,CAACC,KAAI,CAACG,OAAO,CAACC,MAAM,GAAGJ,KAAI,CAACmC,YAAY,CAAC/B,MAAM,IAAImD,YAAY,CAACE,QAClE,CAAC;QACDD,QAAQ,CAAChD,GAAG,CAAC+C,YAAY,CAACX,KAAK,CAAC;QAChCQ,aAAa,CAACC,IAAI,CAAC,GAAG,IAAI3D,eAAe,CAAC8D,QAAQ,EAAED,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,UAAU,CAAC;MACrG;MACA,MAAMC,UAAU,GAAG,IAAIC,WAAW,CAAC5D,KAAI,CAACG,OAAO,CAACC,MAAM,CAAC;MACvDuD,UAAU,CAACnD,GAAG,CAACR,KAAI,CAACG,OAAO,CAAC;MAC5B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAI,CAACmC,YAAY,CAAC/B,MAAM,EAAEC,CAAC,EAAE,EAAE;QACjD,MAAMwD,KAAK,GAAG7D,KAAI,CAACmC,YAAY,CAAC9B,CAAC,CAAC;QAClC,MAAMC,KAAK,GAAGN,KAAI,CAACG,OAAO,CAAC0D,KAAK,CAAChC,QAAQ,CAAC;QAC1C,KAAK,IAAIiC,SAAS,IAAI/E,MAAM,CAACgF,MAAM,CAACX,aAAa,CAAC,EAAE;UAClD,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8C,SAAS,CAACL,QAAQ,EAAEzC,CAAC,EAAE,EAAE;YAC3C8C,SAAS,CAAClB,KAAK,CAAC,CAAC5C,KAAI,CAACG,OAAO,CAACC,MAAM,GAAGC,CAAC,IAAIyD,SAAS,CAACL,QAAQ,GAAGzC,CAAC,CAAC,GAAG8C,SAAS,CAAClB,KAAK,CAACtC,KAAK,GAAGwD,SAAS,CAACL,QAAQ,GAAGzC,CAAC,CAAC;UACvH;QACF;QACA,KAAK,IAAIA,CAAC,IAAI6C,KAAK,CAAC1D,OAAO,EAAE;UAC3BwD,UAAU,CAAC3C,CAAC,CAAC,GAAGhB,KAAI,CAACG,OAAO,CAACC,MAAM,GAAGC,CAAC;QACzC;MACF;MACAgC,QAAQ,GAAG,IAAI1C,cAAc,CAAC,CAAC;MAC/B0C,QAAQ,CAAC2B,QAAQ,CAAC,IAAItE,eAAe,CAACiE,UAAU,EAAE,CAAC,CAAC,CAAC;MACrD,KAAK,IAAIN,IAAI,IAAItE,MAAM,CAACuE,IAAI,CAACF,aAAa,CAAC,EAAE;QAC3Cf,QAAQ,CAAC4B,YAAY,CAACZ,IAAI,EAAED,aAAa,CAACC,IAAI,CAAC,CAAC;MAClD;MACA,IAAIb,UAAU,EAAE;QACdH,QAAQ,CAAC6B,oBAAoB,CAAC,CAAC;QAC/B,IAAIlE,KAAI,CAAC2C,UAAU,KAAK,IAAI,EAAE;UAC5B,MAAMwB,cAAc,GAAG,IAAI9C,KAAK,CAACrB,KAAI,CAAC2C,UAAU,CAACvC,MAAM,GAAG,CAAC,CAAC,CAACgE,IAAI,CAAC,KAAK,CAAC;UACxE,KAAK,IAAIC,SAAS,IAAIrE,KAAI,CAACmC,YAAY,EACrCgC,cAAc,CAACE,SAAS,CAACxC,QAAQ,CAAC,GAAG,IAAI;UAC3C,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8D,cAAc,CAAC/D,MAAM,EAAEC,CAAC,EAAE,EAAE;YAC9C,IAAI8D,cAAc,CAAC9D,CAAC,CAAC,KAAK,KAAK,EAAE;cAC/B,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;gBAC1BqB,QAAQ,CAACI,UAAU,CAAC5B,MAAM,CAAC+B,KAAK,CAAC,CAAC,GAAGvC,CAAC,GAAGW,CAAC,CAAC,GAAGhB,KAAI,CAAC2C,UAAU,CAAC,CAAC,GAAGtC,CAAC,GAAGW,CAAC,CAAC;cAC1E;YACF;UACF;QACF;MACF;MACA,OAAOqB,QAAQ;IACjB,CAAC,CAAC;EACJ;AACF;AACA,SACEvC,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}