{"ast":null,"code":"import { Mesh, MathUtils } from \"three\";\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = \"__default\";\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start,\n      end,\n      length: end - start + 1,\n      fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        const range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n      i++;\n    }\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  }\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  }\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  }\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  }\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n    }\n  }\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  }\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active) continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n}\nexport { MorphBlendMesh };","map":{"version":3,"names":["Mesh","MathUtils","MorphBlendMesh","constructor","geometry","material","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/misc/MorphBlendMesh.js"],"sourcesContent":["import { Mesh, MathUtils } from \"three\";\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = \"__default\";\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start,\n      end,\n      length: end - start + 1,\n      fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name])\n          frameRanges[name] = { start: Infinity, end: -Infinity };\n        const range = frameRanges[name];\n        if (i < range.start)\n          range.start = i;\n        if (i > range.end)\n          range.end = i;\n        if (!firstAnimation)\n          firstAnimation = name;\n      }\n      i++;\n    }\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  }\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  }\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  }\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  }\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n    }\n  }\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  }\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active)\n        continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0)\n          animation.time += animation.duration;\n      }\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards)\n        mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n}\nexport {\n  MorphBlendMesh\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}