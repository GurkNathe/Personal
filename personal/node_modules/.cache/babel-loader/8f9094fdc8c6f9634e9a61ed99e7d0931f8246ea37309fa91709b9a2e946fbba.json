{"ast":null,"code":"import _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\nvar _Reflector = /*#__PURE__*/function (_Mesh) {\n  _inherits(_Reflector, _Mesh);\n  var _super = _createSuper(_Reflector);\n  function _Reflector(geometry) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, _Reflector);\n    _this = _super.call(this, geometry);\n    _this.isReflector = true;\n    _this.type = \"Reflector\";\n    _this.camera = new PerspectiveCamera();\n    var scope = _assertThisInitialized(_this);\n    var color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || _Reflector.ReflectorShader;\n    var multisample = options.multisample !== void 0 ? options.multisample : 4;\n    var reflectorPlane = new Plane();\n    var normal = new Vector3();\n    var reflectorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var clipPlane = new Vector4();\n    var view = new Vector3();\n    var target = new Vector3();\n    var q = new Vector4();\n    var textureMatrix = new Matrix4();\n    var virtualCamera = _this.camera;\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    var material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    _this.material = material;\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      var currentToneMapping = renderer.toneMapping;\n      var isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"linear-srgb\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      renderer.setRenderTarget(currentRenderTarget);\n      var viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    _this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n    return _this;\n  }\n  return _createClass(_Reflector);\n}(Mesh);\nvar Reflector = _Reflector;\n__publicField(Reflector, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\n\\t\\t}\"\n});\nexport { Reflector };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Vector3","Matrix4","Vector4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","NoToneMapping","_Reflector","_Mesh","_inherits","_super","_createSuper","geometry","_this","options","arguments","length","undefined","_classCallCheck","call","isReflector","type","camera","scope","_assertThisInitialized","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","uniforms","clone","fragmentShader","vertexShader","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","_createClass","Reflector","tDiffuse"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/objects/Reflector.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\nconst _Reflector = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflector = true;\n    this.type = \"Reflector\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Reflector.ReflectorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material = material;\n    this.onBeforeRender = function(renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0)\n        return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer)\n        isSRGB = renderer.outputColorSpace === \"srgb\";\n      else\n        isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"linear-srgb\";\n      else\n        renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n      else\n        renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    this.getRenderTarget = function() {\n      return renderTarget;\n    };\n    this.dispose = function() {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Reflector = _Reflector;\n__publicField(Reflector, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Reflector\n};\n"],"mappings":";;;;;AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAc;AACrC,IAAIC,eAAe,GAAG,SAAlBA,eAAeA,CAAIC,GAAG,EAAEC,GAAG,EAAEC,KAAK;EAAA,OAAKD,GAAG,IAAID,GAAG,GAAGJ,SAAS,CAACI,GAAG,EAAEC,GAAG,EAAE;IAAEE,UAAU,EAAE,IAAI;IAAEC,YAAY,EAAE,IAAI;IAAEC,QAAQ,EAAE,IAAI;IAAEH,KAAK,EAALA;EAAM,CAAC,CAAC,GAAGF,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;AAAA;AAC/J,IAAII,aAAa,GAAG,SAAhBA,aAAaA,CAAIN,GAAG,EAAEC,GAAG,EAAEC,KAAK,EAAK;EACvCH,eAAe,CAACC,GAAG,EAAE,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAG,EAAE,GAAGA,GAAG,EAAEC,KAAK,CAAC;EACrE,OAAOA,KAAK;AACd,CAAC;AACD,SAASK,IAAI,EAAEC,iBAAiB,EAAEC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,cAAc,EAAEC,aAAa,EAAEC,aAAa,QAAQ,OAAO;AACxK,IAAMC,UAAU,0BAAAC,KAAA;EAAAC,SAAA,CAAAF,UAAA,EAAAC,KAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,UAAA;EACd,SAAAA,WAAYK,QAAQ,EAAgB;IAAA,IAAAC,KAAA;IAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAAAG,eAAA,OAAAX,UAAA;IAChCM,KAAA,GAAAH,MAAA,CAAAS,IAAA,OAAMP,QAAQ;IACdC,KAAA,CAAKO,WAAW,GAAG,IAAI;IACvBP,KAAA,CAAKQ,IAAI,GAAG,WAAW;IACvBR,KAAA,CAAKS,MAAM,GAAG,IAAI1B,iBAAiB,CAAC,CAAC;IACrC,IAAM2B,KAAK,GAAAC,sBAAA,CAAAX,KAAA,CAAO;IAClB,IAAMY,KAAK,GAAGX,OAAO,CAACW,KAAK,KAAK,KAAK,CAAC,GAAG,IAAI5B,KAAK,CAACiB,OAAO,CAACW,KAAK,CAAC,GAAG,IAAI5B,KAAK,CAAC,OAAO,CAAC;IACtF,IAAM6B,YAAY,GAAGZ,OAAO,CAACY,YAAY,IAAI,GAAG;IAChD,IAAMC,aAAa,GAAGb,OAAO,CAACa,aAAa,IAAI,GAAG;IAClD,IAAMC,QAAQ,GAAGd,OAAO,CAACc,QAAQ,IAAI,CAAC;IACtC,IAAMC,MAAM,GAAGf,OAAO,CAACe,MAAM,IAAItB,UAAU,CAACuB,eAAe;IAC3D,IAAMC,WAAW,GAAGjB,OAAO,CAACiB,WAAW,KAAK,KAAK,CAAC,GAAGjB,OAAO,CAACiB,WAAW,GAAG,CAAC;IAC5E,IAAMC,cAAc,GAAG,IAAIlC,KAAK,CAAC,CAAC;IAClC,IAAMmC,MAAM,GAAG,IAAIlC,OAAO,CAAC,CAAC;IAC5B,IAAMmC,sBAAsB,GAAG,IAAInC,OAAO,CAAC,CAAC;IAC5C,IAAMoC,mBAAmB,GAAG,IAAIpC,OAAO,CAAC,CAAC;IACzC,IAAMqC,cAAc,GAAG,IAAIpC,OAAO,CAAC,CAAC;IACpC,IAAMqC,cAAc,GAAG,IAAItC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC5C,IAAMuC,SAAS,GAAG,IAAIrC,OAAO,CAAC,CAAC;IAC/B,IAAMsC,IAAI,GAAG,IAAIxC,OAAO,CAAC,CAAC;IAC1B,IAAMyC,MAAM,GAAG,IAAIzC,OAAO,CAAC,CAAC;IAC5B,IAAM0C,CAAC,GAAG,IAAIxC,OAAO,CAAC,CAAC;IACvB,IAAMyC,aAAa,GAAG,IAAI1C,OAAO,CAAC,CAAC;IACnC,IAAM2C,aAAa,GAAG9B,KAAA,CAAKS,MAAM;IACjC,IAAMsB,YAAY,GAAG,IAAI1C,iBAAiB,CAACwB,YAAY,EAAEC,aAAa,EAAE;MACtEkB,OAAO,EAAEd,WAAW;MACpBV,IAAI,EAAElB;IACR,CAAC,CAAC;IACF,IAAM2C,QAAQ,GAAG,IAAI1C,cAAc,CAAC;MAClC2C,QAAQ,EAAE1C,aAAa,CAAC2C,KAAK,CAACnB,MAAM,CAACkB,QAAQ,CAAC;MAC9CE,cAAc,EAAEpB,MAAM,CAACoB,cAAc;MACrCC,YAAY,EAAErB,MAAM,CAACqB;IACvB,CAAC,CAAC;IACFJ,QAAQ,CAACC,QAAQ,CAAC,UAAU,CAAC,CAACzD,KAAK,GAAGsD,YAAY,CAACO,OAAO;IAC1DL,QAAQ,CAACC,QAAQ,CAAC,OAAO,CAAC,CAACzD,KAAK,GAAGmC,KAAK;IACxCqB,QAAQ,CAACC,QAAQ,CAAC,eAAe,CAAC,CAACzD,KAAK,GAAGoD,aAAa;IACxD7B,KAAA,CAAKiC,QAAQ,GAAGA,QAAQ;IACxBjC,KAAA,CAAKuC,cAAc,GAAG,UAASC,QAAQ,EAAEC,KAAK,EAAEhC,MAAM,EAAE;MACtDY,sBAAsB,CAACqB,qBAAqB,CAAChC,KAAK,CAACiC,WAAW,CAAC;MAC/DrB,mBAAmB,CAACoB,qBAAqB,CAACjC,MAAM,CAACkC,WAAW,CAAC;MAC7DpB,cAAc,CAACqB,eAAe,CAAClC,KAAK,CAACiC,WAAW,CAAC;MACjDvB,MAAM,CAACyB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACnBzB,MAAM,CAAC0B,YAAY,CAACvB,cAAc,CAAC;MACnCG,IAAI,CAACqB,UAAU,CAAC1B,sBAAsB,EAAEC,mBAAmB,CAAC;MAC5D,IAAII,IAAI,CAACsB,GAAG,CAAC5B,MAAM,CAAC,GAAG,CAAC,EACtB;MACFM,IAAI,CAACuB,OAAO,CAAC7B,MAAM,CAAC,CAAC8B,MAAM,CAAC,CAAC;MAC7BxB,IAAI,CAACyB,GAAG,CAAC9B,sBAAsB,CAAC;MAChCE,cAAc,CAACqB,eAAe,CAACnC,MAAM,CAACkC,WAAW,CAAC;MAClDnB,cAAc,CAACqB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC5BrB,cAAc,CAACsB,YAAY,CAACvB,cAAc,CAAC;MAC3CC,cAAc,CAAC2B,GAAG,CAAC7B,mBAAmB,CAAC;MACvCK,MAAM,CAACoB,UAAU,CAAC1B,sBAAsB,EAAEG,cAAc,CAAC;MACzDG,MAAM,CAACsB,OAAO,CAAC7B,MAAM,CAAC,CAAC8B,MAAM,CAAC,CAAC;MAC/BvB,MAAM,CAACwB,GAAG,CAAC9B,sBAAsB,CAAC;MAClCS,aAAa,CAACsB,QAAQ,CAACC,IAAI,CAAC3B,IAAI,CAAC;MACjCI,aAAa,CAACwB,EAAE,CAACT,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC7Bf,aAAa,CAACwB,EAAE,CAACR,YAAY,CAACvB,cAAc,CAAC;MAC7CO,aAAa,CAACwB,EAAE,CAACL,OAAO,CAAC7B,MAAM,CAAC;MAChCU,aAAa,CAACyB,MAAM,CAAC5B,MAAM,CAAC;MAC5BG,aAAa,CAAC0B,GAAG,GAAG/C,MAAM,CAAC+C,GAAG;MAC9B1B,aAAa,CAAC2B,iBAAiB,CAAC,CAAC;MACjC3B,aAAa,CAAC4B,gBAAgB,CAACL,IAAI,CAAC5C,MAAM,CAACiD,gBAAgB,CAAC;MAC5D7B,aAAa,CAACgB,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC7EhB,aAAa,CAAC8B,QAAQ,CAAC7B,aAAa,CAAC4B,gBAAgB,CAAC;MACtD7B,aAAa,CAAC8B,QAAQ,CAAC7B,aAAa,CAAC8B,kBAAkB,CAAC;MACxD/B,aAAa,CAAC8B,QAAQ,CAACjD,KAAK,CAACiC,WAAW,CAAC;MACzCxB,cAAc,CAAC0C,6BAA6B,CAACzC,MAAM,EAAEC,sBAAsB,CAAC;MAC5EF,cAAc,CAAC2B,YAAY,CAAChB,aAAa,CAAC8B,kBAAkB,CAAC;MAC7DnC,SAAS,CAACoB,GAAG,CAAC1B,cAAc,CAACC,MAAM,CAAC0C,CAAC,EAAE3C,cAAc,CAACC,MAAM,CAAC2C,CAAC,EAAE5C,cAAc,CAACC,MAAM,CAAC4C,CAAC,EAAE7C,cAAc,CAAC8C,QAAQ,CAAC;MACjH,IAAMP,gBAAgB,GAAG5B,aAAa,CAAC4B,gBAAgB;MACvD9B,CAAC,CAACkC,CAAC,GAAG,CAACI,IAAI,CAACC,IAAI,CAAC1C,SAAS,CAACqC,CAAC,CAAC,GAAGJ,gBAAgB,CAACU,QAAQ,CAAC,CAAC,CAAC,IAAIV,gBAAgB,CAACU,QAAQ,CAAC,CAAC,CAAC;MAC5FxC,CAAC,CAACmC,CAAC,GAAG,CAACG,IAAI,CAACC,IAAI,CAAC1C,SAAS,CAACsC,CAAC,CAAC,GAAGL,gBAAgB,CAACU,QAAQ,CAAC,CAAC,CAAC,IAAIV,gBAAgB,CAACU,QAAQ,CAAC,CAAC,CAAC;MAC5FxC,CAAC,CAACoC,CAAC,GAAG,CAAC,CAAC;MACRpC,CAAC,CAACyC,CAAC,GAAG,CAAC,CAAC,GAAGX,gBAAgB,CAACU,QAAQ,CAAC,EAAE,CAAC,IAAIV,gBAAgB,CAACU,QAAQ,CAAC,EAAE,CAAC;MACzE3C,SAAS,CAAC6C,cAAc,CAAC,CAAC,GAAG7C,SAAS,CAACuB,GAAG,CAACpB,CAAC,CAAC,CAAC;MAC9C8B,gBAAgB,CAACU,QAAQ,CAAC,CAAC,CAAC,GAAG3C,SAAS,CAACqC,CAAC;MAC1CJ,gBAAgB,CAACU,QAAQ,CAAC,CAAC,CAAC,GAAG3C,SAAS,CAACsC,CAAC;MAC1CL,gBAAgB,CAACU,QAAQ,CAAC,EAAE,CAAC,GAAG3C,SAAS,CAACuC,CAAC,GAAG,CAAC,GAAGjD,QAAQ;MAC1D2C,gBAAgB,CAACU,QAAQ,CAAC,EAAE,CAAC,GAAG3C,SAAS,CAAC4C,CAAC;MAC3C3D,KAAK,CAAC6D,OAAO,GAAG,KAAK;MACrB,IAAMC,mBAAmB,GAAGhC,QAAQ,CAACiC,eAAe,CAAC,CAAC;MACtD,IAAMC,gBAAgB,GAAGlC,QAAQ,CAACmC,EAAE,CAACC,OAAO;MAC5C,IAAMC,uBAAuB,GAAGrC,QAAQ,CAACsC,SAAS,CAACC,UAAU;MAC7D,IAAMC,kBAAkB,GAAGxC,QAAQ,CAACyC,WAAW;MAC/C,IAAIC,MAAM,GAAG,KAAK;MAClB,IAAI,kBAAkB,IAAI1C,QAAQ,EAChC0C,MAAM,GAAG1C,QAAQ,CAAC2C,gBAAgB,KAAK,MAAM,CAAC,KAE9CD,MAAM,GAAG1C,QAAQ,CAAC4C,cAAc,KAAK,IAAI;MAC3C5C,QAAQ,CAACmC,EAAE,CAACC,OAAO,GAAG,KAAK;MAC3BpC,QAAQ,CAACsC,SAAS,CAACC,UAAU,GAAG,KAAK;MACrC,IAAI,kBAAkB,IAAIvC,QAAQ,EAChCA,QAAQ,CAAC2C,gBAAgB,GAAG,aAAa,CAAC,KAE1C3C,QAAQ,CAAC4C,cAAc,GAAG,GAAG;MAC/B5C,QAAQ,CAACyC,WAAW,GAAGxF,aAAa;MACpC+C,QAAQ,CAAC6C,eAAe,CAACtD,YAAY,CAAC;MACtCS,QAAQ,CAAC8C,KAAK,CAACC,OAAO,CAACC,KAAK,CAACC,OAAO,CAAC,IAAI,CAAC;MAC1C,IAAIjD,QAAQ,CAACkD,SAAS,KAAK,KAAK,EAC9BlD,QAAQ,CAACmD,KAAK,CAAC,CAAC;MAClBnD,QAAQ,CAACoD,MAAM,CAACnD,KAAK,EAAEX,aAAa,CAAC;MACrCU,QAAQ,CAACmC,EAAE,CAACC,OAAO,GAAGF,gBAAgB;MACtClC,QAAQ,CAACsC,SAAS,CAACC,UAAU,GAAGF,uBAAuB;MACvDrC,QAAQ,CAACyC,WAAW,GAAGD,kBAAkB;MACzC,IAAI,kBAAkB,IAAIxC,QAAQ,EAChCA,QAAQ,CAAC2C,gBAAgB,GAAGD,MAAM,GAAG,MAAM,GAAG,aAAa,CAAC,KAE5D1C,QAAQ,CAAC4C,cAAc,GAAGF,MAAM,GAAG,IAAI,GAAG,GAAG;MAC/C1C,QAAQ,CAAC6C,eAAe,CAACb,mBAAmB,CAAC;MAC7C,IAAMqB,QAAQ,GAAGpF,MAAM,CAACoF,QAAQ;MAChC,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvBrD,QAAQ,CAAC8C,KAAK,CAACO,QAAQ,CAACA,QAAQ,CAAC;MACnC;MACAnF,KAAK,CAAC6D,OAAO,GAAG,IAAI;IACtB,CAAC;IACDvE,KAAA,CAAKyE,eAAe,GAAG,YAAW;MAChC,OAAO1C,YAAY;IACrB,CAAC;IACD/B,KAAA,CAAK8F,OAAO,GAAG,YAAW;MACxB/D,YAAY,CAAC+D,OAAO,CAAC,CAAC;MACtBpF,KAAK,CAACuB,QAAQ,CAAC6D,OAAO,CAAC,CAAC;IAC1B,CAAC;IAAC,OAAA9F,KAAA;EACJ;EAAC,OAAA+F,YAAA,CAAArG,UAAA;AAAA,EA5H8BZ,IAAI,CA6HpC;AACD,IAAIkH,SAAS,GAAGtG,UAAU;AAC1Bb,aAAa,CAACmH,SAAS,EAAE,iBAAiB,EAAE;EAC1C9D,QAAQ,EAAE;IACRtB,KAAK,EAAE;MACLnC,KAAK,EAAE;IACT,CAAC;IACDwH,QAAQ,EAAE;MACRxH,KAAK,EAAE;IACT,CAAC;IACDoD,aAAa,EAAE;MACbpD,KAAK,EAAE;IACT;EACF,CAAC;EACD4D,YAAY,EACV,mVAiBD;EACDD,cAAc,EACZ;AAgCJ,CAAC,CAAC;AACF,SACE4D,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}