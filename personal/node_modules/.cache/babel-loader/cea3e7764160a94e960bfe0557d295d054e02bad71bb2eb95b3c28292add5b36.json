{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Mesh, Vector3, Matrix3 } from \"three\";\nvar PLYExporter = /*#__PURE__*/function () {\n  function PLYExporter() {\n    _classCallCheck(this, PLYExporter);\n  }\n  _createClass(PLYExporter, [{\n    key: \"parse\",\n    value: function parse(object, onDone, options) {\n      if (onDone && typeof onDone === \"object\") {\n        console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n        options = onDone;\n        onDone = void 0;\n      }\n      var defaultOptions = {\n        binary: false,\n        excludeAttributes: [],\n        // normal, uv, color, index\n        littleEndian: false\n      };\n      options = Object.assign(defaultOptions, options);\n      var excludeAttributes = options.excludeAttributes;\n      var includeNormals = false;\n      var includeColors = false;\n      var includeUVs = false;\n      var vertexCount = 0;\n      var faceCount = 0;\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n          if (!geometry.isBufferGeometry) {\n            throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n          }\n          var vertices = geometry.getAttribute(\"position\");\n          var normals = geometry.getAttribute(\"normal\");\n          var uvs = geometry.getAttribute(\"uv\");\n          var colors = geometry.getAttribute(\"color\");\n          var indices = geometry.getIndex();\n          if (vertices === void 0) {\n            return;\n          }\n          vertexCount += vertices.count;\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n          if (normals !== void 0) includeNormals = true;\n          if (uvs !== void 0) includeUVs = true;\n          if (colors !== void 0) includeColors = true;\n        }\n      });\n      var includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"index\")) === -1;\n      includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"normal\")) === -1;\n      includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"color\")) === -1;\n      includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"uv\")) === -1;\n      if (includeIndices && faceCount !== Math.floor(faceCount)) {\n        console.error(\"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\");\n        return null;\n      }\n      var indexByteCount = 4;\n      var header = \"ply\\nformat \".concat(options.binary ? options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\" : \"ascii\", \" 1.0\\nelement vertex \").concat(vertexCount, \"\\nproperty float x\\nproperty float y\\nproperty float z\\n\");\n      if (includeNormals) {\n        header += \"property float nx\\nproperty float ny\\nproperty float nz\\n\";\n      }\n      if (includeUVs) {\n        header += \"property float s\\nproperty float t\\n\";\n      }\n      if (includeColors) {\n        header += \"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\";\n      }\n      if (includeIndices) {\n        header += \"\".concat(\"element face \".concat(faceCount, \"\\n\"), \"property list uchar int vertex_index\\n\");\n      }\n      header += \"end_header\\n\";\n      var vertex = new Vector3();\n      var normalMatrixWorld = new Matrix3();\n      var result = null;\n      if (options.binary) {\n        var headerBin = new TextEncoder().encode(header);\n        var vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n        var faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n        var output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n        new Uint8Array(output.buffer).set(headerBin, 0);\n        var vOffset = headerBin.length;\n        var fOffset = headerBin.length + vertexListLength;\n        var writtenVertices = 0;\n        this.traverseMeshes(object, function (mesh, geometry) {\n          var vertices = geometry.getAttribute(\"position\");\n          var normals = geometry.getAttribute(\"normal\");\n          var uvs = geometry.getAttribute(\"uv\");\n          var colors = geometry.getAttribute(\"color\");\n          var indices = geometry.getIndex();\n          normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n          for (var i = 0, l = vertices.count; i < l; i++) {\n            vertex.x = vertices.getX(i);\n            vertex.y = vertices.getY(i);\n            vertex.z = vertices.getZ(i);\n            vertex.applyMatrix4(mesh.matrixWorld);\n            output.setFloat32(vOffset, vertex.x, options.littleEndian);\n            vOffset += 4;\n            output.setFloat32(vOffset, vertex.y, options.littleEndian);\n            vOffset += 4;\n            output.setFloat32(vOffset, vertex.z, options.littleEndian);\n            vOffset += 4;\n            if (includeNormals) {\n              if (normals != null) {\n                vertex.x = normals.getX(i);\n                vertex.y = normals.getY(i);\n                vertex.z = normals.getZ(i);\n                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                output.setFloat32(vOffset, vertex.x, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, vertex.y, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, vertex.z, options.littleEndian);\n                vOffset += 4;\n              } else {\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n              }\n            }\n            if (includeUVs) {\n              if (uvs != null) {\n                output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n                vOffset += 4;\n              } else if (!includeUVs) {\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n              }\n            }\n            if (includeColors) {\n              if (colors != null) {\n                output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n                vOffset += 1;\n                output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n                vOffset += 1;\n                output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n                vOffset += 1;\n              } else {\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n              }\n            }\n          }\n          if (includeIndices) {\n            if (indices !== null) {\n              for (var _i = 0, _l = indices.count; _i < _l; _i += 3) {\n                output.setUint8(fOffset, 3);\n                fOffset += 1;\n                output.setUint32(fOffset, indices.getX(_i + 0) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, indices.getX(_i + 1) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, indices.getX(_i + 2) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n              }\n            } else {\n              for (var _i2 = 0, _l2 = vertices.count; _i2 < _l2; _i2 += 3) {\n                output.setUint8(fOffset, 3);\n                fOffset += 1;\n                output.setUint32(fOffset, writtenVertices + _i2, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, writtenVertices + _i2 + 1, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, writtenVertices + _i2 + 2, options.littleEndian);\n                fOffset += indexByteCount;\n              }\n            }\n          }\n          writtenVertices += vertices.count;\n        });\n        result = output.buffer;\n      } else {\n        var _writtenVertices = 0;\n        var vertexList = \"\";\n        var faceList = \"\";\n        this.traverseMeshes(object, function (mesh, geometry) {\n          var vertices = geometry.getAttribute(\"position\");\n          var normals = geometry.getAttribute(\"normal\");\n          var uvs = geometry.getAttribute(\"uv\");\n          var colors = geometry.getAttribute(\"color\");\n          var indices = geometry.getIndex();\n          normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n          for (var i = 0, l = vertices.count; i < l; i++) {\n            vertex.x = vertices.getX(i);\n            vertex.y = vertices.getY(i);\n            vertex.z = vertices.getZ(i);\n            vertex.applyMatrix4(mesh.matrixWorld);\n            var line = vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n            if (includeNormals) {\n              if (normals != null) {\n                vertex.x = normals.getX(i);\n                vertex.y = normals.getY(i);\n                vertex.z = normals.getZ(i);\n                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                line += \" \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n              } else {\n                line += \" 0 0 0\";\n              }\n            }\n            if (includeUVs) {\n              if (uvs != null) {\n                line += \" \" + uvs.getX(i) + \" \" + uvs.getY(i);\n              } else if (includeUVs) {\n                line += \" 0 0\";\n              }\n            }\n            if (includeColors) {\n              if (colors != null) {\n                line += \" \" + Math.floor(colors.getX(i) * 255) + \" \" + Math.floor(colors.getY(i) * 255) + \" \" + Math.floor(colors.getZ(i) * 255);\n              } else {\n                line += \" 255 255 255\";\n              }\n            }\n            vertexList += line + \"\\n\";\n          }\n          if (includeIndices) {\n            if (indices !== null) {\n              for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n                faceList += \"3 \".concat(indices.getX(_i3 + 0) + _writtenVertices);\n                faceList += \" \".concat(indices.getX(_i3 + 1) + _writtenVertices);\n                faceList += \" \".concat(indices.getX(_i3 + 2) + _writtenVertices, \"\\n\");\n              }\n            } else {\n              for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n                faceList += \"3 \".concat(_writtenVertices + _i4, \" \").concat(_writtenVertices + _i4 + 1, \" \").concat(_writtenVertices + _i4 + 2, \"\\n\");\n              }\n            }\n            faceCount += indices ? indices.count / 3 : vertices.count / 3;\n          }\n          _writtenVertices += vertices.count;\n        });\n        result = \"\".concat(header).concat(vertexList).concat(includeIndices ? \"\".concat(faceList, \"\\n\") : \"\\n\");\n      }\n      if (typeof onDone === \"function\") {\n        requestAnimationFrame(function () {\n          return onDone && onDone(typeof result === \"string\" ? result : \"\");\n        });\n      }\n      return result;\n    }\n    // Iterate over the valid meshes in the object\n  }, {\n    key: \"traverseMeshes\",\n    value: function traverseMeshes(object, cb) {\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n          if (!geometry.isBufferGeometry) {\n            throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n          }\n          if (geometry.hasAttribute(\"position\")) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    }\n  }]);\n  return PLYExporter;\n}();\nexport { PLYExporter };","map":{"version":3,"names":["Mesh","Vector3","Matrix3","PLYExporter","_classCallCheck","_createClass","key","value","parse","object","onDone","options","console","warn","defaultOptions","binary","excludeAttributes","littleEndian","Object","assign","includeNormals","includeColors","includeUVs","vertexCount","faceCount","traverse","child","isMesh","mesh","geometry","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","indexByteCount","header","concat","vertex","normalMatrixWorld","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","traverseMeshes","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame","cb","hasAttribute"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/exporters/PLYExporter.js"],"sourcesContent":["import { Mesh, Vector3, Matrix3 } from \"three\";\nclass PLYExporter {\n  parse(object, onDone, options) {\n    if (onDone && typeof onDone === \"object\") {\n      console.warn(\n        'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.'\n      );\n      options = onDone;\n      onDone = void 0;\n    }\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false;\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(function(child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        if (vertices === void 0) {\n          return;\n        }\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== void 0)\n          includeNormals = true;\n        if (uvs !== void 0)\n          includeUVs = true;\n        if (colors !== void 0)\n          includeColors = true;\n      }\n    });\n    const includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"index\")) === -1;\n    includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"normal\")) === -1;\n    includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"color\")) === -1;\n    includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"uv\")) === -1;\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      console.error(\n        \"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\"\n      );\n      return null;\n    }\n    const indexByteCount = 4;\n    let header = `ply\nformat ${options.binary ? options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\" : \"ascii\"} 1.0\nelement vertex ${vertexCount}\nproperty float x\nproperty float y\nproperty float z\n`;\n    if (includeNormals) {\n      header += \"property float nx\\nproperty float ny\\nproperty float nz\\n\";\n    }\n    if (includeUVs) {\n      header += \"property float s\\nproperty float t\\n\";\n    }\n    if (includeColors) {\n      header += \"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\";\n    }\n    if (includeIndices) {\n      header += `${`element face ${faceCount}\n`}property list uchar int vertex_index\n`;\n    }\n    header += \"end_header\\n\";\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n    if (options.binary) {\n      const headerBin = new TextEncoder().encode(header);\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      let writtenVertices = 0;\n      this.traverseMeshes(object, function(mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        }\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      let writtenVertices = 0;\n      let vertexList = \"\";\n      let faceList = \"\";\n      this.traverseMeshes(object, function(mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          let line = vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += \" \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n            } else {\n              line += \" 0 0 0\";\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              line += \" \" + uvs.getX(i) + \" \" + uvs.getY(i);\n            } else if (includeUVs) {\n              line += \" 0 0\";\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              line += \" \" + Math.floor(colors.getX(i) * 255) + \" \" + Math.floor(colors.getY(i) * 255) + \" \" + Math.floor(colors.getZ(i) * 255);\n            } else {\n              line += \" 255 255 255\";\n            }\n          }\n          vertexList += line + \"\\n\";\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\n`;\n            }\n          }\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\n` : \"\\n\"}`;\n    }\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone && onDone(typeof result === \"string\" ? result : \"\"));\n    }\n    return result;\n  }\n  // Iterate over the valid meshes in the object\n  traverseMeshes(object, cb) {\n    object.traverse(function(child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        if (geometry.hasAttribute(\"position\")) {\n          cb(mesh, geometry);\n        }\n      }\n    });\n  }\n}\nexport {\n  PLYExporter\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}