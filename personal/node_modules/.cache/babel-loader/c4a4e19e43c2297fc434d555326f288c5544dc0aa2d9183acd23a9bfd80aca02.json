{"ast":null,"code":"import _regeneratorRuntime from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createError } from '../errors.js';\nimport { getNested, intersect } from '../utils.js';\nvar DEFAULT_REDUCE = {\n  reducer: function reducer(_, acc, res, index) {\n    acc[index] = res;\n    return acc;\n  },\n  getInitialValue: function getInitialValue(length) {\n    return Array.from({\n      length: length\n    });\n  }\n};\nvar ALLOWED_TYPES = ['string', 'number', 'boolean'];\nexport function getGroups(_x, _x2, _x3) {\n  return _getGroups.apply(this, arguments);\n}\nfunction _getGroups() {\n  _getGroups = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(orama, results, groupBy) {\n    var properties, propertiesLength, schemaProperties, i, property, allIDs, allDocs, allDocsLength, returnedCount, listOfValues, g, _i, groupByKey, group, values, j, doc, value, keyValue, combinations, combinationsLength, groups, _i2, combination, combinationLength, _group, indexes, _j, _value, _property, groupsLength, res, _i3, _group2, reduce, docs, func, initialValue, aggregationValue;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          properties = groupBy.properties;\n          propertiesLength = properties.length;\n          _context.next = 4;\n          return orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n        case 4:\n          schemaProperties = _context.sent;\n          i = 0;\n        case 6:\n          if (!(i < propertiesLength)) {\n            _context.next = 15;\n            break;\n          }\n          property = properties[i];\n          if (!(typeof schemaProperties[property] === 'undefined')) {\n            _context.next = 10;\n            break;\n          }\n          throw createError('UNKNOWN_GROUP_BY_PROPERTY', property);\n        case 10:\n          if (ALLOWED_TYPES.includes(schemaProperties[property])) {\n            _context.next = 12;\n            break;\n          }\n          throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property]);\n        case 12:\n          i++;\n          _context.next = 6;\n          break;\n        case 15:\n          allIDs = results.map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 1),\n              id = _ref2[0];\n            return id;\n          }); // allDocs is already sorted by the sortBy algorithm\n          // We leverage on that to limit the number of documents returned\n          _context.next = 18;\n          return orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n        case 18:\n          allDocs = _context.sent;\n          allDocsLength = allDocs.length;\n          returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER;\n          listOfValues = []; // We want to understand which documents have which values\n          // and group them by the property and values\n          g = {};\n          _i = 0;\n        case 24:\n          if (!(_i < propertiesLength)) {\n            _context.next = 51;\n            break;\n          }\n          groupByKey = properties[_i];\n          group = {\n            property: groupByKey,\n            perValue: {}\n          };\n          values = new Set();\n          j = 0;\n        case 29:\n          if (!(j < allDocsLength)) {\n            _context.next = 46;\n            break;\n          }\n          doc = allDocs[j];\n          _context.next = 33;\n          return getNested(doc, groupByKey);\n        case 33:\n          value = _context.sent;\n          if (!(typeof value === 'undefined')) {\n            _context.next = 36;\n            break;\n          }\n          return _context.abrupt(\"continue\", 43);\n        case 36:\n          keyValue = typeof value !== 'boolean' ? value : '' + value;\n          if (typeof group.perValue[keyValue] === 'undefined') {\n            group.perValue[keyValue] = {\n              indexes: [],\n              count: 0\n            };\n          }\n          if (!(group.perValue[keyValue].count >= returnedCount)) {\n            _context.next = 40;\n            break;\n          }\n          return _context.abrupt(\"continue\", 43);\n        case 40:\n          // We use the index to keep track of the original order\n          group.perValue[keyValue].indexes.push(j);\n          group.perValue[keyValue].count++;\n          values.add(value);\n        case 43:\n          j++;\n          _context.next = 29;\n          break;\n        case 46:\n          listOfValues.push(Array.from(values));\n          g[groupByKey] = group;\n        case 48:\n          _i++;\n          _context.next = 24;\n          break;\n        case 51:\n          combinations = calculateCombination(listOfValues);\n          combinationsLength = combinations.length;\n          groups = [];\n          _i2 = 0;\n        case 55:\n          if (!(_i2 < combinationsLength)) {\n            _context.next = 68;\n            break;\n          }\n          combination = combinations[_i2];\n          combinationLength = combination.length;\n          _group = {\n            values: [],\n            indexes: []\n          };\n          indexes = [];\n          for (_j = 0; _j < combinationLength; _j++) {\n            _value = combination[_j];\n            _property = properties[_j];\n            indexes.push(g[_property].perValue[typeof _value !== 'boolean' ? _value : '' + _value].indexes);\n            _group.values.push(_value);\n          }\n          // We leverage on the index to sort the results by the original order\n          _group.indexes = intersect(indexes).sort(function (a, b) {\n            return a - b;\n          });\n          // don't generate empty groups\n          if (!(_group.indexes.length === 0)) {\n            _context.next = 64;\n            break;\n          }\n          return _context.abrupt(\"continue\", 65);\n        case 64:\n          groups.push(_group);\n        case 65:\n          _i2++;\n          _context.next = 55;\n          break;\n        case 68:\n          groupsLength = groups.length;\n          res = Array.from({\n            length: groupsLength\n          });\n          for (_i3 = 0; _i3 < groupsLength; _i3++) {\n            _group2 = groups[_i3];\n            reduce = groupBy.reduce || DEFAULT_REDUCE;\n            docs = _group2.indexes.map(function (index) {\n              return {\n                id: allIDs[index],\n                score: results[index][1],\n                document: allDocs[index]\n              };\n            });\n            func = reduce.reducer.bind(null, _group2.values);\n            initialValue = reduce.getInitialValue(_group2.indexes.length);\n            aggregationValue = docs.reduce(func, initialValue);\n            res[_i3] = {\n              values: _group2.values,\n              result: aggregationValue\n            };\n          }\n          return _context.abrupt(\"return\", res);\n        case 72:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _getGroups.apply(this, arguments);\n}\nfunction calculateCombination(arrs) {\n  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (index + 1 === arrs.length) return arrs[index].map(function (item) {\n    return [item];\n  });\n  var head = arrs[index];\n  var c = calculateCombination(arrs, index + 1);\n  var combinations = [];\n  var _iterator = _createForOfIteratorHelper(head),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n      var _iterator2 = _createForOfIteratorHelper(c),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var combination = _step2.value;\n          combinations.push([value].concat(_toConsumableArray(combination)));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return combinations;\n}","map":{"version":3,"names":["createError","getNested","intersect","DEFAULT_REDUCE","reducer","_","acc","res","index","getInitialValue","length","Array","from","ALLOWED_TYPES","getGroups","_x","_x2","_x3","_getGroups","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","orama","results","groupBy","properties","propertiesLength","schemaProperties","i","property","allIDs","allDocs","allDocsLength","returnedCount","listOfValues","g","_i","groupByKey","group","values","j","doc","value","keyValue","combinations","combinationsLength","groups","_i2","combination","combinationLength","_group","indexes","_j","_value","_property","groupsLength","_i3","_group2","reduce","docs","func","initialValue","aggregationValue","wrap","_callee$","_context","prev","next","getSearchablePropertiesWithTypes","data","sent","includes","join","map","_ref","_ref2","_slicedToArray","id","documentsStore","getMultiple","maxResult","Number","MAX_SAFE_INTEGER","perValue","Set","abrupt","count","push","add","calculateCombination","sort","a","b","score","document","bind","result","stop","arrs","undefined","item","head","c","_iterator","_createForOfIteratorHelper","_step","s","n","done","_iterator2","_step2","concat","_toConsumableArray","err","e","f"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/components/groups.ts"],"sourcesContent":["import type { Orama, ScalarSearchableValue, TokenScore, GroupByParams, GroupResult, Result, Reduce } from '../types.js'\nimport { createError } from '../errors.js'\nimport { getNested, intersect } from '../utils.js'\n\ninterface PropertyGroup {\n  property: string\n  perValue: Record<\n    string,\n    {\n      indexes: number[]\n      count: number\n    }\n  >\n}\n\ninterface Group {\n  values: ScalarSearchableValue[]\n  indexes: number[]\n}\n\nconst DEFAULT_REDUCE: Reduce<Result[]> = {\n  reducer: (_, acc, res, index) => {\n    acc[index] = res\n    return acc\n  },\n  getInitialValue: (length) => Array.from({ length }),\n}\n\nconst ALLOWED_TYPES = ['string', 'number', 'boolean']\n\nexport async function getGroups<AggValue>(orama: Orama, results: TokenScore[], groupBy: GroupByParams<AggValue>): Promise<GroupResult<AggValue>> {\n  const properties = groupBy.properties\n  const propertiesLength = properties.length\n\n  const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i]\n    if (typeof schemaProperties[property] === 'undefined') {\n      throw createError('UNKNOWN_GROUP_BY_PROPERTY', property)\n    }\n    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {\n      throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property])\n    }\n  }\n\n  const allIDs = results.map(([id]) => id)\n\n  // allDocs is already sorted by the sortBy algorithm\n  // We leverage on that to limit the number of documents returned\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const allDocsLength = allDocs.length\n\n  const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER\n\n  const listOfValues: ScalarSearchableValue[][] = []\n\n  // We want to understand which documents have which values\n  // and group them by the property and values\n  const g: Record<string, PropertyGroup> = {}\n  for (let i = 0; i < propertiesLength; i++) {\n    const groupByKey = properties[i]\n    const group: PropertyGroup = {\n      property: groupByKey,\n      perValue: {},\n    }\n\n    const values: Set<ScalarSearchableValue> = new Set()\n    for (let j = 0; j < allDocsLength; j++) {\n      const doc = allDocs[j]\n\n      const value = await getNested<ScalarSearchableValue>(doc as object, groupByKey)\n      // we don't want to consider undefined values\n      if (typeof value === 'undefined') {\n        continue\n      }\n      const keyValue = typeof value !== 'boolean' ? value : '' + value\n      if (typeof group.perValue[keyValue] === 'undefined') {\n        group.perValue[keyValue] = {\n          indexes: [],\n          count: 0,\n        }\n      }\n      if (group.perValue[keyValue].count >= returnedCount) {\n        // We stop early because for this value we react the limit\n        continue\n      }\n\n      // We use the index to keep track of the original order\n      group.perValue[keyValue].indexes.push(j)\n      group.perValue[keyValue].count++\n\n      values.add(value)\n    }\n\n    listOfValues.push(Array.from(values))\n\n    g[groupByKey] = group\n  }\n\n  const combinations = calculateCombination(listOfValues)\n  const combinationsLength = combinations.length\n\n  const groups: Group[] = []\n  for (let i = 0; i < combinationsLength; i++) {\n    const combination = combinations[i]\n    const combinationLength = combination.length\n\n    const group: Group = {\n      values: [],\n      indexes: [],\n    }\n    const indexes: number[][] = []\n    for (let j = 0; j < combinationLength; j++) {\n      const value = combination[j]\n      const property = properties[j]\n      indexes.push(g[property].perValue[typeof value !== 'boolean' ? value : '' + value].indexes)\n      group.values.push(value)\n    }\n    // We leverage on the index to sort the results by the original order\n    group.indexes = intersect(indexes).sort((a, b) => a - b)\n\n    // don't generate empty groups\n    if (group.indexes.length === 0) {\n      continue\n    }\n\n    groups.push(group)\n  }\n\n  const groupsLength = groups.length\n  const res: GroupResult<AggValue> = Array.from({ length: groupsLength })\n  for (let i = 0; i < groupsLength; i++) {\n    const group = groups[i]\n\n    const reduce = (groupBy.reduce || DEFAULT_REDUCE) as Reduce<AggValue>\n\n    const docs = group.indexes.map(index => {\n      return {\n        id: allIDs[index],\n        score: results[index][1],\n        document: allDocs[index]!,\n      }\n    })\n\n    const func = reduce.reducer.bind(null, group.values)\n    const initialValue = reduce.getInitialValue(group.indexes.length)\n    const aggregationValue = docs.reduce(func, initialValue)\n\n    res[i] = {\n      values: group.values,\n      result: aggregationValue,\n    }\n  }\n\n  return res\n}\n\nfunction calculateCombination(arrs: ScalarSearchableValue[][], index = 0): ScalarSearchableValue[][] {\n  if (index + 1 === arrs.length) return arrs[index].map(item => [item]);\n\n  const head = arrs[index];\n  const c = calculateCombination(arrs, index + 1);\n\n  const combinations = [];\n  for (const value of head) {\n    for (const combination of c) {\n      combinations.push([value, ...combination]);\n    }\n  }\n\n  return combinations;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}