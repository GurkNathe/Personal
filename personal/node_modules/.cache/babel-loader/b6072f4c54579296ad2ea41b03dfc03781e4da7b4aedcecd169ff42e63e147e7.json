{"ast":null,"code":"import _slicedToArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"debug\", \"children\", \"frames\", \"ior\", \"color\", \"causticsOnly\", \"backside\", \"backsideIOR\", \"worldRadius\", \"intensity\", \"resolution\", \"lightSource\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { useHelper } from './useHelper.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { Edges } from './Edges.js';\nimport { FullScreenQuad } from 'three-stdlib';\nfunction createNormalMaterial() {\n  var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : THREE.FrontSide;\n  var viewMatrix = {\n    value: new THREE.Matrix4()\n  };\n  return Object.assign(new THREE.MeshNormalMaterial({\n    side: side\n  }), {\n    viewMatrix: viewMatrix,\n    onBeforeCompile: function onBeforeCompile(shader) {\n      shader.uniforms.viewMatrix = viewMatrix;\n      shader.fragmentShader = \"vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n         }\\n\" + shader.fragmentShader.replace('#include <normal_fragment_maps>', \"#include <normal_fragment_maps>\\n           normal = inverseTransformDirection( normal, viewMatrix );\\n\");\n    }\n  });\n}\nvar CausticsProjectionMaterial = shaderMaterial({\n  causticsTexture: null,\n  causticsTextureB: null,\n  color: new THREE.Color(),\n  lightProjMatrix: new THREE.Matrix4(),\n  lightViewMatrix: new THREE.Matrix4()\n}, \"varying vec3 vWorldPosition;   \\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\\n     vWorldPosition = worldPosition.xyz;\\n   }\", \"varying vec3 vWorldPosition;\\n  uniform vec3 color;\\n  uniform sampler2D causticsTexture; \\n  uniform sampler2D causticsTextureB; \\n  uniform mat4 lightProjMatrix;\\n  uniform mat4 lightViewMatrix;\\n   void main() {\\n    // Apply caustics  \\n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\\n    lightSpacePos.xyz /= lightSpacePos.w;\\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \\n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\\n    gl_FragColor = vec4((front + back) * color, 1.0);\\n    #include <tonemapping_fragment>\\n    #include <encodings_fragment>\\n   }\");\nvar CausticsMaterial = shaderMaterial({\n  cameraMatrixWorld: new THREE.Matrix4(),\n  cameraProjectionMatrixInv: new THREE.Matrix4(),\n  normalTexture: null,\n  depthTexture: null,\n  lightDir: new THREE.Vector3(0, 1, 0),\n  lightPlaneNormal: new THREE.Vector3(0, 1, 0),\n  lightPlaneConstant: 0,\n  near: 0.1,\n  far: 100,\n  modelMatrix: new THREE.Matrix4(),\n  worldRadius: 1 / 40,\n  ior: 1.1,\n  bounces: 0,\n  resolution: 1024,\n  size: 10,\n  intensity: 0.5\n}, /* glsl */\"\\n  varying vec2 vUv;\\n  void main() {\\n      vUv = uv;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n  }\", /* glsl */\"  \\n  uniform mat4 cameraMatrixWorld;\\n  uniform mat4 cameraProjectionMatrixInv;\\n  uniform vec3 lightDir;\\n  uniform vec3 lightPlaneNormal;\\n  uniform float lightPlaneConstant;\\n  uniform float near;\\n  uniform float far;\\n  uniform float time;\\n  uniform float worldRadius;\\n  uniform float resolution;\\n  uniform float size;\\n  uniform float intensity;\\n  uniform float ior;\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  uniform sampler2D normalTexture;\\n  uniform sampler2D depthTexture;\\n  uniform float bounces;\\n  varying vec2 vUv;\\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\\n    float z = depth * 2.0 - 1.0;\\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\\n    // Perspective division\\n    viewSpacePosition /= viewSpacePosition.w;\\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\\n    return worldSpacePosition.xyz;\\n  }                  \\n  float sdPlane( vec3 p, vec3 n, float h ) {\\n    // n must be normalized\\n    return dot(p,n) + h;\\n  }\\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\n  }\\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\\n    rayOrigin = ro;\\n    rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = pos + rayDirection * 0.1;\\n    return rayDirection;\\n  }\\n  void main() {\\n    // Each sample consists of random offset in the x and y direction\\n    float caustic = 0.0;\\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\\n    float texelsNeeded = worldRadius / causticTexelSize;\\n    float sampleRadius = texelsNeeded / resolution;\\n    float sum = 0.0;\\n    if (texture2D(depthTexture, vUv).x == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 uv1 = vUv + offset1 * sampleRadius;\\n    vec2 uv2 = vUv + offset2 * sampleRadius;\\n    vec2 uv3 = vUv + offset3 * sampleRadius;\\n    vec2 uv4 = vUv + offset4 * sampleRadius;\\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\\n    // Sanity check the depths\\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\\n    vec3 endPos1, endPos2, endPos3, endPos4;\\n    vec3 endDir1, endDir2, endDir3, endDir4;\\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\\n    caustic += intensity * (lightPosArea / finalArea);\\n    // Calculate the area of the triangle in light spaces\\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\\n  }\");\nvar NORMALPROPS = {\n  depth: true,\n  minFilter: THREE.LinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  type: THREE.UnsignedByteType\n};\nvar CAUSTICPROPS = {\n  minFilter: THREE.LinearMipmapLinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  format: THREE.RGBAFormat,\n  type: THREE.FloatType,\n  generateMipmaps: true\n};\nvar Caustics = /*#__PURE__*/React.forwardRef(function (_ref, fref) {\n  var debug = _ref.debug,\n    children = _ref.children,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? 1 : _ref$frames,\n    _ref$ior = _ref.ior,\n    ior = _ref$ior === void 0 ? 1.1 : _ref$ior,\n    _ref$color = _ref.color,\n    color = _ref$color === void 0 ? 'white' : _ref$color,\n    _ref$causticsOnly = _ref.causticsOnly,\n    causticsOnly = _ref$causticsOnly === void 0 ? false : _ref$causticsOnly,\n    _ref$backside = _ref.backside,\n    backside = _ref$backside === void 0 ? false : _ref$backside,\n    _ref$backsideIOR = _ref.backsideIOR,\n    backsideIOR = _ref$backsideIOR === void 0 ? 1.1 : _ref$backsideIOR,\n    _ref$worldRadius = _ref.worldRadius,\n    worldRadius = _ref$worldRadius === void 0 ? 0.3125 : _ref$worldRadius,\n    _ref$intensity = _ref.intensity,\n    intensity = _ref$intensity === void 0 ? 0.05 : _ref$intensity,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 2024 : _ref$resolution,\n    _ref$lightSource = _ref.lightSource,\n    lightSource = _ref$lightSource === void 0 ? [5, 5, 5] : _ref$lightSource,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    CausticsProjectionMaterial: CausticsProjectionMaterial\n  });\n  var ref = React.useRef(null);\n  var camera = React.useRef(null);\n  var scene = React.useRef(null);\n  var plane = React.useRef(null);\n  var gl = useThree(function (state) {\n    return state.gl;\n  });\n  var helper = useHelper(debug && camera, THREE.CameraHelper); // Buffers for front and back faces\n\n  var normalTarget = useFBO(resolution, resolution, NORMALPROPS);\n  var normalTargetB = useFBO(resolution, resolution, NORMALPROPS);\n  var causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);\n  var causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS); // Normal materials for front and back faces\n\n  var _React$useState = React.useState(function () {\n      return createNormalMaterial();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    normalMat = _React$useState2[0];\n  var _React$useState3 = React.useState(function () {\n      return createNormalMaterial(THREE.BackSide);\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 1),\n    normalMatB = _React$useState4[0]; // The quad that catches the caustics\n\n  var _React$useState5 = React.useState(function () {\n      return new CausticsMaterial();\n    }),\n    _React$useState6 = _slicedToArray(_React$useState5, 1),\n    causticsMaterial = _React$useState6[0];\n  var _React$useState7 = React.useState(function () {\n      return new FullScreenQuad(causticsMaterial);\n    }),\n    _React$useState8 = _slicedToArray(_React$useState7, 1),\n    causticsQuad = _React$useState8[0];\n  React.useLayoutEffect(function () {\n    ref.current.updateWorldMatrix(false, true);\n  });\n  var count = 0;\n  var v = new THREE.Vector3();\n  var lpF = new THREE.Frustum();\n  var lpM = new THREE.Matrix4();\n  var lpP = new THREE.Plane();\n  var lightDir = new THREE.Vector3();\n  var lightDirInv = new THREE.Vector3();\n  var bounds = new THREE.Box3();\n  var focusPos = new THREE.Vector3();\n  useFrame(function (state, delta) {\n    if (frames === Infinity || count++ < frames) {\n      var _scene$current$parent, _helper$current;\n      if (Array.isArray(lightSource)) lightDir.fromArray(lightSource).normalize();else lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v)).normalize());\n      lightDirInv.copy(lightDir).multiplyScalar(-1);\n      var boundsVertices = [];\n      (_scene$current$parent = scene.current.parent) == null ? void 0 : _scene$current$parent.matrixWorld.identity();\n      bounds.setFromObject(scene.current, true);\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z));\n      var worldVerts = boundsVertices.map(function (v) {\n        return v.clone();\n      });\n      bounds.getCenter(focusPos);\n      boundsVertices = boundsVertices.map(function (v) {\n        return v.clone().sub(focusPos);\n      });\n      var lightPlane = lpP.set(lightDirInv, 0);\n      var projectedVerts = boundsVertices.map(function (v) {\n        return lightPlane.projectPoint(v, new THREE.Vector3());\n      });\n      var centralVert = projectedVerts.reduce(function (a, b) {\n        return a.add(b);\n      }, v.set(0, 0, 0)).divideScalar(projectedVerts.length);\n      var radius = projectedVerts.map(function (v) {\n        return v.distanceTo(centralVert);\n      }).reduce(function (a, b) {\n        return Math.max(a, b);\n      });\n      var dirLength = boundsVertices.map(function (x) {\n        return x.dot(lightDir);\n      }).reduce(function (a, b) {\n        return Math.max(a, b);\n      }); // Shadows\n\n      camera.current.position.copy(lightDir.clone().multiplyScalar(dirLength).add(focusPos));\n      camera.current.lookAt(scene.current.localToWorld(focusPos.clone()));\n      var dirMatrix = lpM.lookAt(camera.current.position, focusPos, v.set(0, 1, 0));\n      camera.current.left = -radius;\n      camera.current.right = radius;\n      camera.current.top = radius;\n      camera.current.bottom = -radius;\n      var yOffset = v.set(0, radius, 0).applyMatrix4(dirMatrix);\n      var yTime = (camera.current.position.y + yOffset.y) / lightDir.y;\n      camera.current.near = 0.1;\n      camera.current.far = yTime;\n      camera.current.updateProjectionMatrix();\n      camera.current.updateMatrixWorld(); // Now find size of ground plane\n\n      var groundProjectedCoords = worldVerts.map(function (v) {\n        return v.add(lightDir.clone().multiplyScalar(-v.y / lightDir.y));\n      });\n      var centerPos = groundProjectedCoords.reduce(function (a, b) {\n        return a.add(b);\n      }, v.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);\n      var maxSize = 2 * groundProjectedCoords.map(function (v) {\n        return Math.hypot(v.x - centerPos.x, v.z - centerPos.z);\n      }).reduce(function (a, b) {\n        return Math.max(a, b);\n      });\n      plane.current.scale.setScalar(maxSize);\n      plane.current.position.copy(centerPos);\n      if (debug) (_helper$current = helper.current) == null ? void 0 : _helper$current.update(); // Inject uniforms\n\n      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;\n      var dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];\n      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;\n      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;\n      causticsMaterial.lightDir = lightDirInv;\n      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;\n      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant;\n      causticsMaterial.near = camera.current.near;\n      causticsMaterial.far = camera.current.far;\n      causticsMaterial.resolution = resolution;\n      causticsMaterial.size = radius;\n      causticsMaterial.intensity = intensity;\n      causticsMaterial.worldRadius = worldRadius; // Switch the scene on\n\n      scene.current.visible = true; // Render front face normals\n\n      gl.setRenderTarget(normalTarget);\n      gl.clear();\n      scene.current.overrideMaterial = normalMat;\n      gl.render(scene.current, camera.current); // Render back face normals, if enabled\n\n      gl.setRenderTarget(normalTargetB);\n      gl.clear();\n      if (backside) {\n        scene.current.overrideMaterial = normalMatB;\n        gl.render(scene.current, camera.current);\n      } // Remove the override material\n\n      scene.current.overrideMaterial = null; // Render front face caustics\n\n      causticsMaterial.ior = ior;\n      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;\n      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;\n      causticsMaterial.normalTexture = normalTarget.texture;\n      causticsMaterial.depthTexture = normalTarget.depthTexture;\n      gl.setRenderTarget(causticsTarget);\n      gl.clear();\n      causticsQuad.render(gl); // Render back face caustics, if enabled\n\n      causticsMaterial.ior = backsideIOR;\n      causticsMaterial.normalTexture = normalTargetB.texture;\n      causticsMaterial.depthTexture = normalTargetB.depthTexture;\n      gl.setRenderTarget(causticsTargetB);\n      gl.clear();\n      if (backside) causticsQuad.render(gl); // Reset render target\n\n      gl.setRenderTarget(null); // Switch the scene off if caustics is all that's wanted\n\n      if (causticsOnly) scene.current.visible = false;\n    }\n  });\n  React.useImperativeHandle(fref, function () {\n    return ref.current;\n  }, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"scene\", {\n    ref: scene\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: camera,\n    up: [0, 1, 0]\n  }), children), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: 2,\n    ref: plane,\n    \"rotation-x\": -Math.PI / 2\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"causticsProjectionMaterial\", {\n    transparent: true,\n    color: color,\n    causticsTexture: causticsTarget.texture,\n    causticsTextureB: causticsTargetB.texture,\n    blending: THREE.CustomBlending,\n    blendSrc: THREE.OneFactor,\n    blendDst: THREE.SrcAlphaFactor,\n    depthWrite: false\n  }), debug && /*#__PURE__*/React.createElement(Edges, null, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: \"#ffff00\",\n    toneMapped: false\n  }))));\n});\nexport { Caustics };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useFrame","useFBO","useHelper","shaderMaterial","Edges","FullScreenQuad","createNormalMaterial","side","arguments","length","undefined","FrontSide","viewMatrix","value","Matrix4","Object","assign","MeshNormalMaterial","onBeforeCompile","shader","uniforms","fragmentShader","replace","CausticsProjectionMaterial","causticsTexture","causticsTextureB","color","Color","lightProjMatrix","lightViewMatrix","CausticsMaterial","cameraMatrixWorld","cameraProjectionMatrixInv","normalTexture","depthTexture","lightDir","Vector3","lightPlaneNormal","lightPlaneConstant","near","far","modelMatrix","worldRadius","ior","bounces","resolution","size","intensity","NORMALPROPS","depth","minFilter","LinearFilter","magFilter","encoding","LinearEncoding","type","UnsignedByteType","CAUSTICPROPS","LinearMipmapLinearFilter","format","RGBAFormat","FloatType","generateMipmaps","Caustics","forwardRef","_ref","fref","debug","children","_ref$frames","frames","_ref$ior","_ref$color","_ref$causticsOnly","causticsOnly","_ref$backside","backside","_ref$backsideIOR","backsideIOR","_ref$worldRadius","_ref$intensity","_ref$resolution","_ref$lightSource","lightSource","props","_objectWithoutProperties","_excluded","ref","useRef","camera","scene","plane","gl","state","helper","CameraHelper","normalTarget","normalTargetB","causticsTarget","causticsTargetB","_React$useState","useState","_React$useState2","_slicedToArray","normalMat","_React$useState3","BackSide","_React$useState4","normalMatB","_React$useState5","_React$useState6","causticsMaterial","_React$useState7","_React$useState8","causticsQuad","useLayoutEffect","current","updateWorldMatrix","count","v","lpF","Frustum","lpM","lpP","Plane","lightDirInv","bounds","Box3","focusPos","delta","Infinity","_scene$current$parent","_helper$current","Array","isArray","fromArray","normalize","copy","worldToLocal","getWorldPosition","multiplyScalar","boundsVertices","parent","matrixWorld","identity","setFromObject","push","min","x","y","z","max","worldVerts","map","clone","getCenter","sub","lightPlane","set","projectedVerts","projectPoint","centralVert","reduce","a","b","add","divideScalar","radius","distanceTo","Math","dirLength","dot","position","lookAt","localToWorld","dirMatrix","left","right","top","bottom","yOffset","applyMatrix4","yTime","updateProjectionMatrix","updateMatrixWorld","groundProjectedCoords","centerPos","maxSize","hypot","scale","setScalar","update","matrixWorldInverse","dirLightNearPlane","setFromProjectionMatrix","multiplyMatrices","projectionMatrix","planes","projectionMatrixInverse","normal","constant","visible","setRenderTarget","clear","overrideMaterial","render","material","texture","useImperativeHandle","createElement","up","renderOrder","PI","transparent","blending","CustomBlending","blendSrc","OneFactor","blendDst","SrcAlphaFactor","depthWrite","toneMapped"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@react-three+drei@9.72.1_@react-three+fiber@8.13.0_@types+three@0.150.2_react-dom@18.2.0_react@18.2.0_three@0.151.3/node_modules/@react-three/drei/core/Caustics.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { useHelper } from './useHelper.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { Edges } from './Edges.js';\nimport { FullScreenQuad } from 'three-stdlib';\n\nfunction createNormalMaterial(side = THREE.FrontSide) {\n  const viewMatrix = {\n    value: new THREE.Matrix4()\n  };\n  return Object.assign(new THREE.MeshNormalMaterial({\n    side\n  }), {\n    viewMatrix,\n    onBeforeCompile: shader => {\n      shader.uniforms.viewMatrix = viewMatrix;\n      shader.fragmentShader = `vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\\n` + shader.fragmentShader.replace('#include <normal_fragment_maps>', `#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\\n`);\n    }\n  });\n}\n\nconst CausticsProjectionMaterial = shaderMaterial({\n  causticsTexture: null,\n  causticsTextureB: null,\n  color: new THREE.Color(),\n  lightProjMatrix: new THREE.Matrix4(),\n  lightViewMatrix: new THREE.Matrix4()\n}, `varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }`, `varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n   }`);\nconst CausticsMaterial = shaderMaterial({\n  cameraMatrixWorld: new THREE.Matrix4(),\n  cameraProjectionMatrixInv: new THREE.Matrix4(),\n  normalTexture: null,\n  depthTexture: null,\n  lightDir: new THREE.Vector3(0, 1, 0),\n  lightPlaneNormal: new THREE.Vector3(0, 1, 0),\n  lightPlaneConstant: 0,\n  near: 0.1,\n  far: 100,\n  modelMatrix: new THREE.Matrix4(),\n  worldRadius: 1 / 40,\n  ior: 1.1,\n  bounces: 0,\n  resolution: 1024,\n  size: 10,\n  intensity: 0.5\n},\n/* glsl */\n`\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }`,\n/* glsl */\n`  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }`);\nconst NORMALPROPS = {\n  depth: true,\n  minFilter: THREE.LinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  type: THREE.UnsignedByteType\n};\nconst CAUSTICPROPS = {\n  minFilter: THREE.LinearMipmapLinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  format: THREE.RGBAFormat,\n  type: THREE.FloatType,\n  generateMipmaps: true\n};\nconst Caustics = /*#__PURE__*/React.forwardRef(({\n  debug,\n  children,\n  frames = 1,\n  ior = 1.1,\n  color = 'white',\n  causticsOnly = false,\n  backside = false,\n  backsideIOR = 1.1,\n  worldRadius = 0.3125,\n  intensity = 0.05,\n  resolution = 2024,\n  lightSource = [5, 5, 5],\n  ...props\n}, fref) => {\n  extend({\n    CausticsProjectionMaterial\n  });\n  const ref = React.useRef(null);\n  const camera = React.useRef(null);\n  const scene = React.useRef(null);\n  const plane = React.useRef(null);\n  const gl = useThree(state => state.gl);\n  const helper = useHelper(debug && camera, THREE.CameraHelper); // Buffers for front and back faces\n\n  const normalTarget = useFBO(resolution, resolution, NORMALPROPS);\n  const normalTargetB = useFBO(resolution, resolution, NORMALPROPS);\n  const causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);\n  const causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS); // Normal materials for front and back faces\n\n  const [normalMat] = React.useState(() => createNormalMaterial());\n  const [normalMatB] = React.useState(() => createNormalMaterial(THREE.BackSide)); // The quad that catches the caustics\n\n  const [causticsMaterial] = React.useState(() => new CausticsMaterial());\n  const [causticsQuad] = React.useState(() => new FullScreenQuad(causticsMaterial));\n  React.useLayoutEffect(() => {\n    ref.current.updateWorldMatrix(false, true);\n  });\n  let count = 0;\n  const v = new THREE.Vector3();\n  const lpF = new THREE.Frustum();\n  const lpM = new THREE.Matrix4();\n  const lpP = new THREE.Plane();\n  const lightDir = new THREE.Vector3();\n  const lightDirInv = new THREE.Vector3();\n  const bounds = new THREE.Box3();\n  const focusPos = new THREE.Vector3();\n  useFrame((state, delta) => {\n    if (frames === Infinity || count++ < frames) {\n      var _scene$current$parent, _helper$current;\n\n      if (Array.isArray(lightSource)) lightDir.fromArray(lightSource).normalize();else lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v)).normalize());\n      lightDirInv.copy(lightDir).multiplyScalar(-1);\n      let boundsVertices = [];\n      (_scene$current$parent = scene.current.parent) == null ? void 0 : _scene$current$parent.matrixWorld.identity();\n      bounds.setFromObject(scene.current, true);\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z));\n      const worldVerts = boundsVertices.map(v => v.clone());\n      bounds.getCenter(focusPos);\n      boundsVertices = boundsVertices.map(v => v.clone().sub(focusPos));\n      const lightPlane = lpP.set(lightDirInv, 0);\n      const projectedVerts = boundsVertices.map(v => lightPlane.projectPoint(v, new THREE.Vector3()));\n      const centralVert = projectedVerts.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(projectedVerts.length);\n      const radius = projectedVerts.map(v => v.distanceTo(centralVert)).reduce((a, b) => Math.max(a, b));\n      const dirLength = boundsVertices.map(x => x.dot(lightDir)).reduce((a, b) => Math.max(a, b)); // Shadows\n\n      camera.current.position.copy(lightDir.clone().multiplyScalar(dirLength).add(focusPos));\n      camera.current.lookAt(scene.current.localToWorld(focusPos.clone()));\n      const dirMatrix = lpM.lookAt(camera.current.position, focusPos, v.set(0, 1, 0));\n      camera.current.left = -radius;\n      camera.current.right = radius;\n      camera.current.top = radius;\n      camera.current.bottom = -radius;\n      const yOffset = v.set(0, radius, 0).applyMatrix4(dirMatrix);\n      const yTime = (camera.current.position.y + yOffset.y) / lightDir.y;\n      camera.current.near = 0.1;\n      camera.current.far = yTime;\n      camera.current.updateProjectionMatrix();\n      camera.current.updateMatrixWorld(); // Now find size of ground plane\n\n      const groundProjectedCoords = worldVerts.map(v => v.add(lightDir.clone().multiplyScalar(-v.y / lightDir.y)));\n      const centerPos = groundProjectedCoords.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);\n      const maxSize = 2 * groundProjectedCoords.map(v => Math.hypot(v.x - centerPos.x, v.z - centerPos.z)).reduce((a, b) => Math.max(a, b));\n      plane.current.scale.setScalar(maxSize);\n      plane.current.position.copy(centerPos);\n      if (debug) (_helper$current = helper.current) == null ? void 0 : _helper$current.update(); // Inject uniforms\n\n      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;\n      const dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];\n      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;\n      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;\n      causticsMaterial.lightDir = lightDirInv;\n      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;\n      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant;\n      causticsMaterial.near = camera.current.near;\n      causticsMaterial.far = camera.current.far;\n      causticsMaterial.resolution = resolution;\n      causticsMaterial.size = radius;\n      causticsMaterial.intensity = intensity;\n      causticsMaterial.worldRadius = worldRadius; // Switch the scene on\n\n      scene.current.visible = true; // Render front face normals\n\n      gl.setRenderTarget(normalTarget);\n      gl.clear();\n      scene.current.overrideMaterial = normalMat;\n      gl.render(scene.current, camera.current); // Render back face normals, if enabled\n\n      gl.setRenderTarget(normalTargetB);\n      gl.clear();\n\n      if (backside) {\n        scene.current.overrideMaterial = normalMatB;\n        gl.render(scene.current, camera.current);\n      } // Remove the override material\n\n\n      scene.current.overrideMaterial = null; // Render front face caustics\n\n      causticsMaterial.ior = ior;\n      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;\n      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;\n      causticsMaterial.normalTexture = normalTarget.texture;\n      causticsMaterial.depthTexture = normalTarget.depthTexture;\n      gl.setRenderTarget(causticsTarget);\n      gl.clear();\n      causticsQuad.render(gl); // Render back face caustics, if enabled\n\n      causticsMaterial.ior = backsideIOR;\n      causticsMaterial.normalTexture = normalTargetB.texture;\n      causticsMaterial.depthTexture = normalTargetB.depthTexture;\n      gl.setRenderTarget(causticsTargetB);\n      gl.clear();\n      if (backside) causticsQuad.render(gl); // Reset render target\n\n      gl.setRenderTarget(null); // Switch the scene off if caustics is all that's wanted\n\n      if (causticsOnly) scene.current.visible = false;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"scene\", {\n    ref: scene\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: camera,\n    up: [0, 1, 0]\n  }), children), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: 2,\n    ref: plane,\n    \"rotation-x\": -Math.PI / 2\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"causticsProjectionMaterial\", {\n    transparent: true,\n    color: color,\n    causticsTexture: causticsTarget.texture,\n    causticsTextureB: causticsTargetB.texture,\n    blending: THREE.CustomBlending,\n    blendSrc: THREE.OneFactor,\n    blendDst: THREE.SrcAlphaFactor,\n    depthWrite: false\n  }), debug && /*#__PURE__*/React.createElement(Edges, null, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: \"#ffff00\",\n    toneMapped: false\n  }))));\n});\n\nexport { Caustics };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}