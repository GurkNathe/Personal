{"ast":null,"code":"const BALANCE_STATE = {\n  UNBALANCED_RIGHT: -2,\n  SLIGHTLY_UNBALANCED_RIGHT: -1,\n  BALANCED: 0,\n  SLIGHTLY_UNBALANCED_LEFT: 1,\n  UNBALANCED_LEFT: 2\n};\nfunction getHeight(node) {\n  return node ? node.height : -1;\n}\nfunction rotateLeft(node) {\n  const right = node.right;\n  node.right = right.left;\n  right.left = node;\n  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;\n  right.height = Math.max(getHeight(right.left), getHeight(right.right)) + 1;\n  return right;\n}\nfunction rotateRight(node) {\n  const left = node.left;\n  node.left = left.right;\n  left.right = node;\n  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;\n  left.height = Math.max(getHeight(left.left), getHeight(left.right)) + 1;\n  return left;\n}\nexport function contains(node, key) {\n  return !!find(node, key);\n}\nexport function getSize(root) {\n  let size = 0;\n  const queue = [];\n  if (root !== null) {\n    queue.push(root);\n  }\n  while (queue.length > 0) {\n    const node = queue.shift();\n    size++;\n    if (node.left !== null) {\n      queue.push(node.left);\n    }\n    if (node.right !== null) {\n      queue.push(node.right);\n    }\n  }\n  return size;\n}\nexport function isBalanced(root) {\n  if (root === null) return true;\n  const stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (node === undefined) return true;\n    const heightDiff = getHeight(node.left) - getHeight(node.right);\n    if (heightDiff > 1 || heightDiff < -1) {\n      return false;\n    }\n    if (node.right !== null) {\n      stack.push(node.right);\n    }\n    if (node.left !== null) {\n      stack.push(node.left);\n    }\n  }\n  return true;\n}\nexport function rangeSearch(node, min, max) {\n  if (!node) {\n    return [];\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result = [];\n  function traverse(node) {\n    if (!node) {\n      return;\n    }\n    if (node.key > min) {\n      traverse(node.left);\n    }\n    if (node.key >= min && node.key <= max) {\n      result.push(...node.value);\n    }\n    if (node.key < max) {\n      traverse(node.right);\n    }\n  }\n  traverse(node);\n  return result;\n}\nexport function greaterThan(node, key) {\n  let inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!node) {\n    return [];\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result = [];\n  function traverse(node) {\n    if (!node) {\n      return;\n    }\n    if (inclusive && node.key >= key) {\n      result.push(...node.value);\n    }\n    if (!inclusive && node.key > key) {\n      result.push(...node.value);\n    }\n    traverse(node.left);\n    traverse(node.right);\n  }\n  traverse(node);\n  return result;\n}\nexport function lessThan(node, key) {\n  let inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!node) {\n    return [];\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result = [];\n  function traverse(node) {\n    if (!node) {\n      return;\n    }\n    if (inclusive && node.key <= key) {\n      result.push(...node.value);\n    }\n    if (!inclusive && node.key < key) {\n      result.push(...node.value);\n    }\n    traverse(node.left);\n    traverse(node.right);\n  }\n  traverse(node);\n  return result;\n}\nfunction getNodeByKey(node, key) {\n  while (node !== null) {\n    if (key < node.key) {\n      node = node.left;\n    } else if (key > node.key) {\n      node = node.right;\n    } else {\n      return node;\n    }\n  }\n  return null;\n}\nexport function create(key, value) {\n  return {\n    key,\n    value,\n    left: null,\n    right: null,\n    height: 0\n  };\n}\nexport function insert(root, key, value) {\n  let parent = null;\n  let current = root;\n  while (current !== null) {\n    parent = current;\n    if (key < current.key) {\n      current = current.left;\n    } else if (key > current.key) {\n      current = current.right;\n    } else {\n      // assuming value is an array here\n      current.value = current.value.concat(value);\n      return root;\n    }\n  }\n  const newNode = create(key, value);\n  if (!parent) {\n    root = newNode; // tree was empty\n  } else if (key < parent.key) {\n    parent.left = newNode;\n  } else {\n    parent.right = newNode;\n  }\n  current = newNode;\n  while (parent) {\n    const balanceFactor = getHeight(parent.left) - getHeight(parent.right);\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {\n      if (key < parent.left.key) {\n        parent = rotateRight(parent);\n      } else {\n        parent.left = rotateLeft(parent.left);\n        parent = rotateRight(parent);\n      }\n    }\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {\n      if (key > parent.right.key) {\n        parent = rotateLeft(parent);\n      } else {\n        parent.right = rotateRight(parent.right);\n        parent = rotateLeft(parent);\n      }\n    }\n    if (parent == root) {\n      break;\n    }\n    current = parent;\n    parent = getNodeParent(root, current.key);\n  }\n  return root;\n}\nfunction getNodeParent(root, key) {\n  let current = root;\n  let parent = null;\n  while (current !== null) {\n    if (key < current.key) {\n      parent = current;\n      current = current.left;\n    } else if (key > current.key) {\n      parent = current;\n      current = current.right;\n    } else {\n      break;\n    }\n  }\n  return parent;\n}\nexport function find(root, key) {\n  const node = getNodeByKey(root, key);\n  if (!node) {\n    return null;\n  }\n  return node.value;\n}\nexport function remove(root, key) {\n  let node = root;\n  let parentNode = null;\n  while (node && node.key !== key) {\n    parentNode = node;\n    if (key < node.key) {\n      node = node.left;\n    } else {\n      node = node.right;\n    }\n  }\n  if (!node) {\n    return null;\n  }\n  if (!node.left && !node.right) {\n    if (!parentNode) {\n      // Node to be deleted is root\n      root = null;\n    } else {\n      if (parentNode.left === node) {\n        parentNode.left = null;\n      } else {\n        parentNode.right = null;\n      }\n    }\n  } else if (node.left && node.right) {\n    let minValueNode = node.right;\n    let minValueParent = node;\n    while (minValueNode.left) {\n      minValueParent = minValueNode;\n      minValueNode = minValueNode.left;\n    }\n    node.key = minValueNode.key;\n    if (minValueParent === node) {\n      minValueParent.right = minValueNode.right;\n    } else {\n      minValueParent.left = minValueNode.right;\n    }\n  } else {\n    const childNode = node.left ? node.left : node.right;\n    if (!parentNode) {\n      root = childNode;\n    } else {\n      if (parentNode.left === node) {\n        parentNode.left = childNode;\n      } else {\n        parentNode.right = childNode;\n      }\n    }\n  }\n  return root;\n}\nexport function removeDocument(root, id, key) {\n  const node = getNodeByKey(root, key);\n  if (node.value.length === 1) {\n    remove(root, key);\n    return;\n  }\n  node.value.splice(node.value.indexOf(id), 1);\n}","map":{"version":3,"names":["BALANCE_STATE","UNBALANCED_RIGHT","SLIGHTLY_UNBALANCED_RIGHT","BALANCED","SLIGHTLY_UNBALANCED_LEFT","UNBALANCED_LEFT","getHeight","node","height","rotateLeft","right","left","Math","max","rotateRight","contains","key","find","getSize","root","size","queue","push","length","shift","isBalanced","stack","pop","undefined","heightDiff","rangeSearch","min","result","traverse","value","greaterThan","inclusive","arguments","lessThan","getNodeByKey","create","insert","parent","current","concat","newNode","balanceFactor","getNodeParent","remove","parentNode","minValueNode","minValueParent","childNode","removeDocument","id","splice","indexOf"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/trees/avl.ts"],"sourcesContent":["export type Node<K, V> = {\n  key: K\n  value: V\n  left: Node<K, V> | null\n  right: Node<K, V> | null\n  height: number\n}\n\nconst BALANCE_STATE = {\n  UNBALANCED_RIGHT: -2,\n  SLIGHTLY_UNBALANCED_RIGHT: -1,\n  BALANCED: 0,\n  SLIGHTLY_UNBALANCED_LEFT: 1,\n  UNBALANCED_LEFT: 2,\n}\n\nfunction getHeight<K, V>(node: Node<K, V> | null): number {\n  return node ? node.height : -1\n}\n\nfunction rotateLeft<K, V>(node: Node<K, V>): Node<K, V> {\n  const right = node.right as Node<K, V>\n  node.right = right.left\n  right.left = node\n  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1\n  right.height = Math.max(getHeight(right.left), getHeight(right.right)) + 1\n  return right\n}\n\nfunction rotateRight<K, V>(node: Node<K, V>): Node<K, V> {\n  const left = node.left as Node<K, V>\n  node.left = left.right\n  left.right = node\n  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1\n  left.height = Math.max(getHeight(left.left), getHeight(left.right)) + 1\n  return left\n}\n\nexport function contains<K, V>(node: Node<K, V>, key: K): boolean {\n  return !!find(node, key)\n}\n\nexport function getSize<K, V>(root: Node<K, V> | null): number {\n  let size = 0;\n  const queue: Array<Node<K, V>> = [];\n\n  if (root !== null) {\n    queue.push(root);\n  }\n\n  while (queue.length > 0) {\n    const node = queue.shift() as Node<K, V>;\n    size++;\n\n    if (node.left !== null) {\n      queue.push(node.left);\n    }\n\n    if (node.right !== null) {\n      queue.push(node.right);\n    }\n  }\n\n  return size;\n}\n\nexport function isBalanced<K, V>(root: Node<K, V> | null): boolean {\n  if (root === null)\n    return true;\n\n  const stack: Node<K, V>[] = [root];\n\n  while (stack.length > 0) {\n    const node = stack.pop();\n\n    if (node === undefined)\n      return true;\n\n    const heightDiff = getHeight(node.left) - getHeight(node.right);\n\n    if (heightDiff > 1 || heightDiff < -1) {\n      return false;\n    }\n\n    if (node.right !== null) {\n      stack.push(node.right);\n    }\n\n    if (node.left !== null) {\n      stack.push(node.left);\n    }\n  }\n\n  return true;\n}\n\nexport function rangeSearch<K, V>(node: Node<K, V>, min: K, max: K): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result: V[] = []\n\n  function traverse(node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (node.key > min) {\n      traverse(node.left as Node<K, V>)\n    }\n\n    if (node.key >= min && node.key <= max) {\n      result.push(...(node.value as V[]))\n    }\n\n    if (node.key < max) {\n      traverse(node.right as Node<K, V>)\n    }\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nexport function greaterThan<K, V>(node: Node<K, V>, key: K, inclusive = false): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result: V[] = []\n\n  function traverse(node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (inclusive && node.key >= key) {\n      result.push(...(node.value as V[]))\n    }\n\n    if (!inclusive && node.key > key) {\n      result.push(...(node.value as V[]))\n    }\n\n    traverse(node.left as Node<K, V>)\n    traverse(node.right as Node<K, V>)\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nexport function lessThan<K, V>(node: Node<K, V>, key: K, inclusive = false): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result: V[] = []\n\n  function traverse(node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (inclusive && node.key <= key) {\n      result.push(...(node.value as V[]))\n    }\n\n    if (!inclusive && node.key < key) {\n      result.push(...(node.value as V[]))\n    }\n\n    traverse(node.left as Node<K, V>)\n    traverse(node.right as Node<K, V>)\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nfunction getNodeByKey<K, V>(node: Node<K, V> | null, key: K): Node<K, V> | null {\n  while (node !== null) {\n    if (key < node.key) {\n      node = node.left;\n    } else if (key > node.key) {\n      node = node.right;\n    } else {\n      return node;\n    }\n  }\n  return null;\n}\n\nexport function create<K, V>(key: K, value: V): Node<K, V> {\n  return {\n    key,\n    value,\n    left: null,\n    right: null,\n    height: 0,\n  }\n}\n\nexport function insert<K, V>(root: Node<K, V>, key: K, value: V): Node<K, V> {\n  let parent = null;\n  let current = root;\n\n  while (current !== null) {\n    parent = current;\n    if (key < current.key) {\n        current = current.left as Node<K, V>;\n    } else if (key > current.key) {\n        current = current.right as Node<K, V>;\n    } else {\n      // assuming value is an array here\n      (current.value as string[]) = (current.value as string[]).concat(value as string);\n      return root;\n    }\n  }\n\n  const newNode = create(key, value);\n\n  if (!parent) {\n      root = newNode; // tree was empty\n  } else if (key < parent.key) {\n      parent.left = newNode;\n  } else {\n      parent.right = newNode;\n  }\n\n  current = newNode;\n\n  while (parent) {\n    const balanceFactor = getHeight(parent.left) - getHeight(parent.right)\n\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {\n        if (key < (parent.left as Node<K, V>).key) {\n            parent = rotateRight(parent);\n        } else {\n            parent.left = rotateLeft(parent.left as Node<K, V>);\n            parent = rotateRight(parent);\n        }\n    }\n\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {\n        if (key > (parent.right as Node<K, V>).key) {\n            parent = rotateLeft(parent);\n        } else {\n            parent.right = rotateRight(parent.right as Node<K, V>);\n            parent = rotateLeft(parent);\n        }\n    }\n\n    if (parent == root) {\n        break;\n    }\n\n    current = parent;\n    parent = getNodeParent(root, current.key);\n  }\n\n  return root;\n}\n\nfunction getNodeParent<K, V>(root: Node<K, V>, key: K): Node<K, V> | null {\n    let current = root;\n    let parent = null;\n\n    while (current !== null) {\n        if (key < current.key) {\n            parent = current;\n            current = current.left as Node<K, V>;\n        } else if (key > current.key) {\n            parent = current;\n            current = current.right as Node<K, V>;\n        } else {\n            break;\n        }\n    }\n\n    return parent;\n}\n\nexport function find<K, V>(root: Node<K, V>, key: K): V | null {\n  const node = getNodeByKey(root, key)\n  if (!node) {\n    return null\n  }\n  return node.value\n}\n\nexport function remove<K, V>(root: Node<K, V> | null, key: K): Node<K, V> | null {\n  let node = root;\n  let parentNode: Node<K, V> | null = null;\n\n  while (node && node.key !== key) {\n    parentNode = node;\n    if (key < node.key) {\n      node = node.left as Node<K, V>;\n    } else {\n      node = node.right as Node<K, V>;\n    }\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  if (!node.left && !node.right) {\n    if (!parentNode) {\n      // Node to be deleted is root\n      root = null;\n    } else {\n      if (parentNode.left === node) {\n        parentNode.left = null;\n      } else {\n        parentNode.right = null;\n      }\n    }\n  } else if (node.left && node.right) {\n    let minValueNode = node.right;\n    let minValueParent = node;\n\n    while (minValueNode.left) {\n      minValueParent = minValueNode;\n      minValueNode = minValueNode.left;\n    }\n\n    node.key = minValueNode.key;\n\n    if (minValueParent === node) {\n      minValueParent.right = minValueNode.right;\n    } else {\n      minValueParent.left = minValueNode.right;\n    }\n  } else {\n    const childNode = node.left ? node.left : node.right;\n\n    if (!parentNode) {\n      root = childNode as Node<K, V>;\n    } else {\n      if (parentNode.left === node) {\n        parentNode.left = childNode;\n      } else {\n        parentNode.right = childNode;\n      }\n    }\n  }\n\n  return root;\n}\n\nexport function removeDocument<K>(root: Node<K, string[]>, id: string, key: K): void {\n  const node = getNodeByKey(root, key)!\n\n  if (node.value.length === 1) {\n    remove(root, key)\n    return\n  }\n\n  node.value.splice(node.value.indexOf(id), 1)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}