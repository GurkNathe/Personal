{"ast":null,"code":"import { getNested } from '../utils.js';\nfunction sortingPredicate() {\n  let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'desc';\n  let a = arguments.length > 1 ? arguments[1] : undefined;\n  let b = arguments.length > 2 ? arguments[2] : undefined;\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1];\n  } else {\n    return b[1] - a[1];\n  }\n}\nexport async function getFacets(orama, results, facetsConfig) {\n  const facets = {};\n  const allIDs = results.map(_ref => {\n    let [id] = _ref;\n    return id;\n  });\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n  const facetKeys = Object.keys(facetsConfig);\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n  for (const facet of facetKeys) {\n    let values = {};\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const {\n        ranges\n      } = facetsConfig[facet];\n      const tmp = [];\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0]);\n      }\n      values = Object.fromEntries(tmp);\n    }\n    facets[facet] = {\n      count: 0,\n      values\n    };\n  }\n  const allDocsLength = allDocs.length;\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i];\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.') ? await getNested(doc, facet) : doc[facet];\n      const propertyType = properties[facet];\n      switch (propertyType) {\n        case 'number':\n          {\n            const ranges = facetsConfig[facet].ranges;\n            calculateNumberFacet(ranges, facets[facet].values, facetValue);\n            break;\n          }\n        case 'number[]':\n          {\n            const alreadyInsertedValues = new Set();\n            const ranges = facetsConfig[facet].ranges;\n            for (const v of facetValue) {\n              calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues);\n            }\n            break;\n          }\n        case 'boolean':\n        case 'string':\n          {\n            calculateBooleanOrStringFacet(facets[facet].values, facetValue, propertyType);\n            break;\n          }\n        case 'boolean[]':\n        case 'string[]':\n          {\n            const alreadyInsertedValues = new Set();\n            const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string';\n            for (const v of facetValue) {\n              calculateBooleanOrStringFacet(facets[facet].values, v, innerType, alreadyInsertedValues);\n            }\n            break;\n          }\n      }\n    }\n  }\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length;\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig;\n      facets[facet].values = Object.fromEntries(Object.entries(facets[facet].values).sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b)).slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10));\n    }\n  }\n  return facets;\n}\nfunction calculateNumberFacet(ranges, values, facetValue, alreadyInsertedValues) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`;\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue;\n    }\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1;\n      } else {\n        values[value]++;\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value);\n        }\n      }\n    }\n  }\n}\nfunction calculateBooleanOrStringFacet(values, facetValue, propertyType, alreadyInsertedValues) {\n  // String or boolean based facets\n  const value = (facetValue === null || facetValue === void 0 ? void 0 : facetValue.toString()) ?? (propertyType === 'boolean' ? 'false' : '');\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return;\n  }\n  values[value] = (values[value] ?? 0) + 1;\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value);\n  }\n}","map":{"version":3,"names":["getNested","sortingPredicate","order","arguments","length","undefined","a","b","toLowerCase","getFacets","orama","results","facetsConfig","facets","allIDs","map","_ref","id","allDocs","documentsStore","getMultiple","data","docs","facetKeys","Object","keys","properties","index","getSearchablePropertiesWithTypes","facet","values","ranges","tmp","range","push","from","to","fromEntries","count","allDocsLength","i","doc","facetValue","includes","propertyType","calculateNumberFacet","alreadyInsertedValues","Set","v","calculateBooleanOrStringFacet","innerType","stringFacetDefinition","entries","sort","slice","offset","limit","value","has","add","toString"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/components/facets.ts"],"sourcesContent":["import type {\n  FacetResult,\n  FacetSorting,\n  FacetsParams,\n  NumberFacetDefinition,\n  Orama,\n  Schema,\n  SearchableValue,\n  StringFacetDefinition,\n  TokenScore,\n} from '../types.js'\nimport { getNested } from '../utils.js'\n\nfunction sortingPredicate(order: FacetSorting = 'desc', a: [string, number], b: [string, number]) {\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1]\n  } else {\n    return b[1] - a[1]\n  }\n}\n\nexport async function getFacets<S extends Schema>(\n  orama: Orama<{ Schema: S }>,\n  results: TokenScore[],\n  facetsConfig: FacetsParams,\n): Promise<FacetResult> {\n  const facets: FacetResult = {}\n  const allIDs = results.map(([id]) => id)\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const facetKeys = Object.keys(facetsConfig!)\n\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n\n  for (const facet of facetKeys) {\n    let values = {}\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const { ranges } = facetsConfig[facet] as NumberFacetDefinition\n      const tmp = []\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0])\n      }\n      values = Object.fromEntries(tmp)\n    }\n\n    facets[facet] = {\n      count: 0,\n      values,\n    }\n  }\n\n  const allDocsLength = allDocs.length\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i]\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? (await getNested<string>(doc!, facet))!\n        : (doc![facet] as SearchableValue)\n\n      const propertyType = properties[facet]\n      switch (propertyType) {\n        case 'number': {\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          calculateNumberFacet(ranges, facets[facet].values, facetValue as number)\n          break\n        }\n        case 'number[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          for (const v of facetValue as Array<number>) {\n            calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues)\n          }\n          break\n        }\n        case 'boolean':\n        case 'string': {\n          calculateBooleanOrStringFacet(facets[facet].values, facetValue as string | boolean, propertyType)\n          break\n        }\n        case 'boolean[]':\n        case 'string[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string'\n          for (const v of facetValue as Array<string | boolean>) {\n            calculateBooleanOrStringFacet(facets[facet].values, v, innerType, alreadyInsertedValues)\n          }\n          break\n        }\n      }\n    }\n  }\n\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length\n\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig as StringFacetDefinition\n\n      facets[facet].values = Object.fromEntries(\n        Object.entries(facets[facet].values)\n          .sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b))\n          .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10),\n      )\n    }\n  }\n\n  return facets\n}\n\nfunction calculateNumberFacet(\n  ranges: NumberFacetDefinition['ranges'],\n  values: Record<string, number>,\n  facetValue: number,\n  alreadyInsertedValues?: Set<string>,\n) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue\n    }\n\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1\n      } else {\n        values[value]++\n\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value)\n        }\n      }\n    }\n  }\n}\n\nfunction calculateBooleanOrStringFacet(\n  values: Record<string, number>,\n  facetValue: string | boolean,\n  propertyType: 'string' | 'boolean',\n  alreadyInsertedValues?: Set<string>,\n) {\n  // String or boolean based facets\n  const value = facetValue?.toString() ?? (propertyType === 'boolean' ? 'false' : '')\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return\n  }\n  values[value] = (values[value] ?? 0) + 1\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}