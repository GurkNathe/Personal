{"ast":null,"code":"import { createError } from '../errors.js';\nimport { create as avlCreate, find as avlFind, greaterThan as avlGreaterThan, insert as avlInsert, lessThan as avlLessThan, rangeSearch as avlRangeSearch, removeDocument as avlRemoveDocument } from '../trees/avl.js';\nimport { create as radixCreate, find as radixFind, insert as radixInsert, removeDocumentByWord as radixRemoveDocument } from '../trees/radix.js';\nimport { intersect } from '../utils.js';\nimport { BM25 } from './algorithms.js';\nimport { getInnerType, isArrayType } from './defaults.js';\nexport async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;\n  index.fieldLengths[prop][id] = tokens.length;\n  index.frequencies[prop][id] = {};\n}\nexport async function insertTokenScoreParameters(index, prop, id, tokens, token) {\n  let tokenFrequency = 0;\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++;\n    }\n  }\n  const tf = tokenFrequency / tokens.length;\n  index.frequencies[prop][id][token] = tf;\n  if (!(token in index.tokenOccurrencies[prop])) {\n    index.tokenOccurrencies[prop][token] = 0;\n  }\n  // increase a token counter that may not yet exist\n  index.tokenOccurrencies[prop][token] = (index.tokenOccurrencies[prop][token] ?? 0) + 1;\n}\nexport async function removeDocumentScoreParameters(index, prop, id, docsCount) {\n  index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][id]) / (docsCount - 1);\n  index.fieldLengths[prop][id] = undefined;\n  index.frequencies[prop][id] = undefined;\n}\nexport async function removeTokenScoreParameters(index, prop, token) {\n  index.tokenOccurrencies[prop][token]--;\n}\nexport async function calculateResultScores(context, index, prop, term, ids) {\n  const documentIDs = Array.from(ids);\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop];\n  const fieldLengths = index.fieldLengths[prop];\n  const oramaOccurrencies = index.tokenOccurrencies[prop];\n  const oramaFrequencies = index.frequencies[prop];\n  // oramaOccurrencies[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrencies = typeof oramaOccurrencies[term] === 'number' ? oramaOccurrencies[term] ?? 0 : 0;\n  const scoreList = [];\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length;\n  for (let k = 0; k < documentIDsLength; k++) {\n    var _oramaFrequencies_id;\n    const id = documentIDs[k];\n    const tf = (oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_id = oramaFrequencies[id]) === null || _oramaFrequencies_id === void 0 ? void 0 : _oramaFrequencies_id[term]) ?? 0;\n    const bm25 = BM25(tf, termOccurrencies, context.docsCount, fieldLengths[id], avgFieldLength, context.params.relevance);\n    scoreList.push([id, bm25]);\n  }\n  return scoreList;\n}\nexport async function create(orama, schema, index) {\n  let prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n  if (!index) {\n    index = {\n      indexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrencies: {},\n      avgFieldLength: {},\n      fieldLengths: {}\n    };\n  }\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type;\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, type, index, path);\n      continue;\n    }\n    switch (type) {\n      case 'boolean':\n      case 'boolean[]':\n        index.indexes[path] = {\n          true: [],\n          false: []\n        };\n        break;\n      case 'number':\n      case 'number[]':\n        index.indexes[path] = avlCreate(0, []);\n        break;\n      case 'string':\n      case 'string[]':\n        index.indexes[path] = radixCreate();\n        index.avgFieldLength[path] = 0;\n        index.frequencies[path] = {};\n        index.tokenOccurrencies[path] = {};\n        index.fieldLengths[path] = {};\n        break;\n      default:\n        throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n    }\n    index.searchableProperties.push(path);\n    index.searchablePropertiesWithTypes[path] = type;\n  }\n  return index;\n}\nasync function insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  switch (schemaType) {\n    case 'boolean':\n      {\n        const booleanIndex = index.indexes[prop];\n        booleanIndex[value ? 'true' : 'false'].push(id);\n        break;\n      }\n    case 'number':\n      avlInsert(index.indexes[prop], value, [id]);\n      break;\n    case 'string':\n      {\n        const tokens = await tokenizer.tokenize(value, language, prop);\n        await implementation.insertDocumentScoreParameters(index, prop, id, tokens, docsCount);\n        for (const token of tokens) {\n          await implementation.insertTokenScoreParameters(index, prop, id, tokens, token);\n          radixInsert(index.indexes[prop], token, id);\n        }\n        break;\n      }\n  }\n}\nexport async function insert(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  if (!isArrayType(schemaType)) {\n    return insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n  }\n  const innerSchemaType = getInnerType(schemaType);\n  const elements = value;\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n  }\n}\nasync function removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  switch (schemaType) {\n    case 'number':\n      {\n        avlRemoveDocument(index.indexes[prop], id, value);\n        return true;\n      }\n    case 'boolean':\n      {\n        const booleanKey = value ? 'true' : 'false';\n        const position = index.indexes[prop][booleanKey].indexOf(id);\n        index.indexes[prop][value ? 'true' : 'false'].splice(position, 1);\n        return true;\n      }\n    case 'string':\n      {\n        const tokens = await tokenizer.tokenize(value, language, prop);\n        await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);\n        for (const token of tokens) {\n          await implementation.removeTokenScoreParameters(index, prop, token);\n          radixRemoveDocument(index.indexes[prop], token, id);\n        }\n        return true;\n      }\n  }\n}\nexport async function remove(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n  }\n  const innerSchemaType = getInnerType(schemaType);\n  const elements = value;\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n  }\n  return true;\n}\nexport async function search(context, index, prop, term) {\n  if (!(prop in index.tokenOccurrencies)) {\n    return [];\n  }\n  // Performa the search\n  const rootNode = index.indexes[prop];\n  const {\n    exact,\n    tolerance\n  } = context.params;\n  const searchResult = radixFind(rootNode, {\n    term,\n    exact,\n    tolerance\n  });\n  const ids = new Set();\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id);\n    }\n  }\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));\n}\nexport async function searchByWhereClause(context, index, filters) {\n  const filterKeys = Object.keys(filters);\n  const filtersMap = filterKeys.reduce((acc, key) => ({\n    [key]: [],\n    ...acc\n  }), {});\n  for (const param of filterKeys) {\n    const operation = filters[param];\n    if (typeof operation === 'boolean') {\n      const idx = index.indexes[param];\n      const filteredIDs = idx[operation.toString()];\n      filtersMap[param].push(...filteredIDs);\n      continue;\n    }\n    if (typeof operation === 'string' || Array.isArray(operation)) {\n      const idx = index.indexes[param];\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param);\n        const filteredIDsResults = radixFind(idx, {\n          term: term[0],\n          exact: true\n        });\n        filtersMap[param].push(...Object.values(filteredIDsResults).flat());\n      }\n      continue;\n    }\n    const operationKeys = Object.keys(operation);\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length);\n    }\n    const operationOpt = operationKeys[0];\n    const operationValue = operation[operationOpt];\n    const AVLNode = index.indexes[param];\n    switch (operationOpt) {\n      case 'gt':\n        {\n          const filteredIDs = avlGreaterThan(AVLNode, operationValue, false);\n          filtersMap[param].push(...filteredIDs);\n          break;\n        }\n      case 'gte':\n        {\n          const filteredIDs = avlGreaterThan(AVLNode, operationValue, true);\n          filtersMap[param].push(...filteredIDs);\n          break;\n        }\n      case 'lt':\n        {\n          const filteredIDs = avlLessThan(AVLNode, operationValue, false);\n          filtersMap[param].push(...filteredIDs);\n          break;\n        }\n      case 'lte':\n        {\n          const filteredIDs = avlLessThan(AVLNode, operationValue, true);\n          filtersMap[param].push(...filteredIDs);\n          break;\n        }\n      case 'eq':\n        {\n          const filteredIDs = avlFind(AVLNode, operationValue) ?? [];\n          filtersMap[param].push(...filteredIDs);\n          break;\n        }\n      case 'between':\n        {\n          const [min, max] = operationValue;\n          const filteredIDs = avlRangeSearch(AVLNode, min, max);\n          filtersMap[param].push(...filteredIDs);\n        }\n    }\n  }\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap));\n  return result;\n}\nexport async function getSearchableProperties(index) {\n  return index.searchableProperties;\n}\nexport async function getSearchablePropertiesWithTypes(index) {\n  return index.searchablePropertiesWithTypes;\n}\nexport async function load(raw) {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths\n  } = raw;\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths\n  };\n}\nexport async function save(index) {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths\n  } = index;\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths\n  };\n}\nexport async function createIndex() {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save\n  };\n}","map":{"version":3,"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","intersect","BM25","getInnerType","isArrayType","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrencies","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","documentIDs","Array","from","oramaOccurrencies","oramaFrequencies","termOccurrencies","scoreList","documentIDsLength","k","_oramaFrequencies_id","bm25","params","relevance","push","orama","schema","prefix","arguments","indexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","typeActualType","path","isArray","true","false","insertScalar","implementation","value","schemaType","language","tokenizer","booleanIndex","tokenize","innerSchemaType","elements","elementsLength","i","removeScalar","booleanKey","position","indexOf","splice","remove","search","rootNode","exact","tolerance","searchResult","Set","key","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","raw","flat","filteredIDsResults","values","operationKeys","operationOpt","operationValue","AVLNode","min","max","result","getSearchableProperties","getSearchablePropertiesWithTypes","load","save","createIndex"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/components/index.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  Node as AVLNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument,\n} from '../trees/avl.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument,\n} from '../trees/radix.js'\nimport {\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  IIndex,\n  OpaqueDocumentStore,\n  OpaqueIndex,\n  Orama,\n  ScalarSearchableType,\n  Schema,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  Tokenizer,\n  TokenScore,\n} from '../types.js'\nimport { intersect } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getInnerType, isArrayType } from './defaults.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: string]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: string[]\n  false: string[]\n}\n\nexport interface Index extends OpaqueIndex {\n  indexes: Record<string, RadixNode | AVLNode<number, string[]> | BooleanIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrencies: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<string, number | undefined>>\n}\n\nexport type DefaultIndex = IIndex<Index>\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: string,\n  tokens: string[],\n  docsCount: number,\n): Promise<void> {\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][id] = tokens.length\n  index.frequencies[prop][id] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: string,\n  tokens: string[],\n  token: string,\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][id]![token] = tf\n\n  if (!(token in index.tokenOccurrencies[prop])) {\n    index.tokenOccurrencies[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrencies[prop][token] = (index.tokenOccurrencies[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: string,\n  docsCount: number,\n): Promise<void> {\n  index.avgFieldLength[prop] =\n    (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][id]!) / (docsCount - 1)\n  index.fieldLengths[prop][id] = undefined\n  index.frequencies[prop][id] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrencies[prop][token]--\n}\n\nexport async function calculateResultScores<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: string[],\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrencies = index.tokenOccurrencies[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrencies[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrencies = typeof oramaOccurrencies[term] === 'number' ? oramaOccurrencies[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const id = documentIDs[k]\n    const tf = oramaFrequencies?.[id]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrencies,\n      context.docsCount,\n      fieldLengths[id]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>,\n    )\n\n    scoreList.push([id, bm25])\n  }\n  return scoreList\n}\n\nexport async function create(\n  orama: Orama<{ Index: DefaultIndex }>,\n  schema: Schema,\n  index?: Index,\n  prefix = '',\n): Promise<Index> {\n  if (!index) {\n    index = {\n      indexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrencies: {},\n      avgFieldLength: {},\n      fieldLengths: {},\n    }\n  }\n\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, type as Schema, index, path)\n      continue\n    }\n\n    switch (type) {\n      case 'boolean':\n      case 'boolean[]':\n        index.indexes[path] = { true: [], false: [] }\n        break\n      case 'number':\n      case 'number[]':\n        index.indexes[path] = avlCreate<number, string[]>(0, [])\n        break\n      case 'string':\n      case 'string[]':\n        index.indexes[path] = radixCreate()\n        index.avgFieldLength[path] = 0\n        index.frequencies[path] = {}\n        index.tokenOccurrencies[path] = {}\n        index.fieldLengths[path] = {}\n        break\n      default:\n        throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : (type as unknown as string), path)\n    }\n\n    index.searchableProperties.push(path)\n    index.searchablePropertiesWithTypes[path] = type\n  }\n\n  return index\n}\n\nasync function insertScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  switch (schemaType) {\n    case 'boolean': {\n      const booleanIndex = index.indexes[prop] as BooleanIndex\n      booleanIndex[value ? 'true' : 'false'].push(id)\n      break\n    }\n    case 'number':\n      avlInsert(index.indexes[prop] as AVLNode<number, string[]>, value as number, [id])\n      break\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n      await implementation.insertDocumentScoreParameters(index, prop, id, tokens, docsCount)\n\n      for (const token of tokens) {\n        await implementation.insertTokenScoreParameters(index, prop, id, tokens, token)\n\n        radixInsert(index.indexes[prop] as RadixNode, token, id)\n      }\n\n      break\n    }\n  }\n}\n\nexport async function insert(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  if (!isArrayType(schemaType)) {\n    return insertScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  switch (schemaType) {\n    case 'number': {\n      avlRemoveDocument(index.indexes[prop] as AVLNode<number, string[]>, id, value)\n      return true\n    }\n    case 'boolean': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = (index.indexes[prop] as BooleanIndex)[booleanKey].indexOf(id)\n\n      ;(index.indexes[prop] as BooleanIndex)[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(index.indexes[prop] as RadixNode, token, id)\n      }\n\n      return true\n    }\n  }\n}\n\nexport async function remove(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<Index, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrencies)) {\n    return []\n  }\n\n  // Performa the search\n  const rootNode = index.indexes[prop] as RadixNode\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(rootNode, { term, exact, tolerance })\n  const ids = new Set<string>()\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  filters: Record<string, boolean | ComparisonOperator>,\n): Promise<string[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, string[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc,\n    }),\n    {},\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]\n\n    if (typeof operation === 'boolean') {\n      const idx = index.indexes[param] as BooleanIndex\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      filtersMap[param].push(...filteredIDs)\n      continue\n    }\n\n    if (typeof operation === 'string' || Array.isArray(operation)) {\n      const idx = index.indexes[param] as RadixNode\n\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        const filteredIDsResults = radixFind(idx, { term: term[0], exact: true })\n        filtersMap[param].push(...Object.values(filteredIDsResults).flat())\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    const operationOpt = operationKeys[0] as keyof ComparisonOperator\n    const operationValue = operation[operationOpt]\n\n    const AVLNode = index.indexes[param] as AVLNode<number, string[]>\n\n    switch (operationOpt) {\n      case 'gt': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'gte': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lt': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lte': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'eq': {\n        const filteredIDs = avlFind(AVLNode, operationValue) ?? []\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'between': {\n        const [min, max] = operationValue as number[]\n        const filteredIDs = avlRangeSearch(AVLNode, min, max)\n        filtersMap[param].push(...filteredIDs)\n      }\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap)) as unknown as string[]\n\n  return result\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nexport async function load<R = unknown>(raw: R): Promise<Index> {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  } = raw as Index\n\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  } = index\n\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  } as R\n}\n\nexport async function createIndex(): Promise<DefaultIndex> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}