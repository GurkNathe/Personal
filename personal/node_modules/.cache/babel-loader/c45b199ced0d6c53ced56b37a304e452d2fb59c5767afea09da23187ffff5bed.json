{"ast":null,"code":"import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    this.addEventListener(\"mousedown\", onEvent);\n    this.addEventListener(\"mousemove\", onEvent);\n    this.addEventListener(\"mouseup\", onEvent);\n    this.addEventListener(\"click\", onEvent);\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n  }\n}\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    if (\"colorSpace\" in this) this.colorSpace = \"srgb\";else this.encoding = 3001;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter;\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n}\nconst canvases = /* @__PURE__ */new WeakMap();\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n  function Clipper(context2) {\n    const clips = [];\n    let isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n        minY = -Infinity;\n      let maxX = Infinity,\n        maxY = Infinity;\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + \"Width\"];\n    const borderStyle = style[which + \"Style\"];\n    const borderColor = style[which + \"Color\"];\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element2, style) {\n    let x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\") return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\") return;\n      const rect = element2.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n      const borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      let match = true;\n      let prevBorder = null;\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        const width2 = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n      if (element2 instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\") accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element2.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"âœ”\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element2.type === \"range\") {\n          const [min, max, value] = [\"min\", \"max\", \"value\"].map(property => parseFloat(element2[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({\n            x,\n            y,\n            width,\n            height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n    const isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping) clipper.add({\n      x,\n      y,\n      width,\n      height\n    });\n    for (let i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  const context = canvas.getContext(\"2d\"\n  /*, { alpha: false }*/);\n\n  const clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      const rect2 = element2.getBoundingClientRect();\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          const [min, max] = [\"min\", \"max\"].map(property => parseFloat(element2[property]));\n          const width = rect2.width;\n          const offsetX = x - rect2.x;\n          const proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", {\n            bubbles: true\n          }));\n        }\n      }\n      for (let i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":{"version":3,"names":["Mesh","PlaneGeometry","MeshBasicMaterial","CanvasTexture","LinearFilter","Color","HTMLMesh","constructor","dom","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","html2canvas","anisotropy","colorSpace","encoding","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","WeakMap","element","range","document","createRange","color","Clipper","context2","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","context","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","element2","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","border","width2","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","set","luminance","sqrt","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","value","property","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","rect2","right","bottom","offsetX","proportion","InputEvent","bubbles"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/interactive/HTMLMesh.js"],"sourcesContent":["import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    const material = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true });\n    super(geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    this.addEventListener(\"mousedown\", onEvent);\n    this.addEventListener(\"mousemove\", onEvent);\n    this.addEventListener(\"mouseup\", onEvent);\n    this.addEventListener(\"click\", onEvent);\n    this.dispose = function() {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n  }\n}\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    if (\"colorSpace\" in this)\n      this.colorSpace = \"srgb\";\n    else\n      this.encoding = 3001;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter;\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = { attributes: true, childList: true, subtree: true, characterData: true };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n}\nconst canvases = /* @__PURE__ */ new WeakMap();\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n  function Clipper(context2) {\n    const clips = [];\n    let isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n      if (clips.length === 0)\n        return;\n      let minX = -Infinity, minY = -Infinity;\n      let maxX = Infinity, maxY = Infinity;\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n    return {\n      add: function(clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function() {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r)\n      r = w / 2;\n    if (h < 2 * r)\n      r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + \"Width\"];\n    const borderStyle = style[which + \"Style\"];\n    const borderColor = style[which + \"Color\"];\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element2, style) {\n    let x = 0, y = 0, width = 0, height = 0;\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\")\n        return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\")\n        return;\n      const rect = element2.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n      const borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      let match = true;\n      let prevBorder = null;\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n        if (match === false)\n          break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        const width2 = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n      if (element2 instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\")\n          accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element2.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"âœ”\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element2.type === \"range\") {\n          const [min, max, value] = [\"min\", \"max\", \"value\"].map((property) => parseFloat(element2[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({ x, y, width, height });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n    const isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping)\n      clipper.add({ x, y, width, height });\n    for (let i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n    if (isClipping)\n      clipper.remove();\n  }\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  const context = canvas.getContext(\n    \"2d\"\n    /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      const rect2 = element2.getBoundingClientRect();\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          const [min, max] = [\"min\", \"max\"].map((property) => parseFloat(element2[property]));\n          const width = rect2.width;\n          const offsetX = x - rect2.x;\n          const proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", { bubbles: true }));\n        }\n      }\n      for (let i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport {\n  HTMLMesh\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}