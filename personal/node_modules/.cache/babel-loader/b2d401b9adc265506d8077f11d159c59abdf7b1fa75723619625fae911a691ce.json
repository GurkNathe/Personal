{"ast":null,"code":"import { Vector2 } from \"three\";\nvar FreiChenShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    aspect: {\n      value: /* @__PURE__ */new Vector2(512, 512)\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform vec2 aspect;\", \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\", \"mat3 G[9];\",\n  // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n  \"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\", \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\", \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\", \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\", \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\", \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\", \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\", \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\", \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\", \"void main(void)\", \"{\", \"\tG[0] = g0,\", \"\tG[1] = g1,\", \"\tG[2] = g2,\", \"\tG[3] = g3,\", \"\tG[4] = g4,\", \"\tG[5] = g5,\", \"\tG[6] = g6,\", \"\tG[7] = g7,\", \"\tG[8] = g8;\", \"\tmat3 I;\", \"\tfloat cnv[9];\", \"\tvec3 sample;\", /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n  \"\tfor (float i=0.0; i<3.0; i++) {\", \"\t\tfor (float j=0.0; j<3.0; j++) {\", \"\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\", \"\t\t\tI[int(i)][int(j)] = length(sample);\", \"\t\t}\", \"\t}\", /* calculate the convolution values for all the masks */\n  \"\tfor (int i=0; i<9; i++) {\", \"\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\", \"\t\tcnv[i] = dp3 * dp3;\", \"\t}\", \"\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\", \"\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\", \"\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\", \"}\"].join(\"\\n\")\n};\nexport { FreiChenShader };","map":{"version":3,"names":["Vector2","FreiChenShader","uniforms","tDiffuse","value","aspect","vertexShader","join","fragmentShader"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/shaders/FreiChenShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst FreiChenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    aspect: { value: /* @__PURE__ */ new Vector2(512, 512) }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDiffuse;\",\n    \"varying vec2 vUv;\",\n    \"uniform vec2 aspect;\",\n    \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n    \"mat3 G[9];\",\n    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n    \"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\n    \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\n    \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\n    \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\n    \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\n    \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\n    \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\n    \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\n    \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\n    \"void main(void)\",\n    \"{\",\n    \"\tG[0] = g0,\",\n    \"\tG[1] = g1,\",\n    \"\tG[2] = g2,\",\n    \"\tG[3] = g3,\",\n    \"\tG[4] = g4,\",\n    \"\tG[5] = g5,\",\n    \"\tG[6] = g6,\",\n    \"\tG[7] = g7,\",\n    \"\tG[8] = g8;\",\n    \"\tmat3 I;\",\n    \"\tfloat cnv[9];\",\n    \"\tvec3 sample;\",\n    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n    \"\tfor (float i=0.0; i<3.0; i++) {\",\n    \"\t\tfor (float j=0.0; j<3.0; j++) {\",\n    \"\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n    \"\t\t\tI[int(i)][int(j)] = length(sample);\",\n    \"\t\t}\",\n    \"\t}\",\n    /* calculate the convolution values for all the masks */\n    \"\tfor (int i=0; i<9; i++) {\",\n    \"\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n    \"\t\tcnv[i] = dp3 * dp3;\",\n    \"\t}\",\n    \"\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\n    \"\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\n    \"\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  FreiChenShader\n};\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;AAC/B,IAAMC,cAAc,GAAG;EACrBC,QAAQ,EAAE;IACRC,QAAQ,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IACzBC,MAAM,EAAE;MAAED,KAAK,EAAE,eAAgB,IAAIJ,OAAO,CAAC,GAAG,EAAE,GAAG;IAAE;EACzD,CAAC;EACDM,YAAY,EAAE,CACZ,mBAAmB,EACnB,eAAe,EACf,YAAY,EACZ,4EAA4E,EAC5E,GAAG,CACJ,CAACC,IAAI,CAAC,IAAI,CAAC;EACZC,cAAc,EAAE,CACd,6BAA6B,EAC7B,mBAAmB,EACnB,sBAAsB,EACtB,oDAAoD,EACpD,YAAY;EACZ;EACA,+HAA+H,EAC/H,+HAA+H,EAC/H,+HAA+H,EAC/H,+HAA+H,EAC/H,8DAA8D,EAC9D,8DAA8D,EAC9D,iNAAiN,EACjN,iNAAiN,EACjN,6MAA6M,EAC7M,iBAAiB,EACjB,GAAG,EACH,aAAa,EACb,aAAa,EACb,aAAa,EACb,aAAa,EACb,aAAa,EACb,aAAa,EACb,aAAa,EACb,aAAa,EACb,aAAa,EACb,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf;EACA,kCAAkC,EAClC,mCAAmC,EACnC,wEAAwE,EACxE,wCAAwC,EACxC,KAAK,EACL,IAAI,EACJ;EACA,4BAA4B,EAC5B,6EAA6E,EAC7E,uBAAuB,EACvB,IAAI,EACJ,mDAAmD,EACnD,kEAAkE,EAClE,6CAA6C,EAC7C,GAAG,CACJ,CAACD,IAAI,CAAC,IAAI;AACb,CAAC;AACD,SACEN,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}