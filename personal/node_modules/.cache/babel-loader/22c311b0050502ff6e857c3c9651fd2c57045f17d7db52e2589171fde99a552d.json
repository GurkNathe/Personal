{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTextureLoader, HalfFloatType, DataUtils, FloatType, RGBAFormat, RedFormat, LinearFilter } from \"three\";\nimport { unzlibSync } from \"fflate\";\nvar EXRLoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(EXRLoader, _DataTextureLoader);\n  var _super = _createSuper(EXRLoader);\n  function EXRLoader(manager) {\n    var _this;\n    _classCallCheck(this, EXRLoader);\n    _this = _super.call(this, manager);\n    _this.type = HalfFloatType;\n    return _this;\n  }\n  _createClass(EXRLoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var USHORT_RANGE = 1 << 16;\n      var BITMAP_SIZE = USHORT_RANGE >> 3;\n      var HUF_ENCBITS = 16;\n      var HUF_DECBITS = 14;\n      var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n      var HUF_DECSIZE = 1 << HUF_DECBITS;\n      var HUF_DECMASK = HUF_DECSIZE - 1;\n      var NBITS = 16;\n      var A_OFFSET = 1 << NBITS - 1;\n      var MOD_MASK = (1 << NBITS) - 1;\n      var SHORT_ZEROCODE_RUN = 59;\n      var LONG_ZEROCODE_RUN = 63;\n      var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n      var ULONG_SIZE = 8;\n      var FLOAT32_SIZE = 4;\n      var INT32_SIZE = 4;\n      var INT16_SIZE = 2;\n      var INT8_SIZE = 1;\n      var STATIC_HUFFMAN = 0;\n      var DEFLATE = 1;\n      var UNKNOWN = 0;\n      var LOSSY_DCT = 1;\n      var RLE = 2;\n      var logBase = Math.pow(2.7182818, 2.2);\n      function reverseLutFromBitmap(bitmap, lut) {\n        var k = 0;\n        for (var i = 0; i < USHORT_RANGE; ++i) {\n          if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n            lut[k++] = i;\n          }\n        }\n        var n = k - 1;\n        while (k < USHORT_RANGE) lut[k++] = 0;\n        return n;\n      }\n      function hufClearDecTable(hdec) {\n        for (var i = 0; i < HUF_DECSIZE; i++) {\n          hdec[i] = {};\n          hdec[i].len = 0;\n          hdec[i].lit = 0;\n          hdec[i].p = null;\n        }\n      }\n      var getBitsReturn = {\n        l: 0,\n        c: 0,\n        lc: 0\n      };\n      function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n        while (lc < nBits) {\n          c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n          lc += 8;\n        }\n        lc -= nBits;\n        getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n        getBitsReturn.c = c;\n        getBitsReturn.lc = lc;\n      }\n      var hufTableBuffer = new Array(59);\n      function hufCanonicalCodeTable(hcode) {\n        for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n        for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n        var c = 0;\n        for (var i = 58; i > 0; --i) {\n          var nc = c + hufTableBuffer[i] >> 1;\n          hufTableBuffer[i] = c;\n          c = nc;\n        }\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          var l = hcode[i];\n          if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n        }\n      }\n      function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n        var p = inOffset;\n        var c = 0;\n        var lc = 0;\n        for (; im <= iM; im++) {\n          if (p.value - inOffset.value > ni) return false;\n          getBits(6, c, lc, uInt8Array2, p);\n          var l = getBitsReturn.l;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          hcode[im] = l;\n          if (l == LONG_ZEROCODE_RUN) {\n            if (p.value - inOffset.value > ni) {\n              throw \"Something wrong with hufUnpackEncTable\";\n            }\n            getBits(8, c, lc, uInt8Array2, p);\n            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n            c = getBitsReturn.c;\n            lc = getBitsReturn.lc;\n            if (im + zerun > iM + 1) {\n              throw \"Something wrong with hufUnpackEncTable\";\n            }\n            while (zerun--) hcode[im++] = 0;\n            im--;\n          } else if (l >= SHORT_ZEROCODE_RUN) {\n            var zerun = l - SHORT_ZEROCODE_RUN + 2;\n            if (im + zerun > iM + 1) {\n              throw \"Something wrong with hufUnpackEncTable\";\n            }\n            while (zerun--) hcode[im++] = 0;\n            im--;\n          }\n        }\n        hufCanonicalCodeTable(hcode);\n      }\n      function hufLength(code) {\n        return code & 63;\n      }\n      function hufCode(code) {\n        return code >> 6;\n      }\n      function hufBuildDecTable(hcode, im, iM, hdecod) {\n        for (; im <= iM; im++) {\n          var c = hufCode(hcode[im]);\n          var l = hufLength(hcode[im]);\n          if (c >> l) {\n            throw \"Invalid table entry\";\n          }\n          if (l > HUF_DECBITS) {\n            var pl = hdecod[c >> l - HUF_DECBITS];\n            if (pl.len) {\n              throw \"Invalid table entry\";\n            }\n            pl.lit++;\n            if (pl.p) {\n              var p = pl.p;\n              pl.p = new Array(pl.lit);\n              for (var i = 0; i < pl.lit - 1; ++i) {\n                pl.p[i] = p[i];\n              }\n            } else {\n              pl.p = new Array(1);\n            }\n            pl.p[pl.lit - 1] = im;\n          } else if (l) {\n            var plOffset = 0;\n            for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n              var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n              if (pl.len || pl.p) {\n                throw \"Invalid table entry\";\n              }\n              pl.len = l;\n              pl.lit = im;\n              plOffset++;\n            }\n          }\n        }\n        return true;\n      }\n      var getCharReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getChar(c, lc, uInt8Array2, inOffset) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n        getCharReturn.c = c;\n        getCharReturn.lc = lc;\n      }\n      var getCodeReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n        if (po == rlc) {\n          if (lc < 8) {\n            getChar(c, lc, uInt8Array2, inOffset);\n            c = getCharReturn.c;\n            lc = getCharReturn.lc;\n          }\n          lc -= 8;\n          var cs = c >> lc;\n          var cs = new Uint8Array([cs])[0];\n          if (outBufferOffset.value + cs > outBufferEndOffset) {\n            return false;\n          }\n          var s = outBuffer[outBufferOffset.value - 1];\n          while (cs-- > 0) {\n            outBuffer[outBufferOffset.value++] = s;\n          }\n        } else if (outBufferOffset.value < outBufferEndOffset) {\n          outBuffer[outBufferOffset.value++] = po;\n        } else {\n          return false;\n        }\n        getCodeReturn.c = c;\n        getCodeReturn.lc = lc;\n      }\n      function UInt16(value) {\n        return value & 65535;\n      }\n      function Int16(value) {\n        var ref = UInt16(value);\n        return ref > 32767 ? ref - 65536 : ref;\n      }\n      var wdec14Return = {\n        a: 0,\n        b: 0\n      };\n      function wdec14(l, h) {\n        var ls = Int16(l);\n        var hs = Int16(h);\n        var hi = hs;\n        var ai = ls + (hi & 1) + (hi >> 1);\n        var as = ai;\n        var bs = ai - hi;\n        wdec14Return.a = as;\n        wdec14Return.b = bs;\n      }\n      function wdec16(l, h) {\n        var m = UInt16(l);\n        var d = UInt16(h);\n        var bb = m - (d >> 1) & MOD_MASK;\n        var aa = d + bb - A_OFFSET & MOD_MASK;\n        wdec14Return.a = aa;\n        wdec14Return.b = bb;\n      }\n      function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n        var w14 = mx < 1 << 14;\n        var n = nx > ny ? ny : nx;\n        var p = 1;\n        var p2;\n        while (p <= n) p <<= 1;\n        p >>= 1;\n        p2 = p;\n        p >>= 1;\n        while (p >= 1) {\n          var py = 0;\n          var ey = py + oy * (ny - p2);\n          var oy1 = oy * p;\n          var oy2 = oy * p2;\n          var ox1 = ox * p;\n          var ox2 = ox * p2;\n          var i00, i01, i10, i11;\n          for (; py <= ey; py += oy2) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              var p10 = px + oy1;\n              var p11 = p10 + ox1;\n              if (w14) {\n                wdec14(buffer2[px + j], buffer2[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec14(i00, i01);\n                buffer2[px + j] = wdec14Return.a;\n                buffer2[p01 + j] = wdec14Return.b;\n                wdec14(i10, i11);\n                buffer2[p10 + j] = wdec14Return.a;\n                buffer2[p11 + j] = wdec14Return.b;\n              } else {\n                wdec16(buffer2[px + j], buffer2[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec16(i00, i01);\n                buffer2[px + j] = wdec14Return.a;\n                buffer2[p01 + j] = wdec14Return.b;\n                wdec16(i10, i11);\n                buffer2[p10 + j] = wdec14Return.a;\n                buffer2[p11 + j] = wdec14Return.b;\n              }\n            }\n            if (nx & p) {\n              var p10 = px + oy1;\n              if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);else wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              buffer2[p10 + j] = wdec14Return.b;\n              buffer2[px + j] = i00;\n            }\n          }\n          if (ny & p) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);else wdec16(buffer2[px + j], buffer2[p01 + j]);\n              i00 = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              buffer2[px + j] = i00;\n            }\n          }\n          p2 = p;\n          p >>= 1;\n        }\n        return py;\n      }\n      function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n        var c = 0;\n        var lc = 0;\n        var outBufferEndOffset = no;\n        var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n        while (inOffset.value < inOffsetEnd) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n          while (lc >= HUF_DECBITS) {\n            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n            var pl = decodingTable[index];\n            if (pl.len) {\n              lc -= pl.len;\n              getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n              c = getCodeReturn.c;\n              lc = getCodeReturn.lc;\n            } else {\n              if (!pl.p) {\n                throw \"hufDecode issues\";\n              }\n              var j;\n              for (j = 0; j < pl.lit; j++) {\n                var l = hufLength(encodingTable[pl.p[j]]);\n                while (lc < l && inOffset.value < inOffsetEnd) {\n                  getChar(c, lc, uInt8Array2, inOffset);\n                  c = getCharReturn.c;\n                  lc = getCharReturn.lc;\n                }\n                if (lc >= l) {\n                  if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                    lc -= l;\n                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                    break;\n                  }\n                }\n              }\n              if (j == pl.lit) {\n                throw \"hufDecode issues\";\n              }\n            }\n          }\n        }\n        var i = 8 - ni & 7;\n        c >>= i;\n        lc -= i;\n        while (lc > 0) {\n          var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            throw \"hufDecode issues\";\n          }\n        }\n        return true;\n      }\n      function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n        var outOffset = {\n          value: 0\n        };\n        var initialInOffset = inOffset.value;\n        var im = parseUint32(inDataView, inOffset);\n        var iM = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        var nBits = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n          throw \"Something wrong with HUF_ENCSIZE\";\n        }\n        var freq = new Array(HUF_ENCSIZE);\n        var hdec = new Array(HUF_DECSIZE);\n        hufClearDecTable(hdec);\n        var ni = nCompressed - (inOffset.value - initialInOffset);\n        hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n        if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n          throw \"Something wrong with hufUncompress\";\n        }\n        hufBuildDecTable(freq, im, iM, hdec);\n        hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n      }\n      function applyLut(lut, data, nData) {\n        for (var i = 0; i < nData; ++i) {\n          data[i] = lut[data[i]];\n        }\n      }\n      function predictor(source) {\n        for (var t = 1; t < source.length; t++) {\n          var d = source[t - 1] + source[t] - 128;\n          source[t] = d;\n        }\n      }\n      function interleaveScalar(source, out) {\n        var t1 = 0;\n        var t2 = Math.floor((source.length + 1) / 2);\n        var s = 0;\n        var stop = source.length - 1;\n        while (true) {\n          if (s > stop) break;\n          out[s++] = source[t1++];\n          if (s > stop) break;\n          out[s++] = source[t2++];\n        }\n      }\n      function decodeRunLength(source) {\n        var size = source.byteLength;\n        var out = new Array();\n        var p = 0;\n        var reader = new DataView(source);\n        while (size > 0) {\n          var l = reader.getInt8(p++);\n          if (l < 0) {\n            var count = -l;\n            size -= count + 1;\n            for (var i = 0; i < count; i++) {\n              out.push(reader.getUint8(p++));\n            }\n          } else {\n            var count = l;\n            size -= 2;\n            var value = reader.getUint8(p++);\n            for (var i = 0; i < count + 1; i++) {\n              out.push(value);\n            }\n          }\n        }\n        return out;\n      }\n      function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n        var dataView = new DataView(outBuffer.buffer);\n        var width = channelData[cscSet.idx[0]].width;\n        var height = channelData[cscSet.idx[0]].height;\n        var numComp = 3;\n        var numFullBlocksX = Math.floor(width / 8);\n        var numBlocksX = Math.ceil(width / 8);\n        var numBlocksY = Math.ceil(height / 8);\n        var leftoverX = width - (numBlocksX - 1) * 8;\n        var leftoverY = height - (numBlocksY - 1) * 8;\n        var currAcComp = {\n          value: 0\n        };\n        var currDcComp = new Array(numComp);\n        var dctData = new Array(numComp);\n        var halfZigBlock = new Array(numComp);\n        var rowBlock = new Array(numComp);\n        var rowOffsets = new Array(numComp);\n        for (var comp2 = 0; comp2 < numComp; ++comp2) {\n          rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n          currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n          dctData[comp2] = new Float32Array(64);\n          halfZigBlock[comp2] = new Uint16Array(64);\n          rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n        }\n        for (var blocky = 0; blocky < numBlocksY; ++blocky) {\n          var maxY = 8;\n          if (blocky == numBlocksY - 1) maxY = leftoverY;\n          var maxX = 8;\n          for (var blockx = 0; blockx < numBlocksX; ++blockx) {\n            if (blockx == numBlocksX - 1) maxX = leftoverX;\n            for (var _comp = 0; _comp < numComp; ++_comp) {\n              halfZigBlock[_comp].fill(0);\n              halfZigBlock[_comp][0] = dcBuffer[currDcComp[_comp]++];\n              unRleAC(currAcComp, acBuffer, halfZigBlock[_comp]);\n              unZigZag(halfZigBlock[_comp], dctData[_comp]);\n              dctInverse(dctData[_comp]);\n            }\n            if (numComp == 3) {\n              csc709Inverse(dctData);\n            }\n            for (var _comp2 = 0; _comp2 < numComp; ++_comp2) {\n              convertToHalf(dctData[_comp2], rowBlock[_comp2], blockx * 64);\n            }\n          }\n          var offset2 = 0;\n          for (var _comp3 = 0; _comp3 < numComp; ++_comp3) {\n            var type2 = channelData[cscSet.idx[_comp3]].type;\n            for (var y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              offset2 = rowOffsets[_comp3][y2];\n              for (var _blockx = 0; _blockx < numFullBlocksX; ++_blockx) {\n                var src = _blockx * 64 + (y2 & 7) * 8;\n                dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[_comp3][src + 0], true);\n                dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[_comp3][src + 1], true);\n                dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[_comp3][src + 2], true);\n                dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[_comp3][src + 3], true);\n                dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[_comp3][src + 4], true);\n                dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[_comp3][src + 5], true);\n                dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[_comp3][src + 6], true);\n                dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[_comp3][src + 7], true);\n                offset2 += 8 * INT16_SIZE * type2;\n              }\n            }\n            if (numFullBlocksX != numBlocksX) {\n              for (var _y = 8 * blocky; _y < 8 * blocky + maxY; ++_y) {\n                var offset3 = rowOffsets[_comp3][_y] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                var _src = numFullBlocksX * 64 + (_y & 7) * 8;\n                for (var x2 = 0; x2 < maxX; ++x2) {\n                  dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[_comp3][_src + x2], true);\n                }\n              }\n            }\n          }\n        }\n        var halfRow = new Uint16Array(width);\n        var dataView = new DataView(outBuffer.buffer);\n        for (var comp = 0; comp < numComp; ++comp) {\n          channelData[cscSet.idx[comp]].decoded = true;\n          var type = channelData[cscSet.idx[comp]].type;\n          if (channelData[comp].type != 2) continue;\n          for (var y = 0; y < height; ++y) {\n            var _offset = rowOffsets[comp][y];\n            for (var x = 0; x < width; ++x) {\n              halfRow[x] = dataView.getUint16(_offset + x * INT16_SIZE * type, true);\n            }\n            for (var x = 0; x < width; ++x) {\n              dataView.setFloat32(_offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n            }\n          }\n        }\n      }\n      function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n        var acValue;\n        var dctComp = 1;\n        while (dctComp < 64) {\n          acValue = acBuffer[currAcComp.value];\n          if (acValue == 65280) {\n            dctComp = 64;\n          } else if (acValue >> 8 == 255) {\n            dctComp += acValue & 255;\n          } else {\n            halfZigBlock[dctComp] = acValue;\n            dctComp++;\n          }\n          currAcComp.value++;\n        }\n      }\n      function unZigZag(src, dst) {\n        dst[0] = decodeFloat16(src[0]);\n        dst[1] = decodeFloat16(src[1]);\n        dst[2] = decodeFloat16(src[5]);\n        dst[3] = decodeFloat16(src[6]);\n        dst[4] = decodeFloat16(src[14]);\n        dst[5] = decodeFloat16(src[15]);\n        dst[6] = decodeFloat16(src[27]);\n        dst[7] = decodeFloat16(src[28]);\n        dst[8] = decodeFloat16(src[2]);\n        dst[9] = decodeFloat16(src[4]);\n        dst[10] = decodeFloat16(src[7]);\n        dst[11] = decodeFloat16(src[13]);\n        dst[12] = decodeFloat16(src[16]);\n        dst[13] = decodeFloat16(src[26]);\n        dst[14] = decodeFloat16(src[29]);\n        dst[15] = decodeFloat16(src[42]);\n        dst[16] = decodeFloat16(src[3]);\n        dst[17] = decodeFloat16(src[8]);\n        dst[18] = decodeFloat16(src[12]);\n        dst[19] = decodeFloat16(src[17]);\n        dst[20] = decodeFloat16(src[25]);\n        dst[21] = decodeFloat16(src[30]);\n        dst[22] = decodeFloat16(src[41]);\n        dst[23] = decodeFloat16(src[43]);\n        dst[24] = decodeFloat16(src[9]);\n        dst[25] = decodeFloat16(src[11]);\n        dst[26] = decodeFloat16(src[18]);\n        dst[27] = decodeFloat16(src[24]);\n        dst[28] = decodeFloat16(src[31]);\n        dst[29] = decodeFloat16(src[40]);\n        dst[30] = decodeFloat16(src[44]);\n        dst[31] = decodeFloat16(src[53]);\n        dst[32] = decodeFloat16(src[10]);\n        dst[33] = decodeFloat16(src[19]);\n        dst[34] = decodeFloat16(src[23]);\n        dst[35] = decodeFloat16(src[32]);\n        dst[36] = decodeFloat16(src[39]);\n        dst[37] = decodeFloat16(src[45]);\n        dst[38] = decodeFloat16(src[52]);\n        dst[39] = decodeFloat16(src[54]);\n        dst[40] = decodeFloat16(src[20]);\n        dst[41] = decodeFloat16(src[22]);\n        dst[42] = decodeFloat16(src[33]);\n        dst[43] = decodeFloat16(src[38]);\n        dst[44] = decodeFloat16(src[46]);\n        dst[45] = decodeFloat16(src[51]);\n        dst[46] = decodeFloat16(src[55]);\n        dst[47] = decodeFloat16(src[60]);\n        dst[48] = decodeFloat16(src[21]);\n        dst[49] = decodeFloat16(src[34]);\n        dst[50] = decodeFloat16(src[37]);\n        dst[51] = decodeFloat16(src[47]);\n        dst[52] = decodeFloat16(src[50]);\n        dst[53] = decodeFloat16(src[56]);\n        dst[54] = decodeFloat16(src[59]);\n        dst[55] = decodeFloat16(src[61]);\n        dst[56] = decodeFloat16(src[35]);\n        dst[57] = decodeFloat16(src[36]);\n        dst[58] = decodeFloat16(src[48]);\n        dst[59] = decodeFloat16(src[49]);\n        dst[60] = decodeFloat16(src[57]);\n        dst[61] = decodeFloat16(src[58]);\n        dst[62] = decodeFloat16(src[62]);\n        dst[63] = decodeFloat16(src[63]);\n      }\n      function dctInverse(data) {\n        var a = 0.5 * Math.cos(3.14159 / 4);\n        var b = 0.5 * Math.cos(3.14159 / 16);\n        var c = 0.5 * Math.cos(3.14159 / 8);\n        var d = 0.5 * Math.cos(3 * 3.14159 / 16);\n        var e = 0.5 * Math.cos(5 * 3.14159 / 16);\n        var f = 0.5 * Math.cos(3 * 3.14159 / 8);\n        var g = 0.5 * Math.cos(7 * 3.14159 / 16);\n        var alpha = new Array(4);\n        var beta = new Array(4);\n        var theta = new Array(4);\n        var gamma = new Array(4);\n        for (var row = 0; row < 8; ++row) {\n          var rowPtr = row * 8;\n          alpha[0] = c * data[rowPtr + 2];\n          alpha[1] = f * data[rowPtr + 2];\n          alpha[2] = c * data[rowPtr + 6];\n          alpha[3] = f * data[rowPtr + 6];\n          beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n          beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n          beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n          beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n          theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n          theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[rowPtr + 0] = gamma[0] + beta[0];\n          data[rowPtr + 1] = gamma[1] + beta[1];\n          data[rowPtr + 2] = gamma[2] + beta[2];\n          data[rowPtr + 3] = gamma[3] + beta[3];\n          data[rowPtr + 4] = gamma[3] - beta[3];\n          data[rowPtr + 5] = gamma[2] - beta[2];\n          data[rowPtr + 6] = gamma[1] - beta[1];\n          data[rowPtr + 7] = gamma[0] - beta[0];\n        }\n        for (var column = 0; column < 8; ++column) {\n          alpha[0] = c * data[16 + column];\n          alpha[1] = f * data[16 + column];\n          alpha[2] = c * data[48 + column];\n          alpha[3] = f * data[48 + column];\n          beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n          beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n          beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n          beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n          theta[0] = a * (data[column] + data[32 + column]);\n          theta[3] = a * (data[column] - data[32 + column]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[0 + column] = gamma[0] + beta[0];\n          data[8 + column] = gamma[1] + beta[1];\n          data[16 + column] = gamma[2] + beta[2];\n          data[24 + column] = gamma[3] + beta[3];\n          data[32 + column] = gamma[3] - beta[3];\n          data[40 + column] = gamma[2] - beta[2];\n          data[48 + column] = gamma[1] - beta[1];\n          data[56 + column] = gamma[0] - beta[0];\n        }\n      }\n      function csc709Inverse(data) {\n        for (var i = 0; i < 64; ++i) {\n          var y = data[0][i];\n          var cb = data[1][i];\n          var cr = data[2][i];\n          data[0][i] = y + 1.5747 * cr;\n          data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n          data[2][i] = y + 1.8556 * cb;\n        }\n      }\n      function convertToHalf(src, dst, idx) {\n        for (var i = 0; i < 64; ++i) {\n          dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n        }\n      }\n      function toLinear(float) {\n        if (float <= 1) {\n          return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n        } else {\n          return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n        }\n      }\n      function uncompressRAW(info) {\n        return new DataView(info.array.buffer, info.offset.value, info.size);\n      }\n      function uncompressRLE(info) {\n        var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer);\n        interleaveScalar(rawBuffer, tmpBuffer);\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressZIP(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed);\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer);\n        interleaveScalar(rawBuffer, tmpBuffer);\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPIZ(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n        var bitmap = new Uint8Array(BITMAP_SIZE);\n        var outBufferEnd = 0;\n        var pizChannelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; i++) {\n          pizChannelData[i] = {};\n          pizChannelData[i][\"start\"] = outBufferEnd;\n          pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n          pizChannelData[i][\"nx\"] = info.width;\n          pizChannelData[i][\"ny\"] = info.lines;\n          pizChannelData[i][\"size\"] = info.type;\n          outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n        }\n        var minNonZero = parseUint16(inDataView, inOffset);\n        var maxNonZero = parseUint16(inDataView, inOffset);\n        if (maxNonZero >= BITMAP_SIZE) {\n          throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n        }\n        if (minNonZero <= maxNonZero) {\n          for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n            bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n          }\n        }\n        var lut = new Uint16Array(USHORT_RANGE);\n        var maxValue = reverseLutFromBitmap(bitmap, lut);\n        var length = parseUint32(inDataView, inOffset);\n        hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = pizChannelData[i];\n          for (var j = 0; j < pizChannelData[i].size; ++j) {\n            wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n          }\n        }\n        applyLut(lut, outBuffer, outBufferEnd);\n        var tmpOffset2 = 0;\n        var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var cd = pizChannelData[c];\n            var n = cd.nx * cd.size;\n            var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n            tmpBuffer.set(cp, tmpOffset2);\n            tmpOffset2 += n * INT16_SIZE;\n            cd.end += n;\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPXR(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed);\n        var sz = info.lines * info.channels * info.width;\n        var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n        var tmpBufferEnd = 0;\n        var writePtr = 0;\n        var ptr = new Array(4);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var pixel = 0;\n            switch (info.type) {\n              case 1:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                tmpBufferEnd = ptr[1] + info.width;\n                for (var j = 0; j < info.width; ++j) {\n                  var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                  pixel += diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n              case 2:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                ptr[2] = ptr[1] + info.width;\n                tmpBufferEnd = ptr[2] + info.width;\n                for (var _j = 0; _j < info.width; ++_j) {\n                  var _diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                  pixel += _diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n            }\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressDWA(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n        var dwaHeader = {\n          version: parseInt64(inDataView, inOffset),\n          unknownUncompressedSize: parseInt64(inDataView, inOffset),\n          unknownCompressedSize: parseInt64(inDataView, inOffset),\n          acCompressedSize: parseInt64(inDataView, inOffset),\n          dcCompressedSize: parseInt64(inDataView, inOffset),\n          rleCompressedSize: parseInt64(inDataView, inOffset),\n          rleUncompressedSize: parseInt64(inDataView, inOffset),\n          rleRawSize: parseInt64(inDataView, inOffset),\n          totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n          totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n          acCompression: parseInt64(inDataView, inOffset)\n        };\n        if (dwaHeader.version < 2) {\n          throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n        }\n        var channelRules = new Array();\n        var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n        while (ruleSize > 0) {\n          var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n          var value = parseUint8(inDataView, inOffset);\n          var compression = value >> 2 & 3;\n          var csc = (value >> 4) - 1;\n          var index = new Int8Array([csc])[0];\n          var type = parseUint8(inDataView, inOffset);\n          channelRules.push({\n            name: name,\n            index: index,\n            type: type,\n            compression: compression\n          });\n          ruleSize -= name.length + 3;\n        }\n        var channels = EXRHeader.channels;\n        var channelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = channelData[i] = {};\n          var channel = channels[i];\n          cd.name = channel.name;\n          cd.compression = UNKNOWN;\n          cd.decoded = false;\n          cd.type = channel.pixelType;\n          cd.pLinear = channel.pLinear;\n          cd.width = info.width;\n          cd.height = info.lines;\n        }\n        var cscSet = {\n          idx: new Array(3)\n        };\n        for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n          var cd = channelData[offset2];\n          for (var i = 0; i < channelRules.length; ++i) {\n            var rule = channelRules[i];\n            if (cd.name == rule.name) {\n              cd.compression = rule.compression;\n              if (rule.index >= 0) {\n                cscSet.idx[rule.index] = offset2;\n              }\n              cd.offset = offset2;\n            }\n          }\n        }\n        if (dwaHeader.acCompressedSize > 0) {\n          switch (dwaHeader.acCompression) {\n            case STATIC_HUFFMAN:\n              var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n              hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n              break;\n            case DEFLATE:\n              var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n              var data = unzlibSync(compressed);\n              var acBuffer = new Uint16Array(data.buffer);\n              inOffset.value += dwaHeader.totalAcUncompressedCount;\n              break;\n          }\n        }\n        if (dwaHeader.dcCompressedSize > 0) {\n          var zlibInfo = {\n            array: info.array,\n            offset: inOffset,\n            size: dwaHeader.dcCompressedSize\n          };\n          var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n          inOffset.value += dwaHeader.dcCompressedSize;\n        }\n        if (dwaHeader.rleRawSize > 0) {\n          var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n          var data = unzlibSync(compressed);\n          var rleBuffer = decodeRunLength(data.buffer);\n          inOffset.value += dwaHeader.rleCompressedSize;\n        }\n        var outBufferEnd = 0;\n        var rowOffsets = new Array(channelData.length);\n        for (var i = 0; i < rowOffsets.length; ++i) {\n          rowOffsets[i] = new Array();\n        }\n        for (var y = 0; y < info.lines; ++y) {\n          for (var chan = 0; chan < channelData.length; ++chan) {\n            rowOffsets[chan].push(outBufferEnd);\n            outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n          }\n        }\n        lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n        for (var i = 0; i < channelData.length; ++i) {\n          var cd = channelData[i];\n          if (cd.decoded) continue;\n          switch (cd.compression) {\n            case RLE:\n              var row = 0;\n              var rleOffset = 0;\n              for (var y = 0; y < info.lines; ++y) {\n                var rowOffsetBytes = rowOffsets[i][row];\n                for (var x = 0; x < cd.width; ++x) {\n                  for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                  }\n                  rleOffset++;\n                }\n                row++;\n              }\n              break;\n            case LOSSY_DCT:\n            default:\n              throw \"EXRLoader.parse: unsupported channel compression\";\n          }\n        }\n        return new DataView(outBuffer.buffer);\n      }\n      function parseNullTerminatedString(buffer2, offset2) {\n        var uintBuffer = new Uint8Array(buffer2);\n        var endOffset = 0;\n        while (uintBuffer[offset2.value + endOffset] != 0) {\n          endOffset += 1;\n        }\n        var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n        offset2.value = offset2.value + endOffset + 1;\n        return stringValue;\n      }\n      function parseFixedLengthString(buffer2, offset2, size) {\n        var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n        offset2.value = offset2.value + size;\n        return stringValue;\n      }\n      function parseRational(dataView, offset2) {\n        var x = parseInt32(dataView, offset2);\n        var y = parseUint32(dataView, offset2);\n        return [x, y];\n      }\n      function parseTimecode(dataView, offset2) {\n        var x = parseUint32(dataView, offset2);\n        var y = parseUint32(dataView, offset2);\n        return [x, y];\n      }\n      function parseInt32(dataView, offset2) {\n        var Int32 = dataView.getInt32(offset2.value, true);\n        offset2.value = offset2.value + INT32_SIZE;\n        return Int32;\n      }\n      function parseUint32(dataView, offset2) {\n        var Uint32 = dataView.getUint32(offset2.value, true);\n        offset2.value = offset2.value + INT32_SIZE;\n        return Uint32;\n      }\n      function parseUint8Array(uInt8Array2, offset2) {\n        var Uint8 = uInt8Array2[offset2.value];\n        offset2.value = offset2.value + INT8_SIZE;\n        return Uint8;\n      }\n      function parseUint8(dataView, offset2) {\n        var Uint8 = dataView.getUint8(offset2.value);\n        offset2.value = offset2.value + INT8_SIZE;\n        return Uint8;\n      }\n      var parseInt64 = function parseInt64(dataView, offset2) {\n        var int;\n        if (\"getBigInt64\" in DataView.prototype) {\n          int = Number(dataView.getBigInt64(offset2.value, true));\n        } else {\n          int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n        }\n        offset2.value += ULONG_SIZE;\n        return int;\n      };\n      function parseFloat32(dataView, offset2) {\n        var float = dataView.getFloat32(offset2.value, true);\n        offset2.value += FLOAT32_SIZE;\n        return float;\n      }\n      function decodeFloat32(dataView, offset2) {\n        return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n      }\n      function decodeFloat16(binary) {\n        var exponent = (binary & 31744) >> 10,\n          fraction = binary & 1023;\n        return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n      }\n      function parseUint16(dataView, offset2) {\n        var Uint16 = dataView.getUint16(offset2.value, true);\n        offset2.value += INT16_SIZE;\n        return Uint16;\n      }\n      function parseFloat16(buffer2, offset2) {\n        return decodeFloat16(parseUint16(buffer2, offset2));\n      }\n      function parseChlist(dataView, buffer2, offset2, size) {\n        var startOffset = offset2.value;\n        var channels = [];\n        while (offset2.value < startOffset + size - 1) {\n          var name = parseNullTerminatedString(buffer2, offset2);\n          var pixelType = parseInt32(dataView, offset2);\n          var pLinear = parseUint8(dataView, offset2);\n          offset2.value += 3;\n          var xSampling = parseInt32(dataView, offset2);\n          var ySampling = parseInt32(dataView, offset2);\n          channels.push({\n            name: name,\n            pixelType: pixelType,\n            pLinear: pLinear,\n            xSampling: xSampling,\n            ySampling: ySampling\n          });\n        }\n        offset2.value += 1;\n        return channels;\n      }\n      function parseChromaticities(dataView, offset2) {\n        var redX = parseFloat32(dataView, offset2);\n        var redY = parseFloat32(dataView, offset2);\n        var greenX = parseFloat32(dataView, offset2);\n        var greenY = parseFloat32(dataView, offset2);\n        var blueX = parseFloat32(dataView, offset2);\n        var blueY = parseFloat32(dataView, offset2);\n        var whiteX = parseFloat32(dataView, offset2);\n        var whiteY = parseFloat32(dataView, offset2);\n        return {\n          redX: redX,\n          redY: redY,\n          greenX: greenX,\n          greenY: greenY,\n          blueX: blueX,\n          blueY: blueY,\n          whiteX: whiteX,\n          whiteY: whiteY\n        };\n      }\n      function parseCompression(dataView, offset2) {\n        var compressionCodes = [\"NO_COMPRESSION\", \"RLE_COMPRESSION\", \"ZIPS_COMPRESSION\", \"ZIP_COMPRESSION\", \"PIZ_COMPRESSION\", \"PXR24_COMPRESSION\", \"B44_COMPRESSION\", \"B44A_COMPRESSION\", \"DWAA_COMPRESSION\", \"DWAB_COMPRESSION\"];\n        var compression = parseUint8(dataView, offset2);\n        return compressionCodes[compression];\n      }\n      function parseBox2i(dataView, offset2) {\n        var xMin = parseUint32(dataView, offset2);\n        var yMin = parseUint32(dataView, offset2);\n        var xMax = parseUint32(dataView, offset2);\n        var yMax = parseUint32(dataView, offset2);\n        return {\n          xMin: xMin,\n          yMin: yMin,\n          xMax: xMax,\n          yMax: yMax\n        };\n      }\n      function parseLineOrder(dataView, offset2) {\n        var lineOrders = [\"INCREASING_Y\"];\n        var lineOrder = parseUint8(dataView, offset2);\n        return lineOrders[lineOrder];\n      }\n      function parseV2f(dataView, offset2) {\n        var x = parseFloat32(dataView, offset2);\n        var y = parseFloat32(dataView, offset2);\n        return [x, y];\n      }\n      function parseV3f(dataView, offset2) {\n        var x = parseFloat32(dataView, offset2);\n        var y = parseFloat32(dataView, offset2);\n        var z = parseFloat32(dataView, offset2);\n        return [x, y, z];\n      }\n      function parseValue(dataView, buffer2, offset2, type, size) {\n        if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n          return parseFixedLengthString(buffer2, offset2, size);\n        } else if (type === \"chlist\") {\n          return parseChlist(dataView, buffer2, offset2, size);\n        } else if (type === \"chromaticities\") {\n          return parseChromaticities(dataView, offset2);\n        } else if (type === \"compression\") {\n          return parseCompression(dataView, offset2);\n        } else if (type === \"box2i\") {\n          return parseBox2i(dataView, offset2);\n        } else if (type === \"lineOrder\") {\n          return parseLineOrder(dataView, offset2);\n        } else if (type === \"float\") {\n          return parseFloat32(dataView, offset2);\n        } else if (type === \"v2f\") {\n          return parseV2f(dataView, offset2);\n        } else if (type === \"v3f\") {\n          return parseV3f(dataView, offset2);\n        } else if (type === \"int\") {\n          return parseInt32(dataView, offset2);\n        } else if (type === \"rational\") {\n          return parseRational(dataView, offset2);\n        } else if (type === \"timecode\") {\n          return parseTimecode(dataView, offset2);\n        } else if (type === \"preview\") {\n          offset2.value += size;\n          return \"skipped\";\n        } else {\n          offset2.value += size;\n          return void 0;\n        }\n      }\n      function parseHeader(dataView, buffer2, offset2) {\n        var EXRHeader2 = {};\n        if (dataView.getUint32(0, true) != 20000630) {\n          throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n        }\n        EXRHeader2.version = dataView.getUint8(4);\n        var spec = dataView.getUint8(5);\n        EXRHeader2.spec = {\n          singleTile: !!(spec & 2),\n          longName: !!(spec & 4),\n          deepFormat: !!(spec & 8),\n          multiPart: !!(spec & 16)\n        };\n        offset2.value = 8;\n        var keepReading = true;\n        while (keepReading) {\n          var attributeName = parseNullTerminatedString(buffer2, offset2);\n          if (attributeName == 0) {\n            keepReading = false;\n          } else {\n            var attributeType = parseNullTerminatedString(buffer2, offset2);\n            var attributeSize = parseUint32(dataView, offset2);\n            var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n            if (attributeValue === void 0) {\n              console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n            } else {\n              EXRHeader2[attributeName] = attributeValue;\n            }\n          }\n        }\n        if (spec != 0) {\n          console.error(\"EXRHeader:\", EXRHeader2);\n          throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n        }\n        return EXRHeader2;\n      }\n      function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n        var EXRDecoder2 = {\n          size: 0,\n          viewer: dataView,\n          array: uInt8Array2,\n          offset: offset2,\n          width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n          height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n          channels: EXRHeader2.channels.length,\n          bytesPerLine: null,\n          lines: null,\n          inputSize: null,\n          type: EXRHeader2.channels[0].pixelType,\n          uncompress: null,\n          getter: null,\n          format: null,\n          encoding: null\n        };\n        switch (EXRHeader2.compression) {\n          case \"NO_COMPRESSION\":\n            EXRDecoder2.lines = 1;\n            EXRDecoder2.uncompress = uncompressRAW;\n            break;\n          case \"RLE_COMPRESSION\":\n            EXRDecoder2.lines = 1;\n            EXRDecoder2.uncompress = uncompressRLE;\n            break;\n          case \"ZIPS_COMPRESSION\":\n            EXRDecoder2.lines = 1;\n            EXRDecoder2.uncompress = uncompressZIP;\n            break;\n          case \"ZIP_COMPRESSION\":\n            EXRDecoder2.lines = 16;\n            EXRDecoder2.uncompress = uncompressZIP;\n            break;\n          case \"PIZ_COMPRESSION\":\n            EXRDecoder2.lines = 32;\n            EXRDecoder2.uncompress = uncompressPIZ;\n            break;\n          case \"PXR24_COMPRESSION\":\n            EXRDecoder2.lines = 16;\n            EXRDecoder2.uncompress = uncompressPXR;\n            break;\n          case \"DWAA_COMPRESSION\":\n            EXRDecoder2.lines = 32;\n            EXRDecoder2.uncompress = uncompressDWA;\n            break;\n          case \"DWAB_COMPRESSION\":\n            EXRDecoder2.lines = 256;\n            EXRDecoder2.uncompress = uncompressDWA;\n            break;\n          default:\n            throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n        }\n        EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n        if (EXRDecoder2.type == 1) {\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder2.getter = parseFloat16;\n              EXRDecoder2.inputSize = INT16_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder2.getter = parseUint16;\n              EXRDecoder2.inputSize = INT16_SIZE;\n              break;\n          }\n        } else if (EXRDecoder2.type == 2) {\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder2.getter = parseFloat32;\n              EXRDecoder2.inputSize = FLOAT32_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder2.getter = decodeFloat32;\n              EXRDecoder2.inputSize = FLOAT32_SIZE;\n          }\n        } else {\n          throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n        }\n        EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n        for (var i = 0; i < EXRDecoder2.blockCount; i++) parseInt64(dataView, offset2);\n        EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n        var size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.byteArray = new Float32Array(size);\n            if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n            break;\n          case HalfFloatType:\n            EXRDecoder2.byteArray = new Uint16Array(size);\n            if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n            break;\n          default:\n            console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n            break;\n        }\n        EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n        if (EXRDecoder2.outputChannels == 4) {\n          EXRDecoder2.format = RGBAFormat;\n          EXRDecoder2.encoding = 3e3;\n        } else {\n          EXRDecoder2.format = RedFormat;\n          EXRDecoder2.encoding = 3e3;\n        }\n        return EXRDecoder2;\n      }\n      var bufferDataView = new DataView(buffer);\n      var uInt8Array = new Uint8Array(buffer);\n      var offset = {\n        value: 0\n      };\n      var EXRHeader = parseHeader(bufferDataView, buffer, offset);\n      var EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n      var tmpOffset = {\n        value: 0\n      };\n      var channelOffsets = {\n        R: 0,\n        G: 1,\n        B: 2,\n        A: 3,\n        Y: 0\n      };\n      for (var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n        var line = parseUint32(bufferDataView, offset);\n        EXRDecoder.size = parseUint32(bufferDataView, offset);\n        EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n        var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n        var viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n        for (var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n          var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n          if (true_y >= EXRDecoder.height) break;\n          for (var channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n            var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n            for (var x = 0; x < EXRDecoder.width; x++) {\n              tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n              var outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n      return {\n        header: EXRHeader,\n        width: EXRDecoder.width,\n        height: EXRDecoder.height,\n        data: EXRDecoder.byteArray,\n        format: EXRDecoder.format,\n        encoding: EXRDecoder.encoding,\n        type: this.type\n      };\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        if (\"colorSpace\" in texture) texture.colorSpace = texData.encoding === 3001 ? \"srgb\" : \"srgb-linear\";else texture.encoding = texData.encoding;\n        texture.minFilter = LinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.flipY = false;\n        if (onLoad) onLoad(texture, texData);\n      }\n      return _get(_getPrototypeOf(EXRLoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n  return EXRLoader;\n}(DataTextureLoader);\nexport { EXRLoader };","map":{"version":3,"names":["DataTextureLoader","HalfFloatType","DataUtils","FloatType","RGBAFormat","RedFormat","LinearFilter","unzlibSync","EXRLoader","_DataTextureLoader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","type","_createClass","key","value","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","buffer2","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp2","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset2","type2","y2","src","setUint16","offset3","x2","halfRow","comp","decoded","y","x","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","offset","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset2","cp","end","set","uncompressPXR","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","parseHeader","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","concat","error","setupDecoder","outputType","EXRDecoder2","dataWindow","bytesPerLine","inputSize","uncompress","getter","format","encoding","blockCount","outputChannels","byteArray","bufferDataView","uInt8Array","EXRDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line","isCompressed","line_y","true_y","channelID","cOff","outIndex","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","colorSpace","minFilter","magFilter","generateMipmaps","flipY","_get","_getPrototypeOf"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/EXRLoader.js"],"sourcesContent":["import { DataTextureLoader, HalfFloatType, DataUtils, FloatType, RGBAFormat, RedFormat, LinearFilter } from \"three\";\nimport { unzlibSync } from \"fflate\";\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE)\n        lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = { l: 0, c: 0, lc: 0 };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i)\n        hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i)\n        hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0)\n          hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni)\n          return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = { c: 0, lc: 0 };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = { c: 0, lc: 0 };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = { a: 0, b: 0 };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n)\n        p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p01 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array2,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset\n                  );\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop)\n          break;\n        out[s++] = source[t1++];\n        if (s > stop)\n          break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = { value: 0 };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1)\n          maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1)\n            maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          if (numComp == 3) {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2)\n          continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount\n            );\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded)\n          continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function(dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\n        \"NO_COMPRESSION\",\n        \"RLE_COMPRESSION\",\n        \"ZIPS_COMPRESSION\",\n        \"ZIP_COMPRESSION\",\n        \"PIZ_COMPRESSION\",\n        \"PXR24_COMPRESSION\",\n        \"B44_COMPRESSION\",\n        \"B44A_COMPRESSION\",\n        \"DWAA_COMPRESSION\",\n        \"DWAB_COMPRESSION\"\n      ];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return { xMin, yMin, xMax, yMax };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if (spec != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        encoding: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++)\n        parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4) {\n        EXRDecoder2.format = RGBAFormat;\n        EXRDecoder2.encoding = 3e3;\n      } else {\n        EXRDecoder2.format = RedFormat;\n        EXRDecoder2.encoding = 3e3;\n      }\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = { value: 0 };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = { value: 0 };\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height)\n          break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      encoding: EXRDecoder.encoding,\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (\"colorSpace\" in texture)\n        texture.colorSpace = texData.encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n      else\n        texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  EXRLoader\n};\n"],"mappings":"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,CAAC,CAAC,CAAC;QAC9Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,C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"},"metadata":{},"sourceType":"module","externalDependencies":[]}