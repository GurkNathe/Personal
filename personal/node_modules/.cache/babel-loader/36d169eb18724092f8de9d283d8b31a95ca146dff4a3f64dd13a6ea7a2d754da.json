{"ast":null,"code":"import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js';\nimport { createDocumentsStore } from '../components/documents-store.js';\nimport { OBJECT_COMPONENTS, FUNCTION_COMPONENTS, SINGLE_OR_ARRAY_COMPONENTS } from '../components/hooks.js';\nimport { createIndex } from '../components/index.js';\nimport { createTokenizer } from '../components/tokenizer/index.js';\nimport { createError } from '../errors.js';\nimport { uniqueId } from '../utils.js';\nimport { createSorter } from '../components/sorter.js';\nfunction validateComponents(components) {\n  const defaultComponents = {\n    formatElapsedTime,\n    getDocumentIndexId,\n    getDocumentProperties,\n    validateSchema\n  };\n  for (const rawKey of FUNCTION_COMPONENTS) {\n    const key = rawKey;\n    if (components[key]) {\n      if (typeof components[key] !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION', key);\n      }\n    } else {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = defaultComponents[key];\n    }\n  }\n  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {\n    const key = rawKey;\n    if (!components[key]) {\n      components[key] = [];\n    } else if (!Array.isArray(components[key])) {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = [components[key]];\n    }\n    for (const fn of components[key]) {\n      if (typeof fn !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS', key);\n      }\n    }\n  }\n  for (const rawKey of Object.keys(components)) {\n    if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey) && !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)) {\n      throw createError('UNSUPPORTED_COMPONENT', rawKey);\n    }\n  }\n}\nexport async function create(_ref) {\n  let {\n    schema,\n    sort,\n    language,\n    components,\n    id\n  } = _ref;\n  if (!components) {\n    components = {};\n  }\n  if (!id) {\n    id = await uniqueId();\n  }\n  let tokenizer = components.tokenizer;\n  let index = components.index;\n  let documentsStore = components.documentsStore;\n  let sorter = components.sorter;\n  if (!tokenizer) {\n    // Use the default tokenizer\n    tokenizer = await createTokenizer({\n      language: language ?? 'english'\n    });\n  } else if (!tokenizer.tokenize) {\n    // If there is no tokenizer function, we assume this is a TokenizerConfig\n    tokenizer = await createTokenizer(tokenizer);\n  }\n  if (components.tokenizer && language) {\n    // Accept language only if a tokenizer is not provided\n    throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER');\n  }\n  if (!index) {\n    index = await createIndex();\n  }\n  if (!sorter) {\n    sorter = await createSorter();\n  }\n  if (!documentsStore) {\n    documentsStore = await createDocumentsStore();\n  }\n  // Validate all other components\n  validateComponents(components);\n  // Assign only recognized components and hooks\n  const {\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime\n  } = components;\n  const orama = {\n    data: {},\n    caches: {},\n    schema,\n    tokenizer,\n    index,\n    sorter,\n    documentsStore,\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n    id\n  };\n  orama.data = {\n    index: await orama.index.create(orama, schema),\n    docs: await orama.documentsStore.create(orama),\n    sorting: await orama.sorter.create(orama, schema, sort)\n  };\n  return orama;\n}","map":{"version":3,"names":["formatElapsedTime","getDocumentIndexId","getDocumentProperties","validateSchema","createDocumentsStore","OBJECT_COMPONENTS","FUNCTION_COMPONENTS","SINGLE_OR_ARRAY_COMPONENTS","createIndex","createTokenizer","createError","uniqueId","createSorter","validateComponents","components","defaultComponents","rawKey","key","Array","isArray","fn","Object","keys","includes","create","_ref","schema","sort","language","id","tokenizer","index","documentsStore","sorter","tokenize","beforeInsert","afterInsert","beforeRemove","afterRemove","beforeUpdate","afterUpdate","beforeMultipleInsert","afterMultipleInsert","beforeMultipleRemove","afterMultipleRemove","beforeMultipleUpdate","afterMultipleUpdate","orama","data","caches","docs","sorting"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/methods/create.ts"],"sourcesContent":["import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js'\nimport { createDocumentsStore } from '../components/documents-store.js'\nimport { OBJECT_COMPONENTS, FUNCTION_COMPONENTS, SINGLE_OR_ARRAY_COMPONENTS } from '../components/hooks.js'\nimport { createIndex } from '../components/index.js'\nimport { createTokenizer } from '../components/tokenizer/index.js'\nimport { createError } from '../errors.js'\nimport { uniqueId } from '../utils.js'\nimport {\n  ArrayCallbackComponents,\n  Components,\n  Orama,\n  Schema,\n  FunctionComponents,\n  SingleOrArrayCallbackComponents,\n  Tokenizer,\n  SorterConfig,\n  OpaqueIndex,\n  OpaqueDocumentStore,\n  OpaqueSorter,\n  ProvidedTypes,\n} from '../types.js'\nimport { createSorter } from '../components/sorter.js'\n\ninterface CreateArguments<P extends ProvidedTypes> {\n  schema: Schema\n  sort?: SorterConfig\n  language?: string\n  components?: Components<P>\n  id?: string\n}\n\nfunction validateComponents<P extends ProvidedTypes>(components: Components<P>) {\n  const defaultComponents = {\n    formatElapsedTime,\n    getDocumentIndexId,\n    getDocumentProperties,\n    validateSchema,\n  }\n\n  for (const rawKey of FUNCTION_COMPONENTS) {\n    const key = rawKey as keyof FunctionComponents\n\n    if (components[key]) {\n      if (typeof components[key] !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION', key)\n      }\n    } else {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = defaultComponents[key]\n    }\n  }\n\n  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {\n    const key = rawKey as keyof ArrayCallbackComponents<P>\n\n    if (!components[key]) {\n      components[key] = []\n    } else if (!Array.isArray(components[key])) {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = [components[key]]\n    }\n\n    for (const fn of components[key] as unknown as SingleOrArrayCallbackComponents<P>[]) {\n      if (typeof fn !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS', key)\n      }\n    }\n  }\n\n  for (const rawKey of Object.keys(components)) {\n    if (\n      !OBJECT_COMPONENTS.includes(rawKey) &&\n      !FUNCTION_COMPONENTS.includes(rawKey) &&\n      !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)\n    ) {\n      throw createError('UNSUPPORTED_COMPONENT', rawKey)\n    }\n  }\n}\n\nexport async function create<P extends ProvidedTypes>({\n  schema,\n  sort,\n  language,\n  components,\n  id,\n}: CreateArguments<P>): Promise<Orama<P>> {\n  if (!components) {\n    components = {}\n  }\n\n  if (!id) {\n    id = await uniqueId()\n  }\n\n  let tokenizer = components.tokenizer as Tokenizer\n  let index: OpaqueIndex | undefined = components.index\n  let documentsStore: OpaqueDocumentStore | undefined = components.documentsStore\n  let sorter: OpaqueSorter | undefined = components.sorter\n\n  if (!tokenizer) {\n    // Use the default tokenizer\n    tokenizer = await createTokenizer({ language: language ?? 'english' })\n  } else if (!tokenizer.tokenize) {\n    // If there is no tokenizer function, we assume this is a TokenizerConfig\n    tokenizer = await createTokenizer(tokenizer)\n  }\n\n  if (components.tokenizer && language) {\n    // Accept language only if a tokenizer is not provided\n    throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER')\n  }\n\n  if (!index) {\n    index = await createIndex()\n  }\n\n  if (!sorter) {\n    sorter = await createSorter()\n  }\n\n  if (!documentsStore) {\n    documentsStore = await createDocumentsStore()\n  }\n\n  // Validate all other components\n  validateComponents(components)\n\n  // Assign only recognized components and hooks\n  const {\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n  } = components\n\n  const orama = {\n    data: {},\n    caches: {},\n    schema,\n    tokenizer,\n    index,\n    sorter,\n    documentsStore,\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n    id,\n  } as Orama\n\n  orama.data = {\n    index: await orama.index.create(orama, schema),\n    docs: await orama.documentsStore.create(orama),\n    sorting: await orama.sorter.create(orama, schema, sort),\n  }\n\n  return orama\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}