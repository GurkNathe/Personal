{"ast":null,"code":"import { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n  }\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === void 0) return;\n    if (this.tree.format === \"LWO2\") {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    } else if (this.tree.format === \"LWO3\") {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n    if (topForm !== \"FORM\") {\n      console.warn(\"LWOLoader: Top-level FORM missing.\");\n      return;\n    }\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n    if (type === \"LWO2\") {\n      this.tree.format = type;\n    } else if (type === \"LWO3\") {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  }\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n    switch (type) {\n      case \"ISEQ\":\n      case \"ANIM\":\n      case \"STCC\":\n      case \"VPVL\":\n      case \"VPRM\":\n      case \"NROT\":\n      case \"WRPW\":\n      case \"WRPH\":\n      case \"FUNC\":\n      case \"FALL\":\n      case \"OPAC\":\n      case \"GRAD\":\n      case \"ENVS\":\n      case \"VMOP\":\n      case \"VMBG\":\n      case \"OMAX\":\n      case \"STEX\":\n      case \"CKBG\":\n      case \"CKEY\":\n      case \"VMLA\":\n      case \"VMLB\":\n        this.debugger.skipped = true;\n        this.skipForm(length);\n        break;\n      case \"META\":\n      case \"NNDS\":\n      case \"NODS\":\n      case \"NDTA\":\n      case \"ADAT\":\n      case \"AOVS\":\n      case \"BLOK\":\n      case \"IBGC\":\n      case \"IOPC\":\n      case \"IIMG\":\n      case \"TXTR\":\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case \"IFAL\":\n      case \"ISCL\":\n      case \"IPOS\":\n      case \"IROT\":\n      case \"IBMP\":\n      case \"IUTD\":\n      case \"IVTD\":\n        this.parseTextureNodeAttribute(type);\n        break;\n      case \"ENVL\":\n        this.parseEnvelope(length);\n        break;\n      case \"CLIP\":\n        if (this.tree.format === \"LWO2\") {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case \"STIL\":\n        this.parseImage();\n        break;\n      case \"XREF\":\n        this.reader.skip(8);\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString()\n          // internal unique ref\n        };\n\n        break;\n      case \"IMST\":\n        this.parseImageStateForm(length);\n        break;\n      case \"SURF\":\n        this.parseSurfaceForm(length);\n        break;\n      case \"VALU\":\n        this.parseValueForm(length);\n        break;\n      case \"NTAG\":\n        this.parseSubNode(length);\n        break;\n      case \"ATTR\":\n      case \"SATR\":\n        this.setupForm(\"attributes\", length);\n        break;\n      case \"NCON\":\n        this.parseConnections(length);\n        break;\n      case \"SSHA\":\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm(\"surfaceShader\", length);\n        break;\n      case \"SSHD\":\n        this.setupForm(\"surfaceShaderData\", length);\n        break;\n      case \"ENTR\":\n        this.parseEntryForm(length);\n        break;\n      case \"IMAP\":\n        this.parseImageMap(length);\n        break;\n      case \"TAMP\":\n        this.parseXVAL(\"amplitude\", length);\n        break;\n      case \"TMAP\":\n        this.setupForm(\"textureMap\", length);\n        break;\n      case \"CNTR\":\n        this.parseXVAL3(\"center\", length);\n        break;\n      case \"SIZE\":\n        this.parseXVAL3(\"scale\", length);\n        break;\n      case \"ROTA\":\n        this.parseXVAL3(\"rotation\", length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n  setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n  parseUnknownForm(type, length) {\n    console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n  parseSurfaceForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSubNode(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var node = {\n      name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  }\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  }\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8);\n    var valueType = this.reader.getString();\n    if (valueType === \"double\") {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === \"int\") {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === \"vparam\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === \"vparam3\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  }\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8);\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  }\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps) this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10);\n  }\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28);\n    this.reader.skip(20);\n    switch (type) {\n      case \"ISCL\":\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case \"IPOS\":\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case \"IROT\":\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case \"IFAL\":\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case \"IBMP\":\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case \"IUTD\":\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case \"IVTD\":\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2);\n  }\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4);\n  }\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag();\n    if (tag === \"FORM\") {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8);\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: \"\"\n    };\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n      if (tag === \"STIL\") {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseImage() {\n    this.reader.skip(8);\n    this.currentForm.fileName = this.reader.getString();\n  }\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset);\n  }\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  }\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  }\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name);\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n  }\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n    for (var i = 0; i < length / 4; i += 3) {\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  }\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16();\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case \"TXUV\":\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case \"MORF\":\n      case \"SPOT\":\n        this.parseMorphTargets(name, finalOffset, type);\n        break;\n      case \"APSL\":\n      case \"NORM\":\n      case \"WGHT\":\n      case \"MNVW\":\n      case \"PICK\":\n      case \"RGB \":\n      case \"RGBA\":\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices,\n        polyIndices,\n        uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices,\n        uvs\n      };\n    }\n  }\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === \"MORF\" ? \"relative\" : \"absolute\";\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices,\n      points,\n      type\n    };\n  }\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = [];\n    var polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16();\n      numverts = numverts & 1023;\n      polygonDimensions.push(numverts);\n      for (var j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex());\n    }\n    var geometryData = {\n      type,\n      vertexIndices: indices,\n      polygonDimensions,\n      points: this.currentPoints\n    };\n    if (polygonDimensions[0] === 1) geometryData.type = \"points\";else if (polygonDimensions[0] === 2) geometryData.type = \"lines\";\n    this.currentLayer.geometry = geometryData;\n  }\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  }\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === \"SURF\") this.parseMaterialIndices(finalOffset);else {\n      this.reader.skip(length - 4);\n    }\n  }\n  parseMaterialIndices(finalOffset) {\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n  parseUnknownCHUNK(blockID, length) {\n    console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n}\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error(\"LWOLoader: invalid buffer offset\");\n    }\n  }\n  endOfFile() {\n    if (this.offset >= this.size()) return true;\n    return false;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  }\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  }\n  getString(size) {\n    if (size === 0) return;\n    const start = this.offset;\n    let result;\n    let length;\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n      length++;\n      length += length % 2;\n    }\n    this.skip(length);\n    return result;\n  }\n  getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split(\"\\0\");\n    return a.filter(Boolean);\n  }\n}\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n  enable() {\n    this.active = true;\n  }\n  log() {\n    if (!this.active) return;\n    var nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = \"FORM\";\n        break;\n      case 1:\n        nodeType = \"CHK\";\n        break;\n      case 2:\n        nodeType = \"S-CHK\";\n        break;\n    }\n    console.log(\"| \".repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? \" {\" : \"\", this.skipped ? \"SKIPPED\" : \"\", this.node == 0 && this.skipped ? \"}\" : \"\");\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  }\n  closeForms() {\n    if (!this.active) return;\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log(\"| \".repeat(this.depth) + \"}\");\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}\nfunction isEven(num) {\n  return num % 2;\n}\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport { IFFParser };","map":{"version":3,"names":["LWO2Parser","LWO3Parser","IFFParser","constructor","debugger","Debugger","parse","buffer","reader","DataViewReader","tree","materials","layers","tags","textures","currentLayer","currentForm","parseTopForm","format","parser","endOfFile","parseBlock","offset","closeForms","topForm","getIDTag","console","warn","length","getUint32","dataOffset","type","node","nodeID","log","parseForm","skipped","skipForm","parseTextureNodeAttribute","parseEnvelope","parseClip","parseImage","skip","referenceTexture","index","refName","getString","parseImageStateForm","parseSurfaceForm","parseValueForm","parseSubNode","setupForm","parseConnections","parentForm","currentSurface","parseEntryForm","parseImageMap","parseXVAL","parseXVAL3","parseUnknownForm","currentNode","currentFormEnd","printBuffer","dv","name","surface","attributes","connections","inputName","nodes","source","parseSurfaceLwo2","valueType","value","getUint64","getFloat64","getFloat64Array","mipMapLevel","getFloat32","maps","map","push","scale","getFloat32Array","position","rotation","falloff","amplitude","uTiles","vTiles","tag","fileName","setOffset","texture","parseClipLwo2","n_length","getUint16","endOffset","x","y","z","parseObjectTag","objectTags","tagString","parseLayer","layer","number","flags","pivot","parsedLength","stringOffset","parent","parsePoints","currentPoints","i","parseVertexMapping","discontinuous","finalOffset","channelName","UVChannel","remainingLength","parseUVMapping","parseMorphTargets","uvIndices","polyIndices","uvs","getVariableLengthIndex","discontinuousUVs","indices","points","morphTargets","parsePolygonList","polygonDimensions","numverts","j","geometryData","vertexIndices","geometry","parseTagStrings","getStringArray","parsePolygonTagMapping","parseMaterialIndices","materialIndices","polygonIndex","materialIndex","parseUnknownCHUNK","blockID","data","DataView","_textDecoder","TextDecoder","_bytes","Uint8Array","size","byteLength","error","getUint8","getInt32","low","high","a","littleEndian","firstByte","start","result","decode","indexOf","split","filter","Boolean","active","depth","formList","enable","nodeType","repeat","splice","isEven","num","string","from","to"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/lwo/IFFParser.js"],"sourcesContent":["import { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n  }\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === void 0)\n      return;\n    if (this.tree.format === \"LWO2\") {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    } else if (this.tree.format === \"LWO3\") {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n    if (topForm !== \"FORM\") {\n      console.warn(\"LWOLoader: Top-level FORM missing.\");\n      return;\n    }\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n    if (type === \"LWO2\") {\n      this.tree.format = type;\n    } else if (type === \"LWO3\") {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  }\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n    switch (type) {\n      case \"ISEQ\":\n      case \"ANIM\":\n      case \"STCC\":\n      case \"VPVL\":\n      case \"VPRM\":\n      case \"NROT\":\n      case \"WRPW\":\n      case \"WRPH\":\n      case \"FUNC\":\n      case \"FALL\":\n      case \"OPAC\":\n      case \"GRAD\":\n      case \"ENVS\":\n      case \"VMOP\":\n      case \"VMBG\":\n      case \"OMAX\":\n      case \"STEX\":\n      case \"CKBG\":\n      case \"CKEY\":\n      case \"VMLA\":\n      case \"VMLB\":\n        this.debugger.skipped = true;\n        this.skipForm(length);\n        break;\n      case \"META\":\n      case \"NNDS\":\n      case \"NODS\":\n      case \"NDTA\":\n      case \"ADAT\":\n      case \"AOVS\":\n      case \"BLOK\":\n      case \"IBGC\":\n      case \"IOPC\":\n      case \"IIMG\":\n      case \"TXTR\":\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case \"IFAL\":\n      case \"ISCL\":\n      case \"IPOS\":\n      case \"IROT\":\n      case \"IBMP\":\n      case \"IUTD\":\n      case \"IVTD\":\n        this.parseTextureNodeAttribute(type);\n        break;\n      case \"ENVL\":\n        this.parseEnvelope(length);\n        break;\n      case \"CLIP\":\n        if (this.tree.format === \"LWO2\") {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case \"STIL\":\n        this.parseImage();\n        break;\n      case \"XREF\":\n        this.reader.skip(8);\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString()\n          // internal unique ref\n        };\n        break;\n      case \"IMST\":\n        this.parseImageStateForm(length);\n        break;\n      case \"SURF\":\n        this.parseSurfaceForm(length);\n        break;\n      case \"VALU\":\n        this.parseValueForm(length);\n        break;\n      case \"NTAG\":\n        this.parseSubNode(length);\n        break;\n      case \"ATTR\":\n      case \"SATR\":\n        this.setupForm(\"attributes\", length);\n        break;\n      case \"NCON\":\n        this.parseConnections(length);\n        break;\n      case \"SSHA\":\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm(\"surfaceShader\", length);\n        break;\n      case \"SSHD\":\n        this.setupForm(\"surfaceShaderData\", length);\n        break;\n      case \"ENTR\":\n        this.parseEntryForm(length);\n        break;\n      case \"IMAP\":\n        this.parseImageMap(length);\n        break;\n      case \"TAMP\":\n        this.parseXVAL(\"amplitude\", length);\n        break;\n      case \"TMAP\":\n        this.setupForm(\"textureMap\", length);\n        break;\n      case \"CNTR\":\n        this.parseXVAL3(\"center\", length);\n        break;\n      case \"SIZE\":\n        this.parseXVAL3(\"scale\", length);\n        break;\n      case \"ROTA\":\n        this.parseXVAL3(\"rotation\", length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n  setupForm(type, length) {\n    if (!this.currentForm)\n      this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n  parseUnknownForm(type, length) {\n    console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n  parseSurfaceForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSubNode(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var node = {\n      name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  }\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  }\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8);\n    var valueType = this.reader.getString();\n    if (valueType === \"double\") {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === \"int\") {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === \"vparam\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === \"vparam3\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  }\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8);\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  }\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps)\n      this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10);\n  }\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28);\n    this.reader.skip(20);\n    switch (type) {\n      case \"ISCL\":\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case \"IPOS\":\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case \"IROT\":\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case \"IFAL\":\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case \"IBMP\":\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case \"IUTD\":\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case \"IVTD\":\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2);\n  }\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4);\n  }\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag();\n    if (tag === \"FORM\") {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8);\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: \"\"\n    };\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n      if (tag === \"STIL\") {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseImage() {\n    this.reader.skip(8);\n    this.currentForm.fileName = this.reader.getString();\n  }\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset);\n  }\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  }\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags)\n      this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  }\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name);\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n  }\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n    for (var i = 0; i < length / 4; i += 3) {\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  }\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16();\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case \"TXUV\":\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case \"MORF\":\n      case \"SPOT\":\n        this.parseMorphTargets(name, finalOffset, type);\n        break;\n      case \"APSL\":\n      case \"NORM\":\n      case \"WGHT\":\n      case \"MNVW\":\n      case \"PICK\":\n      case \"RGB \":\n      case \"RGBA\":\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous)\n        polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs)\n        this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices,\n        polyIndices,\n        uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs)\n        this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices,\n        uvs\n      };\n    }\n  }\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === \"MORF\" ? \"relative\" : \"absolute\";\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets)\n      this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices,\n      points,\n      type\n    };\n  }\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = [];\n    var polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16();\n      numverts = numverts & 1023;\n      polygonDimensions.push(numverts);\n      for (var j = 0; j < numverts; j++)\n        indices.push(this.reader.getVariableLengthIndex());\n    }\n    var geometryData = {\n      type,\n      vertexIndices: indices,\n      polygonDimensions,\n      points: this.currentPoints\n    };\n    if (polygonDimensions[0] === 1)\n      geometryData.type = \"points\";\n    else if (polygonDimensions[0] === 2)\n      geometryData.type = \"lines\";\n    this.currentLayer.geometry = geometryData;\n  }\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  }\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === \"SURF\")\n      this.parseMaterialIndices(finalOffset);\n    else {\n      this.reader.skip(length - 4);\n    }\n  }\n  parseMaterialIndices(finalOffset) {\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n  parseUnknownCHUNK(blockID, length) {\n    console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n}\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error(\"LWOLoader: invalid buffer offset\");\n    }\n  }\n  endOfFile() {\n    if (this.offset >= this.size())\n      return true;\n    return false;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  }\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  }\n  getString(size) {\n    if (size === 0)\n      return;\n    const start = this.offset;\n    let result;\n    let length;\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n      length++;\n      length += length % 2;\n    }\n    this.skip(length);\n    return result;\n  }\n  getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split(\"\\0\");\n    return a.filter(Boolean);\n  }\n}\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n  enable() {\n    this.active = true;\n  }\n  log() {\n    if (!this.active)\n      return;\n    var nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = \"FORM\";\n        break;\n      case 1:\n        nodeType = \"CHK\";\n        break;\n      case 2:\n        nodeType = \"S-CHK\";\n        break;\n    }\n    console.log(\n      \"| \".repeat(this.depth) + nodeType,\n      this.nodeID,\n      `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n      this.node == 0 ? \" {\" : \"\",\n      this.skipped ? \"SKIPPED\" : \"\",\n      this.node == 0 && this.skipped ? \"}\" : \"\"\n    );\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  }\n  closeForms() {\n    if (!this.active)\n      return;\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log(\"| \".repeat(this.depth) + \"}\");\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}\nfunction isEven(num) {\n  return num % 2;\n}\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport {\n  IFFParser\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}