{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from \"three\";\nvar VolumeSlice = /*#__PURE__*/function () {\n  function VolumeSlice(volume, index, axis) {\n    _classCallCheck(this, VolumeSlice);\n    var slice = this;\n    this.volume = volume;\n    index = index || 0;\n    Object.defineProperty(this, \"index\", {\n      get: function get() {\n        return index;\n      },\n      set: function set(value) {\n        index = value;\n        slice.geometryNeedsUpdate = true;\n        return index;\n      }\n    });\n    this.axis = axis || \"z\";\n    this.canvas = document.createElement(\"canvas\");\n    this.canvasBuffer = document.createElement(\"canvas\");\n    this.updateGeometry();\n    var canvasMap = new Texture(this.canvas);\n    canvasMap.minFilter = LinearFilter;\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n    if (\"colorSpace\" in canvasMap) canvasMap.colorSpace = \"srgb\";else canvasMap.encoding = 3001;\n    var material = new MeshBasicMaterial({\n      map: canvasMap,\n      side: DoubleSide,\n      transparent: true\n    });\n    this.mesh = new Mesh(this.geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.geometryNeedsUpdate = true;\n    this.repaint();\n  }\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  _createClass(VolumeSlice, [{\n    key: \"repaint\",\n    value: function repaint() {\n      if (this.geometryNeedsUpdate) {\n        this.updateGeometry();\n      }\n      var iLength = this.iLength,\n        jLength = this.jLength,\n        sliceAccess = this.sliceAccess,\n        volume = this.volume,\n        canvas = this.canvasBuffer,\n        ctx = this.ctxBuffer;\n      var imgData = ctx.getImageData(0, 0, iLength, jLength);\n      var data = imgData.data;\n      var volumeData = volume.data;\n      var upperThreshold = volume.upperThreshold;\n      var lowerThreshold = volume.lowerThreshold;\n      var windowLow = volume.windowLow;\n      var windowHigh = volume.windowHigh;\n      var pixelCount = 0;\n      if (volume.dataType === \"label\") {\n        for (var j = 0; j < jLength; j++) {\n          for (var i = 0; i < iLength; i++) {\n            var label = volumeData[sliceAccess(i, j)];\n            label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n            var color = this.colorMap[label];\n            data[4 * pixelCount] = color >> 24 & 255;\n            data[4 * pixelCount + 1] = color >> 16 & 255;\n            data[4 * pixelCount + 2] = color >> 8 & 255;\n            data[4 * pixelCount + 3] = color & 255;\n            pixelCount++;\n          }\n        }\n      } else {\n        for (var _j = 0; _j < jLength; _j++) {\n          for (var _i = 0; _i < iLength; _i++) {\n            var value = volumeData[sliceAccess(_i, _j)];\n            var alpha = 255;\n            alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n            value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n            value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n            data[4 * pixelCount] = value;\n            data[4 * pixelCount + 1] = value;\n            data[4 * pixelCount + 2] = value;\n            data[4 * pixelCount + 3] = alpha;\n            pixelCount++;\n          }\n        }\n      }\n      ctx.putImageData(imgData, 0, 0);\n      this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n      this.mesh.material.map.needsUpdate = true;\n    }\n    /**\n     * @member {Function} Refresh the geometry according to axis and index\n     * @see Volume.extractPerpendicularPlane\n     * @memberof VolumeSlice\n     */\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n      this.sliceAccess = extracted.sliceAccess;\n      this.jLength = extracted.jLength;\n      this.iLength = extracted.iLength;\n      this.matrix = extracted.matrix;\n      this.canvas.width = extracted.planeWidth;\n      this.canvas.height = extracted.planeHeight;\n      this.canvasBuffer.width = this.iLength;\n      this.canvasBuffer.height = this.jLength;\n      this.ctx = this.canvas.getContext(\"2d\");\n      this.ctxBuffer = this.canvasBuffer.getContext(\"2d\");\n      if (this.geometry) this.geometry.dispose();\n      this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry;\n        this.mesh.matrix.identity();\n        this.mesh.applyMatrix4(this.matrix);\n      }\n      this.geometryNeedsUpdate = false;\n    }\n  }]);\n  return VolumeSlice;\n}();\nexport { VolumeSlice };","map":{"version":3,"names":["Texture","LinearFilter","ClampToEdgeWrapping","MeshBasicMaterial","DoubleSide","Mesh","PlaneGeometry","VolumeSlice","volume","index","axis","_classCallCheck","slice","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","minFilter","wrapS","wrapT","colorSpace","encoding","material","map","side","transparent","mesh","geometry","matrixAutoUpdate","repaint","_createClass","key","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","identity","applyMatrix4"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/misc/VolumeSlice.js"],"sourcesContent":["import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from \"three\";\nclass VolumeSlice {\n  constructor(volume, index, axis) {\n    const slice = this;\n    this.volume = volume;\n    index = index || 0;\n    Object.defineProperty(this, \"index\", {\n      get: function() {\n        return index;\n      },\n      set: function(value) {\n        index = value;\n        slice.geometryNeedsUpdate = true;\n        return index;\n      }\n    });\n    this.axis = axis || \"z\";\n    this.canvas = document.createElement(\"canvas\");\n    this.canvasBuffer = document.createElement(\"canvas\");\n    this.updateGeometry();\n    const canvasMap = new Texture(this.canvas);\n    canvasMap.minFilter = LinearFilter;\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n    if (\"colorSpace\" in canvasMap)\n      canvasMap.colorSpace = \"srgb\";\n    else\n      canvasMap.encoding = 3001;\n    const material = new MeshBasicMaterial({ map: canvasMap, side: DoubleSide, transparent: true });\n    this.mesh = new Mesh(this.geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.geometryNeedsUpdate = true;\n    this.repaint();\n  }\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n    const iLength = this.iLength, jLength = this.jLength, sliceAccess = this.sliceAccess, volume = this.volume, canvas = this.canvasBuffer, ctx = this.ctxBuffer;\n    const imgData = ctx.getImageData(0, 0, iLength, jLength);\n    const data = imgData.data;\n    const volumeData = volume.data;\n    const upperThreshold = volume.upperThreshold;\n    const lowerThreshold = volume.lowerThreshold;\n    const windowLow = volume.windowLow;\n    const windowHigh = volume.windowHigh;\n    let pixelCount = 0;\n    if (volume.dataType === \"label\") {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          const color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 255;\n          data[4 * pixelCount + 1] = color >> 16 & 255;\n          data[4 * pixelCount + 2] = color >> 8 & 255;\n          data[4 * pixelCount + 3] = color & 255;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let value = volumeData[sliceAccess(i, j)];\n          let alpha = 255;\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  }\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry() {\n    const extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.ctxBuffer = this.canvasBuffer.getContext(\"2d\");\n    if (this.geometry)\n      this.geometry.dispose();\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry;\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n    this.geometryNeedsUpdate = false;\n  }\n}\nexport {\n  VolumeSlice\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}