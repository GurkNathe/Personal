{"ast":null,"code":"import { runMultipleHook, runSingleHook } from '../components/hooks.js';\nimport { getDocumentIdFromInternalId, getInternalDocumentId } from '../components/internal-document-id-store.js';\nimport { trackRemoval } from '../components/sync-blocking-checker.js';\nexport async function remove(orama, id, language, skipHooks) {\n  let result = true;\n  const {\n    index,\n    docs\n  } = orama.data;\n  const doc = await orama.documentsStore.get(docs, id);\n  if (!doc) {\n    return false;\n  }\n  const docId = getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id));\n  const docsCount = await orama.documentsStore.count(docs);\n  if (!skipHooks) {\n    await runSingleHook(orama.beforeRemove, orama, docId);\n  }\n  const indexableProperties = await orama.index.getSearchableProperties(index);\n  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);\n  const values = await orama.getDocumentProperties(doc, indexableProperties);\n  for (const prop of indexableProperties) {\n    var _orama_index, _orama_index_beforeRemove, _orama_index1, _orama_index_afterRemove;\n    const value = values[prop];\n    // The document doesn't contain the key\n    if (typeof value === 'undefined') {\n      continue;\n    }\n    const schemaType = indexablePropertiesWithTypes[prop];\n    await ((_orama_index_beforeRemove = (_orama_index = orama.index).beforeRemove) === null || _orama_index_beforeRemove === void 0 ? void 0 : _orama_index_beforeRemove.call(_orama_index, orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount));\n    if (!(await orama.index.remove(orama.index, orama.data.index, prop, id, value, schemaType, language, orama.tokenizer, docsCount))) {\n      result = false;\n    }\n    await ((_orama_index_afterRemove = (_orama_index1 = orama.index).afterRemove) === null || _orama_index_afterRemove === void 0 ? void 0 : _orama_index_afterRemove.call(_orama_index1, orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount));\n  }\n  const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);\n  const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);\n  for (const prop of sortableProperties) {\n    // The document doesn't contain the key\n    if (typeof sortableValues[prop] === 'undefined') {\n      continue;\n    }\n    await orama.sorter.remove(orama.data.sorting, prop, id);\n  }\n  if (!skipHooks) {\n    await runSingleHook(orama.afterRemove, orama, docId);\n  }\n  await orama.documentsStore.remove(orama.data.docs, id);\n  trackRemoval(orama);\n  return result;\n}\nexport async function removeMultiple(orama, ids, batchSize, language, skipHooks) {\n  let result = 0;\n  if (!batchSize) {\n    batchSize = 1000;\n  }\n  const docIdsForHooks = skipHooks ? [] : ids.map(id => getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id)));\n  if (!skipHooks) {\n    await runMultipleHook(orama.beforeMultipleRemove, orama, docIdsForHooks);\n  }\n  await new Promise((resolve, reject) => {\n    let i = 0;\n    async function _insertMultiple() {\n      const batch = ids.slice(i * batchSize, (i + 1) * batchSize);\n      i++;\n      if (!batch.length) {\n        return resolve();\n      }\n      for (const doc of batch) {\n        try {\n          if (await remove(orama, doc, language, skipHooks)) {\n            result++;\n          }\n        } catch (err) {\n          reject(err);\n        }\n      }\n      setTimeout(_insertMultiple, 0);\n    }\n    setTimeout(_insertMultiple, 0);\n  });\n  if (!skipHooks) {\n    await runMultipleHook(orama.afterMultipleRemove, orama, docIdsForHooks);\n  }\n  return result;\n}","map":{"version":3,"names":["runMultipleHook","runSingleHook","getDocumentIdFromInternalId","getInternalDocumentId","trackRemoval","remove","orama","id","language","skipHooks","result","index","docs","data","doc","documentsStore","get","docId","internalDocumentIDStore","docsCount","count","beforeRemove","indexableProperties","getSearchableProperties","indexablePropertiesWithTypes","getSearchablePropertiesWithTypes","values","getDocumentProperties","prop","_orama_index","_orama_index_beforeRemove","_orama_index1","_orama_index_afterRemove","value","schemaType","call","tokenizer","afterRemove","sortableProperties","sorter","getSortableProperties","sorting","sortableValues","removeMultiple","ids","batchSize","docIdsForHooks","map","beforeMultipleRemove","Promise","resolve","reject","i","_insertMultiple","batch","slice","length","err","setTimeout","afterMultipleRemove"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/methods/remove.ts"],"sourcesContent":["import { runMultipleHook, runSingleHook } from '../components/hooks.js'\nimport {\n  DocumentID,\n  getDocumentIdFromInternalId,\n  getInternalDocumentId,\n} from '../components/internal-document-id-store.js'\nimport { trackRemoval } from '../components/sync-blocking-checker.js'\nimport { AnyOrama } from '../types.js'\n\nexport async function remove<T extends AnyOrama>(orama: T, id: DocumentID, language?: string, skipHooks?: boolean): Promise<boolean> {\n  let result = true\n  const { index, docs } = orama.data\n\n  const doc = await orama.documentsStore.get(docs, id)\n  if (!doc) {\n    return false\n  }\n\n  const docId = getDocumentIdFromInternalId(\n    orama.internalDocumentIDStore,\n    getInternalDocumentId(orama.internalDocumentIDStore, id),\n  )\n  const docsCount = await orama.documentsStore.count(docs)\n\n  if (!skipHooks) {\n    await runSingleHook(orama.beforeRemove, orama, docId)\n  }\n\n  const indexableProperties = await orama.index.getSearchableProperties(index)\n  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n  const values = await orama.getDocumentProperties(doc, indexableProperties)\n\n  for (const prop of indexableProperties) {\n    const value = values[prop]\n    // The document doesn't contain the key\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const schemaType = indexablePropertiesWithTypes[prop]\n\n    await orama.index.beforeRemove?.(\n      orama.data.index,\n      prop,\n      docId,\n      value,\n      schemaType,\n      language,\n      orama.tokenizer,\n      docsCount,\n    )\n    if (\n      !(await orama.index.remove(\n        orama.index,\n        orama.data.index,\n        prop,\n        id,\n        value,\n        schemaType,\n        language,\n        orama.tokenizer,\n        docsCount,\n      ))\n    ) {\n      result = false\n    }\n    await orama.index.afterRemove?.(\n      orama.data.index,\n      prop,\n      docId,\n      value,\n      schemaType,\n      language,\n      orama.tokenizer,\n      docsCount,\n    )\n  }\n\n  const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting)\n  const sortableValues = await orama.getDocumentProperties(doc, sortableProperties)\n  for (const prop of sortableProperties) {\n    // The document doesn't contain the key\n    if (typeof sortableValues[prop] === 'undefined') {\n      continue\n    }\n\n    await orama.sorter.remove(orama.data.sorting, prop, id)\n  }\n\n  if (!skipHooks) {\n    await runSingleHook(orama.afterRemove, orama, docId)\n  }\n\n  await orama.documentsStore.remove(orama.data.docs, id)\n\n  trackRemoval(orama)\n  return result\n}\n\nexport async function removeMultiple<T extends AnyOrama>(\n  orama: T,\n  ids: DocumentID[],\n  batchSize?: number,\n  language?: string,\n  skipHooks?: boolean,\n): Promise<number> {\n  let result = 0\n\n  if (!batchSize) {\n    batchSize = 1000\n  }\n\n  const docIdsForHooks = skipHooks\n    ? []\n    : ids.map(id =>\n        getDocumentIdFromInternalId(\n          orama.internalDocumentIDStore,\n          getInternalDocumentId(orama.internalDocumentIDStore, id),\n        ),\n      )\n\n  if (!skipHooks) {\n    await runMultipleHook(orama.beforeMultipleRemove, orama, docIdsForHooks)\n  }\n\n  await new Promise<void>((resolve, reject) => {\n    let i = 0\n    async function _insertMultiple() {\n      const batch = ids.slice(i * batchSize!, (i + 1) * batchSize!)\n      i++\n\n      if (!batch.length) {\n        return resolve()\n      }\n\n      for (const doc of batch) {\n        try {\n          if (await remove(orama, doc, language, skipHooks)) {\n            result++\n          }\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      setTimeout(_insertMultiple, 0)\n    }\n\n    setTimeout(_insertMultiple, 0)\n  })\n\n  if (!skipHooks) {\n    await runMultipleHook(orama.afterMultipleRemove, orama, docIdsForHooks)\n  }\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}