{"ast":null,"code":"import { Vector3, Line3, Plane, Triangle } from \"three\";\nconst Visible = 0;\nconst Deleted = 1;\nconst _v1 = /* @__PURE__ */new Vector3();\nconst _line3 = /* @__PURE__ */new Line3();\nconst _plane = /* @__PURE__ */new Plane();\nconst _closestPoint = /* @__PURE__ */new Vector3();\nconst _triangle = /* @__PURE__ */new Triangle();\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  setFromPoints(points) {\n    if (points.length >= 4) {\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this.compute();\n    }\n    return this;\n  }\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n      if (geometry !== void 0) {\n        const attribute = geometry.attributes.position;\n        if (attribute !== void 0) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n  containsPoint(point) {\n    const faces = this.faces;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n    return true;\n  }\n  intersectRay(ray, target) {\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n      if (vN > 0 && vD >= 0) return null;\n      const t = vD !== 0 ? -vN / vD : 0;\n      if (t <= 0) continue;\n      if (vD > 0) {\n        tFar = Math.min(t, tFar);\n      } else {\n        tNear = Math.max(t, tNear);\n      }\n      if (tNear > tFar) {\n        return null;\n      }\n    }\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n    return target;\n  }\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  }\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n    face.outside = vertex;\n    return this;\n  }\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      if (vertex.next !== null && vertex.next.face === face) {\n        face.outside = vertex.next;\n      } else {\n        face.outside = null;\n      }\n    }\n    this.assigned.remove(vertex);\n    return this;\n  }\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      const start = face.outside;\n      let end = face.outside;\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n      this.assigned.removeSubList(start, end);\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  }\n  // Removes all the visible vertices that 'face' is able to see\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n    if (faceVertices !== void 0) {\n      if (absorbingFace === void 0) {\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        let vertex = faceVertices;\n        do {\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n    return this;\n  }\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n      do {\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n            if (maxDistance > 1e3 * this.tolerance) break;\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n    return this;\n  }\n  // Computes the extremes of a simplex which will be the initial hull\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  }\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n    let maxDistance = 0;\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n    maxDistance = 0;\n    _line3.set(v0.point, v1.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n    maxDistance = -1;\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n    const faces = [];\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n    return this;\n  }\n  // Removes inactive faces\n  reindexFaces() {\n    const activeFaces = [];\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n    this.faces = activeFaces;\n    return this;\n  }\n  // Finds the next vertex to create faces with the current hull\n  nextVertexToAdd() {\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n        maxDistance = 0;\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n      return eyeVertex;\n    }\n  }\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      edge = crossEdge.next;\n    }\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          horizon.push(edge);\n        }\n      }\n      edge = edge.next;\n    } while (edge !== crossEdge);\n    return this;\n  }\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0);\n  }\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  }\n  // Adds a vertex to the hull\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon);\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n  compute() {\n    let vertex;\n    this.computeInitialHull();\n    while ((vertex = this.nextVertexToAdd()) !== void 0) {\n      this.addVertexToHull(vertex);\n    }\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n}\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n    face.edge = e0;\n    return face.compute();\n  }\n  getEdge(i) {\n    let edge = this.edge;\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n    return edge;\n  }\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n    _triangle.set(a.point, b.point, c.point);\n    _triangle.getNormal(this.normal);\n    _triangle.getMidpoint(this.midpoint);\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n}\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  head() {\n    return this.vertex;\n  }\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n    return -1;\n  }\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n    return -1;\n  }\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n}\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null;\n  }\n}\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.tail;\n  }\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  }\n  // Inserts a vertex before the target vertex\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n    target.prev = vertex;\n    return this;\n  }\n  // Inserts a vertex after the target vertex\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n    target.next = vertex;\n    return this;\n  }\n  // Appends a vertex to the end of the linked list\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    vertex.next = null;\n    this.tail = vertex;\n    return this;\n  }\n  // Appends a chain of vertices where 'vertex' is the head.\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n    this.tail = vertex;\n    return this;\n  }\n  // Removes a vertex from the linked list\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n    return this;\n  }\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n    return this;\n  }\n  isEmpty() {\n    return this.head === null;\n  }\n}\nexport { ConvexHull, Face, HalfEdge, VertexList, VertexNode };","map":{"version":3,"names":["Vector3","Line3","Plane","Triangle","Visible","Deleted","_v1","_line3","_plane","_closestPoint","_triangle","ConvexHull","constructor","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","setFromPoints","points","length","makeEmpty","i","l","push","VertexNode","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","face","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","vertex","outside","append","insertBefore","removeVertexFromFace","next","remove","removeAllVerticesFromFace","start","end","removeSubList","prev","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","computeExtremes","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","extremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","addAdjoiningFace","horizonEdge","tail","head","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","midpoint","area","constant","a","b","c","e0","HalfEdge","e1","e2","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/math/ConvexHull.js"],"sourcesContent":["import { Vector3, Line3, Plane, Triangle } from \"three\";\nconst Visible = 0;\nconst Deleted = 1;\nconst _v1 = /* @__PURE__ */ new Vector3();\nconst _line3 = /* @__PURE__ */ new Line3();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _closestPoint = /* @__PURE__ */ new Vector3();\nconst _triangle = /* @__PURE__ */ new Triangle();\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  setFromPoints(points) {\n    if (points.length >= 4) {\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this.compute();\n    }\n    return this;\n  }\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function(node) {\n      const geometry = node.geometry;\n      if (geometry !== void 0) {\n        const attribute = geometry.attributes.position;\n        if (attribute !== void 0) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n  containsPoint(point) {\n    const faces = this.faces;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      if (face.distanceToPoint(point) > this.tolerance)\n        return false;\n    }\n    return true;\n  }\n  intersectRay(ray, target) {\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n      if (vN > 0 && vD >= 0)\n        return null;\n      const t = vD !== 0 ? -vN / vD : 0;\n      if (t <= 0)\n        continue;\n      if (vD > 0) {\n        tFar = Math.min(t, tFar);\n      } else {\n        tNear = Math.max(t, tNear);\n      }\n      if (tNear > tFar) {\n        return null;\n      }\n    }\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n    return target;\n  }\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  }\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n    face.outside = vertex;\n    return this;\n  }\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      if (vertex.next !== null && vertex.next.face === face) {\n        face.outside = vertex.next;\n      } else {\n        face.outside = null;\n      }\n    }\n    this.assigned.remove(vertex);\n    return this;\n  }\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      const start = face.outside;\n      let end = face.outside;\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n      this.assigned.removeSubList(start, end);\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  }\n  // Removes all the visible vertices that 'face' is able to see\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n    if (faceVertices !== void 0) {\n      if (absorbingFace === void 0) {\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        let vertex = faceVertices;\n        do {\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n    return this;\n  }\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n      do {\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n            if (maxDistance > 1e3 * this.tolerance)\n              break;\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n    return this;\n  }\n  // Computes the extremes of a simplex which will be the initial hull\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return { min: minVertices, max: maxVertices };\n  }\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n    let maxDistance = 0;\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n    maxDistance = 0;\n    _line3.set(v0.point, v1.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n    maxDistance = -1;\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n    const faces = [];\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n    return this;\n  }\n  // Removes inactive faces\n  reindexFaces() {\n    const activeFaces = [];\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n    this.faces = activeFaces;\n    return this;\n  }\n  // Finds the next vertex to create faces with the current hull\n  nextVertexToAdd() {\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex, maxDistance = 0;\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n      return eyeVertex;\n    }\n  }\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      edge = crossEdge.next;\n    }\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          horizon.push(edge);\n        }\n      }\n      edge = edge.next;\n    } while (edge !== crossEdge);\n    return this;\n  }\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0);\n  }\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  }\n  // Adds a vertex to the hull\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon);\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n  compute() {\n    let vertex;\n    this.computeInitialHull();\n    while ((vertex = this.nextVertexToAdd()) !== void 0) {\n      this.addVertexToHull(vertex);\n    }\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n}\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n    face.edge = e0;\n    return face.compute();\n  }\n  getEdge(i) {\n    let edge = this.edge;\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n    return edge;\n  }\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n    _triangle.set(a.point, b.point, c.point);\n    _triangle.getNormal(this.normal);\n    _triangle.getMidpoint(this.midpoint);\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n}\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  head() {\n    return this.vertex;\n  }\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n    return -1;\n  }\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n    return -1;\n  }\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n}\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null;\n  }\n}\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.tail;\n  }\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  }\n  // Inserts a vertex before the target vertex\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n    target.prev = vertex;\n    return this;\n  }\n  // Inserts a vertex after the target vertex\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n    target.next = vertex;\n    return this;\n  }\n  // Appends a vertex to the end of the linked list\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    vertex.next = null;\n    this.tail = vertex;\n    return this;\n  }\n  // Appends a chain of vertices where 'vertex' is the head.\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n    this.tail = vertex;\n    return this;\n  }\n  // Removes a vertex from the linked list\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n    return this;\n  }\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n    return this;\n  }\n  isEmpty() {\n    return this.head === null;\n  }\n}\nexport {\n  ConvexHull,\n  Face,\n  HalfEdge,\n  VertexList,\n  VertexNode\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}