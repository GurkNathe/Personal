{"ast":null,"code":"import { syncBoundedLevenshtein } from '../components/levenshtein.js';\nimport { getOwnProperty, syncUniqueId } from '../utils.js';\n/* c8 ignore next 5 */\nfunction serialize() {\n  const {\n    word,\n    subWord,\n    children,\n    docs,\n    end\n  } = this;\n  return {\n    word,\n    subWord,\n    children,\n    docs,\n    end\n  };\n}\nfunction updateParent(node, parent) {\n  node.parent = parent.id;\n  node.word = parent.word + node.subWord;\n}\nfunction addDocument(node, docID) {\n  node.docs.push(docID);\n}\nfunction removeDocument(node, docID) {\n  const index = node.docs.indexOf(docID);\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false;\n  }\n  node.docs.splice(index, 1);\n  return true;\n}\nfunction findAllWords(node, output, term, exact, tolerance) {\n  if (node.end) {\n    const {\n      word,\n      docs: docIDs\n    } = node;\n    if (exact && word !== term) {\n      return {};\n    }\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - word.length);\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = [];\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = [];\n      }\n    }\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      const docs = new Set(output[word]);\n      const docIDsLength = docIDs.length;\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i]);\n      }\n      output[word] = Array.from(docs);\n    }\n  }\n  // recursively search the children\n  for (const character of Object.keys(node.children)) {\n    findAllWords(node.children[character], output, term, exact, tolerance);\n  }\n  return output;\n}\nfunction getCommonPrefix(a, b) {\n  let commonPrefix = '';\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix;\n    }\n    commonPrefix += a[i];\n  }\n  return commonPrefix;\n}\nexport function create() {\n  let end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let subWord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  const node = {\n    id: syncUniqueId(),\n    key,\n    subWord,\n    parent: null,\n    children: {},\n    docs: [],\n    end,\n    word: ''\n  };\n  Object.defineProperty(node, 'toJSON', {\n    value: serialize\n  });\n  return node;\n}\nexport function insert(root, word, docId) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i];\n    const wordAtIndex = word.substring(i);\n    const rootChildCurrentChar = root.children[currentCharacter];\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.subWord;\n      const edgeLabelLength = edgeLabel.length;\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);\n      const commonPrefixLength = commonPrefix.length;\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId);\n        rootChildCurrentChar.end = true;\n        return;\n      }\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        ;\n\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix];\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength);\n        newNodeChild.key = edgeLabelAtCommonPrefix;\n        root.children[currentCharacter] = newNode;\n        updateParent(newNode, root);\n        updateParent(newNodeChild, newNode);\n        addDocument(newNode, docId);\n        return;\n      }\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter);\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        root.children[currentCharacter] = inbetweenNode;\n        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix];\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength);\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix;\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);\n        addDocument(newNode, docId);\n        inbetweenNode.children[wordAtCommonPrefix] = newNode;\n        updateParent(inbetweenNode, root);\n        updateParent(newNode, inbetweenNode);\n        updateParent(inbetweenNodeChild, inbetweenNode);\n        return;\n      }\n      // skip to the next divergent character\n      i += edgeLabelLength - 1;\n      // navigate in the child node\n      root = rootChildCurrentChar;\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter);\n      addDocument(newNode, docId);\n      root.children[currentCharacter] = newNode;\n      updateParent(newNode, root);\n      return;\n    }\n  }\n}\nexport function find(root, _ref) {\n  let {\n    term,\n    exact,\n    tolerance\n  } = _ref;\n  // find the closest node to the term\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character];\n      const edgeLabel = rootChildCurrentChar.subWord;\n      const termSubstring = term.substring(i);\n      // find the common prefix between two words ex: prime and primate = prim\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      const commonPrefixLength = commonPrefix.length;\n      // if the common prefix lenght is equal to edgeLabel lenght (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break;\n        return {};\n      }\n      // skip the subword lenght and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1;\n      // navigate into the child node\n      root = rootChildCurrentChar;\n    } else {\n      return {};\n    }\n  }\n  const output = {};\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance);\n  return output;\n}\nexport function contains(root, term) {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.children) {\n      const rootChildrenChar = root.children[character];\n      const edgeLabel = rootChildrenChar.subWord;\n      const termSubstring = term.substring(i);\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      const commonPrefixLength = commonPrefix.length;\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false;\n      }\n      i += rootChildrenChar.subWord.length - 1;\n      root = rootChildrenChar;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nexport function removeWord(root, term) {\n  if (!term) {\n    return false;\n  }\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    const parent = root;\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1;\n      root = root.children[character];\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key];\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nexport function removeDocumentByWord(root, term, docID) {\n  let exact = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (!term) {\n    return true;\n  }\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character];\n      i += rootChildCurrentChar.subWord.length - 1;\n      root = rootChildCurrentChar;\n      if (exact && root.word !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID);\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["syncBoundedLevenshtein","getOwnProperty","syncUniqueId","serialize","word","subWord","children","docs","end","updateParent","node","parent","id","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","Set","docIDsLength","i","add","Array","from","character","Object","keys","getCommonPrefix","a","b","commonPrefix","len","min","create","arguments","undefined","key","defineProperty","value","insert","root","docId","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","find","_ref","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { Nullable } from '../types.js'\nimport { getOwnProperty, syncUniqueId } from '../utils.js'\n\nexport interface Node {\n  id: string\n  key: string\n  subWord: string\n  parent: Nullable<string>\n  children: Record<string, Node>\n  docs: string[]\n  end: boolean\n  word: string\n}\n\ntype FindParams = {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, string[]>\n\n/* c8 ignore next 5 */\nfunction serialize(this: Node): object {\n  const { word, subWord, children, docs, end } = this\n\n  return { word, subWord, children, docs, end }\n}\n\nfunction updateParent(node: Node, parent: Node): void {\n  node.parent = parent.id\n  node.word = parent.word + node.subWord\n}\n\nfunction addDocument(node: Node, docID: string): void {\n  node.docs.push(docID)\n}\n\nfunction removeDocument(node: Node, docID: string): boolean {\n  const index = node.docs.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.docs.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords(node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.end) {\n    const { word, docs: docIDs } = node\n\n    if (exact && word !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - word.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = []\n      }\n    }\n\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      const docs = new Set(output[word])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[word] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.children)) {\n    findAllWords(node.children[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix(a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create(end = false, subWord = '', key = ''): Node {\n  const node = {\n    id: syncUniqueId(),\n    key,\n    subWord,\n    parent: null,\n    children: {},\n    docs: [],\n    end,\n    word: '',\n  }\n\n  Object.defineProperty(node, 'toJSON', { value: serialize })\n  return node\n}\n\nexport function insert(root: Node, word: string, docId: string) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.children[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.subWord\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.end = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix]\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.key = edgeLabelAtCommonPrefix\n\n        root.children[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.children[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.children[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.children[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nexport function find(root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // find the closest node to the term\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      const edgeLabel = rootChildCurrentChar.subWord\n      const termSubstring = term.substring(i)\n\n      // find the common prefix between two words ex: prime and primate = prim\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n      // if the common prefix lenght is equal to edgeLabel lenght (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break\n        return {}\n      }\n\n      // skip the subword lenght and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1\n      // navigate into the child node\n      root = rootChildCurrentChar\n    } else {\n      return {}\n    }\n  }\n\n  const output: FindResult = {}\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance)\n\n  return output\n}\n\nexport function contains(root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.children) {\n      const rootChildrenChar = root.children[character]\n      const edgeLabel = rootChildrenChar.subWord\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.subWord.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord(root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1\n      root = root.children[character]\n\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord(root: Node, term: string, docID: string, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      i += rootChildCurrentChar.subWord.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.word !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}