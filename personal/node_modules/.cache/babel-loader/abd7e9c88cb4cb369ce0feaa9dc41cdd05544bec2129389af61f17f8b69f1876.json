{"ast":null,"code":"import _slicedToArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _assertThisInitialized from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\nvar HTMLMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(HTMLMesh, _Mesh);\n  var _super = _createSuper(HTMLMesh);\n  function HTMLMesh(dom) {\n    var _this;\n    _classCallCheck(this, HTMLMesh);\n    var texture = new HTMLTexture(dom);\n    var geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    var material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    _this = _super.call(this, geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    _this.addEventListener(\"mousedown\", onEvent);\n    _this.addEventListener(\"mousemove\", onEvent);\n    _this.addEventListener(\"mouseup\", onEvent);\n    _this.addEventListener(\"click\", onEvent);\n    _this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n    return _this;\n  }\n  return _createClass(HTMLMesh);\n}(Mesh);\nvar HTMLTexture = /*#__PURE__*/function (_CanvasTexture) {\n  _inherits(HTMLTexture, _CanvasTexture);\n  var _super2 = _createSuper(HTMLTexture);\n  function HTMLTexture(dom) {\n    var _this2;\n    _classCallCheck(this, HTMLTexture);\n    _this2 = _super2.call(this, html2canvas(dom));\n    _this2.dom = dom;\n    _this2.anisotropy = 16;\n    if (\"colorSpace\" in _assertThisInitialized(_this2)) _this2.colorSpace = \"srgb\";else _this2.encoding = 3001;\n    _this2.minFilter = LinearFilter;\n    _this2.magFilter = LinearFilter;\n    var observer = new MutationObserver(function () {\n      if (!_this2.scheduleUpdate) {\n        _this2.scheduleUpdate = setTimeout(function () {\n          return _this2.update();\n        }, 16);\n      }\n    });\n    var config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    _this2.observer = observer;\n    return _this2;\n  }\n  _createClass(HTMLTexture, [{\n    key: \"dispatchDOMEvent\",\n    value: function dispatchDOMEvent(event) {\n      if (event.data) {\n        htmlevent(this.dom, event.type, event.data.x, event.data.y);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.image = html2canvas(this.dom);\n      this.needsUpdate = true;\n      this.scheduleUpdate = null;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.observer) {\n        this.observer.disconnect();\n      }\n      this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n      _get(_getPrototypeOf(HTMLTexture.prototype), \"dispose\", this).call(this);\n    }\n  }]);\n  return HTMLTexture;\n}(CanvasTexture);\nvar canvases = /* @__PURE__ */new WeakMap();\nfunction html2canvas(element) {\n  var range = document.createRange();\n  var color = new Color();\n  function Clipper(context2) {\n    var clips = [];\n    var isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n      if (clips.length === 0) return;\n      var minX = -Infinity,\n        minY = -Infinity;\n      var maxX = Infinity,\n        maxY = Infinity;\n      for (var i = 0; i < clips.length; i++) {\n        var clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n    return {\n      add: function add(clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function remove() {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    var borderWidth = style[which + \"Width\"];\n    var borderStyle = style[which + \"Style\"];\n    var borderColor = style[which + \"Color\"];\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element2, style) {\n    var x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      var rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\") return;\n      context.save();\n      var dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\") return;\n      var _rect = element2.getBoundingClientRect();\n      x = _rect.left - offset.left - 0.5;\n      y = _rect.top - offset.top - 0.5;\n      width = _rect.width;\n      height = _rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      var backgroundColor = style.backgroundColor;\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n      var borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      var match = true;\n      var prevBorder = null;\n      for (var _i = 0, _borders = borders; _i < _borders.length; _i++) {\n        var border = _borders[_i];\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        var width2 = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n      if (element2 instanceof HTMLInputElement) {\n        var accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\") accentColor = style.color;\n        color.set(accentColor);\n        var luminance = Math.sqrt(0.299 * Math.pow(color.r, 2) + 0.587 * Math.pow(color.g, 2) + 0.114 * Math.pow(color.b, 2));\n        var accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element2.checked) {\n            var currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            var properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"✔\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element2.type === \"range\") {\n          var _map = [\"min\", \"max\", \"value\"].map(function (property) {\n              return parseFloat(element2[property]);\n            }),\n            _map2 = _slicedToArray(_map, 3),\n            min = _map2[0],\n            max = _map2[1],\n            value = _map2[2];\n          var position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n    var isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n    for (var i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  var offset = element.getBoundingClientRect();\n  var canvas = canvases.get(element);\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  var context = canvas.getContext(\"2d\"\n  /*, { alpha: false }*/);\n\n  var clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  var mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  var rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      var rect2 = element2.getBoundingClientRect();\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          var _map3 = [\"min\", \"max\"].map(function (property) {\n              return parseFloat(element2[property]);\n            }),\n            _map4 = _slicedToArray(_map3, 2),\n            min = _map4[0],\n            max = _map4[1];\n          var width = rect2.width;\n          var offsetX = x - rect2.x;\n          var proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", {\n            bubbles: true\n          }));\n        }\n      }\n      for (var i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":{"version":3,"names":["Mesh","PlaneGeometry","MeshBasicMaterial","CanvasTexture","LinearFilter","Color","HTMLMesh","_Mesh","_inherits","_super","_createSuper","dom","_this","_classCallCheck","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","call","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","_createClass","_CanvasTexture","_super2","_this2","html2canvas","anisotropy","_assertThisInitialized","colorSpace","encoding","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","key","value","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","_get","_getPrototypeOf","prototype","WeakMap","element","range","document","createRange","color","Clipper","context2","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","context","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","element2","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","_i","_borders","border","width2","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","set","luminance","sqrt","pow","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","_map","property","_map2","_slicedToArray","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","rect2","right","bottom","_map3","_map4","offsetX","proportion","InputEvent","bubbles"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/interactive/HTMLMesh.js"],"sourcesContent":["import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    const material = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true });\n    super(geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    this.addEventListener(\"mousedown\", onEvent);\n    this.addEventListener(\"mousemove\", onEvent);\n    this.addEventListener(\"mouseup\", onEvent);\n    this.addEventListener(\"click\", onEvent);\n    this.dispose = function() {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n  }\n}\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    if (\"colorSpace\" in this)\n      this.colorSpace = \"srgb\";\n    else\n      this.encoding = 3001;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter;\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = { attributes: true, childList: true, subtree: true, characterData: true };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n}\nconst canvases = /* @__PURE__ */ new WeakMap();\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n  function Clipper(context2) {\n    const clips = [];\n    let isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n      if (clips.length === 0)\n        return;\n      let minX = -Infinity, minY = -Infinity;\n      let maxX = Infinity, maxY = Infinity;\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n    return {\n      add: function(clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function() {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r)\n      r = w / 2;\n    if (h < 2 * r)\n      r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + \"Width\"];\n    const borderStyle = style[which + \"Style\"];\n    const borderColor = style[which + \"Color\"];\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element2, style) {\n    let x = 0, y = 0, width = 0, height = 0;\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\")\n        return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\")\n        return;\n      const rect = element2.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n      const borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      let match = true;\n      let prevBorder = null;\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n        if (match === false)\n          break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        const width2 = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n      if (element2 instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\")\n          accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element2.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"✔\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element2.type === \"range\") {\n          const [min, max, value] = [\"min\", \"max\", \"value\"].map((property) => parseFloat(element2[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({ x, y, width, height });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n    const isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping)\n      clipper.add({ x, y, width, height });\n    for (let i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n    if (isClipping)\n      clipper.remove();\n  }\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  const context = canvas.getContext(\n    \"2d\"\n    /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      const rect2 = element2.getBoundingClientRect();\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          const [min, max] = [\"min\", \"max\"].map((property) => parseFloat(element2[property]));\n          const width = rect2.width;\n          const offsetX = x - rect2.x;\n          const proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", { bubbles: true }));\n        }\n      }\n      for (let i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport {\n  HTMLMesh\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}