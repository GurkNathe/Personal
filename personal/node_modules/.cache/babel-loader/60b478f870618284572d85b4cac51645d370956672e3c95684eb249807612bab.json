{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { strToU8, zipSync } from \"fflate\";\nimport { Mesh, MeshPhysicalMaterial } from \"three\";\nclass USDZExporter {\n  constructor() {\n    __publicField(this, \"PRECISION\", 7);\n    __publicField(this, \"materials\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"files\");\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n  async parse(scene) {\n    const modelFileName = \"model.usda\";\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible(object => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = \"geometries/Geometry_\" + geometry.id + \".usd\";\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split(\"_\")[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(resolve => canvas == null ? void 0 : canvas.toBlob(resolve, isRGBA ? \"image/png\" : \"image/jpeg\", 1));\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? \"png\" : \"jpg\"}`] = new Uint8Array(await blob.arrayBuffer());\n      }\n    }\n    let offset = 0;\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      if (file && typeof file.length === \"number\") {\n        offset = file.length;\n      }\n    }\n    return zipSync(this.files, {\n      level: 0\n    });\n  }\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== \"undefined\" && image instanceof OffscreenCanvas || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext(\"2d\");\n      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n      if (color !== void 0) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context == null ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n        if (imagedata) {\n          const data = imagedata == null ? void 0 : imagedata.data;\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n          context == null ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n      return canvas;\n    }\n  }\n  buildHeader() {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`;\n  }\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  }\n  // Xform\n  buildXform(object, geometry, material) {\n    const name = \"Object_\" + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn(\"THREE.USDZExporter: USDZ does not support negative scales\", object);\n    }\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`;\n  }\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(array, 8)}, ${this.buildMatrixRow(array, 12)} )`;\n  }\n  buildMatrixRow(array, offset) {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n  }\n  // Mesh\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n  }\n  buildMesh(geometry) {\n    const name = \"Geometry\";\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n  }\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(\", \");\n  }\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      return geometry.index.array.join(\", \");\n    }\n    const array = [];\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n    return array.join(\", \");\n  }\n  buildVector3Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: Normals missing.\");\n      return Array(count).fill(\"(0, 0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[i + 2].toPrecision(this.PRECISION)})`);\n    }\n    return array.join(\", \");\n  }\n  buildVector2Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: UVs missing.\");\n      return Array(count).fill(\"(0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 2) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`);\n    }\n    return array.join(\", \");\n  }\n  // Materials\n  buildMaterials(materials) {\n    const array = [];\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n    return `def \"Materials\"\n{\n${array.join(\"\")}\n}\n`;\n  }\n  buildMaterial(material) {\n    const pad = \"            \";\n    const inputs = [];\n    const samplers = [];\n    if (material.map !== null) {\n      inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.map, \"diffuse\", material.color));\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`);\n    }\n    if (material.emissiveMap !== null) {\n      inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.emissiveMap, \"emissive\"));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`);\n    }\n    if (material.normalMap !== null) {\n      inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.normalMap, \"normal\"));\n    }\n    if (material.aoMap !== null) {\n      inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n      samplers.push(this.buildTexture(material, material.aoMap, \"occlusion\"));\n    }\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n      samplers.push(this.buildTexture(material, material.roughnessMap, \"roughness\"));\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n    }\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n      samplers.push(this.buildTexture(material, material.metalnessMap, \"metallic\"));\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n    }\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n    }\n    return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join(\"\\n\")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join(\"\\n\")}\n    }\n`;\n  }\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? \"_\" + color.getHexString() : \"\");\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? \"png\" : \"jpg\"}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n      }`;\n  }\n  buildColor(color) {\n    return `(${color.r}, ${color.g}, ${color.b})`;\n  }\n  buildVector2(vector) {\n    return `(${vector.x}, ${vector.y})`;\n  }\n}\nexport { USDZExporter };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","strToU8","zipSync","Mesh","MeshPhysicalMaterial","USDZExporter","constructor","materials","textures","files","parse","scene","modelFileName","output","buildHeader","traverseVisible","object","isMesh","material","isMeshStandardMaterial","geometry","geometryFileName","id","meshObject","buildMeshObject","buildUSDFileAsString","uuid","buildXform","buildMaterials","texture","color","split","isRGBA","format","canvas","imageToCanvas","image","blob","Promise","resolve","toBlob","Uint8Array","arrayBuffer","offset","filename","file","headerSize","length","offsetMod64","padLength","padding","extra","level","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","scale","Math","max","width","height","document","createElement","min","context","getContext","drawImage","hex","parseInt","r","g","b","imagedata","getImageData","data","i","putImageData","dataToInsert","name","transform","buildMatrix","matrixWorld","determinant","console","warn","matrix","array","elements","buildMatrixRow","mesh","buildMesh","attributes","count","position","buildMeshVertexCount","buildMeshVertexIndices","buildVector3Array","normal","buildVector2Array","uv","index","Array","fill","join","push","attribute","toPrecision","PRECISION","buildMaterial","pad","inputs","samplers","map","buildTexture","buildColor","emissiveMap","emissive","getHex","normalMap","aoMap","roughnessMap","roughness","metalnessMap","metalness","opacity","clearcoat","clearcoatRoughness","ior","mapType","getHexString","buildVector2","repeat","vector","x","y"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/exporters/USDZExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { strToU8, zipSync } from \"fflate\";\nimport { Mesh, MeshPhysicalMaterial } from \"three\";\nclass USDZExporter {\n  constructor() {\n    __publicField(this, \"PRECISION\", 7);\n    __publicField(this, \"materials\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"files\");\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n  async parse(scene) {\n    const modelFileName = \"model.usda\";\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible((object) => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = \"geometries/Geometry_\" + geometry.id + \".usd\";\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split(\"_\")[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(\n        (resolve) => canvas == null ? void 0 : canvas.toBlob(resolve, isRGBA ? \"image/png\" : \"image/jpeg\", 1)\n      );\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? \"png\" : \"jpg\"}`] = new Uint8Array(await blob.arrayBuffer());\n      }\n    }\n    let offset = 0;\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, { extra: { 12345: padding } }];\n      }\n      if (file && typeof file.length === \"number\") {\n        offset = file.length;\n      }\n    }\n    return zipSync(this.files, { level: 0 });\n  }\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== \"undefined\" && image instanceof OffscreenCanvas || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext(\"2d\");\n      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n      if (color !== void 0) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context == null ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n        if (imagedata) {\n          const data = imagedata == null ? void 0 : imagedata.data;\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n          context == null ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n      return canvas;\n    }\n  }\n  buildHeader() {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`;\n  }\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  }\n  // Xform\n  buildXform(object, geometry, material) {\n    const name = \"Object_\" + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn(\"THREE.USDZExporter: USDZ does not support negative scales\", object);\n    }\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`;\n  }\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(\n      array,\n      8\n    )}, ${this.buildMatrixRow(array, 12)} )`;\n  }\n  buildMatrixRow(array, offset) {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n  }\n  // Mesh\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n  }\n  buildMesh(geometry) {\n    const name = \"Geometry\";\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n  }\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(\", \");\n  }\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      return geometry.index.array.join(\", \");\n    }\n    const array = [];\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n    return array.join(\", \");\n  }\n  buildVector3Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: Normals missing.\");\n      return Array(count).fill(\"(0, 0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(\n        `(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[i + 2].toPrecision(this.PRECISION)})`\n      );\n    }\n    return array.join(\", \");\n  }\n  buildVector2Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: UVs missing.\");\n      return Array(count).fill(\"(0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 2) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`);\n    }\n    return array.join(\", \");\n  }\n  // Materials\n  buildMaterials(materials) {\n    const array = [];\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n    return `def \"Materials\"\n{\n${array.join(\"\")}\n}\n`;\n  }\n  buildMaterial(material) {\n    const pad = \"            \";\n    const inputs = [];\n    const samplers = [];\n    if (material.map !== null) {\n      inputs.push(\n        `${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`\n      );\n      samplers.push(this.buildTexture(material, material.map, \"diffuse\", material.color));\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`);\n    }\n    if (material.emissiveMap !== null) {\n      inputs.push(\n        `${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`\n      );\n      samplers.push(this.buildTexture(material, material.emissiveMap, \"emissive\"));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`);\n    }\n    if (material.normalMap !== null) {\n      inputs.push(\n        `${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`\n      );\n      samplers.push(this.buildTexture(material, material.normalMap, \"normal\"));\n    }\n    if (material.aoMap !== null) {\n      inputs.push(\n        `${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`\n      );\n      samplers.push(this.buildTexture(material, material.aoMap, \"occlusion\"));\n    }\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(\n        `${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`\n      );\n      samplers.push(this.buildTexture(material, material.roughnessMap, \"roughness\"));\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n    }\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(\n        `${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`\n      );\n      samplers.push(this.buildTexture(material, material.metalnessMap, \"metallic\"));\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n    }\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n    }\n    return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join(\"\\n\")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join(\"\\n\")}\n    }\n`;\n  }\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? \"_\" + color.getHexString() : \"\");\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? \"png\" : \"jpg\"}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n      }`;\n  }\n  buildColor(color) {\n    return `(${color.r}, ${color.g}, ${color.b})`;\n  }\n  buildVector2(vector) {\n    return `(${vector.x}, ${vector.y})`;\n  }\n}\nexport {\n  USDZExporter\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}