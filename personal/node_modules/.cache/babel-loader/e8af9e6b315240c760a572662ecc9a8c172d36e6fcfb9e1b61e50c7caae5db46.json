{"ast":null,"code":"import { Color, MathUtils } from \"three\";\nclass Lut {\n  constructor(colormap) {\n    let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n  setColorMap(colormap) {\n    let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j + 1][1], \"linear-srgb\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j][1], \"linear-srgb\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],\n  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],\n  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],\n  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]\n};\nexport { ColorMapKeywords, Lut };","map":{"version":3,"names":["Color","MathUtils","Lut","constructor","colormap","count","arguments","length","undefined","isLut","lut","map","n","minV","maxV","setColorMap","set","value","copy","setMin","min","setMax","max","ColorMapKeywords","rainbow","step","minColor","maxColor","push","i","alpha","j","setHex","color","lerpColors","getColor","clamp","colorPosition","Math","round","addColorMap","name","arrayOfColors","createCanvas","canvas","document","createElement","width","height","updateCanvas","ctx","getContext","imageData","getImageData","data","k","finalColor","r","g","b","putImageData","cooltowarm","blackbody","grayscale"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/math/Lut.js"],"sourcesContent":["import { Color, MathUtils } from \"three\";\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j + 1][1], \"linear-srgb\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", { alpha: false });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j][1], \"linear-srgb\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  rainbow: [\n    [0, 255],\n    [0.2, 65535],\n    [0.5, 65280],\n    [0.8, 16776960],\n    [1, 16711680]\n  ],\n  cooltowarm: [\n    [0, 3952322],\n    [0.2, 10206463],\n    [0.5, 14474460],\n    [0.8, 16163717],\n    [1, 11797542]\n  ],\n  blackbody: [\n    [0, 0],\n    [0.2, 7864320],\n    [0.5, 15086080],\n    [0.8, 16776960],\n    [1, 16777215]\n  ],\n  grayscale: [\n    [0, 0],\n    [0.2, 4210752],\n    [0.5, 8355712],\n    [0.8, 12566463],\n    [1, 16777215]\n  ]\n};\nexport {\n  ColorMapKeywords,\n  Lut\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}