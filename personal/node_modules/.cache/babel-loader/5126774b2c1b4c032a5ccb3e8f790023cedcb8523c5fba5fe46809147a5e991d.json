{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\nvar IFFParser = /*#__PURE__*/function () {\n  function IFFParser() {\n    _classCallCheck(this, IFFParser);\n    this.debugger = new Debugger();\n  }\n  _createClass(IFFParser, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      this.reader = new DataViewReader(buffer);\n      this.tree = {\n        materials: {},\n        layers: [],\n        tags: [],\n        textures: []\n      };\n      this.currentLayer = this.tree;\n      this.currentForm = this.tree;\n      this.parseTopForm();\n      if (this.tree.format === void 0) return;\n      if (this.tree.format === \"LWO2\") {\n        this.parser = new LWO2Parser(this);\n        while (!this.reader.endOfFile()) this.parser.parseBlock();\n      } else if (this.tree.format === \"LWO3\") {\n        this.parser = new LWO3Parser(this);\n        while (!this.reader.endOfFile()) this.parser.parseBlock();\n      }\n      this.debugger.offset = this.reader.offset;\n      this.debugger.closeForms();\n      return this.tree;\n    }\n  }, {\n    key: \"parseTopForm\",\n    value: function parseTopForm() {\n      this.debugger.offset = this.reader.offset;\n      var topForm = this.reader.getIDTag();\n      if (topForm !== \"FORM\") {\n        console.warn(\"LWOLoader: Top-level FORM missing.\");\n        return;\n      }\n      var length = this.reader.getUint32();\n      this.debugger.dataOffset = this.reader.offset;\n      this.debugger.length = length;\n      var type = this.reader.getIDTag();\n      if (type === \"LWO2\") {\n        this.tree.format = type;\n      } else if (type === \"LWO3\") {\n        this.tree.format = type;\n      }\n      this.debugger.node = 0;\n      this.debugger.nodeID = type;\n      this.debugger.log();\n      return;\n    }\n    ///\n    // FORM PARSING METHODS\n    ///\n    // Forms are organisational and can contain any number of sub chunks and sub forms\n    // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  }, {\n    key: \"parseForm\",\n    value: function parseForm(length) {\n      var type = this.reader.getIDTag();\n      switch (type) {\n        case \"ISEQ\":\n        case \"ANIM\":\n        case \"STCC\":\n        case \"VPVL\":\n        case \"VPRM\":\n        case \"NROT\":\n        case \"WRPW\":\n        case \"WRPH\":\n        case \"FUNC\":\n        case \"FALL\":\n        case \"OPAC\":\n        case \"GRAD\":\n        case \"ENVS\":\n        case \"VMOP\":\n        case \"VMBG\":\n        case \"OMAX\":\n        case \"STEX\":\n        case \"CKBG\":\n        case \"CKEY\":\n        case \"VMLA\":\n        case \"VMLB\":\n          this.debugger.skipped = true;\n          this.skipForm(length);\n          break;\n        case \"META\":\n        case \"NNDS\":\n        case \"NODS\":\n        case \"NDTA\":\n        case \"ADAT\":\n        case \"AOVS\":\n        case \"BLOK\":\n        case \"IBGC\":\n        case \"IOPC\":\n        case \"IIMG\":\n        case \"TXTR\":\n          this.debugger.length = 4;\n          this.debugger.skipped = true;\n          break;\n        case \"IFAL\":\n        case \"ISCL\":\n        case \"IPOS\":\n        case \"IROT\":\n        case \"IBMP\":\n        case \"IUTD\":\n        case \"IVTD\":\n          this.parseTextureNodeAttribute(type);\n          break;\n        case \"ENVL\":\n          this.parseEnvelope(length);\n          break;\n        case \"CLIP\":\n          if (this.tree.format === \"LWO2\") {\n            this.parseForm(length);\n          } else {\n            this.parseClip(length);\n          }\n          break;\n        case \"STIL\":\n          this.parseImage();\n          break;\n        case \"XREF\":\n          this.reader.skip(8);\n          this.currentForm.referenceTexture = {\n            index: this.reader.getUint32(),\n            refName: this.reader.getString()\n            // internal unique ref\n          };\n\n          break;\n        case \"IMST\":\n          this.parseImageStateForm(length);\n          break;\n        case \"SURF\":\n          this.parseSurfaceForm(length);\n          break;\n        case \"VALU\":\n          this.parseValueForm(length);\n          break;\n        case \"NTAG\":\n          this.parseSubNode(length);\n          break;\n        case \"ATTR\":\n        case \"SATR\":\n          this.setupForm(\"attributes\", length);\n          break;\n        case \"NCON\":\n          this.parseConnections(length);\n          break;\n        case \"SSHA\":\n          this.parentForm = this.currentForm;\n          this.currentForm = this.currentSurface;\n          this.setupForm(\"surfaceShader\", length);\n          break;\n        case \"SSHD\":\n          this.setupForm(\"surfaceShaderData\", length);\n          break;\n        case \"ENTR\":\n          this.parseEntryForm(length);\n          break;\n        case \"IMAP\":\n          this.parseImageMap(length);\n          break;\n        case \"TAMP\":\n          this.parseXVAL(\"amplitude\", length);\n          break;\n        case \"TMAP\":\n          this.setupForm(\"textureMap\", length);\n          break;\n        case \"CNTR\":\n          this.parseXVAL3(\"center\", length);\n          break;\n        case \"SIZE\":\n          this.parseXVAL3(\"scale\", length);\n          break;\n        case \"ROTA\":\n          this.parseXVAL3(\"rotation\", length);\n          break;\n        default:\n          this.parseUnknownForm(type, length);\n      }\n      this.debugger.node = 0;\n      this.debugger.nodeID = type;\n      this.debugger.log();\n    }\n  }, {\n    key: \"setupForm\",\n    value: function setupForm(type, length) {\n      if (!this.currentForm) this.currentForm = this.currentNode;\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n      if (!this.currentForm[type]) {\n        this.currentForm[type] = {};\n        this.currentForm = this.currentForm[type];\n      } else {\n        console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n        this.currentForm = this.currentForm[type];\n      }\n    }\n  }, {\n    key: \"skipForm\",\n    value: function skipForm(length) {\n      this.reader.skip(length - 4);\n    }\n  }, {\n    key: \"parseUnknownForm\",\n    value: function parseUnknownForm(type, length) {\n      console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n      printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n      this.reader.skip(length - 4);\n    }\n  }, {\n    key: \"parseSurfaceForm\",\n    value: function parseSurfaceForm(length) {\n      this.reader.skip(8);\n      var name = this.reader.getString();\n      var surface = {\n        attributes: {},\n        // LWO2 style non-node attributes will go here\n        connections: {},\n        name: name,\n        inputName: name,\n        nodes: {},\n        source: this.reader.getString()\n      };\n      this.tree.materials[name] = surface;\n      this.currentSurface = surface;\n      this.parentForm = this.tree.materials;\n      this.currentForm = surface;\n      this.currentFormEnd = this.reader.offset + length;\n    }\n  }, {\n    key: \"parseSurfaceLwo2\",\n    value: function parseSurfaceLwo2(length) {\n      var name = this.reader.getString();\n      var surface = {\n        attributes: {},\n        // LWO2 style non-node attributes will go here\n        connections: {},\n        name: name,\n        nodes: {},\n        source: this.reader.getString()\n      };\n      this.tree.materials[name] = surface;\n      this.currentSurface = surface;\n      this.parentForm = this.tree.materials;\n      this.currentForm = surface;\n      this.currentFormEnd = this.reader.offset + length;\n    }\n  }, {\n    key: \"parseSubNode\",\n    value: function parseSubNode(length) {\n      this.reader.skip(8);\n      var name = this.reader.getString();\n      var node = {\n        name: name\n      };\n      this.currentForm = node;\n      this.currentNode = node;\n      this.currentFormEnd = this.reader.offset + length;\n    }\n    // collect attributes from all nodes at the top level of a surface\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections(length) {\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n      this.currentForm = this.currentSurface.connections;\n    }\n    // surface node attribute data, e.g. specular, roughness etc\n  }, {\n    key: \"parseEntryForm\",\n    value: function parseEntryForm(length) {\n      this.reader.skip(8);\n      var name = this.reader.getString();\n      this.currentForm = this.currentNode.attributes;\n      this.setupForm(name, length);\n    }\n    // parse values from material - doesn't match up to other LWO3 data types\n    // sub form of entry form\n  }, {\n    key: \"parseValueForm\",\n    value: function parseValueForm() {\n      this.reader.skip(8);\n      var valueType = this.reader.getString();\n      if (valueType === \"double\") {\n        this.currentForm.value = this.reader.getUint64();\n      } else if (valueType === \"int\") {\n        this.currentForm.value = this.reader.getUint32();\n      } else if (valueType === \"vparam\") {\n        this.reader.skip(24);\n        this.currentForm.value = this.reader.getFloat64();\n      } else if (valueType === \"vparam3\") {\n        this.reader.skip(24);\n        this.currentForm.value = this.reader.getFloat64Array(3);\n      }\n    }\n    // holds various data about texture node image state\n    // Data other thanmipMapLevel unknown\n  }, {\n    key: \"parseImageStateForm\",\n    value: function parseImageStateForm() {\n      this.reader.skip(8);\n      this.currentForm.mipMapLevel = this.reader.getFloat32();\n    }\n    // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  }, {\n    key: \"parseImageMap\",\n    value: function parseImageMap(length) {\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n      if (!this.currentForm.maps) this.currentForm.maps = [];\n      var map = {};\n      this.currentForm.maps.push(map);\n      this.currentForm = map;\n      this.reader.skip(10);\n    }\n  }, {\n    key: \"parseTextureNodeAttribute\",\n    value: function parseTextureNodeAttribute(type) {\n      this.reader.skip(28);\n      this.reader.skip(20);\n      switch (type) {\n        case \"ISCL\":\n          this.currentNode.scale = this.reader.getFloat32Array(3);\n          break;\n        case \"IPOS\":\n          this.currentNode.position = this.reader.getFloat32Array(3);\n          break;\n        case \"IROT\":\n          this.currentNode.rotation = this.reader.getFloat32Array(3);\n          break;\n        case \"IFAL\":\n          this.currentNode.falloff = this.reader.getFloat32Array(3);\n          break;\n        case \"IBMP\":\n          this.currentNode.amplitude = this.reader.getFloat32();\n          break;\n        case \"IUTD\":\n          this.currentNode.uTiles = this.reader.getFloat32();\n          break;\n        case \"IVTD\":\n          this.currentNode.vTiles = this.reader.getFloat32();\n          break;\n      }\n      this.reader.skip(2);\n    }\n    // ENVL forms are currently ignored\n  }, {\n    key: \"parseEnvelope\",\n    value: function parseEnvelope(length) {\n      this.reader.skip(length - 4);\n    }\n    ///\n    // CHUNK PARSING METHODS\n    ///\n    // clips can either be defined inside a surface node, or at the top\n    // level and they have a different format in each case\n  }, {\n    key: \"parseClip\",\n    value: function parseClip(length) {\n      var tag = this.reader.getIDTag();\n      if (tag === \"FORM\") {\n        this.reader.skip(16);\n        this.currentNode.fileName = this.reader.getString();\n        return;\n      }\n      this.reader.setOffset(this.reader.offset - 4);\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n      this.reader.skip(8);\n      var texture = {\n        index: this.reader.getUint32()\n      };\n      this.tree.textures.push(texture);\n      this.currentForm = texture;\n    }\n  }, {\n    key: \"parseClipLwo2\",\n    value: function parseClipLwo2(length) {\n      var texture = {\n        index: this.reader.getUint32(),\n        fileName: \"\"\n      };\n      while (true) {\n        var tag = this.reader.getIDTag();\n        var n_length = this.reader.getUint16();\n        if (tag === \"STIL\") {\n          texture.fileName = this.reader.getString();\n          break;\n        }\n        if (n_length >= length) {\n          break;\n        }\n      }\n      this.tree.textures.push(texture);\n      this.currentForm = texture;\n    }\n  }, {\n    key: \"parseImage\",\n    value: function parseImage() {\n      this.reader.skip(8);\n      this.currentForm.fileName = this.reader.getString();\n    }\n  }, {\n    key: \"parseXVAL\",\n    value: function parseXVAL(type, length) {\n      var endOffset = this.reader.offset + length - 4;\n      this.reader.skip(8);\n      this.currentForm[type] = this.reader.getFloat32();\n      this.reader.setOffset(endOffset);\n    }\n  }, {\n    key: \"parseXVAL3\",\n    value: function parseXVAL3(type, length) {\n      var endOffset = this.reader.offset + length - 4;\n      this.reader.skip(8);\n      this.currentForm[type] = {\n        x: this.reader.getFloat32(),\n        y: this.reader.getFloat32(),\n        z: this.reader.getFloat32()\n      };\n      this.reader.setOffset(endOffset);\n    }\n    // Tags associated with an object\n    // OTAG { type[ID4], tag-string[S0] }\n  }, {\n    key: \"parseObjectTag\",\n    value: function parseObjectTag() {\n      if (!this.tree.objectTags) this.tree.objectTags = {};\n      this.tree.objectTags[this.reader.getIDTag()] = {\n        tagString: this.reader.getString()\n      };\n    }\n    // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n    // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  }, {\n    key: \"parseLayer\",\n    value: function parseLayer(length) {\n      var layer = {\n        number: this.reader.getUint16(),\n        flags: this.reader.getUint16(),\n        // If the least significant bit of flags is set, the layer is hidden.\n        pivot: this.reader.getFloat32Array(3),\n        // Note: this seems to be superflous, as the geometry is translated when pivot is present\n        name: this.reader.getString()\n      };\n      this.tree.layers.push(layer);\n      this.currentLayer = layer;\n      var parsedLength = 16 + stringOffset(this.currentLayer.name);\n      this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n    }\n    // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n    // Converting from left to right handed coordinate system:\n    // x -> -x and switch material FrontSide -> BackSide\n  }, {\n    key: \"parsePoints\",\n    value: function parsePoints(length) {\n      this.currentPoints = [];\n      for (var i = 0; i < length / 4; i += 3) {\n        this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n      }\n    }\n    // parse VMAP or VMAD\n    // Associates a set of floating-point vectors with a set of points.\n    // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n    // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n    // Similar to VMAP UVs, but associates with polygon vertices rather than points\n    // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n    // if they exist. The vector values in the VMAD will then replace those in the\n    // corresponding VMAP, but only for calculations involving the specified polygons.\n    // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  }, {\n    key: \"parseVertexMapping\",\n    value: function parseVertexMapping(length, discontinuous) {\n      var finalOffset = this.reader.offset + length;\n      var channelName = this.reader.getString();\n      if (this.reader.offset === finalOffset) {\n        this.currentForm.UVChannel = channelName;\n        return;\n      }\n      this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n      var type = this.reader.getIDTag();\n      this.reader.getUint16();\n      var name = this.reader.getString();\n      var remainingLength = length - 6 - stringOffset(name);\n      switch (type) {\n        case \"TXUV\":\n          this.parseUVMapping(name, finalOffset, discontinuous);\n          break;\n        case \"MORF\":\n        case \"SPOT\":\n          this.parseMorphTargets(name, finalOffset, type);\n          break;\n        case \"APSL\":\n        case \"NORM\":\n        case \"WGHT\":\n        case \"MNVW\":\n        case \"PICK\":\n        case \"RGB \":\n        case \"RGBA\":\n          this.reader.skip(remainingLength);\n          break;\n        default:\n          console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n          this.reader.skip(remainingLength);\n      }\n    }\n  }, {\n    key: \"parseUVMapping\",\n    value: function parseUVMapping(name, finalOffset, discontinuous) {\n      var uvIndices = [];\n      var polyIndices = [];\n      var uvs = [];\n      while (this.reader.offset < finalOffset) {\n        uvIndices.push(this.reader.getVariableLengthIndex());\n        if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n        uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n      }\n      if (discontinuous) {\n        if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n        this.currentLayer.discontinuousUVs[name] = {\n          uvIndices: uvIndices,\n          polyIndices: polyIndices,\n          uvs: uvs\n        };\n      } else {\n        if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n        this.currentLayer.uvs[name] = {\n          uvIndices: uvIndices,\n          uvs: uvs\n        };\n      }\n    }\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(name, finalOffset, type) {\n      var indices = [];\n      var points = [];\n      type = type === \"MORF\" ? \"relative\" : \"absolute\";\n      while (this.reader.offset < finalOffset) {\n        indices.push(this.reader.getVariableLengthIndex());\n        points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n      }\n      if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n      this.currentLayer.morphTargets[name] = {\n        indices: indices,\n        points: points,\n        type: type\n      };\n    }\n    // A list of polygons for the current layer.\n    // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  }, {\n    key: \"parsePolygonList\",\n    value: function parsePolygonList(length) {\n      var finalOffset = this.reader.offset + length;\n      var type = this.reader.getIDTag();\n      var indices = [];\n      var polygonDimensions = [];\n      while (this.reader.offset < finalOffset) {\n        var numverts = this.reader.getUint16();\n        numverts = numverts & 1023;\n        polygonDimensions.push(numverts);\n        for (var j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex());\n      }\n      var geometryData = {\n        type: type,\n        vertexIndices: indices,\n        polygonDimensions: polygonDimensions,\n        points: this.currentPoints\n      };\n      if (polygonDimensions[0] === 1) geometryData.type = \"points\";else if (polygonDimensions[0] === 2) geometryData.type = \"lines\";\n      this.currentLayer.geometry = geometryData;\n    }\n    // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n    // TAGS { tag-string[S0] * }\n  }, {\n    key: \"parseTagStrings\",\n    value: function parseTagStrings(length) {\n      this.tree.tags = this.reader.getStringArray(length);\n    }\n    // Associates tags of a given type with polygons in the most recent POLS chunk.\n    // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  }, {\n    key: \"parsePolygonTagMapping\",\n    value: function parsePolygonTagMapping(length) {\n      var finalOffset = this.reader.offset + length;\n      var type = this.reader.getIDTag();\n      if (type === \"SURF\") this.parseMaterialIndices(finalOffset);else {\n        this.reader.skip(length - 4);\n      }\n    }\n  }, {\n    key: \"parseMaterialIndices\",\n    value: function parseMaterialIndices(finalOffset) {\n      this.currentLayer.geometry.materialIndices = [];\n      while (this.reader.offset < finalOffset) {\n        var polygonIndex = this.reader.getVariableLengthIndex();\n        var materialIndex = this.reader.getUint16();\n        this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n      }\n    }\n  }, {\n    key: \"parseUnknownCHUNK\",\n    value: function parseUnknownCHUNK(blockID, length) {\n      console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n      var data = this.reader.getString(length);\n      this.currentForm[blockID] = data;\n    }\n  }]);\n  return IFFParser;\n}();\nvar DataViewReader = /*#__PURE__*/function () {\n  function DataViewReader(buffer) {\n    _classCallCheck(this, DataViewReader);\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  _createClass(DataViewReader, [{\n    key: \"size\",\n    value: function size() {\n      return this.dv.buffer.byteLength;\n    }\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(offset) {\n      if (offset > 0 && offset < this.dv.buffer.byteLength) {\n        this.offset = offset;\n      } else {\n        console.error(\"LWOLoader: invalid buffer offset\");\n      }\n    }\n  }, {\n    key: \"endOfFile\",\n    value: function endOfFile() {\n      if (this.offset >= this.size()) return true;\n      return false;\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(length) {\n      this.offset += length;\n    }\n  }, {\n    key: \"getUint8\",\n    value: function getUint8() {\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n    }\n  }, {\n    key: \"getUint16\",\n    value: function getUint16() {\n      var value = this.dv.getUint16(this.offset);\n      this.offset += 2;\n      return value;\n    }\n  }, {\n    key: \"getInt32\",\n    value: function getInt32() {\n      var value = this.dv.getInt32(this.offset, false);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getUint32\",\n    value: function getUint32() {\n      var value = this.dv.getUint32(this.offset, false);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getUint64\",\n    value: function getUint64() {\n      var low, high;\n      high = this.getUint32();\n      low = this.getUint32();\n      return high * 4294967296 + low;\n    }\n  }, {\n    key: \"getFloat32\",\n    value: function getFloat32() {\n      var value = this.dv.getFloat32(this.offset, false);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getFloat32Array\",\n    value: function getFloat32Array(size) {\n      var a = [];\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat32());\n      }\n      return a;\n    }\n  }, {\n    key: \"getFloat64\",\n    value: function getFloat64() {\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n    }\n  }, {\n    key: \"getFloat64Array\",\n    value: function getFloat64Array(size) {\n      var a = [];\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat64());\n      }\n      return a;\n    }\n    // get variable-length index data type\n    // VX ::= index[U2] | (index + 0xFF000000)[U4]\n    // If the index value is less than 65,280 (0xFF00),then VX === U2\n    // otherwise VX === U4 with bits 24-31 set\n    // When reading an index, if the first byte encountered is 255 (0xFF), then\n    // the four-byte form is being used and the first byte should be discarded or masked out.\n  }, {\n    key: \"getVariableLengthIndex\",\n    value: function getVariableLengthIndex() {\n      var firstByte = this.getUint8();\n      if (firstByte === 255) {\n        return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n      }\n      return firstByte * 256 + this.getUint8();\n    }\n    // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  }, {\n    key: \"getIDTag\",\n    value: function getIDTag() {\n      return this.getString(4);\n    }\n  }, {\n    key: \"getString\",\n    value: function getString(size) {\n      if (size === 0) return;\n      var start = this.offset;\n      var result;\n      var length;\n      if (size) {\n        length = size;\n        result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n      } else {\n        length = this._bytes.indexOf(0, start) - start;\n        result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n        length++;\n        length += length % 2;\n      }\n      this.skip(length);\n      return result;\n    }\n  }, {\n    key: \"getStringArray\",\n    value: function getStringArray(size) {\n      var a = this.getString(size);\n      a = a.split(\"\\0\");\n      return a.filter(Boolean);\n    }\n  }]);\n  return DataViewReader;\n}();\nvar Debugger = /*#__PURE__*/function () {\n  function Debugger() {\n    _classCallCheck(this, Debugger);\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n  _createClass(Debugger, [{\n    key: \"enable\",\n    value: function enable() {\n      this.active = true;\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (!this.active) return;\n      var nodeType;\n      switch (this.node) {\n        case 0:\n          nodeType = \"FORM\";\n          break;\n        case 1:\n          nodeType = \"CHK\";\n          break;\n        case 2:\n          nodeType = \"S-CHK\";\n          break;\n      }\n      console.log(\"| \".repeat(this.depth) + nodeType, this.nodeID, \"( \".concat(this.offset, \" ) -> ( \").concat(this.dataOffset + this.length, \" )\"), this.node == 0 ? \" {\" : \"\", this.skipped ? \"SKIPPED\" : \"\", this.node == 0 && this.skipped ? \"}\" : \"\");\n      if (this.node == 0 && !this.skipped) {\n        this.depth += 1;\n        this.formList.push(this.dataOffset + this.length);\n      }\n      this.skipped = false;\n    }\n  }, {\n    key: \"closeForms\",\n    value: function closeForms() {\n      if (!this.active) return;\n      for (var i = this.formList.length - 1; i >= 0; i--) {\n        if (this.offset >= this.formList[i]) {\n          this.depth -= 1;\n          console.log(\"| \".repeat(this.depth) + \"}\");\n          this.formList.splice(-1, 1);\n        }\n      }\n    }\n  }]);\n  return Debugger;\n}();\nfunction isEven(num) {\n  return num % 2;\n}\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport { IFFParser };","map":{"version":3,"names":["LWO2Parser","LWO3Parser","IFFParser","_classCallCheck","debugger","Debugger","_createClass","key","value","parse","buffer","reader","DataViewReader","tree","materials","layers","tags","textures","currentLayer","currentForm","parseTopForm","format","parser","endOfFile","parseBlock","offset","closeForms","topForm","getIDTag","console","warn","length","getUint32","dataOffset","type","node","nodeID","log","parseForm","skipped","skipForm","parseTextureNodeAttribute","parseEnvelope","parseClip","parseImage","skip","referenceTexture","index","refName","getString","parseImageStateForm","parseSurfaceForm","parseValueForm","parseSubNode","setupForm","parseConnections","parentForm","currentSurface","parseEntryForm","parseImageMap","parseXVAL","parseXVAL3","parseUnknownForm","currentNode","currentFormEnd","printBuffer","dv","name","surface","attributes","connections","inputName","nodes","source","parseSurfaceLwo2","valueType","getUint64","getFloat64","getFloat64Array","mipMapLevel","getFloat32","maps","map","push","scale","getFloat32Array","position","rotation","falloff","amplitude","uTiles","vTiles","tag","fileName","setOffset","texture","parseClipLwo2","n_length","getUint16","endOffset","x","y","z","parseObjectTag","objectTags","tagString","parseLayer","layer","number","flags","pivot","parsedLength","stringOffset","parent","parsePoints","currentPoints","i","parseVertexMapping","discontinuous","finalOffset","channelName","UVChannel","remainingLength","parseUVMapping","parseMorphTargets","uvIndices","polyIndices","uvs","getVariableLengthIndex","discontinuousUVs","indices","points","morphTargets","parsePolygonList","polygonDimensions","numverts","j","geometryData","vertexIndices","geometry","parseTagStrings","getStringArray","parsePolygonTagMapping","parseMaterialIndices","materialIndices","polygonIndex","materialIndex","parseUnknownCHUNK","blockID","data","DataView","_textDecoder","TextDecoder","_bytes","Uint8Array","size","byteLength","error","getUint8","getInt32","low","high","a","littleEndian","firstByte","start","result","decode","indexOf","split","filter","Boolean","active","depth","formList","enable","nodeType","repeat","concat","splice","isEven","num","string","from","to"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/lwo/IFFParser.js"],"sourcesContent":["import { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n  }\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === void 0)\n      return;\n    if (this.tree.format === \"LWO2\") {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    } else if (this.tree.format === \"LWO3\") {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n    if (topForm !== \"FORM\") {\n      console.warn(\"LWOLoader: Top-level FORM missing.\");\n      return;\n    }\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n    if (type === \"LWO2\") {\n      this.tree.format = type;\n    } else if (type === \"LWO3\") {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  }\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n    switch (type) {\n      case \"ISEQ\":\n      case \"ANIM\":\n      case \"STCC\":\n      case \"VPVL\":\n      case \"VPRM\":\n      case \"NROT\":\n      case \"WRPW\":\n      case \"WRPH\":\n      case \"FUNC\":\n      case \"FALL\":\n      case \"OPAC\":\n      case \"GRAD\":\n      case \"ENVS\":\n      case \"VMOP\":\n      case \"VMBG\":\n      case \"OMAX\":\n      case \"STEX\":\n      case \"CKBG\":\n      case \"CKEY\":\n      case \"VMLA\":\n      case \"VMLB\":\n        this.debugger.skipped = true;\n        this.skipForm(length);\n        break;\n      case \"META\":\n      case \"NNDS\":\n      case \"NODS\":\n      case \"NDTA\":\n      case \"ADAT\":\n      case \"AOVS\":\n      case \"BLOK\":\n      case \"IBGC\":\n      case \"IOPC\":\n      case \"IIMG\":\n      case \"TXTR\":\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case \"IFAL\":\n      case \"ISCL\":\n      case \"IPOS\":\n      case \"IROT\":\n      case \"IBMP\":\n      case \"IUTD\":\n      case \"IVTD\":\n        this.parseTextureNodeAttribute(type);\n        break;\n      case \"ENVL\":\n        this.parseEnvelope(length);\n        break;\n      case \"CLIP\":\n        if (this.tree.format === \"LWO2\") {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case \"STIL\":\n        this.parseImage();\n        break;\n      case \"XREF\":\n        this.reader.skip(8);\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString()\n          // internal unique ref\n        };\n        break;\n      case \"IMST\":\n        this.parseImageStateForm(length);\n        break;\n      case \"SURF\":\n        this.parseSurfaceForm(length);\n        break;\n      case \"VALU\":\n        this.parseValueForm(length);\n        break;\n      case \"NTAG\":\n        this.parseSubNode(length);\n        break;\n      case \"ATTR\":\n      case \"SATR\":\n        this.setupForm(\"attributes\", length);\n        break;\n      case \"NCON\":\n        this.parseConnections(length);\n        break;\n      case \"SSHA\":\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm(\"surfaceShader\", length);\n        break;\n      case \"SSHD\":\n        this.setupForm(\"surfaceShaderData\", length);\n        break;\n      case \"ENTR\":\n        this.parseEntryForm(length);\n        break;\n      case \"IMAP\":\n        this.parseImageMap(length);\n        break;\n      case \"TAMP\":\n        this.parseXVAL(\"amplitude\", length);\n        break;\n      case \"TMAP\":\n        this.setupForm(\"textureMap\", length);\n        break;\n      case \"CNTR\":\n        this.parseXVAL3(\"center\", length);\n        break;\n      case \"SIZE\":\n        this.parseXVAL3(\"scale\", length);\n        break;\n      case \"ROTA\":\n        this.parseXVAL3(\"rotation\", length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n  setupForm(type, length) {\n    if (!this.currentForm)\n      this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n  parseUnknownForm(type, length) {\n    console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n  parseSurfaceForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSubNode(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var node = {\n      name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  }\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  }\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8);\n    var valueType = this.reader.getString();\n    if (valueType === \"double\") {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === \"int\") {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === \"vparam\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === \"vparam3\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  }\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8);\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  }\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps)\n      this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10);\n  }\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28);\n    this.reader.skip(20);\n    switch (type) {\n      case \"ISCL\":\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case \"IPOS\":\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case \"IROT\":\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case \"IFAL\":\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case \"IBMP\":\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case \"IUTD\":\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case \"IVTD\":\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2);\n  }\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4);\n  }\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag();\n    if (tag === \"FORM\") {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8);\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: \"\"\n    };\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n      if (tag === \"STIL\") {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseImage() {\n    this.reader.skip(8);\n    this.currentForm.fileName = this.reader.getString();\n  }\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset);\n  }\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  }\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags)\n      this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  }\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name);\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n  }\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n    for (var i = 0; i < length / 4; i += 3) {\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  }\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16();\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case \"TXUV\":\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case \"MORF\":\n      case \"SPOT\":\n        this.parseMorphTargets(name, finalOffset, type);\n        break;\n      case \"APSL\":\n      case \"NORM\":\n      case \"WGHT\":\n      case \"MNVW\":\n      case \"PICK\":\n      case \"RGB \":\n      case \"RGBA\":\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous)\n        polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs)\n        this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices,\n        polyIndices,\n        uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs)\n        this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices,\n        uvs\n      };\n    }\n  }\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === \"MORF\" ? \"relative\" : \"absolute\";\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets)\n      this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices,\n      points,\n      type\n    };\n  }\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = [];\n    var polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16();\n      numverts = numverts & 1023;\n      polygonDimensions.push(numverts);\n      for (var j = 0; j < numverts; j++)\n        indices.push(this.reader.getVariableLengthIndex());\n    }\n    var geometryData = {\n      type,\n      vertexIndices: indices,\n      polygonDimensions,\n      points: this.currentPoints\n    };\n    if (polygonDimensions[0] === 1)\n      geometryData.type = \"points\";\n    else if (polygonDimensions[0] === 2)\n      geometryData.type = \"lines\";\n    this.currentLayer.geometry = geometryData;\n  }\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  }\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === \"SURF\")\n      this.parseMaterialIndices(finalOffset);\n    else {\n      this.reader.skip(length - 4);\n    }\n  }\n  parseMaterialIndices(finalOffset) {\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n  parseUnknownCHUNK(blockID, length) {\n    console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n}\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error(\"LWOLoader: invalid buffer offset\");\n    }\n  }\n  endOfFile() {\n    if (this.offset >= this.size())\n      return true;\n    return false;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  }\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  }\n  getString(size) {\n    if (size === 0)\n      return;\n    const start = this.offset;\n    let result;\n    let length;\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n      length++;\n      length += length % 2;\n    }\n    this.skip(length);\n    return result;\n  }\n  getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split(\"\\0\");\n    return a.filter(Boolean);\n  }\n}\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n  enable() {\n    this.active = true;\n  }\n  log() {\n    if (!this.active)\n      return;\n    var nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = \"FORM\";\n        break;\n      case 1:\n        nodeType = \"CHK\";\n        break;\n      case 2:\n        nodeType = \"S-CHK\";\n        break;\n    }\n    console.log(\n      \"| \".repeat(this.depth) + nodeType,\n      this.nodeID,\n      `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n      this.node == 0 ? \" {\" : \"\",\n      this.skipped ? \"SKIPPED\" : \"\",\n      this.node == 0 && this.skipped ? \"}\" : \"\"\n    );\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  }\n  closeForms() {\n    if (!this.active)\n      return;\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log(\"| \".repeat(this.depth) + \"}\");\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}\nfunction isEven(num) {\n  return num % 2;\n}\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport {\n  IFFParser\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}