{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, MathUtils } from \"three\";\nvar MorphBlendMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(MorphBlendMesh, _Mesh);\n  var _super = _createSuper(MorphBlendMesh);\n  function MorphBlendMesh(geometry, material) {\n    var _this;\n    _classCallCheck(this, MorphBlendMesh);\n    _this = _super.call(this, geometry, material);\n    _this.animationsMap = {};\n    _this.animationsList = [];\n    var numFrames = Object.keys(_this.morphTargetDictionary).length;\n    var name = \"__default\";\n    var startFrame = 0;\n    var endFrame = numFrames - 1;\n    var fps = numFrames / 1;\n    _this.createAnimation(name, startFrame, endFrame, fps);\n    _this.setAnimationWeight(name, 1);\n    return _this;\n  }\n  _createClass(MorphBlendMesh, [{\n    key: \"createAnimation\",\n    value: function createAnimation(name, start, end, fps) {\n      var animation = {\n        start: start,\n        end: end,\n        length: end - start + 1,\n        fps: fps,\n        duration: (end - start) / fps,\n        lastFrame: 0,\n        currentFrame: 0,\n        active: false,\n        time: 0,\n        direction: 1,\n        weight: 1,\n        directionBackwards: false,\n        mirroredLoop: false\n      };\n      this.animationsMap[name] = animation;\n      this.animationsList.push(animation);\n    }\n  }, {\n    key: \"autoCreateAnimations\",\n    value: function autoCreateAnimations(fps) {\n      var pattern = /([a-z]+)_?(\\d+)/i;\n      var firstAnimation;\n      var frameRanges = {};\n      var i = 0;\n      for (var key in this.morphTargetDictionary) {\n        var chunks = key.match(pattern);\n        if (chunks && chunks.length > 1) {\n          var name = chunks[1];\n          if (!frameRanges[name]) frameRanges[name] = {\n            start: Infinity,\n            end: -Infinity\n          };\n          var range = frameRanges[name];\n          if (i < range.start) range.start = i;\n          if (i > range.end) range.end = i;\n          if (!firstAnimation) firstAnimation = name;\n        }\n        i++;\n      }\n      for (var _name in frameRanges) {\n        var _range = frameRanges[_name];\n        this.createAnimation(_name, _range.start, _range.end, fps);\n      }\n      this.firstAnimation = firstAnimation;\n    }\n  }, {\n    key: \"setAnimationDirectionForward\",\n    value: function setAnimationDirectionForward(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.direction = 1;\n        animation.directionBackwards = false;\n      }\n    }\n  }, {\n    key: \"setAnimationDirectionBackward\",\n    value: function setAnimationDirectionBackward(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.direction = -1;\n        animation.directionBackwards = true;\n      }\n    }\n  }, {\n    key: \"setAnimationFPS\",\n    value: function setAnimationFPS(name, fps) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.fps = fps;\n        animation.duration = (animation.end - animation.start) / animation.fps;\n      }\n    }\n  }, {\n    key: \"setAnimationDuration\",\n    value: function setAnimationDuration(name, duration) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.duration = duration;\n        animation.fps = (animation.end - animation.start) / animation.duration;\n      }\n    }\n  }, {\n    key: \"setAnimationWeight\",\n    value: function setAnimationWeight(name, weight) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.weight = weight;\n      }\n    }\n  }, {\n    key: \"setAnimationTime\",\n    value: function setAnimationTime(name, time) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.time = time;\n      }\n    }\n  }, {\n    key: \"getAnimationTime\",\n    value: function getAnimationTime(name) {\n      var time = 0;\n      var animation = this.animationsMap[name];\n      if (animation) {\n        time = animation.time;\n      }\n      return time;\n    }\n  }, {\n    key: \"getAnimationDuration\",\n    value: function getAnimationDuration(name) {\n      var duration = -1;\n      var animation = this.animationsMap[name];\n      if (animation) {\n        duration = animation.duration;\n      }\n      return duration;\n    }\n  }, {\n    key: \"playAnimation\",\n    value: function playAnimation(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.time = 0;\n        animation.active = true;\n      } else {\n        console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n      }\n    }\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.active = false;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      for (var i = 0, il = this.animationsList.length; i < il; i++) {\n        var animation = this.animationsList[i];\n        if (!animation.active) continue;\n        var frameTime = animation.duration / animation.length;\n        animation.time += animation.direction * delta;\n        if (animation.mirroredLoop) {\n          if (animation.time > animation.duration || animation.time < 0) {\n            animation.direction *= -1;\n            if (animation.time > animation.duration) {\n              animation.time = animation.duration;\n              animation.directionBackwards = true;\n            }\n            if (animation.time < 0) {\n              animation.time = 0;\n              animation.directionBackwards = false;\n            }\n          }\n        } else {\n          animation.time = animation.time % animation.duration;\n          if (animation.time < 0) animation.time += animation.duration;\n        }\n        var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n        var weight = animation.weight;\n        if (keyframe !== animation.currentFrame) {\n          this.morphTargetInfluences[animation.lastFrame] = 0;\n          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n          this.morphTargetInfluences[keyframe] = 0;\n          animation.lastFrame = animation.currentFrame;\n          animation.currentFrame = keyframe;\n        }\n        var mix = animation.time % frameTime / frameTime;\n        if (animation.directionBackwards) mix = 1 - mix;\n        if (animation.currentFrame !== animation.lastFrame) {\n          this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n          this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n        } else {\n          this.morphTargetInfluences[animation.currentFrame] = weight;\n        }\n      }\n    }\n  }]);\n  return MorphBlendMesh;\n}(Mesh);\nexport { MorphBlendMesh };","map":{"version":3,"names":["Mesh","MathUtils","MorphBlendMesh","_Mesh","_inherits","_super","_createSuper","geometry","material","_this","_classCallCheck","call","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","_createClass","key","value","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/misc/MorphBlendMesh.js"],"sourcesContent":["import { Mesh, MathUtils } from \"three\";\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = \"__default\";\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start,\n      end,\n      length: end - start + 1,\n      fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name])\n          frameRanges[name] = { start: Infinity, end: -Infinity };\n        const range = frameRanges[name];\n        if (i < range.start)\n          range.start = i;\n        if (i > range.end)\n          range.end = i;\n        if (!firstAnimation)\n          firstAnimation = name;\n      }\n      i++;\n    }\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  }\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  }\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  }\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  }\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n    }\n  }\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  }\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active)\n        continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0)\n          animation.time += animation.duration;\n      }\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards)\n        mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n}\nexport {\n  MorphBlendMesh\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}