{"ast":null,"code":"import { Vector3, Color } from \"three\";\nvar GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \" vUv = uv;\", \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D tInput;\", \"void main() {\", \"\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\", \"}\"].join(\"\\n\")\n};\nvar GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1\n    },\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */new Vector3()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \" vUv = uv;\", \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#define TAPS_PER_PASS 6.0\", \"varying vec2 vUv;\", \"uniform sampler2D tInput;\", \"uniform vec3 vSunPositionScreenSpace;\", \"uniform float fStepSize;\",\n  // filter step size\n  \"void main() {\",\n  // delta from current pixel to \"sun\" position\n  \"\tvec2 delta = vSunPositionScreenSpace.xy - vUv;\", \"\tfloat dist = length( delta );\",\n  // Step vector (uv space)\n  \"\tvec2 stepv = fStepSize * delta / dist;\",\n  // Number of iterations between pixel and sun\n  \"\tfloat iters = dist/fStepSize;\", \"\tvec2 uv = vUv.xy;\", \"\tfloat col = 0.0;\",\n  // This breaks ANGLE in Chrome 22\n  //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n  /*\n  \t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n  \t\t// so i've just left the loop\n  \n  \t\t\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n  \n  \t\t// Accumulate samples, making sure we dont walk past the light source.\n  \n  \t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n  \t\t// mode, with a black border color. I don't think this is currently\n  \t\t// exposed by three.js. As a result there might be artifacts when the\n  \t\t// sun is to the left, right or bottom of screen as these cases are\n  \t\t// not specifically handled.\n  \n  \t\t\"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n  \t\t\"\tuv += stepv;\",\n  \n  \t\t\"}\",\n  \t\t*/\n  // Unrolling loop manually makes it work in ANGLE\n  \"\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );\",\n  // used to fade out godrays\n  \"\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\",\n  // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n  // objectionable artifacts, in particular near the sun position. The side\n  // effect is that the result is darker than it should be around the sun, as\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n  // When the result is inverted (in the shader 'godrays_combine', this produces\n  // a slight bright spot at the position of the sun, even when it is occluded.\n  \"\tgl_FragColor = vec4( col/TAPS_PER_PASS );\", \"\tgl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n};\nvar GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D tColors;\", \"uniform sampler2D tGodRays;\", \"uniform float fGodRayIntensity;\", \"void main() {\",\n  // Since THREE.MeshDepthMaterial renders foreground objects white and background\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\n  // before being combined with tColors\n  \"\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\", \"\tgl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n};\nvar GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */new Vector3()\n    },\n    fAspect: {\n      value: 1\n    },\n    sunColor: {\n      value: /* @__PURE__ */new Color(16772608)\n    },\n    bgColor: {\n      value: /* @__PURE__ */new Color(0)\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"varying vec2 vUv;\", \"uniform vec3 vSunPositionScreenSpace;\", \"uniform float fAspect;\", \"uniform vec3 sunColor;\", \"uniform vec3 bgColor;\", \"void main() {\", \"\tvec2 diff = vUv - vSunPositionScreenSpace.xy;\",\n  // Correct for aspect ratio\n  \"\tdiff.x *= fAspect;\", \"\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\", \"\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\", \"\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\", \"\tgl_FragColor.w = 1.0;\", \"}\"].join(\"\\n\")\n};\nexport { GodRaysCombineShader, GodRaysDepthMaskShader, GodRaysFakeSunShader, GodRaysGenerateShader };","map":{"version":3,"names":["Vector3","Color","GodRaysDepthMaskShader","uniforms","tInput","value","vertexShader","join","fragmentShader","GodRaysGenerateShader","fStepSize","vSunPositionScreenSpace","GodRaysCombineShader","tColors","tGodRays","fGodRayIntensity","GodRaysFakeSunShader","fAspect","sunColor","bgColor"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/shaders/GodRaysShader.js"],"sourcesContent":["import { Vector3, Color } from \"three\";\nconst GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \" vUv = uv;\",\n    \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tInput;\",\n    \"void main() {\",\n    \"\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1\n    },\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3()\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \" vUv = uv;\",\n    \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#define TAPS_PER_PASS 6.0\",\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tInput;\",\n    \"uniform vec3 vSunPositionScreenSpace;\",\n    \"uniform float fStepSize;\",\n    // filter step size\n    \"void main() {\",\n    // delta from current pixel to \"sun\" position\n    \"\tvec2 delta = vSunPositionScreenSpace.xy - vUv;\",\n    \"\tfloat dist = length( delta );\",\n    // Step vector (uv space)\n    \"\tvec2 stepv = fStepSize * delta / dist;\",\n    // Number of iterations between pixel and sun\n    \"\tfloat iters = dist/fStepSize;\",\n    \"\tvec2 uv = vUv.xy;\",\n    \"\tfloat col = 0.0;\",\n    // This breaks ANGLE in Chrome 22\n    //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n    /*\n    \t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n    \t\t// so i've just left the loop\n    \n    \t\t\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n    \n    \t\t// Accumulate samples, making sure we dont walk past the light source.\n    \n    \t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n    \t\t// mode, with a black border color. I don't think this is currently\n    \t\t// exposed by three.js. As a result there might be artifacts when the\n    \t\t// sun is to the left, right or bottom of screen as these cases are\n    \t\t// not specifically handled.\n    \n    \t\t\"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n    \t\t\"\tuv += stepv;\",\n    \n    \t\t\"}\",\n    \t\t*/\n    // Unrolling loop manually makes it work in ANGLE\n    \"\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );\",\n    // used to fade out godrays\n    \"\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n    // objectionable artifacts, in particular near the sun position. The side\n    // effect is that the result is darker than it should be around the sun, as\n    // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n    // When the result is inverted (in the shader 'godrays_combine', this produces\n    // a slight bright spot at the position of the sun, even when it is occluded.\n    \"\tgl_FragColor = vec4( col/TAPS_PER_PASS );\",\n    \"\tgl_FragColor.a = 1.0;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tColors;\",\n    \"uniform sampler2D tGodRays;\",\n    \"uniform float fGodRayIntensity;\",\n    \"void main() {\",\n    // Since THREE.MeshDepthMaterial renders foreground objects white and background\n    // objects black, the god-rays will be white streaks. Therefore value is inverted\n    // before being combined with tColors\n    \"\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\",\n    \"\tgl_FragColor.a = 1.0;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3()\n    },\n    fAspect: {\n      value: 1\n    },\n    sunColor: {\n      value: /* @__PURE__ */ new Color(16772608)\n    },\n    bgColor: {\n      value: /* @__PURE__ */ new Color(0)\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"varying vec2 vUv;\",\n    \"uniform vec3 vSunPositionScreenSpace;\",\n    \"uniform float fAspect;\",\n    \"uniform vec3 sunColor;\",\n    \"uniform vec3 bgColor;\",\n    \"void main() {\",\n    \"\tvec2 diff = vUv - vSunPositionScreenSpace.xy;\",\n    // Correct for aspect ratio\n    \"\tdiff.x *= fAspect;\",\n    \"\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\",\n    \"\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\",\n    \"\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\",\n    \"\tgl_FragColor.w = 1.0;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  GodRaysCombineShader,\n  GodRaysDepthMaskShader,\n  GodRaysFakeSunShader,\n  GodRaysGenerateShader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}