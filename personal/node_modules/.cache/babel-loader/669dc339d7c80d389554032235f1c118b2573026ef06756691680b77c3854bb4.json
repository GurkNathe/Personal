{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTextureLoader, LinearMipmapLinearFilter } from \"three\";\nvar TGALoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(TGALoader, _DataTextureLoader);\n  var _super = _createSuper(TGALoader);\n  function TGALoader(manager) {\n    _classCallCheck(this, TGALoader);\n    return _super.call(this, manager);\n  }\n  _createClass(TGALoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      function tgaCheckHeader(header2) {\n        switch (header2.image_type) {\n          case TGA_TYPE_INDEXED:\n          case TGA_TYPE_RLE_INDEXED:\n            if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {\n              console.error(\"THREE.TGALoader: Invalid type colormap data for indexed type.\");\n            }\n            break;\n          case TGA_TYPE_RGB:\n          case TGA_TYPE_GREY:\n          case TGA_TYPE_RLE_RGB:\n          case TGA_TYPE_RLE_GREY:\n            if (header2.colormap_type) {\n              console.error(\"THREE.TGALoader: Invalid type colormap data for colormap type.\");\n            }\n            break;\n          case TGA_TYPE_NO_DATA:\n            console.error(\"THREE.TGALoader: No data.\");\n          default:\n            console.error('THREE.TGALoader: Invalid type \"%s\".', header2.image_type);\n        }\n        if (header2.width <= 0 || header2.height <= 0) {\n          console.error(\"THREE.TGALoader: Invalid image size.\");\n        }\n        if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {\n          console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header2.pixel_size);\n        }\n      }\n      function tgaParse(use_rle2, use_pal2, header2, offset2, data) {\n        var pixel_data, palettes;\n        var pixel_size = header2.pixel_size >> 3;\n        var pixel_total = header2.width * header2.height * pixel_size;\n        if (use_pal2) {\n          palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));\n        }\n        if (use_rle2) {\n          pixel_data = new Uint8Array(pixel_total);\n          var c, count, i;\n          var shift = 0;\n          var pixels = new Uint8Array(pixel_size);\n          while (shift < pixel_total) {\n            c = data[offset2++];\n            count = (c & 127) + 1;\n            if (c & 128) {\n              for (i = 0; i < pixel_size; ++i) {\n                pixels[i] = data[offset2++];\n              }\n              for (i = 0; i < count; ++i) {\n                pixel_data.set(pixels, shift + i * pixel_size);\n              }\n              shift += pixel_size * count;\n            } else {\n              count *= pixel_size;\n              for (i = 0; i < count; ++i) {\n                pixel_data[shift + i] = data[offset2++];\n              }\n              shift += count;\n            }\n          }\n        } else {\n          pixel_data = data.subarray(offset2, offset2 += use_pal2 ? header2.width * header2.height : pixel_total);\n        }\n        return {\n          pixel_data: pixel_data,\n          palettes: palettes\n        };\n      }\n      function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n        var colormap = palettes;\n        var color,\n          i = 0,\n          x,\n          y;\n        var width = header.width;\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData2[(x + width * y) * 4 + 3] = 255;\n            imageData2[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n            imageData2[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n            imageData2[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n          }\n        }\n        return imageData2;\n      }\n      function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var color,\n          i = 0,\n          x,\n          y;\n        var width = header.width;\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            color = image[i + 0] + (image[i + 1] << 8);\n            imageData2[(x + width * y) * 4 + 0] = (color & 31744) >> 7;\n            imageData2[(x + width * y) * 4 + 1] = (color & 992) >> 2;\n            imageData2[(x + width * y) * 4 + 2] = (color & 31) >> 3;\n            imageData2[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;\n          }\n        }\n        return imageData2;\n      }\n      function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n          x,\n          y;\n        var width = header.width;\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 3) {\n            imageData2[(x + width * y) * 4 + 3] = 255;\n            imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n          }\n        }\n        return imageData2;\n      }\n      function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n          x,\n          y;\n        var width = header.width;\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 4) {\n            imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n            imageData2[(x + width * y) * 4 + 3] = image[i + 3];\n          }\n        }\n        return imageData2;\n      }\n      function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var color,\n          i = 0,\n          x,\n          y;\n        var width = header.width;\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData2[(x + width * y) * 4 + 0] = color;\n            imageData2[(x + width * y) * 4 + 1] = color;\n            imageData2[(x + width * y) * 4 + 2] = color;\n            imageData2[(x + width * y) * 4 + 3] = 255;\n          }\n        }\n        return imageData2;\n      }\n      function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n          x,\n          y;\n        var width = header.width;\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            imageData2[(x + width * y) * 4 + 0] = image[i + 0];\n            imageData2[(x + width * y) * 4 + 1] = image[i + 0];\n            imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData2[(x + width * y) * 4 + 3] = image[i + 1];\n          }\n        }\n        return imageData2;\n      }\n      function getTgaRGBA(data, width, height, image, palette) {\n        var x_start, y_start, x_step, y_step, x_end, y_end;\n        switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n          default:\n          case TGA_ORIGIN_UL:\n            x_start = 0;\n            x_step = 1;\n            x_end = width;\n            y_start = 0;\n            y_step = 1;\n            y_end = height;\n            break;\n          case TGA_ORIGIN_BL:\n            x_start = 0;\n            x_step = 1;\n            x_end = width;\n            y_start = height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n          case TGA_ORIGIN_UR:\n            x_start = width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = 0;\n            y_step = 1;\n            y_end = height;\n            break;\n          case TGA_ORIGIN_BR:\n            x_start = width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n        }\n        if (use_grey) {\n          switch (header.pixel_size) {\n            case 8:\n              tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n            case 16:\n              tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n            default:\n              console.error(\"THREE.TGALoader: Format not supported.\");\n              break;\n          }\n        } else {\n          switch (header.pixel_size) {\n            case 8:\n              tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n              break;\n            case 16:\n              tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n            case 24:\n              tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n            case 32:\n              tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n            default:\n              console.error(\"THREE.TGALoader: Format not supported.\");\n              break;\n          }\n        }\n        return data;\n      }\n      var TGA_TYPE_NO_DATA = 0,\n        TGA_TYPE_INDEXED = 1,\n        TGA_TYPE_RGB = 2,\n        TGA_TYPE_GREY = 3,\n        TGA_TYPE_RLE_INDEXED = 9,\n        TGA_TYPE_RLE_RGB = 10,\n        TGA_TYPE_RLE_GREY = 11,\n        TGA_ORIGIN_MASK = 48,\n        TGA_ORIGIN_SHIFT = 4,\n        TGA_ORIGIN_BL = 0,\n        TGA_ORIGIN_BR = 1,\n        TGA_ORIGIN_UL = 2,\n        TGA_ORIGIN_UR = 3;\n      if (buffer.length < 19) console.error(\"THREE.TGALoader: Not enough data to contain header.\");\n      var offset = 0;\n      var content = new Uint8Array(buffer),\n        header = {\n          id_length: content[offset++],\n          colormap_type: content[offset++],\n          image_type: content[offset++],\n          colormap_index: content[offset++] | content[offset++] << 8,\n          colormap_length: content[offset++] | content[offset++] << 8,\n          colormap_size: content[offset++],\n          origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n          width: content[offset++] | content[offset++] << 8,\n          height: content[offset++] | content[offset++] << 8,\n          pixel_size: content[offset++],\n          flags: content[offset++]\n        };\n      tgaCheckHeader(header);\n      if (header.id_length + offset > buffer.length) {\n        console.error(\"THREE.TGALoader: No data.\");\n      }\n      offset += header.id_length;\n      var use_rle = false,\n        use_pal = false,\n        use_grey = false;\n      switch (header.image_type) {\n        case TGA_TYPE_RLE_INDEXED:\n          use_rle = true;\n          use_pal = true;\n          break;\n        case TGA_TYPE_INDEXED:\n          use_pal = true;\n          break;\n        case TGA_TYPE_RLE_RGB:\n          use_rle = true;\n          break;\n        case TGA_TYPE_RGB:\n          break;\n        case TGA_TYPE_RLE_GREY:\n          use_rle = true;\n          use_grey = true;\n          break;\n        case TGA_TYPE_GREY:\n          use_grey = true;\n          break;\n      }\n      var imageData = new Uint8Array(header.width * header.height * 4);\n      var result = tgaParse(use_rle, use_pal, header, offset, content);\n      getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n      return {\n        data: imageData,\n        width: header.width,\n        height: header.height,\n        flipY: true,\n        generateMipmaps: true,\n        minFilter: LinearMipmapLinearFilter\n      };\n    }\n  }]);\n  return TGALoader;\n}(DataTextureLoader);\nexport { TGALoader };","map":{"version":3,"names":["DataTextureLoader","LinearMipmapLinearFilter","TGALoader","_DataTextureLoader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","parse","buffer","tgaCheckHeader","header2","image_type","TGA_TYPE_INDEXED","TGA_TYPE_RLE_INDEXED","colormap_length","colormap_size","colormap_type","console","error","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_TYPE_NO_DATA","width","height","pixel_size","tgaParse","use_rle2","use_pal2","offset2","data","pixel_data","palettes","pixel_total","subarray","Uint8Array","c","count","i","shift","pixels","set","tgaGetImageData8bits","imageData2","y_start","y_step","y_end","x_start","x_step","x_end","image","colormap","color","x","y","header","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","getTgaRGBA","palette","flags","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_UL","TGA_ORIGIN_BL","TGA_ORIGIN_UR","TGA_ORIGIN_BR","use_grey","length","offset","content","id_length","colormap_index","origin","use_rle","use_pal","imageData","result","flipY","generateMipmaps","minFilter"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/TGALoader.js"],"sourcesContent":["import { DataTextureLoader, LinearMipmapLinearFilter } from \"three\";\nclass TGALoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n  parse(buffer) {\n    function tgaCheckHeader(header2) {\n      switch (header2.image_type) {\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for indexed type.\");\n          }\n          break;\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header2.colormap_type) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for colormap type.\");\n          }\n          break;\n        case TGA_TYPE_NO_DATA:\n          console.error(\"THREE.TGALoader: No data.\");\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header2.image_type);\n      }\n      if (header2.width <= 0 || header2.height <= 0) {\n        console.error(\"THREE.TGALoader: Invalid image size.\");\n      }\n      if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header2.pixel_size);\n      }\n    }\n    function tgaParse(use_rle2, use_pal2, header2, offset2, data) {\n      let pixel_data, palettes;\n      const pixel_size = header2.pixel_size >> 3;\n      const pixel_total = header2.width * header2.height * pixel_size;\n      if (use_pal2) {\n        palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));\n      }\n      if (use_rle2) {\n        pixel_data = new Uint8Array(pixel_total);\n        let c, count, i;\n        let shift = 0;\n        const pixels = new Uint8Array(pixel_size);\n        while (shift < pixel_total) {\n          c = data[offset2++];\n          count = (c & 127) + 1;\n          if (c & 128) {\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset2++];\n            }\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n            shift += pixel_size * count;\n          } else {\n            count *= pixel_size;\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset2++];\n            }\n            shift += count;\n          }\n        }\n      } else {\n        pixel_data = data.subarray(offset2, offset2 += use_pal2 ? header2.width * header2.height : pixel_total);\n      }\n      return {\n        pixel_data,\n        palettes\n      };\n    }\n    function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      const colormap = palettes;\n      let color, i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData2[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData2[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color, i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8);\n          imageData2[(x + width * y) * 4 + 0] = (color & 31744) >> 7;\n          imageData2[(x + width * y) * 4 + 1] = (color & 992) >> 2;\n          imageData2[(x + width * y) * 4 + 2] = (color & 31) >> 3;\n          imageData2[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color, i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 0] = color;\n          imageData2[(x + width * y) * 4 + 1] = color;\n          imageData2[(x + width * y) * 4 + 2] = color;\n          imageData2[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData2[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n      return imageData2;\n    }\n    function getTgaRGBA(data, width, height, image, palette) {\n      let x_start, y_start, x_step, y_step, x_end, y_end;\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      }\n      return data;\n    }\n    const TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 48, TGA_ORIGIN_SHIFT = 4, TGA_ORIGIN_BL = 0, TGA_ORIGIN_BR = 1, TGA_ORIGIN_UL = 2, TGA_ORIGIN_UR = 3;\n    if (buffer.length < 19)\n      console.error(\"THREE.TGALoader: Not enough data to contain header.\");\n    let offset = 0;\n    const content = new Uint8Array(buffer), header = {\n      id_length: content[offset++],\n      colormap_type: content[offset++],\n      image_type: content[offset++],\n      colormap_index: content[offset++] | content[offset++] << 8,\n      colormap_length: content[offset++] | content[offset++] << 8,\n      colormap_size: content[offset++],\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n      width: content[offset++] | content[offset++] << 8,\n      height: content[offset++] | content[offset++] << 8,\n      pixel_size: content[offset++],\n      flags: content[offset++]\n    };\n    tgaCheckHeader(header);\n    if (header.id_length + offset > buffer.length) {\n      console.error(\"THREE.TGALoader: No data.\");\n    }\n    offset += header.id_length;\n    let use_rle = false, use_pal = false, use_grey = false;\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n      case TGA_TYPE_RGB:\n        break;\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    }\n    const imageData = new Uint8Array(header.width * header.height * 4);\n    const result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter\n    };\n  }\n}\nexport {\n  TGALoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}