{"ast":null,"code":"import _slicedToArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"compute\", \"width\", \"height\", \"samples\", \"renderPriority\", \"eventPriority\", \"frames\", \"stencilBuffer\", \"depthBuffer\", \"generateMipmaps\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nvar RenderTexture = /*#__PURE__*/React.forwardRef(function (_ref, forwardRef) {\n  var children = _ref.children,\n    compute = _ref.compute,\n    width = _ref.width,\n    height = _ref.height,\n    _ref$samples = _ref.samples,\n    samples = _ref$samples === void 0 ? 8 : _ref$samples,\n    _ref$renderPriority = _ref.renderPriority,\n    renderPriority = _ref$renderPriority === void 0 ? 0 : _ref$renderPriority,\n    _ref$eventPriority = _ref.eventPriority,\n    eventPriority = _ref$eventPriority === void 0 ? 0 : _ref$eventPriority,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? Infinity : _ref$frames,\n    _ref$stencilBuffer = _ref.stencilBuffer,\n    stencilBuffer = _ref$stencilBuffer === void 0 ? false : _ref$stencilBuffer,\n    _ref$depthBuffer = _ref.depthBuffer,\n    depthBuffer = _ref$depthBuffer === void 0 ? true : _ref$depthBuffer,\n    _ref$generateMipmaps = _ref.generateMipmaps,\n    generateMipmaps = _ref$generateMipmaps === void 0 ? false : _ref$generateMipmaps,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _useThree = useThree(),\n    size = _useThree.size,\n    viewport = _useThree.viewport;\n  var fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples: samples,\n    stencilBuffer: stencilBuffer,\n    depthBuffer: depthBuffer,\n    generateMipmaps: generateMipmaps\n  });\n  var _React$useState = React.useState(function () {\n      return new THREE.Scene();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    vScene = _React$useState2[0];\n  var uvCompute = React.useCallback(function (event, state, previous) {\n    var _fbo$texture, _previous$previousRoo;\n\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n    var parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      parent = parent.__r3f.parent;\n    }\n    if (!parent) return false; // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState()); // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n\n    var _previous$raycaster$i = previous.raycaster.intersectObject(parent),\n      _previous$raycaster$i2 = _slicedToArray(_previous$raycaster$i, 1),\n      intersection = _previous$raycaster$i2[0];\n    if (!intersection) return false; // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n\n    var uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, function () {\n    return fbo.texture;\n  }, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children), vScene, {\n    events: {\n      compute: compute || uvCompute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n}); // The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\n\nfunction Container(_ref2) {\n  var frames = _ref2.frames,\n    renderPriority = _ref2.renderPriority,\n    children = _ref2.children,\n    fbo = _ref2.fbo;\n  var count = 0;\n  useFrame(function (state) {\n    if (frames === Infinity || count < frames) {\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(null);\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\nexport { RenderTexture };","map":{"version":3,"names":["_extends","THREE","React","useThree","createPortal","useFrame","useFBO","RenderTexture","forwardRef","_ref","children","compute","width","height","_ref$samples","samples","_ref$renderPriority","renderPriority","_ref$eventPriority","eventPriority","_ref$frames","frames","Infinity","_ref$stencilBuffer","stencilBuffer","_ref$depthBuffer","depthBuffer","_ref$generateMipmaps","generateMipmaps","props","_objectWithoutProperties","_excluded","_useThree","size","viewport","fbo","dpr","_React$useState","useState","Scene","_React$useState2","_slicedToArray","vScene","uvCompute","useCallback","event","state","previous","_fbo$texture","_previous$previousRoo","parent","texture","__r3f","Object3D","raycaster","camera","events","previousRoot","getState","_previous$raycaster$i","intersectObject","_previous$raycaster$i2","intersection","uv","setFromCamera","pointer","set","x","y","useImperativeHandle","createElement","Fragment","Container","priority","object","_ref2","count","gl","setRenderTarget","render","scene"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@react-three+drei@9.72.1_@react-three+fiber@8.13.0_@types+three@0.150.2_react-dom@18.2.0_react@18.2.0_three@0.151.3/node_modules/@react-three/drei/core/RenderTexture.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\n\nconst RenderTexture = /*#__PURE__*/React.forwardRef(({\n  children,\n  compute,\n  width,\n  height,\n  samples = 8,\n  renderPriority = 0,\n  eventPriority = 0,\n  frames = Infinity,\n  stencilBuffer = false,\n  depthBuffer = true,\n  generateMipmaps = false,\n  ...props\n}, forwardRef) => {\n  const {\n    size,\n    viewport\n  } = useThree();\n  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples,\n    stencilBuffer,\n    depthBuffer,\n    generateMipmaps\n  });\n  const [vScene] = React.useState(() => new THREE.Scene());\n  const uvCompute = React.useCallback((event, state, previous) => {\n    var _fbo$texture, _previous$previousRoo;\n\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n    let parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;\n\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      parent = parent.__r3f.parent;\n    }\n\n    if (!parent) return false; // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState()); // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n\n    const [intersection] = previous.raycaster.intersectObject(parent);\n    if (!intersection) return false; // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n\n    const uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, () => fbo.texture, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children), vScene, {\n    events: {\n      compute: compute || uvCompute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n}); // The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\n\nfunction Container({\n  frames,\n  renderPriority,\n  children,\n  fbo\n}) {\n  let count = 0;\n  useFrame(state => {\n    if (frames === Infinity || count < frames) {\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(null);\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nexport { RenderTexture };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}