{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3 } from 'three';\nexport var SeparatingAxisBounds = /*#__PURE__*/function () {\n  function SeparatingAxisBounds() {\n    _classCallCheck(this, SeparatingAxisBounds);\n    this.min = Infinity;\n    this.max = -Infinity;\n  }\n  _createClass(SeparatingAxisBounds, [{\n    key: \"setFromPointsField\",\n    value: function setFromPointsField(points, field) {\n      var min = Infinity;\n      var max = -Infinity;\n      for (var i = 0, l = points.length; i < l; i++) {\n        var p = points[i];\n        var val = p[field];\n        min = val < min ? val : min;\n        max = val > max ? val : max;\n      }\n      this.min = min;\n      this.max = max;\n    }\n  }, {\n    key: \"setFromPoints\",\n    value: function setFromPoints(axis, points) {\n      var min = Infinity;\n      var max = -Infinity;\n      for (var i = 0, l = points.length; i < l; i++) {\n        var p = points[i];\n        var val = axis.dot(p);\n        min = val < min ? val : min;\n        max = val > max ? val : max;\n      }\n      this.min = min;\n      this.max = max;\n    }\n  }, {\n    key: \"isSeparated\",\n    value: function isSeparated(other) {\n      return this.min > other.max || other.min > this.max;\n    }\n  }]);\n  return SeparatingAxisBounds;\n}();\nSeparatingAxisBounds.prototype.setFromBox = function () {\n  var p = new Vector3();\n  return function setFromBox(axis, box) {\n    var boxMin = box.min;\n    var boxMax = box.max;\n    var min = Infinity;\n    var max = -Infinity;\n    for (var x = 0; x <= 1; x++) {\n      for (var y = 0; y <= 1; y++) {\n        for (var z = 0; z <= 1; z++) {\n          p.x = boxMin.x * x + boxMax.x * (1 - x);\n          p.y = boxMin.y * y + boxMax.y * (1 - y);\n          p.z = boxMin.z * z + boxMax.z * (1 - z);\n          var val = axis.dot(p);\n          min = Math.min(val, min);\n          max = Math.max(val, max);\n        }\n      }\n    }\n    this.min = min;\n    this.max = max;\n  };\n}();\nexport var areIntersecting = function () {\n  var cacheSatBounds = new SeparatingAxisBounds();\n  return function areIntersecting(shape1, shape2) {\n    var points1 = shape1.points;\n    var satAxes1 = shape1.satAxes;\n    var satBounds1 = shape1.satBounds;\n    var points2 = shape2.points;\n    var satAxes2 = shape2.satAxes;\n    var satBounds2 = shape2.satBounds;\n\n    // check axes of the first shape\n    for (var i = 0; i < 3; i++) {\n      var sb = satBounds1[i];\n      var sa = satAxes1[i];\n      cacheSatBounds.setFromPoints(sa, points2);\n      if (sb.isSeparated(cacheSatBounds)) return false;\n    }\n\n    // check axes of the second shape\n    for (var _i = 0; _i < 3; _i++) {\n      var _sb = satBounds2[_i];\n      var _sa = satAxes2[_i];\n      cacheSatBounds.setFromPoints(_sa, points1);\n      if (_sb.isSeparated(cacheSatBounds)) return false;\n    }\n  };\n}();","map":{"version":3,"names":["Vector3","SeparatingAxisBounds","_classCallCheck","min","Infinity","max","_createClass","key","value","setFromPointsField","points","field","i","l","length","p","val","setFromPoints","axis","dot","isSeparated","other","prototype","setFromBox","box","boxMin","boxMax","x","y","z","Math","areIntersecting","cacheSatBounds","shape1","shape2","points1","satAxes1","satAxes","satBounds1","satBounds","points2","satAxes2","satBounds2","sb","sa"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-mesh-bvh@0.5.24_three@0.151.3/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}