{"ast":null,"code":"import { createError } from '../errors.js';\nfunction innerCreate(schema, sortableDeniedProperties, prefix) {\n  const sorter = {\n    enabled: true,\n    sortableProperties: [],\n    sortablePropertiesWithTypes: {},\n    sorts: {}\n  };\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type;\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n    if (sortableDeniedProperties.includes(path)) {\n      continue;\n    }\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      const ret = innerCreate(type, sortableDeniedProperties, path);\n      sorter.sortableProperties.push(...ret.sortableProperties);\n      sorter.sorts = {\n        ...sorter.sorts,\n        ...ret.sorts\n      };\n      sorter.sortablePropertiesWithTypes = {\n        ...sorter.sortablePropertiesWithTypes,\n        ...ret.sortablePropertiesWithTypes\n      };\n      continue;\n    }\n    switch (type) {\n      case 'boolean':\n      case 'number':\n      case 'string':\n        sorter.sortableProperties.push(path);\n        sorter.sortablePropertiesWithTypes[path] = type;\n        sorter.sorts[path] = {\n          docs: {},\n          orderedDocs: [],\n          type: type\n        };\n        break;\n      case 'boolean[]':\n      case 'number[]':\n      case 'string[]':\n        continue;\n      default:\n        throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n    }\n  }\n  return sorter;\n}\nasync function create(_, schema, config) {\n  const isSortEnabled = (config === null || config === void 0 ? void 0 : config.enabled) !== false;\n  if (!isSortEnabled) {\n    return {\n      disabled: true\n    };\n  }\n  return innerCreate(schema, (config || {}).unsortableProperties || [], '');\n}\nfunction stringSort(value, language, d) {\n  return d[1].localeCompare(value, language) > 0;\n}\nfunction numerSort(value, d) {\n  return d[1] > value;\n}\nfunction booleanSort(value, d) {\n  return d[1];\n}\nasync function insert(sorter, prop, id, value, schemaType, language) {\n  if (!sorter.enabled) {\n    return;\n  }\n  const s = sorter.sorts[prop];\n  let predicate;\n  switch (schemaType) {\n    case 'string':\n      predicate = stringSort.bind(null, value, language);\n      break;\n    case 'number':\n      predicate = numerSort.bind(null, value);\n      break;\n    case 'boolean':\n      predicate = booleanSort.bind(null, value);\n      break;\n  }\n  // Find the right position to insert the element\n  let index = s.orderedDocs.findIndex(predicate);\n  if (index === -1) {\n    index = s.orderedDocs.length;\n    s.orderedDocs.push([id, value]);\n  } else {\n    s.orderedDocs.splice(index, 0, [id, value]);\n  }\n  s.docs[id] = index;\n  // Increment position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length;\n  for (let i = index + 1; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0];\n    s.docs[docId]++;\n  }\n}\nasync function remove(sorter, prop, id) {\n  if (!sorter.enabled) {\n    return;\n  }\n  const s = sorter.sorts[prop];\n  const index = s.docs[id];\n  delete s.docs[id];\n  // Decrement position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length;\n  for (let i = index + 1; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0];\n    s.docs[docId]--;\n  }\n  s.orderedDocs.splice(index, 1);\n}\nasync function sortBy(sorter, docIds, by) {\n  if (!sorter.enabled) {\n    throw createError('SORT_DISABLED');\n  }\n  const property = by.property;\n  const isDesc = by.order === 'DESC';\n  const s = sorter.sorts[property];\n  if (!s) {\n    throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '));\n  }\n  docIds.sort((a, b) => {\n    // This sort algorithm works leveraging on\n    // that s.docs is a map of docId -> position\n    // If a document is not indexed, it will be not present in the map\n    const indexOfA = s.docs[a[0]];\n    const indexOfB = s.docs[b[0]];\n    const isAIndexed = typeof indexOfA !== 'undefined';\n    const isBIndexed = typeof indexOfB !== 'undefined';\n    if (!isAIndexed && !isBIndexed) {\n      return 0;\n    }\n    // unindexed documents are always at the end\n    if (!isAIndexed) {\n      return 1;\n    }\n    if (!isBIndexed) {\n      return -1;\n    }\n    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;\n  });\n  return docIds;\n}\nasync function getSortableProperties(sorter) {\n  if (!sorter.enabled) {\n    return [];\n  }\n  return sorter.sortableProperties;\n}\nasync function getSortablePropertiesWithTypes(sorter) {\n  if (!sorter.enabled) {\n    return {};\n  }\n  return sorter.sortablePropertiesWithTypes;\n}\nexport async function load(raw) {\n  const rawDocument = raw;\n  if (!rawDocument.enabled) {\n    return {\n      enabled: false\n    };\n  }\n  return {\n    sortableProperties: rawDocument.sortableProperties,\n    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n    sorts: rawDocument.sorts,\n    enabled: true\n  };\n}\nexport async function save(sorter) {\n  if (!sorter.enabled) {\n    return {\n      enabled: false\n    };\n  }\n  return {\n    sortableProperties: sorter.sortableProperties,\n    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n    sorts: sorter.sorts,\n    enabled: sorter.enabled\n  };\n}\nexport async function createSorter() {\n  return {\n    create,\n    insert,\n    remove,\n    save,\n    load,\n    sortBy,\n    getSortableProperties,\n    getSortablePropertiesWithTypes\n  };\n}","map":{"version":3,"names":["createError","innerCreate","schema","sortableDeniedProperties","prefix","sorter","enabled","sortableProperties","sortablePropertiesWithTypes","sorts","prop","type","Object","entries","typeActualType","path","includes","Array","isArray","ret","push","docs","orderedDocs","create","_","config","isSortEnabled","disabled","unsortableProperties","stringSort","value","language","d","localeCompare","numerSort","booleanSort","insert","id","schemaType","s","predicate","bind","index","findIndex","length","splice","orderedDocsLength","i","docId","remove","sortBy","docIds","by","property","isDesc","order","join","sort","a","b","indexOfA","indexOfB","isAIndexed","isBIndexed","getSortableProperties","getSortablePropertiesWithTypes","load","raw","rawDocument","save","createSorter"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/components/sorter.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { ISorter, OpaqueSorter, Orama, Schema, SorterConfig, SorterParams, SortType, SortValue } from '../types.js'\n\ninterface PropertySort<K> {\n  docs: Record<string, number>\n  orderedDocs: [string, K][]\n  type: SortType\n}\n\nexport interface Sorter extends OpaqueSorter {\n  enabled: boolean\n  sortableProperties: string[]\n  sortablePropertiesWithTypes: Record<string, SortType>\n  sorts: Record<string, PropertySort<number | string | boolean>>\n}\n\nexport type DefaultSorter = ISorter<Sorter>\n\nfunction innerCreate(schema: Schema, sortableDeniedProperties: string[], prefix: string): Sorter {\n  const sorter: Sorter = {\n    enabled: true,\n    sortableProperties: [],\n    sortablePropertiesWithTypes: {},\n    sorts: {},\n  }\n\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (sortableDeniedProperties.includes(path)) {\n      continue\n    }\n\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      const ret = innerCreate(type as Schema, sortableDeniedProperties, path)\n      sorter.sortableProperties.push(...ret.sortableProperties)\n      sorter.sorts = {\n        ...sorter.sorts,\n        ...ret.sorts,\n      }\n      sorter.sortablePropertiesWithTypes = {\n        ...sorter.sortablePropertiesWithTypes,\n        ...ret.sortablePropertiesWithTypes,\n      }\n      continue\n    }\n\n    switch (type) {\n      case 'boolean':\n      case 'number':\n      case 'string':\n        sorter.sortableProperties.push(path)\n        sorter.sortablePropertiesWithTypes[path] = type\n        sorter.sorts[path] = {\n          docs: {},\n          orderedDocs: [],\n          type: type,\n        }\n        break\n      case 'boolean[]':\n      case 'number[]':\n      case 'string[]':\n        // We don't allow to sort by arrays\n        continue\n      default:\n        throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : (type as unknown as string), path)\n    }\n  }\n\n  return sorter\n}\n\nasync function create(_: Orama, schema: Schema, config?: SorterConfig): Promise<Sorter> {\n  const isSortEnabled = config?.enabled !== false\n  if (!isSortEnabled) {\n    return {\n      disabled: true,\n    } as unknown as Sorter\n  }\n  return innerCreate(schema, (config || {}).unsortableProperties || [], '')\n}\n\nfunction stringSort(value: SortValue, language: string | undefined, d: [string, SortValue]): boolean {\n  return (d[1] as string).localeCompare(value as string, language) > 0\n}\nfunction numerSort(value: SortValue, d: [string, SortValue]): boolean {\n  return (d[1] as number) > (value as number)\n}\nfunction booleanSort(value: SortValue, d: [string, SortValue]): boolean {\n  return d[1] as boolean\n}\n\nasync function insert(\n  sorter: Sorter,\n  prop: string,\n  id: string,\n  value: SortValue,\n  schemaType: SortType,\n  language: string | undefined,\n): Promise<void> {\n  if (!sorter.enabled) {\n    return\n  }\n  const s = sorter.sorts[prop]\n\n  let predicate: (value: [string, SortValue]) => boolean\n  switch (schemaType) {\n    case 'string':\n      predicate = stringSort.bind(null, value, language)\n      break\n    case 'number':\n      predicate = numerSort.bind(null, value)\n      break\n    case 'boolean':\n      predicate = booleanSort.bind(null, value)\n      break\n  }\n\n  // Find the right position to insert the element\n  let index = s.orderedDocs.findIndex(predicate)\n  if (index === -1) {\n    index = s.orderedDocs.length\n    s.orderedDocs.push([id, value])\n  } else {\n    s.orderedDocs.splice(index, 0, [id, value])\n  }\n  s.docs[id] = index\n\n  // Increment position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length\n  for (let i = index + 1; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0]\n    s.docs[docId]++\n  }\n}\n\nasync function remove(sorter: Sorter, prop: string, id: string) {\n  if (!sorter.enabled) {\n    return\n  }\n  const s = sorter.sorts[prop] as PropertySort<SortValue>\n\n  const index = s.docs[id]\n  delete s.docs[id]\n\n  // Decrement position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length\n  for (let i = index + 1; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0]\n    s.docs[docId]--\n  }\n\n  s.orderedDocs.splice(index, 1)\n}\n\nasync function sortBy(sorter: Sorter, docIds: [string, number][], by: SorterParams): Promise<[string, number][]> {\n  if (!sorter.enabled) {\n    throw createError('SORT_DISABLED')\n  }\n\n  const property = by.property\n  const isDesc = by.order === 'DESC'\n\n  const s = sorter.sorts[property]\n  if (!s) {\n    throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '))\n  }\n\n  docIds.sort((a, b) => {\n    // This sort algorithm works leveraging on\n    // that s.docs is a map of docId -> position\n    // If a document is not indexed, it will be not present in the map\n    const indexOfA = s.docs[a[0]]\n    const indexOfB = s.docs[b[0]]\n    const isAIndexed = typeof indexOfA !== 'undefined'\n    const isBIndexed = typeof indexOfB !== 'undefined'\n\n    if (!isAIndexed && !isBIndexed) {\n      return 0\n    }\n    // unindexed documents are always at the end\n    if (!isAIndexed) {\n      return 1\n    }\n    if (!isBIndexed) {\n      return -1\n    }\n\n    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB\n  })\n\n  return docIds\n}\n\nasync function getSortableProperties(sorter: Sorter): Promise<string[]> {\n  if (!sorter.enabled) {\n    return []\n  }\n\n  return sorter.sortableProperties\n}\n\nasync function getSortablePropertiesWithTypes(sorter: Sorter): Promise<Record<string, SortType>> {\n  if (!sorter.enabled) {\n    return {}\n  }\n\n  return sorter.sortablePropertiesWithTypes\n}\n\nexport async function load<R = unknown>(raw: R): Promise<Sorter> {\n  const rawDocument = raw as Sorter\n  if (!rawDocument.enabled) {\n    return {\n      enabled: false,\n    } as unknown as Sorter\n  }\n\n  return {\n    sortableProperties: rawDocument.sortableProperties,\n    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n    sorts: rawDocument.sorts,\n    enabled: true,\n  }\n}\n\nexport async function save<R = unknown>(sorter: Sorter): Promise<R> {\n  if (!sorter.enabled) {\n    return {\n      enabled: false,\n    } as unknown as R\n  }\n\n  return {\n    sortableProperties: sorter.sortableProperties,\n    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n    sorts: sorter.sorts,\n    enabled: sorter.enabled,\n  } as R\n}\n\nexport async function createSorter(): Promise<DefaultSorter> {\n  return {\n    create,\n    insert,\n    remove,\n    save,\n    load,\n    sortBy,\n    getSortableProperties,\n    getSortablePropertiesWithTypes,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}