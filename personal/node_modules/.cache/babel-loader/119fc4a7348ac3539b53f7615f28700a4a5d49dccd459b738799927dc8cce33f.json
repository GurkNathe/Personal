{"ast":null,"code":"import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js';\nimport { createDocumentsStore } from '../components/documents-store.js';\nimport { FUNCTION_COMPONENTS, OBJECT_COMPONENTS, SINGLE_OR_ARRAY_COMPONENTS } from '../components/hooks.js';\nimport { createIndex } from '../components/index.js';\nimport { createInternalDocumentIDStore } from '../components/internal-document-id-store.js';\nimport { createSorter } from '../components/sorter.js';\nimport { createTokenizer } from '../components/tokenizer/index.js';\nimport { createError } from '../errors.js';\nimport { uniqueId } from '../utils.js';\nfunction validateComponents(components) {\n  const defaultComponents = {\n    formatElapsedTime,\n    getDocumentIndexId,\n    getDocumentProperties,\n    validateSchema\n  };\n  for (const rawKey of FUNCTION_COMPONENTS) {\n    const key = rawKey;\n    if (components[key]) {\n      if (typeof components[key] !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION', key);\n      }\n    } else {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = defaultComponents[key];\n    }\n  }\n  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {\n    const key = rawKey;\n    const component = components[key];\n    if (!component) {\n      components[key] = [];\n    } else if (!Array.isArray(components[key])) {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = [components[key]];\n    }\n    for (const fn of components[key]) {\n      if (typeof fn !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS', key);\n      }\n    }\n  }\n  for (const rawKey of Object.keys(components)) {\n    if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey) && !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)) {\n      throw createError('UNSUPPORTED_COMPONENT', rawKey);\n    }\n  }\n}\nexport async function create({\n  schema,\n  sort,\n  language,\n  components,\n  id\n}) {\n  if (!components) {\n    components = {};\n  }\n  if (!id) {\n    id = await uniqueId();\n  }\n  let tokenizer = components.tokenizer;\n  let index = components.index;\n  let documentsStore = components.documentsStore;\n  let sorter = components.sorter;\n  if (!tokenizer) {\n    // Use the default tokenizer\n    tokenizer = await createTokenizer({\n      language: language ?? 'english'\n    });\n  } else if (!tokenizer.tokenize) {\n    // If there is no tokenizer function, we assume this is a TokenizerConfig\n    tokenizer = await createTokenizer(tokenizer);\n  }\n  if (components.tokenizer && language) {\n    // Accept language only if a tokenizer is not provided\n    throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER');\n  }\n  const internalDocumentStore = createInternalDocumentIDStore();\n  index ||= await createIndex();\n  sorter ||= await createSorter();\n  documentsStore ||= await createDocumentsStore();\n  // Validate all other components\n  validateComponents(components);\n  // Assign only recognized components and hooks\n  const {\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime\n  } = components;\n  const orama = {\n    data: {},\n    caches: {},\n    schema,\n    tokenizer,\n    index,\n    sorter,\n    documentsStore,\n    internalDocumentIDStore: internalDocumentStore,\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n    id\n  };\n  orama.data = {\n    index: await orama.index.create(orama, internalDocumentStore, schema),\n    docs: await orama.documentsStore.create(orama, internalDocumentStore),\n    sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort)\n  };\n  return orama;\n}","map":{"version":3,"names":["formatElapsedTime","getDocumentIndexId","getDocumentProperties","validateSchema","createDocumentsStore","FUNCTION_COMPONENTS","OBJECT_COMPONENTS","SINGLE_OR_ARRAY_COMPONENTS","createIndex","createInternalDocumentIDStore","createSorter","createTokenizer","createError","uniqueId","validateComponents","components","defaultComponents","rawKey","key","component","Array","isArray","fn","Object","keys","includes","create","schema","sort","language","id","tokenizer","index","documentsStore","sorter","tokenize","internalDocumentStore","beforeInsert","afterInsert","beforeRemove","afterRemove","beforeUpdate","afterUpdate","afterSearch","beforeMultipleInsert","afterMultipleInsert","beforeMultipleRemove","afterMultipleRemove","beforeMultipleUpdate","afterMultipleUpdate","orama","data","caches","internalDocumentIDStore","docs","sorting"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/methods/create.ts"],"sourcesContent":["import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js'\nimport { DocumentsStore, createDocumentsStore } from '../components/documents-store.js'\nimport { FUNCTION_COMPONENTS, OBJECT_COMPONENTS, SINGLE_OR_ARRAY_COMPONENTS } from '../components/hooks.js'\nimport { Index, createIndex } from '../components/index.js'\nimport { createInternalDocumentIDStore } from '../components/internal-document-id-store.js'\nimport { Sorter, createSorter } from '../components/sorter.js'\nimport { createTokenizer } from '../components/tokenizer/index.js'\nimport { createError } from '../errors.js'\nimport {\n  AfterSearch,\n  ArrayCallbackComponents,\n  Components,\n  FunctionComponents,\n  IDocumentsStore,\n  IIndex,\n  ISorter,\n  MultipleCallbackComponent,\n  Orama,\n  SingleCallbackComponent,\n  SingleOrArray,\n  SingleOrArrayCallbackComponents,\n  SorterConfig,\n  Tokenizer\n} from '../types.js'\nimport { uniqueId } from '../utils.js'\n\ninterface CreateArguments<OramaSchema, TIndex, TDocumentStore, TSorter> {\n  schema: OramaSchema,\n  sort?: SorterConfig\n  language?: string\n  components?: Components<Orama<OramaSchema, TIndex, TDocumentStore, TSorter>, OramaSchema, TIndex, TDocumentStore, TSorter>\n  id?: string\n}\n\nfunction validateComponents<OramaSchema, TIndex, TDocumentStore, TSorter, TOrama extends Orama<OramaSchema, TIndex, TDocumentStore, TSorter>>(components: Components<TOrama, OramaSchema, TIndex, TDocumentStore, TSorter>) {\n  const defaultComponents = {\n    formatElapsedTime,\n    getDocumentIndexId,\n    getDocumentProperties,\n    validateSchema,\n  }\n\n  for (const rawKey of FUNCTION_COMPONENTS) {\n    const key = rawKey as keyof FunctionComponents<OramaSchema>\n\n    if (components[key]) {\n      if (typeof components[key] !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION', key)\n      }\n    } else {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = defaultComponents[key]\n    }\n  }\n\n  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {\n    const key = rawKey as keyof ArrayCallbackComponents<TOrama>\n\n    const component:\n      | SingleOrArray<AfterSearch<TOrama>>\n      | SingleOrArray<SingleCallbackComponent<TOrama>>\n      | SingleOrArray<MultipleCallbackComponent<TOrama>>\n      | undefined = components[key]\n    if (!component) {\n      components[key] = []\n    } else if (!Array.isArray(components[key])) {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = [components[key]]\n    }\n\n    for (const fn of components[key] as unknown as SingleOrArrayCallbackComponents<TOrama>[]) {\n      if (typeof fn !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS', key)\n      }\n    }\n  }\n\n  for (const rawKey of Object.keys(components)) {\n    if (\n      !OBJECT_COMPONENTS.includes(rawKey) &&\n      !FUNCTION_COMPONENTS.includes(rawKey) &&\n      !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)\n    ) {\n      throw createError('UNSUPPORTED_COMPONENT', rawKey)\n    }\n  }\n}\n\nexport async function create<\n  OramaSchema,\n  TIndex = IIndex<Index>, \n  TDocumentStore = IDocumentsStore<DocumentsStore>, \n  TSorter = ISorter<Sorter>> ({\n  schema,\n  sort,\n  language,\n  components,\n  id,\n}: CreateArguments<OramaSchema, TIndex, TDocumentStore, TSorter>): Promise<Orama<OramaSchema, TIndex, TDocumentStore, TSorter>> {\n  if (!components) {\n    components = {}\n  }\n\n  if (!id) {\n    id = await uniqueId()\n  }\n\n  let tokenizer = components.tokenizer as Tokenizer\n  let index: TIndex | undefined = components.index\n  let documentsStore: TDocumentStore | undefined = components.documentsStore\n  let sorter: TSorter | undefined = components.sorter\n\n  if (!tokenizer) {\n    // Use the default tokenizer\n    tokenizer = await createTokenizer({ language: language ?? 'english' })\n  } else if (!tokenizer.tokenize) {\n    // If there is no tokenizer function, we assume this is a TokenizerConfig\n    tokenizer = await createTokenizer(tokenizer)\n  }\n\n  if (components.tokenizer && language) {\n    // Accept language only if a tokenizer is not provided\n    throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER')\n  }\n\n  const internalDocumentStore = createInternalDocumentIDStore()\n\n  index ||= await createIndex() as TIndex\n  sorter ||= await createSorter() as TSorter\n  documentsStore ||= await createDocumentsStore() as TDocumentStore\n\n  // Validate all other components\n  validateComponents(components)\n\n  // Assign only recognized components and hooks\n  const {\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n  } = components\n\n  const orama = {\n    data: {},\n    caches: {},\n    schema,\n    tokenizer,\n    index,\n    sorter,\n    documentsStore,\n    internalDocumentIDStore: internalDocumentStore,\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n    id,\n  } as unknown as Orama<OramaSchema, TIndex, TDocumentStore, TSorter>\n\n  orama.data = {\n    index: await orama.index.create(orama, internalDocumentStore, schema),\n    docs: await orama.documentsStore.create(orama, internalDocumentStore),\n    sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort),\n  }\n\n  return orama\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}