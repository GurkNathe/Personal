{"ast":null,"code":"import { Vector2, RGBAFormat, MeshNormalMaterial, ShaderMaterial, Vector4, WebGLRenderTarget, DepthTexture, NearestFilter } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nclass RenderPixelatedPass extends Pass {\n  constructor(resolution, pixelSize, scene, camera) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var _a, _b;\n    super();\n    this.pixelSize = pixelSize;\n    this.resolution = new Vector2();\n    this.renderResolution = new Vector2();\n    this.setSize(resolution.x, resolution.y);\n    this.fsQuad = new FullScreenQuad(this.material());\n    this.scene = scene;\n    this.camera = camera;\n    this.normalEdgeStrength = (_a = options.normalEdgeStrength) != null ? _a : 0.3;\n    this.depthEdgeStrength = (_b = options.depthEdgeStrength) != null ? _b : 0.4;\n    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true);\n    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false);\n    this.normalMaterial = new MeshNormalMaterial();\n  }\n  dispose() {\n    this.rgbRenderTarget.dispose();\n    this.normalRenderTarget.dispose();\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    var _a, _b, _c;\n    this.resolution.set(width, height);\n    this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n    const {\n      x,\n      y\n    } = this.renderResolution;\n    (_a = this.rgbRenderTarget) == null ? void 0 : _a.setSize(x, y);\n    (_b = this.normalRenderTarget) == null ? void 0 : _b.setSize(x, y);\n    (_c = this.fsQuad) == null ? void 0 : _c.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n  }\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize;\n    this.setSize(this.resolution.x, this.resolution.y);\n  }\n  render(renderer, writeBuffer) {\n    const uniforms = this.fsQuad.material.uniforms;\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n    renderer.setRenderTarget(this.rgbRenderTarget);\n    renderer.render(this.scene, this.camera);\n    const overrideMaterial_old = this.scene.overrideMaterial;\n    renderer.setRenderTarget(this.normalRenderTarget);\n    this.scene.overrideMaterial = this.normalMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = overrideMaterial_old;\n    uniforms.tDiffuse.value = this.rgbRenderTarget.texture;\n    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;\n    uniforms.tNormal.value = this.normalRenderTarget.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n    }\n    this.fsQuad.render(renderer);\n  }\n  material() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: {\n          value: null\n        },\n        tDepth: {\n          value: null\n        },\n        tNormal: {\n          value: null\n        },\n        resolution: {\n          value: new Vector4(this.renderResolution.x, this.renderResolution.y, 1 / this.renderResolution.x, 1 / this.renderResolution.y)\n        },\n        normalEdgeStrength: {\n          value: 0\n        },\n        depthEdgeStrength: {\n          value: 0\n        }\n      },\n      vertexShader: `\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t\t`,\n      fragmentShader: `\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\t\t\t\t\t\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\t\t\t\t\t\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0) \n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0; \n\t\t\t\t\tif (normalEdgeStrength > 0.0) \n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t\t`\n    });\n  }\n}\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  const renderTarget = new WebGLRenderTarget(resolution.x, resolution.y, !useDepthTexture ? void 0 : {\n    depthTexture: new DepthTexture(resolution.x, resolution.y),\n    depthBuffer: true\n  });\n  renderTarget.texture.format = pixelFormat;\n  renderTarget.texture.minFilter = NearestFilter;\n  renderTarget.texture.magFilter = NearestFilter;\n  renderTarget.texture.generateMipmaps = false;\n  renderTarget.stencilBuffer = false;\n  return renderTarget;\n}\nexport { RenderPixelatedPass };","map":{"version":3,"names":["Vector2","RGBAFormat","MeshNormalMaterial","ShaderMaterial","Vector4","WebGLRenderTarget","DepthTexture","NearestFilter","Pass","FullScreenQuad","RenderPixelatedPass","constructor","resolution","pixelSize","scene","camera","options","arguments","length","undefined","_a","_b","renderResolution","setSize","x","y","fsQuad","material","normalEdgeStrength","depthEdgeStrength","rgbRenderTarget","pixelRenderTarget","normalRenderTarget","normalMaterial","dispose","width","height","_c","set","uniforms","value","setPixelSize","render","renderer","writeBuffer","setRenderTarget","overrideMaterial_old","overrideMaterial","tDiffuse","texture","tDepth","depthTexture","tNormal","renderToScreen","clear","vertexShader","fragmentShader","pixelFormat","useDepthTexture","renderTarget","depthBuffer","format","minFilter","magFilter","generateMipmaps","stencilBuffer"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/postprocessing/RenderPixelatedPass.js"],"sourcesContent":["import { Vector2, RGBAFormat, MeshNormalMaterial, ShaderMaterial, Vector4, WebGLRenderTarget, DepthTexture, NearestFilter } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nclass RenderPixelatedPass extends Pass {\n  constructor(resolution, pixelSize, scene, camera, options = {}) {\n    var _a, _b;\n    super();\n    this.pixelSize = pixelSize;\n    this.resolution = new Vector2();\n    this.renderResolution = new Vector2();\n    this.setSize(resolution.x, resolution.y);\n    this.fsQuad = new FullScreenQuad(this.material());\n    this.scene = scene;\n    this.camera = camera;\n    this.normalEdgeStrength = (_a = options.normalEdgeStrength) != null ? _a : 0.3;\n    this.depthEdgeStrength = (_b = options.depthEdgeStrength) != null ? _b : 0.4;\n    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true);\n    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false);\n    this.normalMaterial = new MeshNormalMaterial();\n  }\n  dispose() {\n    this.rgbRenderTarget.dispose();\n    this.normalRenderTarget.dispose();\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    var _a, _b, _c;\n    this.resolution.set(width, height);\n    this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n    const { x, y } = this.renderResolution;\n    (_a = this.rgbRenderTarget) == null ? void 0 : _a.setSize(x, y);\n    (_b = this.normalRenderTarget) == null ? void 0 : _b.setSize(x, y);\n    (_c = this.fsQuad) == null ? void 0 : _c.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n  }\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize;\n    this.setSize(this.resolution.x, this.resolution.y);\n  }\n  render(renderer, writeBuffer) {\n    const uniforms = this.fsQuad.material.uniforms;\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n    renderer.setRenderTarget(this.rgbRenderTarget);\n    renderer.render(this.scene, this.camera);\n    const overrideMaterial_old = this.scene.overrideMaterial;\n    renderer.setRenderTarget(this.normalRenderTarget);\n    this.scene.overrideMaterial = this.normalMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = overrideMaterial_old;\n    uniforms.tDiffuse.value = this.rgbRenderTarget.texture;\n    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;\n    uniforms.tNormal.value = this.normalRenderTarget.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear)\n        renderer.clear();\n    }\n    this.fsQuad.render(renderer);\n  }\n  material() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: { value: null },\n        tDepth: { value: null },\n        tNormal: { value: null },\n        resolution: {\n          value: new Vector4(\n            this.renderResolution.x,\n            this.renderResolution.y,\n            1 / this.renderResolution.x,\n            1 / this.renderResolution.y\n          )\n        },\n        normalEdgeStrength: { value: 0 },\n        depthEdgeStrength: { value: 0 }\n      },\n      vertexShader: `\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t\t`,\n      fragmentShader: `\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\t\t\t\t\t\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\t\t\t\t\t\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0) \n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0; \n\t\t\t\t\tif (normalEdgeStrength > 0.0) \n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t\t`\n    });\n  }\n}\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  const renderTarget = new WebGLRenderTarget(\n    resolution.x,\n    resolution.y,\n    !useDepthTexture ? void 0 : {\n      depthTexture: new DepthTexture(resolution.x, resolution.y),\n      depthBuffer: true\n    }\n  );\n  renderTarget.texture.format = pixelFormat;\n  renderTarget.texture.minFilter = NearestFilter;\n  renderTarget.texture.magFilter = NearestFilter;\n  renderTarget.texture.generateMipmaps = false;\n  renderTarget.stencilBuffer = false;\n  return renderTarget;\n}\nexport {\n  RenderPixelatedPass\n};\n"],"mappings":"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AACG,CAAC,EACvB,CAAC,GAAG,IAAI,CAACH,gBAAgB,CAACE,CAAC,EAC3B,CAAC,GAAG,IAAI,CAACF,gBAAgB,CAACG,CAC5B;QACF,CAAC;QACDG,kBAAkB,EAAE;UAAEY,KAAK,EAAE;QAAE,CAAC;QAChCX,iBAAiB,EAAE;UAAEW,KAAK,EAAE;QAAE;MAChC,CAAC;MACDe,YAAY,EAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;MACCC,cAAc,EAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,CAAC,CAAC;EACJ;AACF;AACA,SAASzB,iBAAiBA,CAACnB,UAAU,EAAE6C,WAAW,EAAEC,eAAe,EAAE;EACnE,MAAMC,YAAY,GAAG,IAAItD,iBAAiB,CACxCO,UAAU,CAACY,CAAC,EACZZ,UAAU,CAACa,CAAC,EACZ,CAACiC,eAAe,GAAG,KAAK,CAAC,GAAG;IAC1BP,YAAY,EAAE,IAAI7C,YAAY,CAACM,UAAU,CAACY,CAAC,EAAEZ,UAAU,CAACa,CAAC,CAAC;IAC1DmC,WAAW,EAAE;EACf,CACF,CAAC;EACDD,YAAY,CAACV,OAAO,CAACY,MAAM,GAAGJ,WAAW;EACzCE,YAAY,CAACV,OAAO,CAACa,SAAS,GAAGvD,aAAa;EAC9CoD,YAAY,CAACV,OAAO,CAACc,SAAS,GAAGxD,aAAa;EAC9CoD,YAAY,CAACV,OAAO,CAACe,eAAe,GAAG,KAAK;EAC5CL,YAAY,CAACM,aAAa,GAAG,KAAK;EAClC,OAAON,YAAY;AACrB;AACA,SACEjD,mBAAmB"},"metadata":{},"sourceType":"module","externalDependencies":[]}