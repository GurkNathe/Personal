{"ast":null,"code":"const HalftoneShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    shape: {\n      value: 1\n    },\n    radius: {\n      value: 4\n    },\n    rotateR: {\n      value: Math.PI / 12 * 1\n    },\n    rotateG: {\n      value: Math.PI / 12 * 2\n    },\n    rotateB: {\n      value: Math.PI / 12 * 3\n    },\n    scatter: {\n      value: 0\n    },\n    width: {\n      value: 1\n    },\n    height: {\n      value: 1\n    },\n    blending: {\n      value: 1\n    },\n    blendingMode: {\n      value: 1\n    },\n    greyscale: {\n      value: false\n    },\n    disable: {\n      value: false\n    }\n  },\n  vertexShader: [\"varying vec2 vUV;\", \"void main() {\", \"\tvUV = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#define SQRT2_MINUS_ONE 0.41421356\", \"#define SQRT2_HALF_MINUS_ONE 0.20710678\", \"#define PI2 6.28318531\", \"#define SHAPE_DOT 1\", \"#define SHAPE_ELLIPSE 2\", \"#define SHAPE_LINE 3\", \"#define SHAPE_SQUARE 4\", \"#define BLENDING_LINEAR 1\", \"#define BLENDING_MULTIPLY 2\", \"#define BLENDING_ADD 3\", \"#define BLENDING_LIGHTER 4\", \"#define BLENDING_DARKER 5\", \"uniform sampler2D tDiffuse;\", \"uniform float radius;\", \"uniform float rotateR;\", \"uniform float rotateG;\", \"uniform float rotateB;\", \"uniform float scatter;\", \"uniform float width;\", \"uniform float height;\", \"uniform int shape;\", \"uniform bool disable;\", \"uniform float blending;\", \"uniform int blendingMode;\", \"varying vec2 vUV;\", \"uniform bool greyscale;\", \"const int samples = 8;\", \"float blend( float a, float b, float t ) {\",\n  // linear blend\n  \"\treturn a * ( 1.0 - t ) + b * t;\", \"}\", \"float hypot( float x, float y ) {\",\n  // vector magnitude\n  \"\treturn sqrt( x * x + y * y );\", \"}\", \"float rand( vec2 seed ){\",\n  // get pseudo-random number\n  \"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\", \"}\", \"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\",\n  // apply shape-specific transforms\n  \"\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );\", \"\tfloat rad = channel;\", \"\tif ( shape == SHAPE_DOT ) {\", \"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\", \"\t} else if ( shape == SHAPE_ELLIPSE ) {\", \"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\", \"\t\tif ( dist != 0.0 ) {\", \"\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\", \"\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\", \"\t\t}\", \"\t} else if ( shape == SHAPE_LINE ) {\", \"\t\trad = pow( abs( rad ), 1.5) * rad_max;\", \"\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\", \"\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );\", \"\t} else if ( shape == SHAPE_SQUARE ) {\", \"\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\", \"\t\tfloat sin_t = abs( sin( theta ) );\", \"\t\tfloat cos_t = abs( cos( theta ) );\", \"\t\trad = pow( abs( rad ), 1.4 );\", \"\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\", \"\t}\", \"\treturn rad - dist;\", \"}\", \"struct Cell {\",\n  // grid sample positions\n  \"\tvec2 normal;\", \"\tvec2 p1;\", \"\tvec2 p2;\", \"\tvec2 p3;\", \"\tvec2 p4;\", \"\tfloat samp2;\", \"\tfloat samp1;\", \"\tfloat samp3;\", \"\tfloat samp4;\", \"};\", \"vec4 getSample( vec2 point ) {\",\n  // multi-sampled point\n  \"\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\", \"\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\", \"\tfloat step = PI2 / float( samples );\", \"\tfloat dist = radius * 0.66;\", \"\tfor ( int i = 0; i < samples; ++i ) {\", \"\t\tfloat r = base + step * float( i );\", \"\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\", \"\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\", \"\t}\", \"\ttex /= float( samples ) + 1.0;\", \"\treturn tex;\", \"}\", \"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\",\n  // get colour for given point\n  \"\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\", \"\tif ( channel == 0 ) {\", \"\t\tc.samp1 = getSample( c.p1 ).r;\", \"\t\tc.samp2 = getSample( c.p2 ).r;\", \"\t\tc.samp3 = getSample( c.p3 ).r;\", \"\t\tc.samp4 = getSample( c.p4 ).r;\", \"\t} else if (channel == 1) {\", \"\t\tc.samp1 = getSample( c.p1 ).g;\", \"\t\tc.samp2 = getSample( c.p2 ).g;\", \"\t\tc.samp3 = getSample( c.p3 ).g;\", \"\t\tc.samp4 = getSample( c.p4 ).g;\", \"\t} else {\", \"\t\tc.samp1 = getSample( c.p1 ).b;\", \"\t\tc.samp3 = getSample( c.p3 ).b;\", \"\t\tc.samp2 = getSample( c.p2 ).b;\", \"\t\tc.samp4 = getSample( c.p4 ).b;\", \"\t}\", \"\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\", \"\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\", \"\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\", \"\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\", \"\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\", \"\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\", \"\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\", \"\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\", \"\tres = clamp( res, 0.0, 1.0 );\", \"\treturn res;\", \"}\", \"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\",\n  // get containing cell\n  \"\tCell c;\",\n  // calc grid\n  \"\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\", \"\tfloat threshold = step * 0.5;\", \"\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\", \"\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\", \"\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\", \"\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );\", \"\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\", \"\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\", \"\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\", \"\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\", \"\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\",\n  // get closest corner\n  \"\tc.normal = n;\", \"\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\", \"\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\",\n  // scatter\n  \"\tif ( scatter != 0.0 ) {\", \"\t\tfloat off_mag = scatter * threshold * 0.5;\", \"\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\", \"\t\tc.p1.x += cos( off_angle ) * off_mag;\", \"\t\tc.p1.y += sin( off_angle ) * off_mag;\", \"\t}\",\n  // find corners\n  \"\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\", \"\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\", \"\tc.p2.x = c.p1.x - n.x * normal_step;\", \"\tc.p2.y = c.p1.y - n.y * normal_step;\", \"\tc.p3.x = c.p1.x + n.y * line_step;\", \"\tc.p3.y = c.p1.y - n.x * line_step;\", \"\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\", \"\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\", \"\treturn c;\", \"}\", \"float blendColour( float a, float b, float t ) {\",\n  // blend colours\n  \"\tif ( blendingMode == BLENDING_LINEAR ) {\", \"\t\treturn blend( a, b, 1.0 - t );\", \"\t} else if ( blendingMode == BLENDING_ADD ) {\", \"\t\treturn blend( a, min( 1.0, a + b ), t );\", \"\t} else if ( blendingMode == BLENDING_MULTIPLY ) {\", \"\t\treturn blend( a, max( 0.0, a * b ), t );\", \"\t} else if ( blendingMode == BLENDING_LIGHTER ) {\", \"\t\treturn blend( a, max( a, b ), t );\", \"\t} else if ( blendingMode == BLENDING_DARKER ) {\", \"\t\treturn blend( a, min( a, b ), t );\", \"\t} else {\", \"\t\treturn blend( a, b, 1.0 - t );\", \"\t}\", \"}\", \"void main() {\", \"\tif ( ! disable ) {\",\n  // setup\n  \"\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );\", \"\t\tvec2 origin = vec2( 0, 0 );\", \"\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\",\n  // get channel samples\n  \"\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );\", \"\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );\", \"\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );\", \"\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );\", \"\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );\", \"\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );\",\n  // blend with original\n  \"\t\tvec4 colour = texture2D( tDiffuse, vUV );\", \"\t\tr = blendColour( r, colour.r, blending );\", \"\t\tg = blendColour( g, colour.g, blending );\", \"\t\tb = blendColour( b, colour.b, blending );\", \"\t\tif ( greyscale ) {\", \"\t\t\tr = g = b = (r + b + g) / 3.0;\", \"\t\t}\", \"\t\tgl_FragColor = vec4( r, g, b, 1.0 );\", \"\t} else {\", \"\t\tgl_FragColor = texture2D( tDiffuse, vUV );\", \"\t}\", \"}\"].join(\"\\n\")\n};\nexport { HalftoneShader };","map":{"version":3,"names":["HalftoneShader","uniforms","tDiffuse","value","shape","radius","rotateR","Math","PI","rotateG","rotateB","scatter","width","height","blending","blendingMode","greyscale","disable","vertexShader","join","fragmentShader"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/shaders/HalftoneShader.js"],"sourcesContent":["const HalftoneShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    shape: { value: 1 },\n    radius: { value: 4 },\n    rotateR: { value: Math.PI / 12 * 1 },\n    rotateG: { value: Math.PI / 12 * 2 },\n    rotateB: { value: Math.PI / 12 * 3 },\n    scatter: { value: 0 },\n    width: { value: 1 },\n    height: { value: 1 },\n    blending: { value: 1 },\n    blendingMode: { value: 1 },\n    greyscale: { value: false },\n    disable: { value: false }\n  },\n  vertexShader: [\n    \"varying vec2 vUV;\",\n    \"void main() {\",\n    \"\tvUV = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#define SQRT2_MINUS_ONE 0.41421356\",\n    \"#define SQRT2_HALF_MINUS_ONE 0.20710678\",\n    \"#define PI2 6.28318531\",\n    \"#define SHAPE_DOT 1\",\n    \"#define SHAPE_ELLIPSE 2\",\n    \"#define SHAPE_LINE 3\",\n    \"#define SHAPE_SQUARE 4\",\n    \"#define BLENDING_LINEAR 1\",\n    \"#define BLENDING_MULTIPLY 2\",\n    \"#define BLENDING_ADD 3\",\n    \"#define BLENDING_LIGHTER 4\",\n    \"#define BLENDING_DARKER 5\",\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform float radius;\",\n    \"uniform float rotateR;\",\n    \"uniform float rotateG;\",\n    \"uniform float rotateB;\",\n    \"uniform float scatter;\",\n    \"uniform float width;\",\n    \"uniform float height;\",\n    \"uniform int shape;\",\n    \"uniform bool disable;\",\n    \"uniform float blending;\",\n    \"uniform int blendingMode;\",\n    \"varying vec2 vUV;\",\n    \"uniform bool greyscale;\",\n    \"const int samples = 8;\",\n    \"float blend( float a, float b, float t ) {\",\n    // linear blend\n    \"\treturn a * ( 1.0 - t ) + b * t;\",\n    \"}\",\n    \"float hypot( float x, float y ) {\",\n    // vector magnitude\n    \"\treturn sqrt( x * x + y * y );\",\n    \"}\",\n    \"float rand( vec2 seed ){\",\n    // get pseudo-random number\n    \"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\",\n    \"}\",\n    \"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\",\n    // apply shape-specific transforms\n    \"\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );\",\n    \"\tfloat rad = channel;\",\n    \"\tif ( shape == SHAPE_DOT ) {\",\n    \"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\",\n    \"\t} else if ( shape == SHAPE_ELLIPSE ) {\",\n    \"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\",\n    \"\t\tif ( dist != 0.0 ) {\",\n    \"\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\",\n    \"\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\",\n    \"\t\t}\",\n    \"\t} else if ( shape == SHAPE_LINE ) {\",\n    \"\t\trad = pow( abs( rad ), 1.5) * rad_max;\",\n    \"\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\",\n    \"\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );\",\n    \"\t} else if ( shape == SHAPE_SQUARE ) {\",\n    \"\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\",\n    \"\t\tfloat sin_t = abs( sin( theta ) );\",\n    \"\t\tfloat cos_t = abs( cos( theta ) );\",\n    \"\t\trad = pow( abs( rad ), 1.4 );\",\n    \"\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\",\n    \"\t}\",\n    \"\treturn rad - dist;\",\n    \"}\",\n    \"struct Cell {\",\n    // grid sample positions\n    \"\tvec2 normal;\",\n    \"\tvec2 p1;\",\n    \"\tvec2 p2;\",\n    \"\tvec2 p3;\",\n    \"\tvec2 p4;\",\n    \"\tfloat samp2;\",\n    \"\tfloat samp1;\",\n    \"\tfloat samp3;\",\n    \"\tfloat samp4;\",\n    \"};\",\n    \"vec4 getSample( vec2 point ) {\",\n    // multi-sampled point\n    \"\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\",\n    \"\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\",\n    \"\tfloat step = PI2 / float( samples );\",\n    \"\tfloat dist = radius * 0.66;\",\n    \"\tfor ( int i = 0; i < samples; ++i ) {\",\n    \"\t\tfloat r = base + step * float( i );\",\n    \"\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\",\n    \"\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\",\n    \"\t}\",\n    \"\ttex /= float( samples ) + 1.0;\",\n    \"\treturn tex;\",\n    \"}\",\n    \"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\",\n    // get colour for given point\n    \"\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\",\n    \"\tif ( channel == 0 ) {\",\n    \"\t\tc.samp1 = getSample( c.p1 ).r;\",\n    \"\t\tc.samp2 = getSample( c.p2 ).r;\",\n    \"\t\tc.samp3 = getSample( c.p3 ).r;\",\n    \"\t\tc.samp4 = getSample( c.p4 ).r;\",\n    \"\t} else if (channel == 1) {\",\n    \"\t\tc.samp1 = getSample( c.p1 ).g;\",\n    \"\t\tc.samp2 = getSample( c.p2 ).g;\",\n    \"\t\tc.samp3 = getSample( c.p3 ).g;\",\n    \"\t\tc.samp4 = getSample( c.p4 ).g;\",\n    \"\t} else {\",\n    \"\t\tc.samp1 = getSample( c.p1 ).b;\",\n    \"\t\tc.samp3 = getSample( c.p3 ).b;\",\n    \"\t\tc.samp2 = getSample( c.p2 ).b;\",\n    \"\t\tc.samp4 = getSample( c.p4 ).b;\",\n    \"\t}\",\n    \"\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\",\n    \"\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\",\n    \"\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\",\n    \"\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\",\n    \"\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\",\n    \"\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\",\n    \"\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\",\n    \"\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\",\n    \"\tres = clamp( res, 0.0, 1.0 );\",\n    \"\treturn res;\",\n    \"}\",\n    \"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\",\n    // get containing cell\n    \"\tCell c;\",\n    // calc grid\n    \"\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\",\n    \"\tfloat threshold = step * 0.5;\",\n    \"\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\",\n    \"\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\",\n    \"\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\",\n    \"\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );\",\n    \"\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\",\n    \"\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\",\n    \"\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\",\n    \"\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\",\n    \"\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\",\n    // get closest corner\n    \"\tc.normal = n;\",\n    \"\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\",\n    \"\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\",\n    // scatter\n    \"\tif ( scatter != 0.0 ) {\",\n    \"\t\tfloat off_mag = scatter * threshold * 0.5;\",\n    \"\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\",\n    \"\t\tc.p1.x += cos( off_angle ) * off_mag;\",\n    \"\t\tc.p1.y += sin( off_angle ) * off_mag;\",\n    \"\t}\",\n    // find corners\n    \"\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\",\n    \"\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\",\n    \"\tc.p2.x = c.p1.x - n.x * normal_step;\",\n    \"\tc.p2.y = c.p1.y - n.y * normal_step;\",\n    \"\tc.p3.x = c.p1.x + n.y * line_step;\",\n    \"\tc.p3.y = c.p1.y - n.x * line_step;\",\n    \"\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\",\n    \"\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\",\n    \"\treturn c;\",\n    \"}\",\n    \"float blendColour( float a, float b, float t ) {\",\n    // blend colours\n    \"\tif ( blendingMode == BLENDING_LINEAR ) {\",\n    \"\t\treturn blend( a, b, 1.0 - t );\",\n    \"\t} else if ( blendingMode == BLENDING_ADD ) {\",\n    \"\t\treturn blend( a, min( 1.0, a + b ), t );\",\n    \"\t} else if ( blendingMode == BLENDING_MULTIPLY ) {\",\n    \"\t\treturn blend( a, max( 0.0, a * b ), t );\",\n    \"\t} else if ( blendingMode == BLENDING_LIGHTER ) {\",\n    \"\t\treturn blend( a, max( a, b ), t );\",\n    \"\t} else if ( blendingMode == BLENDING_DARKER ) {\",\n    \"\t\treturn blend( a, min( a, b ), t );\",\n    \"\t} else {\",\n    \"\t\treturn blend( a, b, 1.0 - t );\",\n    \"\t}\",\n    \"}\",\n    \"void main() {\",\n    \"\tif ( ! disable ) {\",\n    // setup\n    \"\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );\",\n    \"\t\tvec2 origin = vec2( 0, 0 );\",\n    \"\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\",\n    // get channel samples\n    \"\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );\",\n    \"\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );\",\n    \"\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );\",\n    \"\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );\",\n    \"\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );\",\n    \"\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );\",\n    // blend with original\n    \"\t\tvec4 colour = texture2D( tDiffuse, vUV );\",\n    \"\t\tr = blendColour( r, colour.r, blending );\",\n    \"\t\tg = blendColour( g, colour.g, blending );\",\n    \"\t\tb = blendColour( b, colour.b, blending );\",\n    \"\t\tif ( greyscale ) {\",\n    \"\t\t\tr = g = b = (r + b + g) / 3.0;\",\n    \"\t\t}\",\n    \"\t\tgl_FragColor = vec4( r, g, b, 1.0 );\",\n    \"\t} else {\",\n    \"\t\tgl_FragColor = texture2D( tDiffuse, vUV );\",\n    \"\t}\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  HalftoneShader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}