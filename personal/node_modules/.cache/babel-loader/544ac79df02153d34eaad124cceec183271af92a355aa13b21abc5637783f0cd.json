{"ast":null,"code":"import _defineProperty from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { syncBoundedLevenshtein } from '../components/levenshtein.js';\nimport { getOwnProperty } from '../utils.js';\nexport class Node {\n  constructor(key, subWord, end) {\n    // Node children\n    _defineProperty(this, \"c\", {});\n    // Node documents\n    _defineProperty(this, \"d\", []);\n    // Node word\n    _defineProperty(this, \"w\", '');\n    this.k = key;\n    this.s = subWord;\n    this.e = end;\n  }\n  toJSON() {\n    return {\n      w: this.w,\n      s: this.s,\n      c: this.c,\n      d: this.d,\n      e: this.e\n    };\n  }\n}\nfunction updateParent(node, parent) {\n  node.w = parent.w + node.s;\n}\nfunction addDocument(node, docID) {\n  node.d.push(docID);\n}\nfunction removeDocument(node, docID) {\n  const index = node.d.indexOf(docID);\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false;\n  }\n  node.d.splice(index, 1);\n  return true;\n}\nfunction findAllWords(node, output, term, exact, tolerance) {\n  if (node.e) {\n    const {\n      w,\n      d: docIDs\n    } = node;\n    if (exact && w !== term) {\n      return {};\n    }\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, w) == null) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - w.length);\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n          output[w] = [];\n        }\n      } else {\n        // prevent default tolerance not set\n        output[w] = [];\n      }\n    }\n    // check if _output[w] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n      const docs = new Set(output[w]);\n      const docIDsLength = docIDs.length;\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i]);\n      }\n      output[w] = Array.from(docs);\n    }\n  }\n  // recursively search the children\n  for (const character of Object.keys(node.c)) {\n    findAllWords(node.c[character], output, term, exact, tolerance);\n  }\n  return output;\n}\nfunction getCommonPrefix(a, b) {\n  let commonPrefix = '';\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix;\n    }\n    commonPrefix += a[i];\n  }\n  return commonPrefix;\n}\nexport function create() {\n  let end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let subWord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return new Node(key, subWord, end);\n}\nexport function insert(root, word, docId) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i];\n    const wordAtIndex = word.substring(i);\n    const rootChildCurrentChar = root.c[currentCharacter];\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.s;\n      const edgeLabelLength = edgeLabel.length;\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);\n      const commonPrefixLength = commonPrefix.length;\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId);\n        rootChildCurrentChar.e = true;\n        return;\n      }\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        ;\n        newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        const newNodeChild = newNode.c[edgeLabelAtCommonPrefix];\n        newNodeChild.s = edgeLabel.substring(commonPrefixLength);\n        newNodeChild.k = edgeLabelAtCommonPrefix;\n        root.c[currentCharacter] = newNode;\n        updateParent(newNode, root);\n        updateParent(newNodeChild, newNode);\n        addDocument(newNode, docId);\n        return;\n      }\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter);\n        inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        root.c[currentCharacter] = inbetweenNode;\n        const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix];\n        inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength);\n        inbetweenNodeChild.k = edgeLabelAtCommonPrefix;\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);\n        addDocument(newNode, docId);\n        inbetweenNode.c[wordAtCommonPrefix] = newNode;\n        updateParent(inbetweenNode, root);\n        updateParent(newNode, inbetweenNode);\n        updateParent(inbetweenNodeChild, inbetweenNode);\n        return;\n      }\n      // skip to the next divergent character\n      i += edgeLabelLength - 1;\n      // navigate in the child node\n      root = rootChildCurrentChar;\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter);\n      addDocument(newNode, docId);\n      root.c[currentCharacter] = newNode;\n      updateParent(newNode, root);\n      return;\n    }\n  }\n}\nfunction _findLevenshtein(node, term, index, tolerance, originalTolerance, output) {\n  if (tolerance < 0) {\n    return;\n  }\n  if (node.e) {\n    const {\n      w,\n      d: docIDs\n    } = node;\n    if (w) {\n      const difference = Math.abs(term.length - w.length);\n      if (difference <= originalTolerance && syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n        output[w] = [];\n      }\n      if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n        const docs = new Set(output[w]);\n        const docIDsLength = docIDs.length;\n        for (let i = 0; i < docIDsLength; i++) {\n          docs.add(docIDs[i]);\n        }\n        output[w] = Array.from(docs);\n      }\n    }\n  }\n  if (index >= term.length) {\n    return;\n  }\n  // Match current character without consuming tolerance\n  if (term[index] in node.c) {\n    _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output);\n  }\n  // If tolerance is still available, consider other branches:\n  // 1. Deletion (skip the current term character)\n  _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output);\n  // 2. Insertion (skip the current tree node character)\n  for (const character in node.c) {\n    _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output);\n  }\n  // 3. Substitution (skip both current term character and tree node character)\n  for (const character in node.c) {\n    if (character !== term[index]) {\n      _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output);\n    }\n  }\n}\nexport function find(root, _ref) {\n  let {\n    term,\n    exact,\n    tolerance\n  } = _ref;\n  // Find the closest node to the term\n  // Use `if` condition because tolerance `0` is supposed to match only prefix.\n  // (allows infinite insertions at end, which is against normal levenshtein logic).\n  // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n  if (tolerance && !exact) {\n    const output = {};\n    tolerance = tolerance || 0;\n    _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output);\n    return output;\n  } else {\n    for (let i = 0; i < term.length; i++) {\n      const character = term[i];\n      if (character in root.c) {\n        const rootChildCurrentChar = root.c[character];\n        const edgeLabel = rootChildCurrentChar.s;\n        const termSubstring = term.substring(i);\n        // find the common prefix between two words ex: prime and primate = prim\n        const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n        const commonPrefixLength = commonPrefix.length;\n        // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n        // if the common prefix is equal to the term means it is contained in the node\n        if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n          // if tolerance is set we take the current node as the closest\n          if (tolerance) break;\n          return {};\n        }\n        // skip the subword length and check the next divergent character\n        i += rootChildCurrentChar.s.length - 1;\n        // navigate into the child node\n        root = rootChildCurrentChar;\n      } else {\n        return {};\n      }\n    }\n    const output = {};\n    // found the closest node we recursively search through children\n    findAllWords(root, output, term, exact, tolerance);\n    return output;\n  }\n}\nexport function contains(root, term) {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.c) {\n      const rootChildrenChar = root.c[character];\n      const edgeLabel = rootChildrenChar.s;\n      const termSubstring = term.substring(i);\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      const commonPrefixLength = commonPrefix.length;\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false;\n      }\n      i += rootChildrenChar.s.length - 1;\n      root = rootChildrenChar;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nexport function removeWord(root, term) {\n  if (!term) {\n    return false;\n  }\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    const parent = root;\n    if (character in root.c) {\n      i += root.c[character].s.length - 1;\n      root = root.c[character];\n      if (Object.keys(root.c).length === 0) {\n        delete parent.c[root.k];\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nexport function removeDocumentByWord(root, term, docID) {\n  let exact = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (!term) {\n    return true;\n  }\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.c) {\n      const rootChildCurrentChar = root.c[character];\n      i += rootChildCurrentChar.s.length - 1;\n      root = rootChildCurrentChar;\n      if (exact && root.w !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID);\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["syncBoundedLevenshtein","getOwnProperty","Node","constructor","key","subWord","end","_defineProperty","k","s","e","toJSON","w","c","d","updateParent","node","parent","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","docs","Set","docIDsLength","i","add","Array","from","character","Object","keys","getCommonPrefix","a","b","commonPrefix","len","min","create","arguments","undefined","insert","root","word","docId","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","_findLevenshtein","originalTolerance","find","_ref","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getOwnProperty } from '../utils.js'\n\nexport class Node {\n  constructor (key: string, subWord: string, end: boolean) {\n    this.k = key\n    this.s = subWord\n    this.e = end\n  }\n\n  // Node key\n  public k: string\n  // Node subword\n  public s: string\n  // Node children\n  public c: Record<string, Node> = {}\n  // Node documents\n  public d: InternalDocumentID[] = []\n  // Node end\n  public e: boolean\n  // Node word\n  public w = ''\n\n  public toJSON (): object {\n    return {\n      w: this.w,\n      s: this.s,\n      c: this.c,\n      d: this.d,\n      e: this.e\n    }\n  }\n}\n\ninterface FindParams {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, InternalDocumentID[]>\n\nfunction updateParent (node: Node, parent: Node): void {\n  node.w = parent.w + node.s\n}\n\nfunction addDocument (node: Node, docID: InternalDocumentID): void {\n  node.d.push(docID)\n}\n\nfunction removeDocument (node: Node, docID: InternalDocumentID): boolean {\n  const index = node.d.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.d.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords (node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.e) {\n    const { w, d: docIDs } = node\n\n    if (exact && w !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, w) == null) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - w.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n          output[w] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[w] = []\n      }\n    }\n\n    // check if _output[w] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if ((getOwnProperty(output, w) != null) && (docIDs.length > 0)) {\n      const docs = new Set(output[w])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[w] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.c)) {\n    findAllWords(node.c[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix (a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create (end = false, subWord = '', key = ''): Node {\n  return new Node(key, subWord, end)\n}\n\nexport function insert (root: Node, word: string, docId: InternalDocumentID) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.c[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.s\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.e = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.c[edgeLabelAtCommonPrefix]\n        newNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.k = edgeLabelAtCommonPrefix\n\n        root.c[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.c[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.k = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.c[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.c[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nfunction _findLevenshtein (\n  node: Node,\n  term: string,\n  index: number,\n  tolerance: number,\n  originalTolerance: number,\n  output: FindResult\n) {\n  if (tolerance < 0) {\n    return\n  }\n\n  if (node.e) {\n    const { w, d: docIDs } = node\n    if (w) {\n      const difference = Math.abs(term.length - w.length)\n      if (difference <= originalTolerance && syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n        output[w] = []\n      }\n      if ((getOwnProperty(output, w) != null) && (docIDs.length > 0)) {\n        const docs = new Set(output[w])\n\n        const docIDsLength = docIDs.length\n        for (let i = 0; i < docIDsLength; i++) {\n          docs.add(docIDs[i])\n        }\n        output[w] = Array.from(docs)\n      }\n    }\n  }\n\n  if (index >= term.length) {\n    return\n  }\n\n  // Match current character without consuming tolerance\n  if (term[index] in node.c) {\n    _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output)\n  }\n\n  // If tolerance is still available, consider other branches:\n  // 1. Deletion (skip the current term character)\n  _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output)\n\n  // 2. Insertion (skip the current tree node character)\n  for (const character in node.c) {\n    _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output)\n  }\n\n  // 3. Substitution (skip both current term character and tree node character)\n  for (const character in node.c) {\n    if (character !== term[index]) {\n      _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output)\n    }\n  }\n}\n\nexport function find (root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // Find the closest node to the term\n\n  // Use `if` condition because tolerance `0` is supposed to match only prefix.\n  // (allows infinite insertions at end, which is against normal levenshtein logic).\n  // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n  if (tolerance && !exact) {\n    const output: FindResult = {}\n    tolerance = tolerance || 0\n    _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output)\n    return output\n  } else {\n    for (let i = 0; i < term.length; i++) {\n      const character = term[i]\n      if (character in root.c) {\n        const rootChildCurrentChar = root.c[character]\n        const edgeLabel = rootChildCurrentChar.s\n        const termSubstring = term.substring(i)\n\n        // find the common prefix between two words ex: prime and primate = prim\n        const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n        const commonPrefixLength = commonPrefix.length\n        // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n        // if the common prefix is equal to the term means it is contained in the node\n        if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n          // if tolerance is set we take the current node as the closest\n          if (tolerance) break\n          return {}\n        }\n\n        // skip the subword length and check the next divergent character\n        i += rootChildCurrentChar.s.length - 1\n        // navigate into the child node\n        root = rootChildCurrentChar\n      } else {\n        return {}\n      }\n    }\n\n    const output: FindResult = {}\n    // found the closest node we recursively search through children\n    findAllWords(root, output, term, exact, tolerance)\n\n    return output\n  }\n}\n\nexport function contains (root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.c) {\n      const rootChildrenChar = root.c[character]\n      const edgeLabel = rootChildrenChar.s\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.s.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord (root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.c) {\n      i += root.c[character].s.length - 1\n      root = root.c[character]\n\n      if (Object.keys(root.c).length === 0) {\n        delete parent.c[root.k]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord (root: Node, term: string, docID: InternalDocumentID, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.c) {\n      const rootChildCurrentChar = root.c[character]\n      i += rootChildCurrentChar.s.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.w !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}