{"ast":null,"code":"import _toConsumableArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST, BYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG } from './Constants.js';\nfunction ensureIndex(geo, options) {\n  if (!geo.index) {\n    var vertexCount = geo.attributes.position.count;\n    var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    var index;\n    if (vertexCount > 65535) {\n      index = new Uint32Array(new BufferConstructor(4 * vertexCount));\n    } else {\n      index = new Uint16Array(new BufferConstructor(2 * vertexCount));\n    }\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (var i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return [{\n      offset: 0,\n      count: geo.index.count / 3\n    }];\n  }\n  var ranges = [];\n  var rangeBoundaries = new Set();\n  var _iterator = _createForOfIteratorHelper(geo.groups),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      rangeBoundaries.add(group.start);\n      rangeBoundaries.add(group.start + group.count);\n    }\n\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var sortedBoundaries = Array.from(rangeBoundaries.values()).sort(function (a, b) {\n    return a - b;\n  });\n  for (var i = 0; i < sortedBoundaries.length - 1; i++) {\n    var start = sortedBoundaries[i],\n      end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: start / 3,\n      count: (end - start) / 3\n    });\n  }\n  return ranges;\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds(triangleBounds, offset, count, target) {\n  var centroidTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var minx = Infinity;\n  var miny = Infinity;\n  var minz = Infinity;\n  var maxx = -Infinity;\n  var maxy = -Infinity;\n  var maxz = -Infinity;\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  var includeCentroid = centroidTarget !== null;\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    var hx = triangleBounds[i + 1];\n    var lx = cx - hx;\n    var rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    var hy = triangleBounds[i + 3];\n    var ly = cy - hy;\n    var ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    var hz = triangleBounds[i + 5];\n    var lz = cz - hz;\n    var rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n}\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition(index, triangleBounds, offset, count, split) {\n  var left = offset;\n  var right = offset + count - 1;\n  var pos = split.pos;\n  var axisOffset = split.axis * 2;\n\n  // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    }\n\n    // if a triangle center lies on the partition plane it is considered to be on the right side\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n    if (left < right) {\n      // we need to swap all of the information associated with the triangles at index\n      // left and right; that's the verts in the geometry index, the bounds,\n      // and perhaps the SAH planes\n\n      for (var i = 0; i < 3; i++) {\n        var t0 = index[left * 3 + i];\n        index[left * 3 + i] = index[right * 3 + i];\n        index[right * 3 + i] = t0;\n        var t1 = triangleBounds[left * 6 + i * 2 + 0];\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\n        var t2 = triangleBounds[left * 6 + i * 2 + 1];\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\n      }\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\nvar BIN_COUNT = 32;\nvar binsSort = function binsSort(a, b) {\n  return a.candidate - b.candidate;\n};\nvar sahBins = new Array(BIN_COUNT).fill().map(function () {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    leftCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nvar leftBounds = new Float32Array(6);\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  var axis = -1;\n  var pos = 0;\n\n  // Center\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    var rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    var bestCost = TRIANGLE_INTERSECT_COST * count;\n\n    // iterate over all axes\n    var cStart = offset * 6;\n    var cEnd = (offset + count) * 6;\n    for (var a = 0; a < 3; a++) {\n      var axisLeft = centroidBoundingData[a];\n      var axisRight = centroidBoundingData[a + 3];\n      var axisLength = axisRight - axisLeft;\n      var binWidth = axisLength / BIN_COUNT;\n\n      // If we have fewer triangles than we're planning to split then just check all\n      // the triangle positions because it will be faster.\n      if (count < BIN_COUNT / 4) {\n        // initialize the bin candidates\n        var truncatedBins = _toConsumableArray(sahBins);\n        truncatedBins.length = count;\n\n        // set the candidates\n        var b = 0;\n        for (var c = cStart; c < cEnd; c += 6, b++) {\n          var bin = truncatedBins[b];\n          bin.candidate = triangleBounds[c + 2 * a];\n          bin.count = 0;\n          var bounds = bin.bounds,\n            leftCacheBounds = bin.leftCacheBounds,\n            rightCacheBounds = bin.rightCacheBounds;\n          for (var d = 0; d < 3; d++) {\n            rightCacheBounds[d] = Infinity;\n            rightCacheBounds[d + 3] = -Infinity;\n            leftCacheBounds[d] = Infinity;\n            leftCacheBounds[d + 3] = -Infinity;\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n          expandByTriangleBounds(c, triangleBounds, bounds);\n        }\n        truncatedBins.sort(binsSort);\n\n        // remove redundant splits\n        var splitCount = count;\n        for (var bi = 0; bi < splitCount; bi++) {\n          var _bin = truncatedBins[bi];\n          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === _bin.candidate) {\n            truncatedBins.splice(bi + 1, 1);\n            splitCount--;\n          }\n        }\n\n        // find the appropriate bin for each triangle and expand the bounds.\n        for (var _c = cStart; _c < cEnd; _c += 6) {\n          var center = triangleBounds[_c + 2 * a];\n          for (var _bi = 0; _bi < splitCount; _bi++) {\n            var _bin2 = truncatedBins[_bi];\n            if (center >= _bin2.candidate) {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.rightCacheBounds);\n            } else {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.leftCacheBounds);\n              _bin2.count++;\n            }\n          }\n        }\n\n        // expand all the bounds\n        for (var _bi2 = 0; _bi2 < splitCount; _bi2++) {\n          var _bin3 = truncatedBins[_bi2];\n          var leftCount = _bin3.count;\n          var rightCount = count - _bin3.count;\n\n          // check the cost of this split\n          var _leftBounds = _bin3.leftCacheBounds;\n          var rightBounds = _bin3.rightCacheBounds;\n          var leftProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(_leftBounds) / rootSurfaceArea;\n          }\n          var rightProb = 0;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          var cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = _bin3.candidate;\n          }\n        }\n      } else {\n        // reset the bins\n        for (var i = 0; i < BIN_COUNT; i++) {\n          var _bin4 = sahBins[i];\n          _bin4.count = 0;\n          _bin4.candidate = axisLeft + binWidth + i * binWidth;\n          var _bounds = _bin4.bounds;\n          for (var _d = 0; _d < 3; _d++) {\n            _bounds[_d] = Infinity;\n            _bounds[_d + 3] = -Infinity;\n          }\n        }\n\n        // iterate over all center positions\n        for (var _c2 = cStart; _c2 < cEnd; _c2 += 6) {\n          var triCenter = triangleBounds[_c2 + 2 * a];\n          var relativeCenter = triCenter - axisLeft;\n\n          // in the partition function if the centroid lies on the split plane then it is\n          // considered to be on the right side of the split\n          var binIndex = ~~(relativeCenter / binWidth);\n          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n          var _bin5 = sahBins[binIndex];\n          _bin5.count++;\n          expandByTriangleBounds(_c2, triangleBounds, _bin5.bounds);\n        }\n\n        // cache the unioned bounds from right to left so we don't have to regenerate them each time\n        var lastBin = sahBins[BIN_COUNT - 1];\n        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n        for (var _i = BIN_COUNT - 2; _i >= 0; _i--) {\n          var _bin6 = sahBins[_i];\n          var nextBin = sahBins[_i + 1];\n          unionBounds(_bin6.bounds, nextBin.rightCacheBounds, _bin6.rightCacheBounds);\n        }\n        var _leftCount = 0;\n        for (var _i2 = 0; _i2 < BIN_COUNT - 1; _i2++) {\n          var _bin7 = sahBins[_i2];\n          var binCount = _bin7.count;\n          var _bounds2 = _bin7.bounds;\n          var _nextBin = sahBins[_i2 + 1];\n          var _rightBounds = _nextBin.rightCacheBounds;\n\n          // don't do anything with the bounds if the new bounds have no triangles\n          if (binCount !== 0) {\n            if (_leftCount === 0) {\n              copyBounds(_bounds2, leftBounds);\n            } else {\n              unionBounds(_bounds2, leftBounds, leftBounds);\n            }\n          }\n          _leftCount += binCount;\n\n          // check the cost of this split\n          var _leftProb = 0;\n          var _rightProb = 0;\n          if (_leftCount !== 0) {\n            _leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n          var _rightCount = count - _leftCount;\n          if (_rightCount !== 0) {\n            _rightProb = computeSurfaceArea(_rightBounds) / rootSurfaceArea;\n          }\n          var _cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (_leftProb * _leftCount + _rightProb * _rightCount);\n          if (_cost < bestCost) {\n            axis = a;\n            bestCost = _cost;\n            pos = _bin7.candidate;\n          }\n        }\n      }\n    }\n  } else {\n    console.warn(\"MeshBVH: Invalid build strategy value \".concat(strategy, \" used.\"));\n  }\n  return {\n    axis: axis,\n    pos: pos\n  };\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n  var avg = 0;\n  for (var i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n  return avg / count;\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds(geo, fullBounds) {\n  var posAttr = geo.attributes.position;\n  var index = geo.index.array;\n  var triCount = index.length / 3;\n  var triangleBounds = new Float32Array(triCount * 6);\n  var normalized = posAttr.normalized;\n\n  // used for non-normalized positions\n  var posArr = posAttr.array;\n\n  // support for an interleaved position buffer\n  var bufferOffset = posAttr.offset || 0;\n  var stride = 3;\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n\n  // used for normalized positions\n  var getters = ['getX', 'getY', 'getZ'];\n  for (var tri = 0; tri < triCount; tri++) {\n    var tri3 = tri * 3;\n    var tri6 = tri * 6;\n    var ai = void 0,\n      bi = void 0,\n      ci = void 0;\n    if (normalized) {\n      ai = index[tri3 + 0];\n      bi = index[tri3 + 1];\n      ci = index[tri3 + 2];\n    } else {\n      ai = index[tri3 + 0] * stride + bufferOffset;\n      bi = index[tri3 + 1] * stride + bufferOffset;\n      ci = index[tri3 + 2] * stride + bufferOffset;\n    }\n    for (var el = 0; el < 3; el++) {\n      var a = void 0,\n        b = void 0,\n        c = void 0;\n      if (normalized) {\n        a = posAttr[getters[el]](ai);\n        b = posAttr[getters[el]](bi);\n        c = posAttr[getters[el]](ci);\n      } else {\n        a = posArr[ai + el];\n        b = posArr[bi + el];\n        c = posArr[ci + el];\n      }\n      var min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      var max = a;\n      if (b > max) max = b;\n      if (c > max) max = c;\n\n      // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n      var halfExtents = (max - min) / 2;\n      var el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n      if (min < fullBounds[el]) fullBounds[el] = min;\n      if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n    }\n  }\n  return triangleBounds;\n}\nexport function buildTree(geo, options) {\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    var centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(geo);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    var split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    var splitOffset = partition(indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      var left = new MeshBVHNode();\n      var lstart = offset;\n      var lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      var right = new MeshBVHNode();\n      var rstart = splitOffset;\n      var rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n  ensureIndex(geo, options);\n\n  // Compute the full bounds of the geometry at the same time as triangle bounds because\n  // we'll need it for the root bounds in the case with no groups and it should be fast here.\n  // We can't use the geometrying bounding box if it's available because it may be out of date.\n  var fullBounds = new Float32Array(6);\n  var cacheCentroidBoundingData = new Float32Array(6);\n  var triangleBounds = computeTriangleBounds(geo, fullBounds);\n  var indexArray = geo.index.array;\n  var maxDepth = options.maxDepth;\n  var verbose = options.verbose;\n  var maxLeafTris = options.maxLeafTris;\n  var strategy = options.strategy;\n  var onProgress = options.onProgress;\n  var totalTriangles = geo.index.count / 3;\n  var reachedMaxDepth = false;\n  var roots = [];\n  var ranges = getRootIndexRanges(geo);\n  if (ranges.length === 1) {\n    var range = ranges[0];\n    var root = new MeshBVHNode();\n    root.boundingData = fullBounds;\n    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    var _iterator2 = _createForOfIteratorHelper(ranges),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _range = _step2.value;\n        var _root = new MeshBVHNode();\n        _root.boundingData = new Float32Array(6);\n        getBounds(triangleBounds, _range.offset, _range.count, _root.boundingData, cacheCentroidBoundingData);\n        splitNode(_root, _range.offset, _range.count, cacheCentroidBoundingData);\n        roots.push(_root);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return roots;\n}\nexport function buildPackedTree(geo, options) {\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  var roots = buildTree(geo, options);\n  var float32Array;\n  var uint32Array;\n  var uint16Array;\n  var packedRoots = [];\n  var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  for (var i = 0; i < roots.length; i++) {\n    var root = roots[i];\n    var nodeCount = countNodes(root);\n    var buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n  return packedRoots;\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n  function populateBuffer(byteOffset, node) {\n    var stride4Offset = byteOffset / 4;\n    var stride2Offset = byteOffset / 2;\n    var isLeaf = !!node.count;\n    var boundingData = node.boundingData;\n    for (var _i3 = 0; _i3 < 6; _i3++) {\n      float32Array[stride4Offset + _i3] = boundingData[_i3];\n    }\n    if (isLeaf) {\n      var offset = node.offset;\n      var count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      var left = node.left;\n      var right = node.right;\n      var splitAxis = node.splitAxis;\n      var nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":{"version":3,"names":["BufferAttribute","MeshBVHNode","getLongestEdgeIndex","computeSurfaceArea","copyBounds","unionBounds","expandByTriangleBounds","CENTER","AVERAGE","SAH","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","FLOAT32_EPSILON","IS_LEAFNODE_FLAG","ensureIndex","geo","options","index","vertexCount","attributes","position","count","BufferConstructor","useSharedArrayBuffer","SharedArrayBuffer","ArrayBuffer","Uint32Array","Uint16Array","setIndex","i","getRootIndexRanges","groups","length","offset","ranges","rangeBoundaries","Set","_iterator","_createForOfIteratorHelper","_step","s","n","done","group","value","add","start","err","e","f","sortedBoundaries","Array","from","values","sort","a","b","end","push","getBounds","triangleBounds","target","centroidTarget","arguments","undefined","minx","Infinity","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","getCentroidBounds","partition","split","left","right","pos","axisOffset","axis","t0","t1","t2","BIN_COUNT","binsSort","candidate","sahBins","fill","map","bounds","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","axisRight","axisLength","binWidth","truncatedBins","_toConsumableArray","c","bin","d","splitCount","bi","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","triCenter","relativeCenter","binIndex","lastBin","nextBin","binCount","console","warn","concat","avg","computeTriangleBounds","fullBounds","posAttr","array","triCount","normalized","posArr","bufferOffset","stride","isInterleavedBufferAttribute","data","getters","tri","tri3","tri6","ai","ci","el","min","max","halfExtents","el2","Math","abs","buildTree","triggerProgress","trianglesProcessed","onProgress","totalTriangles","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","maxLeafTris","boundingData","splitOffset","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","roots","range","root","_iterator2","_step2","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","pow","Error"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-mesh-bvh@0.5.24_three@0.151.3/node_modules/three-mesh-bvh/src/core/buildFunctions.js"],"sourcesContent":["import { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport {\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\n} from './Constants.js';\n\nfunction ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tlet index;\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo, fullBounds ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai, bi, ci;\n\n\t\tif ( normalized ) {\n\n\t\t\tai = index[ tri3 + 0 ];\n\t\t\tbi = index[ tri3 + 1 ];\n\t\t\tci = index[ tri3 + 2 ];\n\n\t\t} else {\n\n\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo, options );\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = geo.index.count / 3;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}