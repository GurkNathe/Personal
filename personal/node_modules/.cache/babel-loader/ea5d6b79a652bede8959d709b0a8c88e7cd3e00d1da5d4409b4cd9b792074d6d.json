{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTexture, FloatType, IntType, UnsignedIntType, ByteType, UnsignedByteType, ShortType, UnsignedShortType, RedFormat, RGFormat, RGBAFormat, RedIntegerFormat, RGIntegerFormat, RGBAIntegerFormat, NearestFilter } from 'three';\nfunction countToStringFormat(count) {\n  switch (count) {\n    case 1:\n      return 'R';\n    case 2:\n      return 'RG';\n    case 3:\n      return 'RGBA';\n    case 4:\n      return 'RGBA';\n  }\n  throw new Error();\n}\nfunction countToFormat(count) {\n  switch (count) {\n    case 1:\n      return RedFormat;\n    case 2:\n      return RGFormat;\n    case 3:\n      return RGBAFormat;\n    case 4:\n      return RGBAFormat;\n  }\n}\nfunction countToIntFormat(count) {\n  switch (count) {\n    case 1:\n      return RedIntegerFormat;\n    case 2:\n      return RGIntegerFormat;\n    case 3:\n      return RGBAIntegerFormat;\n    case 4:\n      return RGBAIntegerFormat;\n  }\n}\nexport var VertexAttributeTexture = /*#__PURE__*/function (_DataTexture) {\n  _inherits(VertexAttributeTexture, _DataTexture);\n  var _super = _createSuper(VertexAttributeTexture);\n  function VertexAttributeTexture() {\n    var _this;\n    _classCallCheck(this, VertexAttributeTexture);\n    _this = _super.call(this);\n    _this.minFilter = NearestFilter;\n    _this.magFilter = NearestFilter;\n    _this.generateMipmaps = false;\n    _this.overrideItemSize = null;\n    _this._forcedType = null;\n    return _this;\n  }\n  _createClass(VertexAttributeTexture, [{\n    key: \"updateFrom\",\n    value: function updateFrom(attr) {\n      var overrideItemSize = this.overrideItemSize;\n      var originalItemSize = attr.itemSize;\n      var originalCount = attr.count;\n      if (overrideItemSize !== null) {\n        if (originalItemSize * originalCount % overrideItemSize !== 0.0) {\n          throw new Error('VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.');\n        }\n        attr.itemSize = overrideItemSize;\n        attr.count = originalCount * originalItemSize / overrideItemSize;\n      }\n      var itemSize = attr.itemSize;\n      var count = attr.count;\n      var normalized = attr.normalized;\n      var originalBufferCons = attr.array.constructor;\n      var byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n      var targetType = this._forcedType;\n      var finalStride = itemSize;\n\n      // derive the type of texture this should be in the shader\n      if (targetType === null) {\n        switch (originalBufferCons) {\n          case Float32Array:\n            targetType = FloatType;\n            break;\n          case Uint8Array:\n          case Uint16Array:\n          case Uint32Array:\n            targetType = UnsignedIntType;\n            break;\n          case Int8Array:\n          case Int16Array:\n          case Int32Array:\n            targetType = IntType;\n            break;\n        }\n      }\n\n      // get the target format to store the texture as\n      var type, format, normalizeValue, targetBufferCons;\n      var internalFormat = countToStringFormat(itemSize);\n      switch (targetType) {\n        case FloatType:\n          normalizeValue = 1.0;\n          format = countToFormat(itemSize);\n          if (normalized && byteCount === 1) {\n            targetBufferCons = originalBufferCons;\n            internalFormat += '8';\n            if (originalBufferCons === Uint8Array) {\n              type = UnsignedByteType;\n            } else {\n              type = ByteType;\n              internalFormat += '_SNORM';\n            }\n          } else {\n            targetBufferCons = Float32Array;\n            internalFormat += '32F';\n            type = FloatType;\n          }\n          break;\n        case IntType:\n          internalFormat += byteCount * 8 + 'I';\n          normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n          format = countToIntFormat(itemSize);\n          if (byteCount === 1) {\n            targetBufferCons = Int8Array;\n            type = ByteType;\n          } else if (byteCount === 2) {\n            targetBufferCons = Int16Array;\n            type = ShortType;\n          } else {\n            targetBufferCons = Int32Array;\n            type = IntType;\n          }\n          break;\n        case UnsignedIntType:\n          internalFormat += byteCount * 8 + 'UI';\n          normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n          format = countToIntFormat(itemSize);\n          if (byteCount === 1) {\n            targetBufferCons = Uint8Array;\n            type = UnsignedByteType;\n          } else if (byteCount === 2) {\n            targetBufferCons = Uint16Array;\n            type = UnsignedShortType;\n          } else {\n            targetBufferCons = Uint32Array;\n            type = UnsignedIntType;\n          }\n          break;\n      }\n\n      // there will be a mismatch between format length and final length because\n      // RGBFormat and RGBIntegerFormat was removed\n      if (finalStride === 3 && (format === RGBAFormat || format === RGBAIntegerFormat)) {\n        finalStride = 4;\n      }\n\n      // copy the data over to the new texture array\n      var dimension = Math.ceil(Math.sqrt(count));\n      var length = finalStride * dimension * dimension;\n      var dataArray = new targetBufferCons(length);\n\n      // temporarily set the normalized state to false since we have custom normalization logic\n      var originalNormalized = attr.normalized;\n      attr.normalized = false;\n      for (var i = 0; i < count; i++) {\n        var ii = finalStride * i;\n        dataArray[ii] = attr.getX(i) / normalizeValue;\n        if (itemSize >= 2) {\n          dataArray[ii + 1] = attr.getY(i) / normalizeValue;\n        }\n        if (itemSize >= 3) {\n          dataArray[ii + 2] = attr.getZ(i) / normalizeValue;\n          if (finalStride === 4) {\n            dataArray[ii + 3] = 1.0;\n          }\n        }\n        if (itemSize >= 4) {\n          dataArray[ii + 3] = attr.getW(i) / normalizeValue;\n        }\n      }\n      attr.normalized = originalNormalized;\n      this.internalFormat = internalFormat;\n      this.format = format;\n      this.type = type;\n      this.image.width = dimension;\n      this.image.height = dimension;\n      this.image.data = dataArray;\n      this.needsUpdate = true;\n      this.dispose();\n      attr.itemSize = originalItemSize;\n      attr.count = originalCount;\n    }\n  }]);\n  return VertexAttributeTexture;\n}(DataTexture);\nexport var UIntVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu) {\n  _inherits(UIntVertexAttributeTexture, _VertexAttributeTextu);\n  var _super2 = _createSuper(UIntVertexAttributeTexture);\n  function UIntVertexAttributeTexture() {\n    var _this2;\n    _classCallCheck(this, UIntVertexAttributeTexture);\n    _this2 = _super2.call(this);\n    _this2._forcedType = UnsignedIntType;\n    return _this2;\n  }\n  return _createClass(UIntVertexAttributeTexture);\n}(VertexAttributeTexture);\nexport var IntVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu2) {\n  _inherits(IntVertexAttributeTexture, _VertexAttributeTextu2);\n  var _super3 = _createSuper(IntVertexAttributeTexture);\n  function IntVertexAttributeTexture() {\n    var _this3;\n    _classCallCheck(this, IntVertexAttributeTexture);\n    _this3 = _super3.call(this);\n    _this3._forcedType = IntType;\n    return _this3;\n  }\n  return _createClass(IntVertexAttributeTexture);\n}(VertexAttributeTexture);\nexport var FloatVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu3) {\n  _inherits(FloatVertexAttributeTexture, _VertexAttributeTextu3);\n  var _super4 = _createSuper(FloatVertexAttributeTexture);\n  function FloatVertexAttributeTexture() {\n    var _this4;\n    _classCallCheck(this, FloatVertexAttributeTexture);\n    _this4 = _super4.call(this);\n    _this4._forcedType = FloatType;\n    return _this4;\n  }\n  return _createClass(FloatVertexAttributeTexture);\n}(VertexAttributeTexture);","map":{"version":3,"names":["DataTexture","FloatType","IntType","UnsignedIntType","ByteType","UnsignedByteType","ShortType","UnsignedShortType","RedFormat","RGFormat","RGBAFormat","RedIntegerFormat","RGIntegerFormat","RGBAIntegerFormat","NearestFilter","countToStringFormat","count","Error","countToFormat","countToIntFormat","VertexAttributeTexture","_DataTexture","_inherits","_super","_createSuper","_this","_classCallCheck","call","minFilter","magFilter","generateMipmaps","overrideItemSize","_forcedType","_createClass","key","value","updateFrom","attr","originalItemSize","itemSize","originalCount","normalized","originalBufferCons","array","constructor","byteCount","BYTES_PER_ELEMENT","targetType","finalStride","Float32Array","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","type","format","normalizeValue","targetBufferCons","internalFormat","Math","pow","dimension","ceil","sqrt","length","dataArray","originalNormalized","i","ii","getX","getY","getZ","getW","image","width","height","data","needsUpdate","dispose","UIntVertexAttributeTexture","_VertexAttributeTextu","_super2","_this2","IntVertexAttributeTexture","_VertexAttributeTextu2","_super3","_this3","FloatVertexAttributeTexture","_VertexAttributeTextu3","_super4","_this4"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-mesh-bvh@0.5.24_three@0.151.3/node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js"],"sourcesContent":["import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}