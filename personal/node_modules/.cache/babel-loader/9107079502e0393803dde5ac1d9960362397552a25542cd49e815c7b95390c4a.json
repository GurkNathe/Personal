{"ast":null,"code":"import _objectSpread from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from '../core/shaderMaterial.js';\nvar WireframeMaterialShaders = {\n  uniforms: {\n    strokeOpacity: 1,\n    fillOpacity: 0.25,\n    fillMix: 0,\n    thickness: 0.05,\n    colorBackfaces: false,\n    dashInvert: true,\n    dash: false,\n    dashRepeats: 4,\n    dashLength: 0.5,\n    squeeze: false,\n    squeezeMin: 0.2,\n    squeezeMax: 1,\n    stroke: new THREE.Color('#ff0000'),\n    backfaceStroke: new THREE.Color('#0000ff'),\n    fill: new THREE.Color('#00ff00')\n  },\n  vertex: /* glsl */\"\\n\\t  attribute vec3 barycentric;\\n\\t\\n\\t\\tvarying vec3 v_edges_Barycentric;\\n\\t\\tvarying vec3 v_edges_Position;\\n\\n\\t\\tvoid initWireframe() {\\n\\t\\t\\tv_edges_Barycentric = barycentric;\\n\\t\\t\\tv_edges_Position = position.xyz;\\n\\t\\t}\\n\\t  \",\n  fragment: /* glsl */\"\\n\\t\\t#ifndef PI\\n\\t  \\t#define PI 3.1415926535897932384626433832795\\n\\t\\t#endif\\n  \\n\\t  varying vec3 v_edges_Barycentric;\\n\\t  varying vec3 v_edges_Position;\\n  \\n\\t  uniform float strokeOpacity;\\n\\t  uniform float fillOpacity;\\n\\t  uniform float fillMix;\\n\\t  uniform float thickness;\\n\\t  uniform bool colorBackfaces;\\n  \\n\\t  // Dash\\n\\t  uniform bool dashInvert;\\n\\t  uniform bool dash;\\n\\t  uniform bool dashOnly;\\n\\t  uniform float dashRepeats;\\n\\t  uniform float dashLength;\\n  \\n\\t  // Squeeze\\n\\t  uniform bool squeeze;\\n\\t  uniform float squeezeMin;\\n\\t  uniform float squeezeMax;\\n  \\n\\t  // Colors\\n\\t  uniform vec3 stroke;\\n\\t  uniform vec3 backfaceStroke;\\n\\t  uniform vec3 fill;\\n  \\n\\t  // This is like\\n\\t  float wireframe_aastep(float threshold, float dist) {\\n\\t\\t  float afwidth = fwidth(dist) * 0.5;\\n\\t\\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\\n\\t  }\\n  \\n\\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\\n\\t\\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\\n\\t  }\\n  \\n\\t  float getWireframe() {\\n\\t\\t\\tvec3 barycentric = v_edges_Barycentric;\\n\\t\\t\\n\\t\\t\\t// Distance from center of each triangle to its edges.\\n\\t\\t\\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\\n\\n\\t\\t\\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\\n\\t\\t\\tfloat positionAlong = max(barycentric.x, barycentric.y);\\n\\t\\t\\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\\n\\t\\t\\t\\tpositionAlong = 1.0 - positionAlong;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// the thickness of the stroke\\n\\t\\t\\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\\n\\n\\t\\t\\t// if we want to shrink the thickness toward the center of the line segment\\n\\t\\t\\tif (squeeze) {\\n\\t\\t\\t\\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Create dash pattern\\n\\t\\t\\tif (dash) {\\n\\t\\t\\t\\t// here we offset the stroke position depending on whether it\\n\\t\\t\\t\\t// should overlap or not\\n\\t\\t\\t\\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\\n\\t\\t\\t\\tif (!dashInvert) {\\n\\t\\t\\t\\t\\toffset += 1.0 / dashRepeats / 2.0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if we should animate the dash or not\\n\\t\\t\\t\\t// if (dashAnimate) {\\n\\t\\t\\t\\t// \\toffset += time * 0.22;\\n\\t\\t\\t\\t// }\\n\\n\\t\\t\\t\\t// create the repeating dash pattern\\n\\t\\t\\t\\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\\n\\t\\t\\t\\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the anti-aliased stroke edge  \\n\\t\\t\\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\\n\\n\\t\\t\\treturn edge;\\n\\t  }\\n\\t  \"\n};\nvar WireframeMaterial = shaderMaterial(WireframeMaterialShaders.uniforms, WireframeMaterialShaders.vertex + /* glsl */\"\\n  \\tvoid main() {\\n\\t\\tinitWireframe();\\n\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n\\t}\\n  \", WireframeMaterialShaders.fragment + /* glsl */\"\\n  void main () {\\n\\t\\t// Compute color\\n\\n\\t\\tfloat edge = getWireframe();\\n\\t\\tvec4 colorStroke = vec4(stroke, edge);\\n\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tcolorStroke.rgb = backfaceStroke;\\n\\t\\t#endif\\n    \\n\\t\\tvec4 colorFill = vec4(fill, fillOpacity);\\n\\t\\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\\n\\n\\t\\tgl_FragColor = outColor;\\n\\t}\\n  \");\nfunction setWireframeOverride(material, uniforms) {\n  material.onBeforeCompile = function (shader) {\n    shader.uniforms = _objectSpread(_objectSpread({}, shader.uniforms), uniforms);\n    shader.vertexShader = shader.vertexShader.replace('void main() {', \"\\n\\t\\t  \".concat(WireframeMaterialShaders.vertex, \"\\n\\t\\t  void main() {\\n\\t\\t\\tinitWireframe();\\n\\t\\t\"));\n    shader.fragmentShader = shader.fragmentShader.replace('void main() {', \"\\n\\t\\t  \".concat(WireframeMaterialShaders.fragment, \"\\n\\t\\t  void main() {\\n\\t\\t\"));\n    shader.fragmentShader = shader.fragmentShader.replace('#include <color_fragment>', /* glsl */\"\\n\\t\\t  #include <color_fragment>\\n\\t\\t\\t  float edge = getWireframe();\\n\\t\\t  vec4 colorStroke = vec4(stroke, edge);\\n\\t\\t  #ifdef FLIP_SIDED\\n\\t\\t\\tcolorStroke.rgb = backfaceStroke;\\n\\t\\t  #endif\\n\\t\\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\\n\\t\\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\\n\\n\\t\\t  diffuseColor.rgb = outColor.rgb;\\n\\t\\t  diffuseColor.a *= outColor.a;\\n\\t\\t\");\n  };\n  material.side = THREE.DoubleSide;\n  material.transparent = true;\n}\nfunction useWireframeUniforms(uniforms, props) {\n  React.useEffect(function () {\n    var _props$fillOpacity;\n    return void (uniforms.fillOpacity.value = (_props$fillOpacity = props.fillOpacity) !== null && _props$fillOpacity !== void 0 ? _props$fillOpacity : uniforms.fillOpacity.value);\n  }, [props.fillOpacity]);\n  React.useEffect(function () {\n    var _props$fillMix;\n    return void (uniforms.fillMix.value = (_props$fillMix = props.fillMix) !== null && _props$fillMix !== void 0 ? _props$fillMix : uniforms.fillMix.value);\n  }, [props.fillMix]);\n  React.useEffect(function () {\n    var _props$strokeOpacity;\n    return void (uniforms.strokeOpacity.value = (_props$strokeOpacity = props.strokeOpacity) !== null && _props$strokeOpacity !== void 0 ? _props$strokeOpacity : uniforms.strokeOpacity.value);\n  }, [props.strokeOpacity]);\n  React.useEffect(function () {\n    var _props$thickness;\n    return void (uniforms.thickness.value = (_props$thickness = props.thickness) !== null && _props$thickness !== void 0 ? _props$thickness : uniforms.thickness.value);\n  }, [props.thickness]);\n  React.useEffect(function () {\n    return void (uniforms.colorBackfaces.value = !!props.colorBackfaces);\n  }, [props.colorBackfaces]);\n  React.useEffect(function () {\n    return void (uniforms.dash.value = !!props.dash);\n  }, [props.dash]);\n  React.useEffect(function () {\n    return void (uniforms.dashInvert.value = !!props.dashInvert);\n  }, [props.dashInvert]);\n  React.useEffect(function () {\n    var _props$dashRepeats;\n    return void (uniforms.dashRepeats.value = (_props$dashRepeats = props.dashRepeats) !== null && _props$dashRepeats !== void 0 ? _props$dashRepeats : uniforms.dashRepeats.value);\n  }, [props.dashRepeats]);\n  React.useEffect(function () {\n    var _props$dashLength;\n    return void (uniforms.dashLength.value = (_props$dashLength = props.dashLength) !== null && _props$dashLength !== void 0 ? _props$dashLength : uniforms.dashLength.value);\n  }, [props.dashLength]);\n  React.useEffect(function () {\n    return void (uniforms.squeeze.value = !!props.squeeze);\n  }, [props.squeeze]);\n  React.useEffect(function () {\n    var _props$squeezeMin;\n    return void (uniforms.squeezeMin.value = (_props$squeezeMin = props.squeezeMin) !== null && _props$squeezeMin !== void 0 ? _props$squeezeMin : uniforms.squeezeMin.value);\n  }, [props.squeezeMin]);\n  React.useEffect(function () {\n    var _props$squeezeMax;\n    return void (uniforms.squeezeMax.value = (_props$squeezeMax = props.squeezeMax) !== null && _props$squeezeMax !== void 0 ? _props$squeezeMax : uniforms.squeezeMax.value);\n  }, [props.squeezeMax]);\n  React.useEffect(function () {\n    return void (uniforms.stroke.value = props.stroke ? new THREE.Color(props.stroke) : uniforms.stroke.value);\n  }, [props.stroke]);\n  React.useEffect(function () {\n    return void (uniforms.fill.value = props.fill ? new THREE.Color(props.fill) : uniforms.fill.value);\n  }, [props.fill]);\n  React.useEffect(function () {\n    return void (uniforms.backfaceStroke.value = props.backfaceStroke ? new THREE.Color(props.backfaceStroke) : uniforms.backfaceStroke.value);\n  }, [props.backfaceStroke]);\n}\nexport { WireframeMaterial, WireframeMaterialShaders, setWireframeOverride, useWireframeUniforms };","map":{"version":3,"names":["THREE","React","shaderMaterial","WireframeMaterialShaders","uniforms","strokeOpacity","fillOpacity","fillMix","thickness","colorBackfaces","dashInvert","dash","dashRepeats","dashLength","squeeze","squeezeMin","squeezeMax","stroke","Color","backfaceStroke","fill","vertex","fragment","WireframeMaterial","setWireframeOverride","material","onBeforeCompile","shader","_objectSpread","vertexShader","replace","concat","fragmentShader","side","DoubleSide","transparent","useWireframeUniforms","props","useEffect","_props$fillOpacity","value","_props$fillMix","_props$strokeOpacity","_props$thickness","_props$dashRepeats","_props$dashLength","_props$squeezeMin","_props$squeezeMax"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@react-three+drei@9.72.1_@react-three+fiber@8.13.0_@types+three@0.150.2_react-dom@18.2.0_react@18.2.0_three@0.151.3/node_modules/@react-three/drei/materials/WireframeMaterial.js"],"sourcesContent":["import * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from '../core/shaderMaterial.js';\n\nconst WireframeMaterialShaders = {\n  uniforms: {\n    strokeOpacity: 1,\n    fillOpacity: 0.25,\n    fillMix: 0,\n    thickness: 0.05,\n    colorBackfaces: false,\n    dashInvert: true,\n    dash: false,\n    dashRepeats: 4,\n    dashLength: 0.5,\n    squeeze: false,\n    squeezeMin: 0.2,\n    squeezeMax: 1,\n    stroke: new THREE.Color('#ff0000'),\n    backfaceStroke: new THREE.Color('#0000ff'),\n    fill: new THREE.Color('#00ff00')\n  },\n  vertex:\n  /* glsl */\n  `\n\t  attribute vec3 barycentric;\n\t\n\t\tvarying vec3 v_edges_Barycentric;\n\t\tvarying vec3 v_edges_Position;\n\n\t\tvoid initWireframe() {\n\t\t\tv_edges_Barycentric = barycentric;\n\t\t\tv_edges_Position = position.xyz;\n\t\t}\n\t  `,\n  fragment:\n  /* glsl */\n  `\n\t\t#ifndef PI\n\t  \t#define PI 3.1415926535897932384626433832795\n\t\t#endif\n  \n\t  varying vec3 v_edges_Barycentric;\n\t  varying vec3 v_edges_Position;\n  \n\t  uniform float strokeOpacity;\n\t  uniform float fillOpacity;\n\t  uniform float fillMix;\n\t  uniform float thickness;\n\t  uniform bool colorBackfaces;\n  \n\t  // Dash\n\t  uniform bool dashInvert;\n\t  uniform bool dash;\n\t  uniform bool dashOnly;\n\t  uniform float dashRepeats;\n\t  uniform float dashLength;\n  \n\t  // Squeeze\n\t  uniform bool squeeze;\n\t  uniform float squeezeMin;\n\t  uniform float squeezeMax;\n  \n\t  // Colors\n\t  uniform vec3 stroke;\n\t  uniform vec3 backfaceStroke;\n\t  uniform vec3 fill;\n  \n\t  // This is like\n\t  float wireframe_aastep(float threshold, float dist) {\n\t\t  float afwidth = fwidth(dist) * 0.5;\n\t\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n\t  }\n  \n\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t  }\n  \n\t  float getWireframe() {\n\t\t\tvec3 barycentric = v_edges_Barycentric;\n\t\t\n\t\t\t// Distance from center of each triangle to its edges.\n\t\t\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\n\n\t\t\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\n\t\t\tfloat positionAlong = max(barycentric.x, barycentric.y);\n\t\t\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\n\t\t\t\tpositionAlong = 1.0 - positionAlong;\n\t\t\t}\n\n\t\t\t// the thickness of the stroke\n\t\t\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\n\n\t\t\t// if we want to shrink the thickness toward the center of the line segment\n\t\t\tif (squeeze) {\n\t\t\t\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\n\t\t\t}\n\n\t\t\t// Create dash pattern\n\t\t\tif (dash) {\n\t\t\t\t// here we offset the stroke position depending on whether it\n\t\t\t\t// should overlap or not\n\t\t\t\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\n\t\t\t\tif (!dashInvert) {\n\t\t\t\t\toffset += 1.0 / dashRepeats / 2.0;\n\t\t\t\t}\n\n\t\t\t\t// if we should animate the dash or not\n\t\t\t\t// if (dashAnimate) {\n\t\t\t\t// \toffset += time * 0.22;\n\t\t\t\t// }\n\n\t\t\t\t// create the repeating dash pattern\n\t\t\t\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\n\t\t\t\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\n\t\t\t}\n\n\t\t\t// compute the anti-aliased stroke edge  \n\t\t\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\n\n\t\t\treturn edge;\n\t  }\n\t  `\n};\nconst WireframeMaterial = shaderMaterial(WireframeMaterialShaders.uniforms, WireframeMaterialShaders.vertex +\n/* glsl */\n`\n  \tvoid main() {\n\t\tinitWireframe();\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n  `, WireframeMaterialShaders.fragment +\n/* glsl */\n`\n  void main () {\n\t\t// Compute color\n\n\t\tfloat edge = getWireframe();\n\t\tvec4 colorStroke = vec4(stroke, edge);\n\n\t\t#ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t#endif\n    \n\t\tvec4 colorFill = vec4(fill, fillOpacity);\n\t\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\tgl_FragColor = outColor;\n\t}\n  `);\nfunction setWireframeOverride(material, uniforms) {\n  material.onBeforeCompile = shader => {\n    shader.uniforms = { ...shader.uniforms,\n      ...uniforms\n    };\n    shader.vertexShader = shader.vertexShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.vertex}\n\t\t  void main() {\n\t\t\tinitWireframe();\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.fragment}\n\t\t  void main() {\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('#include <color_fragment>',\n    /* glsl */\n    `\n\t\t  #include <color_fragment>\n\t\t\t  float edge = getWireframe();\n\t\t  vec4 colorStroke = vec4(stroke, edge);\n\t\t  #ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t  #endif\n\t\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\n\t\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\t  diffuseColor.rgb = outColor.rgb;\n\t\t  diffuseColor.a *= outColor.a;\n\t\t`);\n  };\n\n  material.side = THREE.DoubleSide;\n  material.transparent = true;\n}\nfunction useWireframeUniforms(uniforms, props) {\n  React.useEffect(() => {\n    var _props$fillOpacity;\n\n    return void (uniforms.fillOpacity.value = (_props$fillOpacity = props.fillOpacity) !== null && _props$fillOpacity !== void 0 ? _props$fillOpacity : uniforms.fillOpacity.value);\n  }, [props.fillOpacity]);\n  React.useEffect(() => {\n    var _props$fillMix;\n\n    return void (uniforms.fillMix.value = (_props$fillMix = props.fillMix) !== null && _props$fillMix !== void 0 ? _props$fillMix : uniforms.fillMix.value);\n  }, [props.fillMix]);\n  React.useEffect(() => {\n    var _props$strokeOpacity;\n\n    return void (uniforms.strokeOpacity.value = (_props$strokeOpacity = props.strokeOpacity) !== null && _props$strokeOpacity !== void 0 ? _props$strokeOpacity : uniforms.strokeOpacity.value);\n  }, [props.strokeOpacity]);\n  React.useEffect(() => {\n    var _props$thickness;\n\n    return void (uniforms.thickness.value = (_props$thickness = props.thickness) !== null && _props$thickness !== void 0 ? _props$thickness : uniforms.thickness.value);\n  }, [props.thickness]);\n  React.useEffect(() => void (uniforms.colorBackfaces.value = !!props.colorBackfaces), [props.colorBackfaces]);\n  React.useEffect(() => void (uniforms.dash.value = !!props.dash), [props.dash]);\n  React.useEffect(() => void (uniforms.dashInvert.value = !!props.dashInvert), [props.dashInvert]);\n  React.useEffect(() => {\n    var _props$dashRepeats;\n\n    return void (uniforms.dashRepeats.value = (_props$dashRepeats = props.dashRepeats) !== null && _props$dashRepeats !== void 0 ? _props$dashRepeats : uniforms.dashRepeats.value);\n  }, [props.dashRepeats]);\n  React.useEffect(() => {\n    var _props$dashLength;\n\n    return void (uniforms.dashLength.value = (_props$dashLength = props.dashLength) !== null && _props$dashLength !== void 0 ? _props$dashLength : uniforms.dashLength.value);\n  }, [props.dashLength]);\n  React.useEffect(() => void (uniforms.squeeze.value = !!props.squeeze), [props.squeeze]);\n  React.useEffect(() => {\n    var _props$squeezeMin;\n\n    return void (uniforms.squeezeMin.value = (_props$squeezeMin = props.squeezeMin) !== null && _props$squeezeMin !== void 0 ? _props$squeezeMin : uniforms.squeezeMin.value);\n  }, [props.squeezeMin]);\n  React.useEffect(() => {\n    var _props$squeezeMax;\n\n    return void (uniforms.squeezeMax.value = (_props$squeezeMax = props.squeezeMax) !== null && _props$squeezeMax !== void 0 ? _props$squeezeMax : uniforms.squeezeMax.value);\n  }, [props.squeezeMax]);\n  React.useEffect(() => void (uniforms.stroke.value = props.stroke ? new THREE.Color(props.stroke) : uniforms.stroke.value), [props.stroke]);\n  React.useEffect(() => void (uniforms.fill.value = props.fill ? new THREE.Color(props.fill) : uniforms.fill.value), [props.fill]);\n  React.useEffect(() => void (uniforms.backfaceStroke.value = props.backfaceStroke ? new THREE.Color(props.backfaceStroke) : uniforms.backfaceStroke.value), [props.backfaceStroke]);\n}\n\nexport { WireframeMaterial, WireframeMaterialShaders, setWireframeOverride, useWireframeUniforms };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}