{"ast":null,"code":"import _objectSpread from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport { raycast as _raycast, raycastFirst as _raycastFirst, shapecast as _shapecast, intersectsGeometry as _intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar aabb = /* @__PURE__ */new Box3();\nvar aabb2 = /* @__PURE__ */new Box3();\nvar tempMatrix = /* @__PURE__ */new Matrix4();\nvar obb = /* @__PURE__ */new OrientedBox();\nvar obb2 = /* @__PURE__ */new OrientedBox();\nvar temp = /* @__PURE__ */new Vector3();\nvar temp1 = /* @__PURE__ */new Vector3();\nvar temp2 = /* @__PURE__ */new Vector3();\nvar temp3 = /* @__PURE__ */new Vector3();\nvar temp4 = /* @__PURE__ */new Vector3();\nvar tempBox = /* @__PURE__ */new Box3();\nvar trianglePool = /* @__PURE__ */new PrimitivePool(function () {\n  return new ExtendedTriangle();\n});\nexport var MeshBVH = /*#__PURE__*/function () {\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, MeshBVH);\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null\n    }, SKIP_GENERATION, false), options);\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined') {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n    this._roots = null;\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n  }\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n      }\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i];\n            var x = posAttr.getX(index);\n            var y = posAttr.getY(index);\n            var z = posAttr.getZ(index);\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6];\n\n          // the identifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var forceChildren = force;\n          var includesLeft = false;\n          var includesRight = false;\n          if (nodeIndices) {\n            // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            if (!forceChildren) {\n              includesLeft = nodeIndices.has(offsetLeft);\n              includesRight = nodeIndices.has(offsetRight);\n              forceChildren = !includesLeft && !includesRight;\n            }\n          } else {\n            includesLeft = true;\n            includesRight = true;\n          }\n          var traverseLeft = forceChildren || includesLeft;\n          var traverseRight = forceChildren || includesRight;\n          var leftChange = false;\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceChildren);\n          }\n          var rightChange = false;\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceChildren);\n          }\n          var didChange = leftChange || rightChange;\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n      _traverse(0);\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n\n    /* Core Cast Functions */\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        setBuffer(roots[i]);\n        _raycast(0, geometry, materialSide, ray, intersects);\n        clearBuffer();\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        setBuffer(roots[i]);\n        var result = _raycastFirst(0, geometry, materialSide, ray);\n        clearBuffer();\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n      var _iterator = _createForOfIteratorHelper(this._roots),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n          setBuffer(root);\n          result = _intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n          clearBuffer();\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n      var triangle = trianglePool.getPrimitive();\n      var _callbacks = callbacks,\n        boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n        intersectsBounds = _callbacks.intersectsBounds,\n        intersectsRange = _callbacks.intersectsRange,\n        intersectsTriangle = _callbacks.intersectsTriangle;\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n      var result = false;\n      var byteOffset = 0;\n      var _iterator2 = _createForOfIteratorHelper(this._roots),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var root = _step2.value;\n          setBuffer(root);\n          result = _shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          clearBuffer();\n          if (result) {\n            break;\n          }\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      trianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n      // than an approach that walks down the tree (see bvhcast.js file for more info).\n\n      var intersectsRanges = callbacks.intersectsRanges,\n        intersectsTriangles = callbacks.intersectsTriangles;\n      var indexAttr = this.geometry.index;\n      var positionAttr = this.geometry.attributes.position;\n      var otherIndexAttr = otherBvh.geometry.index;\n      var otherPositionAttr = otherBvh.geometry.attributes.position;\n      tempMatrix.copy(matrixToLocal).invert();\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n      if (intersectsTriangles) {\n        var iterateOverDoubleTriangles = function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          for (var i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n            setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n            triangle2.a.applyMatrix4(matrixToLocal);\n            triangle2.b.applyMatrix4(matrixToLocal);\n            triangle2.c.applyMatrix4(matrixToLocal);\n            triangle2.needsUpdate = true;\n            for (var i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n              setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n              triangle.needsUpdate = true;\n              if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                return true;\n              }\n            }\n          }\n          return false;\n        };\n        if (intersectsRanges) {\n          var originalIntersectsRanges = intersectsRanges;\n          intersectsRanges = function intersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n            if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n              return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n            }\n            return true;\n          };\n        } else {\n          intersectsRanges = iterateOverDoubleTriangles;\n        }\n      }\n      otherBvh.getBoundingBox(aabb2);\n      aabb2.applyMatrix4(matrixToLocal);\n      var result = this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return aabb2.intersectsBox(box);\n        },\n        intersectsRange: function intersectsRange(offset1, count1, contained, depth1, nodeIndex1, box) {\n          aabb.copy(box);\n          aabb.applyMatrix4(tempMatrix);\n          return otherBvh.shapecast({\n            intersectsBounds: function intersectsBounds(box) {\n              return aabb.intersectsBox(box);\n            },\n            intersectsRange: function intersectsRange(offset2, count2, contained, depth2, nodeIndex2) {\n              return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n            }\n          });\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      return result;\n    }\n\n    /* Derived Cast Functions */\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n      var tempTarget1 = temp1;\n      var tempTargetDest1 = temp2;\n      var tempTarget2 = null;\n      var tempTargetDest2 = null;\n      if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n      }\n      var closestDistance = Infinity;\n      var closestDistanceTriIndex = null;\n      var closestDistanceOtherTriIndex = null;\n      tempMatrix.copy(geometryToBvh).invert();\n      obb2.matrix.copy(tempMatrix);\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n            return true;\n          }\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast({\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box);\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  setTriangle(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    setTriangle(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                    if (dist < closestDistance) {\n                      tempTargetDest1.copy(tempTarget1);\n                      if (tempTargetDest2) {\n                        tempTargetDest2.copy(tempTarget2);\n                      }\n                      closestDistance = dist;\n                      closestDistanceTriIndex = i / 3;\n                      closestDistanceOtherTriIndex = i2 / 3;\n                    }\n\n                    // stop traversal if we find a point that's under the given threshold\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              setTriangle(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                setTriangle(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                if (dist < closestDistance) {\n                  tempTargetDest1.copy(tempTarget1);\n                  if (tempTargetDest2) {\n                    tempTargetDest2.copy(tempTarget2);\n                  }\n                  closestDistance = dist;\n                  closestDistanceTriIndex = i / 3;\n                  closestDistanceOtherTriIndex = i2 / 3;\n                }\n\n                // stop traversal if we find a point that's under the given threshold\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      if (closestDistance === Infinity) return null;\n      if (!target1.point) target1.point = tempTargetDest1.clone();else target1.point.copy(tempTargetDest1);\n      target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n      if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n      }\n      return target1;\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      var closestDistanceTriIndex = null;\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri, triIndex) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n          if (distSq < closestDistanceSq) {\n            temp1.copy(temp);\n            closestDistanceSq = distSq;\n            closestDistanceTriIndex = triIndex;\n          }\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      if (closestDistanceSq === Infinity) return null;\n      var closestDistance = Math.sqrt(closestDistanceSq);\n      if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n      target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n      return target;\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }], [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (options.isBufferGeometry) {\n        console.warn('MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.serialize(arguments[0], {\n          cloneBuffers: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result;\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute.array.slice()\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute.array\n        };\n      }\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (typeof options === 'boolean') {\n        console.warn('MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.deserialize(arguments[0], arguments[1], {\n          setIndex: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n      options = _objectSpread({\n        setIndex: true\n      }, options);\n      var index = data.index,\n        roots = data.roots;\n      var bvh = new MeshBVH(geometry, _objectSpread(_objectSpread({}, options), {}, _defineProperty({}, SKIP_GENERATION, true)));\n      bvh._roots = roots;\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n      return bvh;\n    }\n  }]);\n  return MeshBVH;\n}();","map":{"version":3,"names":["Vector3","BufferAttribute","Box3","FrontSide","Matrix4","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","raycast","raycastFirst","shapecast","intersectsGeometry","setBuffer","clearBuffer","OrientedBox","ExtendedTriangle","PrimitivePool","arrayToBox","iterateOverTriangles","setTriangle","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","obb","obb2","temp","temp1","temp2","temp3","temp4","tempBox","trianglePool","MeshBVH","geometry","options","arguments","length","undefined","_classCallCheck","isBufferGeometry","Error","index","isInterleavedBufferAttribute","Object","assign","_defineProperty","strategy","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","SharedArrayBuffer","_roots","boundingBox","getBoundingBox","_createClass","key","value","refit","nodeIndices","Array","isArray","Set","indexArr","array","posAttr","attributes","position","buffer","uint32Array","uint16Array","float32Array","byteOffset","roots","i","l","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","offset","count","minx","Infinity","miny","minz","maxx","maxy","maxz","x","getX","y","getY","z","getZ","left","right","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","depth","splitAxis","stopTraversal","ray","materialOrSide","intersects","isMaterial","isArrayMaterial","groups","side","materialSide","materialIndex","startCount","j","jl","face","closestResult","result","distance","otherGeometry","geomToMesh","_iterator","_createForOfIteratorHelper","_step","s","n","done","root","err","e","f","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","console","warn","triangle","getPrimitive","_callbacks","originalIntersectsRange","nodeIndex","_iterator2","_step2","releasePrimitive","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","copy","invert","triangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","i2","l2","a","applyMatrix4","b","c","needsUpdate","i1","l1","originalIntersectsRanges","box","intersectsBox","nodeIndex1","nodeIndex2","boxToMesh","set","min","max","intersectsSphere","sphere","closestPointToGeometry","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","matrix","distanceToBox","score","boundsTree","otherOffset","otherCount","dist","distanceToTriangle","triCount","point","clone","faceIndex","sub","closestPointToPoint","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","triIndex","distSq","Math","sqrt","makeEmpty","forEach","union","serialize","bvh","cloneBuffers","_objectSpread","rootData","indexAttribute","getIndex","map","slice","deserialize","data","setIndex","newIndex"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-mesh-bvh@0.5.24_three@0.151.3/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"sourcesContent":["import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\totherBvh.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}