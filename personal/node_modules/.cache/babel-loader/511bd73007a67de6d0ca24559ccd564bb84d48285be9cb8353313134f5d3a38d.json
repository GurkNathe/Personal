{"ast":null,"code":"import { DataTextureLoader, HalfFloatType, DataUtils, FloatType, RGBAFormat, RedFormat, LinearFilter } from \"three\";\nimport { unzlibSync } from \"fflate\";\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE) lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n) p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);else wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);else wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          if (numComp == 3) {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function (dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10,\n        fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\"NO_COMPRESSION\", \"RLE_COMPRESSION\", \"ZIPS_COMPRESSION\", \"ZIP_COMPRESSION\", \"PIZ_COMPRESSION\", \"PXR24_COMPRESSION\", \"B44_COMPRESSION\", \"B44A_COMPRESSION\", \"DWAA_COMPRESSION\", \"DWAB_COMPRESSION\"];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return {\n        xMin,\n        yMin,\n        xMax,\n        yMax\n      };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if (spec != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        encoding: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++) parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4) {\n        EXRDecoder2.format = RGBAFormat;\n        EXRDecoder2.encoding = 3e3;\n      } else {\n        EXRDecoder2.format = RedFormat;\n        EXRDecoder2.encoding = 3e3;\n      }\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = {\n      value: 0\n    };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = {\n      value: 0\n    };\n    const channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3,\n      Y: 0\n    };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height) break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      encoding: EXRDecoder.encoding,\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (\"colorSpace\" in texture) texture.colorSpace = texData.encoding === 3001 ? \"srgb\" : \"srgb-linear\";else texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad) onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport { EXRLoader };","map":{"version":3,"names":["DataTextureLoader","HalfFloatType","DataUtils","FloatType","RGBAFormat","RedFormat","LinearFilter","unzlibSync","EXRLoader","constructor","manager","type","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","value","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","buffer2","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp2","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset2","type2","y2","src","setUint16","offset3","x2","halfRow","comp","decoded","y","x","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","offset","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset2","cp","end","set","uncompressPXR","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","parseHeader","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","error","setupDecoder","outputType","EXRDecoder2","dataWindow","bytesPerLine","inputSize","uncompress","getter","format","encoding","blockCount","outputChannels","byteArray","bufferDataView","uInt8Array","EXRDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line","isCompressed","line_y","true_y","channelID","cOff","outIndex","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","colorSpace","minFilter","magFilter","generateMipmaps","flipY"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/EXRLoader.js"],"sourcesContent":["import { DataTextureLoader, HalfFloatType, DataUtils, FloatType, RGBAFormat, RedFormat, LinearFilter } from \"three\";\nimport { unzlibSync } from \"fflate\";\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE)\n        lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = { l: 0, c: 0, lc: 0 };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i)\n        hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i)\n        hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0)\n          hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni)\n          return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = { c: 0, lc: 0 };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = { c: 0, lc: 0 };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = { a: 0, b: 0 };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n)\n        p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p01 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array2,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset\n                  );\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop)\n          break;\n        out[s++] = source[t1++];\n        if (s > stop)\n          break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = { value: 0 };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1)\n          maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1)\n            maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          if (numComp == 3) {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2)\n          continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount\n            );\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded)\n          continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function(dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\n        \"NO_COMPRESSION\",\n        \"RLE_COMPRESSION\",\n        \"ZIPS_COMPRESSION\",\n        \"ZIP_COMPRESSION\",\n        \"PIZ_COMPRESSION\",\n        \"PXR24_COMPRESSION\",\n        \"B44_COMPRESSION\",\n        \"B44A_COMPRESSION\",\n        \"DWAA_COMPRESSION\",\n        \"DWAB_COMPRESSION\"\n      ];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return { xMin, yMin, xMax, yMax };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if (spec != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        encoding: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++)\n        parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4) {\n        EXRDecoder2.format = RGBAFormat;\n        EXRDecoder2.encoding = 3e3;\n      } else {\n        EXRDecoder2.format = RedFormat;\n        EXRDecoder2.encoding = 3e3;\n      }\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = { value: 0 };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = { value: 0 };\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height)\n          break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      encoding: EXRDecoder.encoding,\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (\"colorSpace\" in texture)\n        texture.colorSpace = texData.encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n      else\n        texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  EXRLoader\n};\n"],"mappings":"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AGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAC/Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;MAC9Bc,GAAG,CAAC,CAAC,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;MAC9Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;MAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;MAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;MAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,CAAC,CAAC,CAAC;MAC/Bc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACX,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCc,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}