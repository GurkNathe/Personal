{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, MathUtils, Vector3, Quaternion, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, Matrix4, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, RepeatWrapping, ClampToEdgeWrapping, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, Scene, TextureLoader, Euler } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nvar ColladaLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(ColladaLoader, _Loader);\n  var _super = _createSuper(ColladaLoader);\n  function ColladaLoader(manager) {\n    _classCallCheck(this, ColladaLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(ColladaLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path) {\n      function getElementsByTagName(xml2, name) {\n        var array = [];\n        var childNodes = xml2.childNodes;\n        for (var i = 0, l = childNodes.length; i < l; i++) {\n          var child = childNodes[i];\n          if (child.nodeName === name) {\n            array.push(child);\n          }\n        }\n        return array;\n      }\n      function parseStrings(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parts[i];\n        }\n        return array;\n      }\n      function parseFloats(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseFloat(parts[i]);\n        }\n        return array;\n      }\n      function parseInts(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseInt(parts[i]);\n        }\n        return array;\n      }\n      function parseId(text2) {\n        return text2.substring(1);\n      }\n      function generateId() {\n        return \"three_default_\" + count++;\n      }\n      function isEmpty(object) {\n        return Object.keys(object).length === 0;\n      }\n      function parseAsset(xml2) {\n        return {\n          unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n          upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n        };\n      }\n      function parseAssetUnit(xml2) {\n        if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n          return parseFloat(xml2.getAttribute(\"meter\"));\n        } else {\n          return 1;\n        }\n      }\n      function parseAssetUpAxis(xml2) {\n        return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n      }\n      function parseLibrary(xml2, libraryName, nodeName, parser) {\n        var library2 = getElementsByTagName(xml2, libraryName)[0];\n        if (library2 !== void 0) {\n          var elements = getElementsByTagName(library2, nodeName);\n          for (var i = 0; i < elements.length; i++) {\n            parser(elements[i]);\n          }\n        }\n      }\n      function buildLibrary(data, builder) {\n        for (var name in data) {\n          var object = data[name];\n          object.build = builder(data[name]);\n        }\n      }\n      function getBuild(data, builder) {\n        if (data.build !== void 0) return data.build;\n        data.build = builder(data);\n        return data.build;\n      }\n      function parseAnimation(xml2) {\n        var data = {\n          sources: {},\n          samplers: {},\n          channels: {}\n        };\n        var hasChildren = false;\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = void 0;\n          switch (child.nodeName) {\n            case \"source\":\n              id = child.getAttribute(\"id\");\n              data.sources[id] = parseSource(child);\n              break;\n            case \"sampler\":\n              id = child.getAttribute(\"id\");\n              data.samplers[id] = parseAnimationSampler(child);\n              break;\n            case \"channel\":\n              id = child.getAttribute(\"target\");\n              data.channels[id] = parseAnimationChannel(child);\n              break;\n            case \"animation\":\n              parseAnimation(child);\n              hasChildren = true;\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasChildren === false) {\n          library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n        }\n      }\n      function parseAnimationSampler(xml2) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var id = parseId(child.getAttribute(\"source\"));\n              var semantic = child.getAttribute(\"semantic\");\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseAnimationChannel(xml2) {\n        var data = {};\n        var target = xml2.getAttribute(\"target\");\n        var parts = target.split(\"/\");\n        var id = parts.shift();\n        var sid = parts.shift();\n        var arraySyntax = sid.indexOf(\"(\") !== -1;\n        var memberSyntax = sid.indexOf(\".\") !== -1;\n        if (memberSyntax) {\n          parts = sid.split(\".\");\n          sid = parts.shift();\n          data.member = parts.shift();\n        } else if (arraySyntax) {\n          var indices = sid.split(\"(\");\n          sid = indices.shift();\n          for (var i = 0; i < indices.length; i++) {\n            indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n          }\n          data.indices = indices;\n        }\n        data.id = id;\n        data.sid = sid;\n        data.arraySyntax = arraySyntax;\n        data.memberSyntax = memberSyntax;\n        data.sampler = parseId(xml2.getAttribute(\"source\"));\n        return data;\n      }\n      function buildAnimation(data) {\n        var tracks = [];\n        var channels = data.channels;\n        var samplers = data.samplers;\n        var sources = data.sources;\n        for (var target in channels) {\n          if (channels.hasOwnProperty(target)) {\n            var channel = channels[target];\n            var sampler = samplers[channel.sampler];\n            var inputId = sampler.inputs.INPUT;\n            var outputId = sampler.inputs.OUTPUT;\n            var inputSource = sources[inputId];\n            var outputSource = sources[outputId];\n            var animation = buildAnimationChannel(channel, inputSource, outputSource);\n            createKeyframeTracks(animation, tracks);\n          }\n        }\n        return tracks;\n      }\n      function getAnimation(id) {\n        return getBuild(library.animations[id], buildAnimation);\n      }\n      function buildAnimationChannel(channel, inputSource, outputSource) {\n        var node = library.nodes[channel.id];\n        var object3D = getNode(node.id);\n        var transform = node.transforms[channel.sid];\n        var defaultMatrix = node.matrix.clone().transpose();\n        var time, stride;\n        var i, il, j, jl;\n        var data = {};\n        switch (transform) {\n          case \"matrix\":\n            for (i = 0, il = inputSource.array.length; i < il; i++) {\n              time = inputSource.array[i];\n              stride = i * outputSource.stride;\n              if (data[time] === void 0) data[time] = {};\n              if (channel.arraySyntax === true) {\n                var value = outputSource.array[stride];\n                var index = channel.indices[0] + 4 * channel.indices[1];\n                data[time][index] = value;\n              } else {\n                for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                  data[time][j] = outputSource.array[stride + j];\n                }\n              }\n            }\n            break;\n          case \"translate\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case \"rotate\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case \"scale\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n        }\n        var keyframes = prepareAnimationData(data, defaultMatrix);\n        var animation = {\n          name: object3D.uuid,\n          keyframes: keyframes\n        };\n        return animation;\n      }\n      function prepareAnimationData(data, defaultMatrix) {\n        var keyframes = [];\n        for (var time in data) {\n          keyframes.push({\n            time: parseFloat(time),\n            value: data[time]\n          });\n        }\n        keyframes.sort(ascending);\n        for (var i = 0; i < 16; i++) {\n          transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n        }\n        return keyframes;\n        function ascending(a, b) {\n          return a.time - b.time;\n        }\n      }\n      var position = new Vector3();\n      var scale = new Vector3();\n      var quaternion = new Quaternion();\n      function createKeyframeTracks(animation, tracks) {\n        var keyframes = animation.keyframes;\n        var name = animation.name;\n        var times = [];\n        var positionData = [];\n        var quaternionData = [];\n        var scaleData = [];\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          var time = keyframe.time;\n          var value = keyframe.value;\n          matrix.fromArray(value).transpose();\n          matrix.decompose(position, quaternion, scale);\n          times.push(time);\n          positionData.push(position.x, position.y, position.z);\n          quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n          scaleData.push(scale.x, scale.y, scale.z);\n        }\n        if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n        if (quaternionData.length > 0) {\n          tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n        }\n        if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n        return tracks;\n      }\n      function transformAnimationData(keyframes, property, defaultValue) {\n        var keyframe;\n        var empty = true;\n        var i, l;\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          if (keyframe.value[property] === void 0) {\n            keyframe.value[property] = null;\n          } else {\n            empty = false;\n          }\n        }\n        if (empty === true) {\n          for (i = 0, l = keyframes.length; i < l; i++) {\n            keyframe = keyframes[i];\n            keyframe.value[property] = defaultValue;\n          }\n        } else {\n          createMissingKeyframes(keyframes, property);\n        }\n      }\n      function createMissingKeyframes(keyframes, property) {\n        var prev, next;\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] === null) {\n            prev = getPrev(keyframes, i, property);\n            next = getNext(keyframes, i, property);\n            if (prev === null) {\n              keyframe.value[property] = next.value[property];\n              continue;\n            }\n            if (next === null) {\n              keyframe.value[property] = prev.value[property];\n              continue;\n            }\n            interpolate(keyframe, prev, next, property);\n          }\n        }\n      }\n      function getPrev(keyframes, i, property) {\n        while (i >= 0) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i--;\n        }\n        return null;\n      }\n      function getNext(keyframes, i, property) {\n        while (i < keyframes.length) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i++;\n        }\n        return null;\n      }\n      function interpolate(key, prev, next, property) {\n        if (next.time - prev.time === 0) {\n          key.value[property] = prev.value[property];\n          return;\n        }\n        key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n      }\n      function parseAnimationClip(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"id\") || \"default\",\n          start: parseFloat(xml2.getAttribute(\"start\") || 0),\n          end: parseFloat(xml2.getAttribute(\"end\") || 0),\n          animations: []\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"instance_animation\":\n              data.animations.push(parseId(child.getAttribute(\"url\")));\n              break;\n          }\n        }\n        library.clips[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildAnimationClip(data) {\n        var tracks = [];\n        var name = data.name;\n        var duration = data.end - data.start || -1;\n        var animations2 = data.animations;\n        for (var i = 0, il = animations2.length; i < il; i++) {\n          var animationTracks = getAnimation(animations2[i]);\n          for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n            tracks.push(animationTracks[j]);\n          }\n        }\n        return new AnimationClip(name, duration, tracks);\n      }\n      function getAnimationClip(id) {\n        return getBuild(library.clips[id], buildAnimationClip);\n      }\n      function parseController(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"skin\":\n              data.id = parseId(child.getAttribute(\"source\"));\n              data.skin = parseSkin(child);\n              break;\n            case \"morph\":\n              data.id = parseId(child.getAttribute(\"source\"));\n              console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n              break;\n          }\n        }\n        library.controllers[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseSkin(xml2) {\n        var data = {\n          sources: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"bind_shape_matrix\":\n              data.bindShapeMatrix = parseFloats(child.textContent);\n              break;\n            case \"source\":\n              var id = child.getAttribute(\"id\");\n              data.sources[id] = parseSource(child);\n              break;\n            case \"joints\":\n              data.joints = parseJoints(child);\n              break;\n            case \"vertex_weights\":\n              data.vertexWeights = parseVertexWeights(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseJoints(xml2) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var semantic = child.getAttribute(\"semantic\");\n              var id = parseId(child.getAttribute(\"source\"));\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseVertexWeights(xml2) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var semantic = child.getAttribute(\"semantic\");\n              var id = parseId(child.getAttribute(\"source\"));\n              var offset = parseInt(child.getAttribute(\"offset\"));\n              data.inputs[semantic] = {\n                id: id,\n                offset: offset\n              };\n              break;\n            case \"vcount\":\n              data.vcount = parseInts(child.textContent);\n              break;\n            case \"v\":\n              data.v = parseInts(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildController(data) {\n        var build = {\n          id: data.id\n        };\n        var geometry = library.geometries[build.id];\n        if (data.skin !== void 0) {\n          build.skin = buildSkin(data.skin);\n          geometry.sources.skinIndices = build.skin.indices;\n          geometry.sources.skinWeights = build.skin.weights;\n        }\n        return build;\n      }\n      function buildSkin(data) {\n        var BONE_LIMIT = 4;\n        var build = {\n          joints: [],\n          // this must be an array to preserve the joint order\n          indices: {\n            array: [],\n            stride: BONE_LIMIT\n          },\n          weights: {\n            array: [],\n            stride: BONE_LIMIT\n          }\n        };\n        var sources = data.sources;\n        var vertexWeights = data.vertexWeights;\n        var vcount = vertexWeights.vcount;\n        var v = vertexWeights.v;\n        var jointOffset = vertexWeights.inputs.JOINT.offset;\n        var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n        var jointSource = data.sources[data.joints.inputs.JOINT];\n        var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n        var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n        var stride = 0;\n        var i, j, l;\n        for (i = 0, l = vcount.length; i < l; i++) {\n          var jointCount = vcount[i];\n          var vertexSkinData = [];\n          for (j = 0; j < jointCount; j++) {\n            var skinIndex = v[stride + jointOffset];\n            var weightId = v[stride + weightOffset];\n            var skinWeight = weights[weightId];\n            vertexSkinData.push({\n              index: skinIndex,\n              weight: skinWeight\n            });\n            stride += 2;\n          }\n          vertexSkinData.sort(descending);\n          for (j = 0; j < BONE_LIMIT; j++) {\n            var d = vertexSkinData[j];\n            if (d !== void 0) {\n              build.indices.array.push(d.index);\n              build.weights.array.push(d.weight);\n            } else {\n              build.indices.array.push(0);\n              build.weights.array.push(0);\n            }\n          }\n        }\n        if (data.bindShapeMatrix) {\n          build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n        } else {\n          build.bindMatrix = new Matrix4().identity();\n        }\n        for (i = 0, l = jointSource.array.length; i < l; i++) {\n          var name = jointSource.array[i];\n          var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n          build.joints.push({\n            name: name,\n            boneInverse: boneInverse\n          });\n        }\n        return build;\n        function descending(a, b) {\n          return b.weight - a.weight;\n        }\n      }\n      function getController(id) {\n        return getBuild(library.controllers[id], buildController);\n      }\n      function parseImage(xml2) {\n        var data = {\n          init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n        };\n        library.images[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildImage(data) {\n        if (data.build !== void 0) return data.build;\n        return data.init_from;\n      }\n      function getImage(id) {\n        var data = library.images[id];\n        if (data !== void 0) {\n          return getBuild(data, buildImage);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n        return null;\n      }\n      function parseEffect(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"profile_COMMON\":\n              data.profile = parseEffectProfileCOMMON(child);\n              break;\n          }\n        }\n        library.effects[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseEffectProfileCOMMON(xml2) {\n        var data = {\n          surfaces: {},\n          samplers: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"newparam\":\n              parseEffectNewparam(child, data);\n              break;\n            case \"technique\":\n              data.technique = parseEffectTechnique(child);\n              break;\n            case \"extra\":\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectNewparam(xml2, data) {\n        var sid = xml2.getAttribute(\"sid\");\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"surface\":\n              data.surfaces[sid] = parseEffectSurface(child);\n              break;\n            case \"sampler2D\":\n              data.samplers[sid] = parseEffectSampler(child);\n              break;\n          }\n        }\n      }\n      function parseEffectSurface(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"init_from\":\n              data.init_from = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectSampler(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"source\":\n              data.source = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectTechnique(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"constant\":\n            case \"lambert\":\n            case \"blinn\":\n            case \"phong\":\n              data.type = child.nodeName;\n              data.parameters = parseEffectParameters(child);\n              break;\n            case \"extra\":\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameters(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"emission\":\n            case \"diffuse\":\n            case \"specular\":\n            case \"bump\":\n            case \"ambient\":\n            case \"shininess\":\n            case \"transparency\":\n              data[child.nodeName] = parseEffectParameter(child);\n              break;\n            case \"transparent\":\n              data[child.nodeName] = {\n                opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n                data: parseEffectParameter(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameter(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"color\":\n              data[child.nodeName] = parseFloats(child.textContent);\n              break;\n            case \"float\":\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case \"texture\":\n              data[child.nodeName] = {\n                id: child.getAttribute(\"texture\"),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTexture(xml2) {\n        var data = {\n          technique: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"extra\":\n              parseEffectParameterTextureExtra(child, data);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTextureExtra(xml2, data) {\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique\":\n              parseEffectParameterTextureExtraTechnique(child, data);\n              break;\n          }\n        }\n      }\n      function parseEffectParameterTextureExtraTechnique(xml2, data) {\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"repeatU\":\n            case \"repeatV\":\n            case \"offsetU\":\n            case \"offsetV\":\n              data.technique[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case \"wrapU\":\n            case \"wrapV\":\n              if (child.textContent.toUpperCase() === \"TRUE\") {\n                data.technique[child.nodeName] = 1;\n              } else if (child.textContent.toUpperCase() === \"FALSE\") {\n                data.technique[child.nodeName] = 0;\n              } else {\n                data.technique[child.nodeName] = parseInt(child.textContent);\n              }\n              break;\n            case \"bump\":\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n      }\n      function parseEffectExtra(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique\":\n              data.technique = parseEffectExtraTechnique(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechnique(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"double_sided\":\n              data[child.nodeName] = parseInt(child.textContent);\n              break;\n            case \"bump\":\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechniqueBump(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"texture\":\n              data[child.nodeName] = {\n                id: child.getAttribute(\"texture\"),\n                texcoord: child.getAttribute(\"texcoord\"),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function buildEffect(data) {\n        return data;\n      }\n      function getEffect(id) {\n        return getBuild(library.effects[id], buildEffect);\n      }\n      function parseMaterial(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\")\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"instance_effect\":\n              data.url = parseId(child.getAttribute(\"url\"));\n              break;\n          }\n        }\n        library.materials[xml2.getAttribute(\"id\")] = data;\n      }\n      function getTextureLoader(image) {\n        var loader;\n        var extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n        extension = extension.toLowerCase();\n        switch (extension) {\n          case \"tga\":\n            loader = tgaLoader;\n            break;\n          default:\n            loader = textureLoader;\n        }\n        return loader;\n      }\n      function buildMaterial(data) {\n        var effect = getEffect(data.url);\n        var technique = effect.profile.technique;\n        var material;\n        switch (technique.type) {\n          case \"phong\":\n          case \"blinn\":\n            material = new MeshPhongMaterial();\n            break;\n          case \"lambert\":\n            material = new MeshLambertMaterial();\n            break;\n          default:\n            material = new MeshBasicMaterial();\n            break;\n        }\n        material.name = data.name || \"\";\n        function getTexture(textureObject) {\n          var sampler = effect.profile.samplers[textureObject.id];\n          var image = null;\n          if (sampler !== void 0) {\n            var surface = effect.profile.surfaces[sampler.source];\n            image = getImage(surface.init_from);\n          } else {\n            console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n            image = getImage(textureObject.id);\n          }\n          if (image !== null) {\n            var loader = getTextureLoader(image);\n            if (loader !== void 0) {\n              var texture = loader.load(image);\n              var extra = textureObject.extra;\n              if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n                var technique2 = extra.technique;\n                texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n                texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n              } else {\n                texture.wrapS = RepeatWrapping;\n                texture.wrapT = RepeatWrapping;\n              }\n              return texture;\n            } else {\n              console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n              return null;\n            }\n          } else {\n            console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n            return null;\n          }\n        }\n        var parameters = technique.parameters;\n        for (var key in parameters) {\n          var parameter = parameters[key];\n          switch (key) {\n            case \"diffuse\":\n              if (parameter.color) material.color.fromArray(parameter.color);\n              if (parameter.texture) material.map = getTexture(parameter.texture);\n              break;\n            case \"specular\":\n              if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n              if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n              break;\n            case \"bump\":\n              if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n              break;\n            case \"ambient\":\n              if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n              break;\n            case \"shininess\":\n              if (parameter.float && material.shininess) material.shininess = parameter.float;\n              break;\n            case \"emission\":\n              if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n              if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n              break;\n          }\n        }\n        var transparent = parameters[\"transparent\"];\n        var transparency = parameters[\"transparency\"];\n        if (transparency === void 0 && transparent) {\n          transparency = {\n            float: 1\n          };\n        }\n        if (transparent === void 0 && transparency) {\n          transparent = {\n            opaque: \"A_ONE\",\n            data: {\n              color: [1, 1, 1, 1]\n            }\n          };\n        }\n        if (transparent && transparency) {\n          if (transparent.data.texture) {\n            material.transparent = true;\n          } else {\n            var color = transparent.data.color;\n            switch (transparent.opaque) {\n              case \"A_ONE\":\n                material.opacity = color[3] * transparency.float;\n                break;\n              case \"RGB_ZERO\":\n                material.opacity = 1 - color[0] * transparency.float;\n                break;\n              case \"A_ZERO\":\n                material.opacity = 1 - color[3] * transparency.float;\n                break;\n              case \"RGB_ONE\":\n                material.opacity = color[0] * transparency.float;\n                break;\n              default:\n                console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n            }\n            if (material.opacity < 1) material.transparent = true;\n          }\n        }\n        if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n          var techniques = technique.extra.technique;\n          for (var k in techniques) {\n            var v = techniques[k];\n            switch (k) {\n              case \"double_sided\":\n                material.side = v === 1 ? DoubleSide : FrontSide;\n                break;\n              case \"bump\":\n                material.normalMap = getTexture(v.texture);\n                material.normalScale = new Vector2(1, 1);\n                break;\n            }\n          }\n        }\n        return material;\n      }\n      function getMaterial(id) {\n        return getBuild(library.materials[id], buildMaterial);\n      }\n      function parseCamera(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\")\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"optics\":\n              data.optics = parseCameraOptics(child);\n              break;\n          }\n        }\n        library.cameras[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseCameraOptics(xml2) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"technique_common\":\n              return parseCameraTechnique(child);\n          }\n        }\n        return {};\n      }\n      function parseCameraTechnique(xml2) {\n        var data = {};\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"perspective\":\n            case \"orthographic\":\n              data.technique = child.nodeName;\n              data.parameters = parseCameraParameters(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseCameraParameters(xml2) {\n        var data = {};\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"xfov\":\n            case \"yfov\":\n            case \"xmag\":\n            case \"ymag\":\n            case \"znear\":\n            case \"zfar\":\n            case \"aspect_ratio\":\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildCamera(data) {\n        var camera;\n        switch (data.optics.technique) {\n          case \"perspective\":\n            camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          case \"orthographic\":\n            var ymag = data.optics.parameters.ymag;\n            var xmag = data.optics.parameters.xmag;\n            var aspectRatio = data.optics.parameters.aspect_ratio;\n            xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n            ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n            xmag *= 0.5;\n            ymag *= 0.5;\n            camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          default:\n            camera = new PerspectiveCamera();\n            break;\n        }\n        camera.name = data.name || \"\";\n        return camera;\n      }\n      function getCamera(id) {\n        var data = library.cameras[id];\n        if (data !== void 0) {\n          return getBuild(data, buildCamera);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n        return null;\n      }\n      function parseLight(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique_common\":\n              data = parseLightTechnique(child);\n              break;\n          }\n        }\n        library.lights[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseLightTechnique(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"directional\":\n            case \"point\":\n            case \"spot\":\n            case \"ambient\":\n              data.technique = child.nodeName;\n              data.parameters = parseLightParameters(child);\n          }\n        }\n        return data;\n      }\n      function parseLightParameters(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"color\":\n              var array = parseFloats(child.textContent);\n              data.color = new Color().fromArray(array);\n              break;\n            case \"falloff_angle\":\n              data.falloffAngle = parseFloat(child.textContent);\n              break;\n            case \"quadratic_attenuation\":\n              var f = parseFloat(child.textContent);\n              data.distance = f ? Math.sqrt(1 / f) : 0;\n              break;\n          }\n        }\n        return data;\n      }\n      function buildLight(data) {\n        var light;\n        switch (data.technique) {\n          case \"directional\":\n            light = new DirectionalLight();\n            break;\n          case \"point\":\n            light = new PointLight();\n            break;\n          case \"spot\":\n            light = new SpotLight();\n            break;\n          case \"ambient\":\n            light = new AmbientLight();\n            break;\n        }\n        if (data.parameters.color) light.color.copy(data.parameters.color);\n        if (data.parameters.distance) light.distance = data.parameters.distance;\n        return light;\n      }\n      function getLight(id) {\n        var data = library.lights[id];\n        if (data !== void 0) {\n          return getBuild(data, buildLight);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n        return null;\n      }\n      function parseGeometry(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\"),\n          sources: {},\n          vertices: {},\n          primitives: []\n        };\n        var mesh = getElementsByTagName(xml2, \"mesh\")[0];\n        if (mesh === void 0) return;\n        for (var i = 0; i < mesh.childNodes.length; i++) {\n          var child = mesh.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = child.getAttribute(\"id\");\n          switch (child.nodeName) {\n            case \"source\":\n              data.sources[id] = parseSource(child);\n              break;\n            case \"vertices\":\n              data.vertices = parseGeometryVertices(child);\n              break;\n            case \"polygons\":\n              console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n              break;\n            case \"lines\":\n            case \"linestrips\":\n            case \"polylist\":\n            case \"triangles\":\n              data.primitives.push(parseGeometryPrimitive(child));\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        library.geometries[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseSource(xml2) {\n        var data = {\n          array: [],\n          stride: 3\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"float_array\":\n              data.array = parseFloats(child.textContent);\n              break;\n            case \"Name_array\":\n              data.array = parseStrings(child.textContent);\n              break;\n            case \"technique_common\":\n              var accessor = getElementsByTagName(child, \"accessor\")[0];\n              if (accessor !== void 0) {\n                data.stride = parseInt(accessor.getAttribute(\"stride\"));\n              }\n              break;\n          }\n        }\n        return data;\n      }\n      function parseGeometryVertices(xml2) {\n        var data = {};\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n        }\n        return data;\n      }\n      function parseGeometryPrimitive(xml2) {\n        var primitive = {\n          type: xml2.nodeName,\n          material: xml2.getAttribute(\"material\"),\n          count: parseInt(xml2.getAttribute(\"count\")),\n          inputs: {},\n          stride: 0,\n          hasUV: false\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var id = parseId(child.getAttribute(\"source\"));\n              var semantic = child.getAttribute(\"semantic\");\n              var offset = parseInt(child.getAttribute(\"offset\"));\n              var set = parseInt(child.getAttribute(\"set\"));\n              var inputname = set > 0 ? semantic + set : semantic;\n              primitive.inputs[inputname] = {\n                id: id,\n                offset: offset\n              };\n              primitive.stride = Math.max(primitive.stride, offset + 1);\n              if (semantic === \"TEXCOORD\") primitive.hasUV = true;\n              break;\n            case \"vcount\":\n              primitive.vcount = parseInts(child.textContent);\n              break;\n            case \"p\":\n              primitive.p = parseInts(child.textContent);\n              break;\n          }\n        }\n        return primitive;\n      }\n      function groupPrimitives(primitives) {\n        var build = {};\n        for (var i = 0; i < primitives.length; i++) {\n          var primitive = primitives[i];\n          if (build[primitive.type] === void 0) build[primitive.type] = [];\n          build[primitive.type].push(primitive);\n        }\n        return build;\n      }\n      function checkUVCoordinates(primitives) {\n        var count2 = 0;\n        for (var i = 0, l = primitives.length; i < l; i++) {\n          var primitive = primitives[i];\n          if (primitive.hasUV === true) {\n            count2++;\n          }\n        }\n        if (count2 > 0 && count2 < primitives.length) {\n          primitives.uvsNeedsFix = true;\n        }\n      }\n      function buildGeometry(data) {\n        var build = {};\n        var sources = data.sources;\n        var vertices = data.vertices;\n        var primitives = data.primitives;\n        if (primitives.length === 0) return {};\n        var groupedPrimitives = groupPrimitives(primitives);\n        for (var type in groupedPrimitives) {\n          var primitiveType = groupedPrimitives[type];\n          checkUVCoordinates(primitiveType);\n          build[type] = buildGeometryType(primitiveType, sources, vertices);\n        }\n        return build;\n      }\n      function buildGeometryType(primitives, sources, vertices) {\n        var build = {};\n        var position2 = {\n          array: [],\n          stride: 0\n        };\n        var normal = {\n          array: [],\n          stride: 0\n        };\n        var uv = {\n          array: [],\n          stride: 0\n        };\n        var uv2 = {\n          array: [],\n          stride: 0\n        };\n        var color = {\n          array: [],\n          stride: 0\n        };\n        var skinIndex = {\n          array: [],\n          stride: 4\n        };\n        var skinWeight = {\n          array: [],\n          stride: 4\n        };\n        var geometry = new BufferGeometry();\n        var materialKeys = [];\n        var start = 0;\n        for (var p = 0; p < primitives.length; p++) {\n          var primitive = primitives[p];\n          var inputs = primitive.inputs;\n          var count2 = 0;\n          switch (primitive.type) {\n            case \"lines\":\n            case \"linestrips\":\n              count2 = primitive.count * 2;\n              break;\n            case \"triangles\":\n              count2 = primitive.count * 3;\n              break;\n            case \"polylist\":\n              for (var g = 0; g < primitive.count; g++) {\n                var vc = primitive.vcount[g];\n                switch (vc) {\n                  case 3:\n                    count2 += 3;\n                    break;\n                  case 4:\n                    count2 += 6;\n                    break;\n                  default:\n                    count2 += (vc - 2) * 3;\n                    break;\n                }\n              }\n              break;\n            default:\n              console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n          }\n          geometry.addGroup(start, count2, p);\n          start += count2;\n          if (primitive.material) {\n            materialKeys.push(primitive.material);\n          }\n          for (var name in inputs) {\n            var input = inputs[name];\n            switch (name) {\n              case \"VERTEX\":\n                for (var key in vertices) {\n                  var id = vertices[key];\n                  switch (key) {\n                    case \"POSITION\":\n                      var prevLength = position2.array.length;\n                      buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                      position2.stride = sources[id].stride;\n                      if (sources.skinWeights && sources.skinIndices) {\n                        buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                        buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                      }\n                      if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                        var count3 = (position2.array.length - prevLength) / position2.stride;\n                        for (var i = 0; i < count3; i++) {\n                          uv.array.push(0, 0);\n                        }\n                      }\n                      break;\n                    case \"NORMAL\":\n                      buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                      normal.stride = sources[id].stride;\n                      break;\n                    case \"COLOR\":\n                      buildGeometryData(primitive, sources[id], input.offset, color.array);\n                      color.stride = sources[id].stride;\n                      break;\n                    case \"TEXCOORD\":\n                      buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    case \"TEXCOORD1\":\n                      buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                  }\n                }\n                break;\n              case \"NORMAL\":\n                buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                normal.stride = sources[input.id].stride;\n                break;\n              case \"COLOR\":\n                buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n                color.stride = sources[input.id].stride;\n                break;\n              case \"TEXCOORD\":\n                buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                uv.stride = sources[input.id].stride;\n                break;\n              case \"TEXCOORD1\":\n                buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n                uv2.stride = sources[input.id].stride;\n                break;\n            }\n          }\n        }\n        if (position2.array.length > 0) {\n          geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n        }\n        if (normal.array.length > 0) {\n          geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n        }\n        if (color.array.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n        if (uv.array.length > 0) geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n        if (uv2.array.length > 0) geometry.setAttribute(\"uv2\", new Float32BufferAttribute(uv2.array, uv2.stride));\n        if (skinIndex.array.length > 0) {\n          geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n        }\n        if (skinWeight.array.length > 0) {\n          geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n        }\n        build.data = geometry;\n        build.type = primitives[0].type;\n        build.materialKeys = materialKeys;\n        return build;\n      }\n      function buildGeometryData(primitive, source, offset, array) {\n        var indices = primitive.p;\n        var stride = primitive.stride;\n        var vcount = primitive.vcount;\n        function pushVector(i) {\n          var index = indices[i + offset] * sourceStride;\n          var length = index + sourceStride;\n          for (; index < length; index++) {\n            array.push(sourceArray[index]);\n          }\n        }\n        var sourceArray = source.array;\n        var sourceStride = source.stride;\n        if (primitive.vcount !== void 0) {\n          var index = 0;\n          for (var i = 0, l = vcount.length; i < l; i++) {\n            var count2 = vcount[i];\n            if (count2 === 4) {\n              var a = index + stride * 0;\n              var b = index + stride * 1;\n              var c = index + stride * 2;\n              var d = index + stride * 3;\n              pushVector(a);\n              pushVector(b);\n              pushVector(d);\n              pushVector(b);\n              pushVector(c);\n              pushVector(d);\n            } else if (count2 === 3) {\n              var _a = index + stride * 0;\n              var _b = index + stride * 1;\n              var _c = index + stride * 2;\n              pushVector(_a);\n              pushVector(_b);\n              pushVector(_c);\n            } else if (count2 > 4) {\n              for (var k = 1, kl = count2 - 2; k <= kl; k++) {\n                var _a2 = index + stride * 0;\n                var _b2 = index + stride * k;\n                var _c2 = index + stride * (k + 1);\n                pushVector(_a2);\n                pushVector(_b2);\n                pushVector(_c2);\n              }\n            }\n            index += stride * count2;\n          }\n        } else {\n          for (var _i = 0, _l = indices.length; _i < _l; _i += stride) {\n            pushVector(_i);\n          }\n        }\n      }\n      function getGeometry(id) {\n        return getBuild(library.geometries[id], buildGeometry);\n      }\n      function parseKinematicsModel(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          joints: {},\n          links: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique_common\":\n              parseKinematicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n        library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildKinematicsModel(data) {\n        if (data.build !== void 0) return data.build;\n        return data;\n      }\n      function getKinematicsModel(id) {\n        return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n      }\n      function parseKinematicsTechniqueCommon(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"joint\":\n              data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n              break;\n            case \"link\":\n              data.links.push(parseKinematicsLink(child));\n              break;\n          }\n        }\n      }\n      function parseKinematicsJoint(xml2) {\n        var data;\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"prismatic\":\n            case \"revolute\":\n              data = parseKinematicsJointParameter(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsJointParameter(xml2) {\n        var data = {\n          sid: xml2.getAttribute(\"sid\"),\n          name: xml2.getAttribute(\"name\") || \"\",\n          axis: new Vector3(),\n          limits: {\n            min: 0,\n            max: 0\n          },\n          type: xml2.nodeName,\n          static: false,\n          zeroPosition: 0,\n          middlePosition: 0\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"axis\":\n              var array = parseFloats(child.textContent);\n              data.axis.fromArray(array);\n              break;\n            case \"limits\":\n              var max = child.getElementsByTagName(\"max\")[0];\n              var min = child.getElementsByTagName(\"min\")[0];\n              data.limits.max = parseFloat(max.textContent);\n              data.limits.min = parseFloat(min.textContent);\n              break;\n          }\n        }\n        if (data.limits.min >= data.limits.max) {\n          data.static = true;\n        }\n        data.middlePosition = (data.limits.min + data.limits.max) / 2;\n        return data;\n      }\n      function parseKinematicsLink(xml2) {\n        var data = {\n          sid: xml2.getAttribute(\"sid\"),\n          name: xml2.getAttribute(\"name\") || \"\",\n          attachments: [],\n          transforms: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"attachment_full\":\n              data.attachments.push(parseKinematicsAttachment(child));\n              break;\n            case \"matrix\":\n            case \"translate\":\n            case \"rotate\":\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsAttachment(xml2) {\n        var data = {\n          joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n          transforms: [],\n          links: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"link\":\n              data.links.push(parseKinematicsLink(child));\n              break;\n            case \"matrix\":\n            case \"translate\":\n            case \"rotate\":\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsTransform(xml2) {\n        var data = {\n          type: xml2.nodeName\n        };\n        var array = parseFloats(xml2.textContent);\n        switch (data.type) {\n          case \"matrix\":\n            data.obj = new Matrix4();\n            data.obj.fromArray(array).transpose();\n            break;\n          case \"translate\":\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            break;\n          case \"rotate\":\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            data.angle = MathUtils.degToRad(array[3]);\n            break;\n        }\n        return data;\n      }\n      function parsePhysicsModel(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          rigidBodies: {}\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"rigid_body\":\n              data.rigidBodies[child.getAttribute(\"name\")] = {};\n              parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n              break;\n          }\n        }\n        library.physicsModels[xml2.getAttribute(\"id\")] = data;\n      }\n      function parsePhysicsRigidBody(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique_common\":\n              parsePhysicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n      }\n      function parsePhysicsTechniqueCommon(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"inertia\":\n              data.inertia = parseFloats(child.textContent);\n              break;\n            case \"mass\":\n              data.mass = parseFloats(child.textContent)[0];\n              break;\n          }\n        }\n      }\n      function parseKinematicsScene(xml2) {\n        var data = {\n          bindJointAxis: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"bind_joint_axis\":\n              data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n              break;\n          }\n        }\n        library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n      }\n      function parseKinematicsBindJointAxis(xml2) {\n        var data = {\n          target: xml2.getAttribute(\"target\").split(\"/\").pop()\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"axis\":\n              var param = child.getElementsByTagName(\"param\")[0];\n              data.axis = param.textContent;\n              var tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n              data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildKinematicsScene(data) {\n        if (data.build !== void 0) return data.build;\n        return data;\n      }\n      function getKinematicsScene(id) {\n        return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n      }\n      function setupKinematics() {\n        var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n        var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n        var visualSceneId = Object.keys(library.visualScenes)[0];\n        if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;\n        var kinematicsModel = getKinematicsModel(kinematicsModelId);\n        var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n        var visualScene = getVisualScene(visualSceneId);\n        var bindJointAxis = kinematicsScene.bindJointAxis;\n        var jointMap = {};\n        for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n          var axis = bindJointAxis[i];\n          var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n          if (targetElement) {\n            var parentVisualElement = targetElement.parentElement;\n            connect(axis.jointIndex, parentVisualElement);\n          }\n        }\n        function connect(jointIndex, visualElement) {\n          var visualElementName = visualElement.getAttribute(\"name\");\n          var joint = kinematicsModel.joints[jointIndex];\n          visualScene.traverse(function (object) {\n            if (object.name === visualElementName) {\n              jointMap[jointIndex] = {\n                object: object,\n                transforms: buildTransformList(visualElement),\n                joint: joint,\n                position: joint.zeroPosition\n              };\n            }\n          });\n        }\n        var m0 = new Matrix4();\n        kinematics = {\n          joints: kinematicsModel && kinematicsModel.joints,\n          getJointValue: function getJointValue(jointIndex) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              return jointData.position;\n            } else {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n            }\n          },\n          setJointValue: function setJointValue(jointIndex, value) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              var joint = jointData.joint;\n              if (value > joint.limits.max || value < joint.limits.min) {\n                console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\");\n              } else if (joint.static) {\n                console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n              } else {\n                var object = jointData.object;\n                var _axis = joint.axis;\n                var transforms = jointData.transforms;\n                matrix.identity();\n                for (var _i2 = 0; _i2 < transforms.length; _i2++) {\n                  var transform = transforms[_i2];\n                  if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                    switch (joint.type) {\n                      case \"revolute\":\n                        matrix.multiply(m0.makeRotationAxis(_axis, MathUtils.degToRad(value)));\n                        break;\n                      case \"prismatic\":\n                        matrix.multiply(m0.makeTranslation(_axis.x * value, _axis.y * value, _axis.z * value));\n                        break;\n                      default:\n                        console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                        break;\n                    }\n                  } else {\n                    switch (transform.type) {\n                      case \"matrix\":\n                        matrix.multiply(transform.obj);\n                        break;\n                      case \"translate\":\n                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                        break;\n                      case \"scale\":\n                        matrix.scale(transform.obj);\n                        break;\n                      case \"rotate\":\n                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                        break;\n                    }\n                  }\n                }\n                object.matrix.copy(matrix);\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\n                jointMap[jointIndex].position = value;\n              }\n            } else {\n              console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n            }\n          }\n        };\n      }\n      function buildTransformList(node) {\n        var transforms = [];\n        var xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0,\n            vector2 = void 0;\n          switch (child.nodeName) {\n            case \"matrix\":\n              array = parseFloats(child.textContent);\n              var matrix2 = new Matrix4().fromArray(array).transpose();\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: matrix2\n              });\n              break;\n            case \"translate\":\n            case \"scale\":\n              array = parseFloats(child.textContent);\n              vector2 = new Vector3().fromArray(array);\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: vector2\n              });\n              break;\n            case \"rotate\":\n              array = parseFloats(child.textContent);\n              vector2 = new Vector3().fromArray(array);\n              var angle = MathUtils.degToRad(array[3]);\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: vector2,\n                angle: angle\n              });\n              break;\n          }\n        }\n        return transforms;\n      }\n      function prepareNodes(xml2) {\n        var elements = xml2.getElementsByTagName(\"node\");\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i];\n          if (element.hasAttribute(\"id\") === false) {\n            element.setAttribute(\"id\", generateId());\n          }\n        }\n      }\n      var matrix = new Matrix4();\n      var vector = new Vector3();\n      function parseNode(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          type: xml2.getAttribute(\"type\"),\n          id: xml2.getAttribute(\"id\"),\n          sid: xml2.getAttribute(\"sid\"),\n          matrix: new Matrix4(),\n          nodes: [],\n          instanceCameras: [],\n          instanceControllers: [],\n          instanceLights: [],\n          instanceGeometries: [],\n          instanceNodes: [],\n          transforms: {}\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0;\n          switch (child.nodeName) {\n            case \"node\":\n              data.nodes.push(child.getAttribute(\"id\"));\n              parseNode(child);\n              break;\n            case \"instance_camera\":\n              data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n              break;\n            case \"instance_controller\":\n              data.instanceControllers.push(parseNodeInstance(child));\n              break;\n            case \"instance_light\":\n              data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n              break;\n            case \"instance_geometry\":\n              data.instanceGeometries.push(parseNodeInstance(child));\n              break;\n            case \"instance_node\":\n              data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n              break;\n            case \"matrix\":\n              array = parseFloats(child.textContent);\n              data.matrix.multiply(matrix.fromArray(array).transpose());\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"translate\":\n              array = parseFloats(child.textContent);\n              vector.fromArray(array);\n              data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"rotate\":\n              array = parseFloats(child.textContent);\n              var angle = MathUtils.degToRad(array[3]);\n              data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"scale\":\n              array = parseFloats(child.textContent);\n              data.matrix.scale(vector.fromArray(array));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"extra\":\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasNode(data.id)) {\n          console.warn(\"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\", data.id);\n        } else {\n          library.nodes[data.id] = data;\n        }\n        return data;\n      }\n      function parseNodeInstance(xml2) {\n        var data = {\n          id: parseId(xml2.getAttribute(\"url\")),\n          materials: {},\n          skeletons: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"bind_material\":\n              var instances = child.getElementsByTagName(\"instance_material\");\n              for (var j = 0; j < instances.length; j++) {\n                var instance = instances[j];\n                var symbol = instance.getAttribute(\"symbol\");\n                var target = instance.getAttribute(\"target\");\n                data.materials[symbol] = parseId(target);\n              }\n              break;\n            case \"skeleton\":\n              data.skeletons.push(parseId(child.textContent));\n              break;\n            default:\n              break;\n          }\n        }\n        return data;\n      }\n      function buildSkeleton(skeletons, joints) {\n        var boneData = [];\n        var sortedBoneData = [];\n        var i, j, data;\n        for (i = 0; i < skeletons.length; i++) {\n          var skeleton = skeletons[i];\n          var root = void 0;\n          if (hasNode(skeleton)) {\n            root = getNode(skeleton);\n            buildBoneHierarchy(root, joints, boneData);\n          } else if (hasVisualScene(skeleton)) {\n            var visualScene = library.visualScenes[skeleton];\n            var children = visualScene.children;\n            for (var j2 = 0; j2 < children.length; j2++) {\n              var child = children[j2];\n              if (child.type === \"JOINT\") {\n                var root2 = getNode(child.id);\n                buildBoneHierarchy(root2, joints, boneData);\n              }\n            }\n          } else {\n            console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n          }\n        }\n        for (i = 0; i < joints.length; i++) {\n          for (j = 0; j < boneData.length; j++) {\n            data = boneData[j];\n            if (data.bone.name === joints[i].name) {\n              sortedBoneData[i] = data;\n              data.processed = true;\n              break;\n            }\n          }\n        }\n        for (i = 0; i < boneData.length; i++) {\n          data = boneData[i];\n          if (data.processed === false) {\n            sortedBoneData.push(data);\n            data.processed = true;\n          }\n        }\n        var bones = [];\n        var boneInverses = [];\n        for (i = 0; i < sortedBoneData.length; i++) {\n          data = sortedBoneData[i];\n          bones.push(data.bone);\n          boneInverses.push(data.boneInverse);\n        }\n        return new Skeleton(bones, boneInverses);\n      }\n      function buildBoneHierarchy(root, joints, boneData) {\n        root.traverse(function (object) {\n          if (object.isBone === true) {\n            var boneInverse;\n            for (var i = 0; i < joints.length; i++) {\n              var joint = joints[i];\n              if (joint.name === object.name) {\n                boneInverse = joint.boneInverse;\n                break;\n              }\n            }\n            if (boneInverse === void 0) {\n              boneInverse = new Matrix4();\n            }\n            boneData.push({\n              bone: object,\n              boneInverse: boneInverse,\n              processed: false\n            });\n          }\n        });\n      }\n      function buildNode(data) {\n        var objects = [];\n        var matrix2 = data.matrix;\n        var nodes = data.nodes;\n        var type = data.type;\n        var instanceCameras = data.instanceCameras;\n        var instanceControllers = data.instanceControllers;\n        var instanceLights = data.instanceLights;\n        var instanceGeometries = data.instanceGeometries;\n        var instanceNodes = data.instanceNodes;\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          objects.push(getNode(nodes[i]));\n        }\n        for (var _i3 = 0, _l2 = instanceCameras.length; _i3 < _l2; _i3++) {\n          var instanceCamera = getCamera(instanceCameras[_i3]);\n          if (instanceCamera !== null) {\n            objects.push(instanceCamera.clone());\n          }\n        }\n        for (var _i4 = 0, _l3 = instanceControllers.length; _i4 < _l3; _i4++) {\n          var instance = instanceControllers[_i4];\n          var controller = getController(instance.id);\n          var geometries = getGeometry(controller.id);\n          var newObjects = buildObjects(geometries, instance.materials);\n          var skeletons = instance.skeletons;\n          var joints = controller.skin.joints;\n          var skeleton = buildSkeleton(skeletons, joints);\n          for (var j = 0, jl = newObjects.length; j < jl; j++) {\n            var object2 = newObjects[j];\n            if (object2.isSkinnedMesh) {\n              object2.bind(skeleton, controller.skin.bindMatrix);\n              object2.normalizeSkinWeights();\n            }\n            objects.push(object2);\n          }\n        }\n        for (var _i5 = 0, _l4 = instanceLights.length; _i5 < _l4; _i5++) {\n          var instanceLight = getLight(instanceLights[_i5]);\n          if (instanceLight !== null) {\n            objects.push(instanceLight.clone());\n          }\n        }\n        for (var _i6 = 0, _l5 = instanceGeometries.length; _i6 < _l5; _i6++) {\n          var _instance = instanceGeometries[_i6];\n          var _geometries = getGeometry(_instance.id);\n          var _newObjects = buildObjects(_geometries, _instance.materials);\n          for (var _j = 0, _jl = _newObjects.length; _j < _jl; _j++) {\n            objects.push(_newObjects[_j]);\n          }\n        }\n        for (var _i7 = 0, _l6 = instanceNodes.length; _i7 < _l6; _i7++) {\n          objects.push(getNode(instanceNodes[_i7]).clone());\n        }\n        var object;\n        if (nodes.length === 0 && objects.length === 1) {\n          object = objects[0];\n        } else {\n          object = type === \"JOINT\" ? new Bone() : new Group();\n          for (var _i8 = 0; _i8 < objects.length; _i8++) {\n            object.add(objects[_i8]);\n          }\n        }\n        object.name = type === \"JOINT\" ? data.sid : data.name;\n        object.matrix.copy(matrix2);\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n        return object;\n      }\n      var fallbackMaterial = new MeshBasicMaterial({\n        color: 16711935\n      });\n      function resolveMaterialBinding(keys, instanceMaterials) {\n        var materials = [];\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var id = instanceMaterials[keys[i]];\n          if (id === void 0) {\n            console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n            materials.push(fallbackMaterial);\n          } else {\n            materials.push(getMaterial(id));\n          }\n        }\n        return materials;\n      }\n      function buildObjects(geometries, instanceMaterials) {\n        var objects = [];\n        for (var type in geometries) {\n          var geometry = geometries[type];\n          var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n          if (materials.length === 0) {\n            if (type === \"lines\" || type === \"linestrips\") {\n              materials.push(new LineBasicMaterial());\n            } else {\n              materials.push(new MeshPhongMaterial());\n            }\n          }\n          var skinning = geometry.data.attributes.skinIndex !== void 0;\n          var material = materials.length === 1 ? materials[0] : materials;\n          var object = void 0;\n          switch (type) {\n            case \"lines\":\n              object = new LineSegments(geometry.data, material);\n              break;\n            case \"linestrips\":\n              object = new Line(geometry.data, material);\n              break;\n            case \"triangles\":\n            case \"polylist\":\n              if (skinning) {\n                object = new SkinnedMesh(geometry.data, material);\n              } else {\n                object = new Mesh(geometry.data, material);\n              }\n              break;\n          }\n          objects.push(object);\n        }\n        return objects;\n      }\n      function hasNode(id) {\n        return library.nodes[id] !== void 0;\n      }\n      function getNode(id) {\n        return getBuild(library.nodes[id], buildNode);\n      }\n      function parseVisualScene(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\"),\n          children: []\n        };\n        prepareNodes(xml2);\n        var elements = getElementsByTagName(xml2, \"node\");\n        for (var i = 0; i < elements.length; i++) {\n          data.children.push(parseNode(elements[i]));\n        }\n        library.visualScenes[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildVisualScene(data) {\n        var group = new Group();\n        group.name = data.name;\n        var children = data.children;\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          group.add(getNode(child.id));\n        }\n        return group;\n      }\n      function hasVisualScene(id) {\n        return library.visualScenes[id] !== void 0;\n      }\n      function getVisualScene(id) {\n        return getBuild(library.visualScenes[id], buildVisualScene);\n      }\n      function parseScene(xml2) {\n        var instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n        return getVisualScene(parseId(instance.getAttribute(\"url\")));\n      }\n      function setupAnimations() {\n        var clips = library.clips;\n        if (isEmpty(clips) === true) {\n          if (isEmpty(library.animations) === false) {\n            var tracks = [];\n            for (var id in library.animations) {\n              var animationTracks = getAnimation(id);\n              for (var i = 0, l = animationTracks.length; i < l; i++) {\n                tracks.push(animationTracks[i]);\n              }\n            }\n            animations.push(new AnimationClip(\"default\", -1, tracks));\n          }\n        } else {\n          for (var _id in clips) {\n            animations.push(getAnimationClip(_id));\n          }\n        }\n      }\n      function parserErrorToText(parserError2) {\n        var result = \"\";\n        var stack = [parserError2];\n        while (stack.length) {\n          var node = stack.shift();\n          if (node.nodeType === Node.TEXT_NODE) {\n            result += node.textContent;\n          } else {\n            result += \"\\n\";\n            stack.push.apply(stack, node.childNodes);\n          }\n        }\n        return result.trim();\n      }\n      if (text.length === 0) {\n        return {\n          scene: new Scene()\n        };\n      }\n      var xml = new DOMParser().parseFromString(text, \"application/xml\");\n      var collada = getElementsByTagName(xml, \"COLLADA\")[0];\n      var parserError = xml.getElementsByTagName(\"parsererror\")[0];\n      if (parserError !== void 0) {\n        var errorElement = getElementsByTagName(parserError, \"div\")[0];\n        var errorText;\n        if (errorElement) {\n          errorText = errorElement.textContent;\n        } else {\n          errorText = parserErrorToText(parserError);\n        }\n        console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n        return null;\n      }\n      var version = collada.getAttribute(\"version\");\n      console.log(\"THREE.ColladaLoader: File version\", version);\n      var asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var tgaLoader;\n      if (TGALoader) {\n        tgaLoader = new TGALoader(this.manager);\n        tgaLoader.setPath(this.resourcePath || path);\n      }\n      var animations = [];\n      var kinematics = {};\n      var count = 0;\n      var library = {\n        animations: {},\n        clips: {},\n        controllers: {},\n        images: {},\n        effects: {},\n        materials: {},\n        cameras: {},\n        lights: {},\n        geometries: {},\n        nodes: {},\n        visualScenes: {},\n        kinematicsModels: {},\n        physicsModels: {},\n        kinematicsScenes: {}\n      };\n      parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n      parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n      parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n      parseLibrary(collada, \"library_images\", \"image\", parseImage);\n      parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n      parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n      parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n      parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n      parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n      parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n      parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n      parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n      parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n      parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n      buildLibrary(library.animations, buildAnimation);\n      buildLibrary(library.clips, buildAnimationClip);\n      buildLibrary(library.controllers, buildController);\n      buildLibrary(library.images, buildImage);\n      buildLibrary(library.effects, buildEffect);\n      buildLibrary(library.materials, buildMaterial);\n      buildLibrary(library.cameras, buildCamera);\n      buildLibrary(library.lights, buildLight);\n      buildLibrary(library.geometries, buildGeometry);\n      buildLibrary(library.visualScenes, buildVisualScene);\n      setupAnimations();\n      setupKinematics();\n      var scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n      scene.animations = animations;\n      if (asset.upAxis === \"Z_UP\") {\n        scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      }\n      scene.scale.multiplyScalar(asset.unit);\n      return {\n        get animations() {\n          console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n          return animations;\n        },\n        kinematics: kinematics,\n        library: library,\n        scene: scene\n      };\n    }\n  }]);\n  return ColladaLoader;\n}(Loader);\nexport { ColladaLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","MathUtils","Vector3","Quaternion","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","Matrix4","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","RepeatWrapping","ClampToEdgeWrapping","Vector2","DoubleSide","FrontSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","Scene","TextureLoader","Euler","TGALoader","ColladaLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml2","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","text2","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library2","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","library","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animations2","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","technique2","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","techniques","k","side","normalScale","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","count2","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","position2","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","count3","setAttribute","pushVector","sourceStride","sourceArray","c","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector2","matrix2","prepareNodes","element","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","j2","root2","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","object2","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError2","result","stack","Node","TEXT_NODE","apply","scene","xml","DOMParser","parseFromString","parserError","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/ColladaLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, MathUtils, Vector3, Quaternion, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, Matrix4, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, RepeatWrapping, ClampToEdgeWrapping, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, Scene, TextureLoader, Euler } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text, path) {\n    function getElementsByTagName(xml2, name) {\n      const array = [];\n      const childNodes = xml2.childNodes;\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text2) {\n      return text2.substring(1);\n    }\n    function generateId() {\n      return \"three_default_\" + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    }\n    function parseAsset(xml2) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n      };\n    }\n    function parseAssetUnit(xml2) {\n      if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n        return parseFloat(xml2.getAttribute(\"meter\"));\n      } else {\n        return 1;\n      }\n    }\n    function parseAssetUpAxis(xml2) {\n      return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n    }\n    function parseLibrary(xml2, libraryName, nodeName, parser) {\n      const library2 = getElementsByTagName(xml2, libraryName)[0];\n      if (library2 !== void 0) {\n        const elements = getElementsByTagName(library2, nodeName);\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    }\n    function getBuild(data, builder) {\n      if (data.build !== void 0)\n        return data.build;\n      data.build = builder(data);\n      return data.build;\n    }\n    function parseAnimation(xml2) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let id;\n        switch (child.nodeName) {\n          case \"source\":\n            id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"sampler\":\n            id = child.getAttribute(\"id\");\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case \"channel\":\n            id = child.getAttribute(\"target\");\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          case \"animation\":\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasChildren === false) {\n        library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n      }\n    }\n    function parseAnimationSampler(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml2) {\n      const data = {};\n      const target = xml2.getAttribute(\"target\");\n      let parts = target.split(\"/\");\n      const id = parts.shift();\n      let sid = parts.shift();\n      const arraySyntax = sid.indexOf(\"(\") !== -1;\n      const memberSyntax = sid.indexOf(\".\") !== -1;\n      if (memberSyntax) {\n        parts = sid.split(\".\");\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        const indices = sid.split(\"(\");\n        sid = indices.shift();\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml2.getAttribute(\"source\"));\n      return data;\n    }\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {};\n      switch (transform) {\n        case \"matrix\":\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === void 0)\n              data[time] = {};\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case \"translate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"rotate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"scale\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = [];\n      for (const time in data) {\n        keyframes.push({ time: parseFloat(time), value: data[time] });\n      }\n      keyframes.sort(ascending);\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes;\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0)\n        tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n      }\n      if (scaleData.length > 0)\n        tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l;\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === void 0) {\n          keyframe.value[property] = null;\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null)\n          return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null)\n          return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    }\n    function parseAnimationClip(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"id\") || \"default\",\n        start: parseFloat(xml2.getAttribute(\"start\") || 0),\n        end: parseFloat(xml2.getAttribute(\"end\") || 0),\n        animations: []\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"instance_animation\":\n            data.animations.push(parseId(child.getAttribute(\"url\")));\n            break;\n        }\n      }\n      library.clips[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations2 = data.animations;\n      for (let i = 0, il = animations2.length; i < il; i++) {\n        const animationTracks = getAnimation(animations2[i]);\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    }\n    function parseController(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"skin\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            data.skin = parseSkin(child);\n            break;\n          case \"morph\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n            break;\n        }\n      }\n      library.controllers[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSkin(xml2) {\n      const data = {\n        sources: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"bind_shape_matrix\":\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case \"source\":\n            const id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"joints\":\n            data.joints = parseJoints(child);\n            break;\n          case \"vertex_weights\":\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            data.inputs[semantic] = { id, offset };\n            break;\n          case \"vcount\":\n            data.vcount = parseInts(child.textContent);\n            break;\n          case \"v\":\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n      if (data.skin !== void 0) {\n        build.skin = buildSkin(data.skin);\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l;\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i];\n        const vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({ index: skinIndex, weight: skinWeight });\n          stride += 2;\n        }\n        vertexSkinData.sort(descending);\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n          if (d !== void 0) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      }\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      }\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({ name, boneInverse });\n      }\n      return build;\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    }\n    function parseImage(xml2) {\n      const data = {\n        init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n      };\n      library.images[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      const data = library.images[id];\n      if (data !== void 0) {\n        return getBuild(data, buildImage);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    }\n    function parseEffect(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"profile_COMMON\":\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseEffectProfileCOMMON(xml2) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"newparam\":\n            parseEffectNewparam(child, data);\n            break;\n          case \"technique\":\n            data.technique = parseEffectTechnique(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml2, data) {\n      const sid = xml2.getAttribute(\"sid\");\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"surface\":\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case \"sampler2D\":\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"init_from\":\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"source\":\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"constant\":\n          case \"lambert\":\n          case \"blinn\":\n          case \"phong\":\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"emission\":\n          case \"diffuse\":\n          case \"specular\":\n          case \"bump\":\n          case \"ambient\":\n          case \"shininess\":\n          case \"transparency\":\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case \"transparent\":\n            data[child.nodeName] = {\n              opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"color\":\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case \"float\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"texture\":\n            data[child.nodeName] = { id: child.getAttribute(\"texture\"), extra: parseEffectParameterTexture(child) };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml2) {\n      const data = {\n        technique: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"extra\":\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"repeatU\":\n          case \"repeatV\":\n          case \"offsetU\":\n          case \"offsetV\":\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"wrapU\":\n          case \"wrapV\":\n            if (child.textContent.toUpperCase() === \"TRUE\") {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === \"FALSE\") {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"double_sided\":\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechniqueBump(xml2) {\n      var data = {};\n      for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n        var child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"texture\":\n            data[child.nodeName] = {\n              id: child.getAttribute(\"texture\"),\n              texcoord: child.getAttribute(\"texcoord\"),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    }\n    function parseMaterial(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"instance_effect\":\n            data.url = parseId(child.getAttribute(\"url\"));\n            break;\n        }\n      }\n      library.materials[xml2.getAttribute(\"id\")] = data;\n    }\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case \"tga\":\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n      switch (technique.type) {\n        case \"phong\":\n        case \"blinn\":\n          material = new MeshPhongMaterial();\n          break;\n        case \"lambert\":\n          material = new MeshLambertMaterial();\n          break;\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name || \"\";\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null;\n        if (sampler !== void 0) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n          image = getImage(textureObject.id);\n        }\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n          if (loader !== void 0) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n            if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n              const technique2 = extra.technique;\n              texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n              texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n            return texture;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n      const parameters = technique.parameters;\n      for (const key in parameters) {\n        const parameter = parameters[key];\n        switch (key) {\n          case \"diffuse\":\n            if (parameter.color)\n              material.color.fromArray(parameter.color);\n            if (parameter.texture)\n              material.map = getTexture(parameter.texture);\n            break;\n          case \"specular\":\n            if (parameter.color && material.specular)\n              material.specular.fromArray(parameter.color);\n            if (parameter.texture)\n              material.specularMap = getTexture(parameter.texture);\n            break;\n          case \"bump\":\n            if (parameter.texture)\n              material.normalMap = getTexture(parameter.texture);\n            break;\n          case \"ambient\":\n            if (parameter.texture)\n              material.lightMap = getTexture(parameter.texture);\n            break;\n          case \"shininess\":\n            if (parameter.float && material.shininess)\n              material.shininess = parameter.float;\n            break;\n          case \"emission\":\n            if (parameter.color && material.emissive)\n              material.emissive.fromArray(parameter.color);\n            if (parameter.texture)\n              material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      }\n      let transparent = parameters[\"transparent\"];\n      let transparency = parameters[\"transparency\"];\n      if (transparency === void 0 && transparent) {\n        transparency = {\n          float: 1\n        };\n      }\n      if (transparent === void 0 && transparency) {\n        transparent = {\n          opaque: \"A_ONE\",\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        if (transparent.data.texture) {\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n          switch (transparent.opaque) {\n            case \"A_ONE\":\n              material.opacity = color[3] * transparency.float;\n              break;\n            case \"RGB_ZERO\":\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case \"A_ZERO\":\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case \"RGB_ONE\":\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1)\n            material.transparent = true;\n        }\n      }\n      if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n        const techniques = technique.extra.technique;\n        for (const k in techniques) {\n          const v = techniques[k];\n          switch (k) {\n            case \"double_sided\":\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n            case \"bump\":\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    }\n    function parseCamera(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"optics\":\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseCameraOptics(xml2) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"technique_common\":\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"perspective\":\n          case \"orthographic\":\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"xfov\":\n          case \"yfov\":\n          case \"xmag\":\n          case \"ymag\":\n          case \"znear\":\n          case \"zfar\":\n          case \"aspect_ratio\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      let camera;\n      switch (data.optics.technique) {\n        case \"perspective\":\n          camera = new PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n        case \"orthographic\":\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n          ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(\n            -xmag,\n            xmag,\n            ymag,\n            -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name || \"\";\n      return camera;\n    }\n    function getCamera(id) {\n      const data = library.cameras[id];\n      if (data !== void 0) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    }\n    function parseLight(xml2) {\n      let data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseLightTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"directional\":\n          case \"point\":\n          case \"spot\":\n          case \"ambient\":\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"color\":\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n          case \"falloff_angle\":\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case \"quadratic_attenuation\":\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      let light;\n      switch (data.technique) {\n        case \"directional\":\n          light = new DirectionalLight();\n          break;\n        case \"point\":\n          light = new PointLight();\n          break;\n        case \"spot\":\n          light = new SpotLight();\n          break;\n        case \"ambient\":\n          light = new AmbientLight();\n          break;\n      }\n      if (data.parameters.color)\n        light.color.copy(data.parameters.color);\n      if (data.parameters.distance)\n        light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      const data = library.lights[id];\n      if (data !== void 0) {\n        return getBuild(data, buildLight);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    }\n    function parseGeometry(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml2, \"mesh\")[0];\n      if (mesh === void 0)\n        return;\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        const id = child.getAttribute(\"id\");\n        switch (child.nodeName) {\n          case \"source\":\n            data.sources[id] = parseSource(child);\n            break;\n          case \"vertices\":\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case \"polygons\":\n            console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n            break;\n          case \"lines\":\n          case \"linestrips\":\n          case \"polylist\":\n          case \"triangles\":\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSource(xml2) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"float_array\":\n            data.array = parseFloats(child.textContent);\n            break;\n          case \"Name_array\":\n            data.array = parseStrings(child.textContent);\n            break;\n          case \"technique_common\":\n            const accessor = getElementsByTagName(child, \"accessor\")[0];\n            if (accessor !== void 0) {\n              data.stride = parseInt(accessor.getAttribute(\"stride\"));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml2) {\n      const primitive = {\n        type: xml2.nodeName,\n        material: xml2.getAttribute(\"material\"),\n        count: parseInt(xml2.getAttribute(\"count\")),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            const set = parseInt(child.getAttribute(\"set\"));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = { id, offset };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === \"TEXCOORD\")\n              primitive.hasUV = true;\n            break;\n          case \"vcount\":\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case \"p\":\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      const build = {};\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === void 0)\n          build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      let count2 = 0;\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count2++;\n        }\n      }\n      if (count2 > 0 && count2 < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0)\n        return {};\n      const groupedPrimitives = groupPrimitives(primitives);\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type];\n        checkUVCoordinates(primitiveType);\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position2 = { array: [], stride: 0 };\n      const normal = { array: [], stride: 0 };\n      const uv = { array: [], stride: 0 };\n      const uv2 = { array: [], stride: 0 };\n      const color = { array: [], stride: 0 };\n      const skinIndex = { array: [], stride: 4 };\n      const skinWeight = { array: [], stride: 4 };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs;\n        let count2 = 0;\n        switch (primitive.type) {\n          case \"lines\":\n          case \"linestrips\":\n            count2 = primitive.count * 2;\n            break;\n          case \"triangles\":\n            count2 = primitive.count * 3;\n            break;\n          case \"polylist\":\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count2 += 3;\n                  break;\n                case 4:\n                  count2 += 6;\n                  break;\n                default:\n                  count2 += (vc - 2) * 3;\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n        }\n        geometry.addGroup(start, count2, p);\n        start += count2;\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        }\n        for (const name in inputs) {\n          const input = inputs[name];\n          switch (name) {\n            case \"VERTEX\":\n              for (const key in vertices) {\n                const id = vertices[key];\n                switch (key) {\n                  case \"POSITION\":\n                    const prevLength = position2.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                    position2.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    }\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count3 = (position2.array.length - prevLength) / position2.stride;\n                      for (let i = 0; i < count3; i++) {\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case \"NORMAL\":\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case \"COLOR\":\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD1\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case \"NORMAL\":\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case \"COLOR\":\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD1\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      }\n      if (position2.array.length > 0) {\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n      }\n      if (color.array.length > 0)\n        geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0)\n        geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0)\n        geometry.setAttribute(\"uv2\", new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n      if (primitive.vcount !== void 0) {\n        let index = 0;\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count2 = vcount[i];\n          if (count2 === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count2 === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count2 > 4) {\n            for (let k = 1, kl = count2 - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count2;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    }\n    function parseKinematicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        joints: {},\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"joint\":\n            data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n            break;\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml2) {\n      let data;\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"prismatic\":\n          case \"revolute\":\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml2.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case \"limits\":\n            const max = child.getElementsByTagName(\"max\")[0];\n            const min = child.getElementsByTagName(\"min\")[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      }\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      }\n      data.middlePosition = (data.limits.min + data.limits.max) / 2;\n      return data;\n    }\n    function parseKinematicsLink(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        attachments: [],\n        transforms: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"attachment_full\":\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml2) {\n      const data = {\n        joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n        transforms: [],\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml2) {\n      const data = {\n        type: xml2.nodeName\n      };\n      const array = parseFloats(xml2.textContent);\n      switch (data.type) {\n        case \"matrix\":\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case \"translate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n        case \"rotate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    }\n    function parsePhysicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        rigidBodies: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"rigid_body\":\n            data.rigidBodies[child.getAttribute(\"name\")] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n            break;\n        }\n      }\n      library.physicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function parsePhysicsRigidBody(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"inertia\":\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case \"mass\":\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    }\n    function parseKinematicsScene(xml2) {\n      const data = {\n        bindJointAxis: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"bind_joint_axis\":\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml2) {\n      const data = {\n        target: xml2.getAttribute(\"target\").split(\"/\").pop()\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const param = child.getElementsByTagName(\"param\")[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === void 0 || kinematicsSceneId === void 0)\n        return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i];\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          const parentVisualElement = targetElement.parentElement;\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute(\"name\");\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function(object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object,\n              transforms: buildTransformList(visualElement),\n              joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function(jointIndex) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function(jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            const joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\n                \"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\"\n              );\n            } else if (joint.static) {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity();\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i];\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case \"revolute\":\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n                    case \"prismatic\":\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case \"matrix\":\n                      matrix.multiply(transform.obj);\n                      break;\n                    case \"translate\":\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case \"scale\":\n                      matrix.scale(transform.obj);\n                      break;\n                    case \"rotate\":\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let array, vector2;\n        switch (child.nodeName) {\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            const matrix2 = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: matrix2\n            });\n            break;\n          case \"translate\":\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2\n            });\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2,\n              angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    }\n    function prepareNodes(xml2) {\n      const elements = xml2.getElementsByTagName(\"node\");\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        if (element.hasAttribute(\"id\") === false) {\n          element.setAttribute(\"id\", generateId());\n        }\n      }\n    }\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n    function parseNode(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        type: xml2.getAttribute(\"type\"),\n        id: xml2.getAttribute(\"id\"),\n        sid: xml2.getAttribute(\"sid\"),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let array;\n        switch (child.nodeName) {\n          case \"node\":\n            data.nodes.push(child.getAttribute(\"id\"));\n            parseNode(child);\n            break;\n          case \"instance_camera\":\n            data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_controller\":\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case \"instance_light\":\n            data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_geometry\":\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case \"instance_node\":\n            data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"translate\":\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"extra\":\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn(\n          \"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\",\n          data.id\n        );\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml2) {\n      const data = {\n        id: parseId(xml2.getAttribute(\"url\")),\n        materials: {},\n        skeletons: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"bind_material\":\n            const instances = child.getElementsByTagName(\"instance_material\");\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute(\"symbol\");\n              const target = instance.getAttribute(\"target\");\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case \"skeleton\":\n            data.skeletons.push(parseId(child.textContent));\n            break;\n          default:\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data;\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n          for (let j2 = 0; j2 < children.length; j2++) {\n            const child = children[j2];\n            if (child.type === \"JOINT\") {\n              const root2 = getNode(child.id);\n              buildBoneHierarchy(root2, joints, boneData);\n            }\n          }\n        } else {\n          console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n        }\n      }\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      }\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      }\n      const bones = [];\n      const boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      root.traverse(function(object) {\n        if (object.isBone === true) {\n          let boneInverse;\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === void 0) {\n            boneInverse = new Matrix4();\n          }\n          boneData.push({ bone: object, boneInverse, processed: false });\n        }\n      });\n    }\n    function buildNode(data) {\n      const objects = [];\n      const matrix2 = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes;\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      }\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      }\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object2 = newObjects[j];\n          if (object2.isSkinnedMesh) {\n            object2.bind(skeleton, controller.skin.bindMatrix);\n            object2.normalizeSkinWeights();\n          }\n          objects.push(object2);\n        }\n      }\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      }\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i];\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      }\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      let object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === \"JOINT\" ? new Bone() : new Group();\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      object.name = type === \"JOINT\" ? data.sid : data.name;\n      object.matrix.copy(matrix2);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    const fallbackMaterial = new MeshBasicMaterial({ color: 16711935 });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n        if (id === void 0) {\n          console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n        if (materials.length === 0) {\n          if (type === \"lines\" || type === \"linestrips\") {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        }\n        const skinning = geometry.data.attributes.skinIndex !== void 0;\n        const material = materials.length === 1 ? materials[0] : materials;\n        let object;\n        switch (type) {\n          case \"lines\":\n            object = new LineSegments(geometry.data, material);\n            break;\n          case \"linestrips\":\n            object = new Line(geometry.data, material);\n            break;\n          case \"triangles\":\n          case \"polylist\":\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== void 0;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    }\n    function parseVisualScene(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        children: []\n      };\n      prepareNodes(xml2);\n      const elements = getElementsByTagName(xml2, \"node\");\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== void 0;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    }\n    function parseScene(xml2) {\n      const instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n      return getVisualScene(parseId(instance.getAttribute(\"url\")));\n    }\n    function setupAnimations() {\n      const clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          const tracks = [];\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new AnimationClip(\"default\", -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n    function parserErrorToText(parserError2) {\n      let result = \"\";\n      const stack = [parserError2];\n      while (stack.length) {\n        const node = stack.shift();\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += \"\\n\";\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n      return result.trim();\n    }\n    if (text.length === 0) {\n      return { scene: new Scene() };\n    }\n    const xml = new DOMParser().parseFromString(text, \"application/xml\");\n    const collada = getElementsByTagName(xml, \"COLLADA\")[0];\n    const parserError = xml.getElementsByTagName(\"parsererror\")[0];\n    if (parserError !== void 0) {\n      const errorElement = getElementsByTagName(parserError, \"div\")[0];\n      let errorText;\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n      console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n      return null;\n    }\n    const version = collada.getAttribute(\"version\");\n    console.log(\"THREE.ColladaLoader: File version\", version);\n    const asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    }\n    const animations = [];\n    let kinematics = {};\n    let count = 0;\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n    parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n    parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n    parseLibrary(collada, \"library_images\", \"image\", parseImage);\n    parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n    parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n    parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n    parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n    parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n    parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n    parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n    parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n    parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n    parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n    scene.animations = animations;\n    if (asset.upAxis === \"Z_UP\") {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n        return animations;\n      },\n      kinematics,\n      library,\n      scene\n    };\n  }\n}\nexport {\n  ColladaLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}