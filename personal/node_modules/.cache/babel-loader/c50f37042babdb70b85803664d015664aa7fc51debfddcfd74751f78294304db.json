{"ast":null,"code":"import { Triangle, Vector3 } from \"three\";\nconst _face = /* @__PURE__ */new Triangle();\nconst _color = /* @__PURE__ */new Vector3();\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry;\n    if (geometry.index) {\n      console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\");\n      geometry = geometry.toNonIndexed();\n    }\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute(\"position\");\n    this.colorAttribute = this.geometry.getAttribute(\"color\");\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n    return this;\n  }\n  build() {\n    const positionAttribute = this.positionAttribute;\n    const weightAttribute = this.weightAttribute;\n    const faceWeights = new Float32Array(positionAttribute.count / 3);\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1;\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n      }\n      _face.a.fromBufferAttribute(positionAttribute, i);\n      _face.b.fromBufferAttribute(positionAttribute, i + 1);\n      _face.c.fromBufferAttribute(positionAttribute, i + 2);\n      faceWeight *= _face.getArea();\n      faceWeights[i / 3] = faceWeight;\n    }\n    this.distribution = new Float32Array(positionAttribute.count / 3);\n    let cumulativeTotal = 0;\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i];\n      this.distribution[i] = cumulativeTotal;\n    }\n    return this;\n  }\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction;\n    return this;\n  }\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex();\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n  }\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1];\n    return this.binarySearch(this.randomFunction() * cumulativeTotal);\n  }\n  binarySearch(x) {\n    const dist = this.distribution;\n    let start = 0;\n    let end = dist.length - 1;\n    let index = -1;\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2);\n      if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n        index = mid;\n        break;\n      } else if (x < dist[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    return index;\n  }\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction();\n    let v = this.randomFunction();\n    if (u + v > 1) {\n      u = 1 - u;\n      v = 1 - v;\n    }\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n    targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n    if (targetNormal !== void 0) {\n      _face.getNormal(targetNormal);\n    }\n    if (targetColor !== void 0 && this.colorAttribute !== void 0) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n      _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      targetColor.r = _color.x;\n      targetColor.g = _color.y;\n      targetColor.b = _color.z;\n    }\n    return this;\n  }\n}\nexport { MeshSurfaceSampler };","map":{"version":3,"names":["Triangle","Vector3","_face","_color","MeshSurfaceSampler","constructor","mesh","geometry","index","console","warn","toNonIndexed","randomFunction","Math","random","positionAttribute","getAttribute","colorAttribute","weightAttribute","distribution","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","faceIndex","sampleFaceIndex","sampleFace","binarySearch","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","getNormal","r","g","y","z"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/math/MeshSurfaceSampler.js"],"sourcesContent":["import { Triangle, Vector3 } from \"three\";\nconst _face = /* @__PURE__ */ new Triangle();\nconst _color = /* @__PURE__ */ new Vector3();\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry;\n    if (geometry.index) {\n      console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\");\n      geometry = geometry.toNonIndexed();\n    }\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute(\"position\");\n    this.colorAttribute = this.geometry.getAttribute(\"color\");\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n    return this;\n  }\n  build() {\n    const positionAttribute = this.positionAttribute;\n    const weightAttribute = this.weightAttribute;\n    const faceWeights = new Float32Array(positionAttribute.count / 3);\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1;\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n      }\n      _face.a.fromBufferAttribute(positionAttribute, i);\n      _face.b.fromBufferAttribute(positionAttribute, i + 1);\n      _face.c.fromBufferAttribute(positionAttribute, i + 2);\n      faceWeight *= _face.getArea();\n      faceWeights[i / 3] = faceWeight;\n    }\n    this.distribution = new Float32Array(positionAttribute.count / 3);\n    let cumulativeTotal = 0;\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i];\n      this.distribution[i] = cumulativeTotal;\n    }\n    return this;\n  }\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction;\n    return this;\n  }\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex();\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n  }\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1];\n    return this.binarySearch(this.randomFunction() * cumulativeTotal);\n  }\n  binarySearch(x) {\n    const dist = this.distribution;\n    let start = 0;\n    let end = dist.length - 1;\n    let index = -1;\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2);\n      if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n        index = mid;\n        break;\n      } else if (x < dist[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    return index;\n  }\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction();\n    let v = this.randomFunction();\n    if (u + v > 1) {\n      u = 1 - u;\n      v = 1 - v;\n    }\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n    targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n    if (targetNormal !== void 0) {\n      _face.getNormal(targetNormal);\n    }\n    if (targetColor !== void 0 && this.colorAttribute !== void 0) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n      _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      targetColor.r = _color.x;\n      targetColor.g = _color.y;\n      targetColor.b = _color.z;\n    }\n    return this;\n  }\n}\nexport {\n  MeshSurfaceSampler\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}