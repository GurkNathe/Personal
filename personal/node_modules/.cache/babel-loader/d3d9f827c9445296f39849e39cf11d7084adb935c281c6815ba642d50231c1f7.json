{"ast":null,"code":"import { Matrix4, Vector3 } from \"three\";\nconst inverseProjectionMatrix = /* @__PURE__ */new Matrix4();\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== void 0) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);\n    }\n  }\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert();\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1));\n      }\n    });\n    return this.vertices;\n  }\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n    target.length = breaks.length;\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n}\nexport { CSMFrustum };","map":{"version":3,"names":["Matrix4","Vector3","inverseProjectionMatrix","CSMFrustum","constructor","data","vertices","near","far","projectionMatrix","setFromProjectionMatrix","maxFar","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","split","breaks","target","length","push","i","cascade","j","lerpVectors","toSpace","cameraMatrix"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/csm/CSMFrustum.js"],"sourcesContent":["import { Matrix4, Vector3 } from \"three\";\nconst inverseProjectionMatrix = /* @__PURE__ */ new Matrix4();\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== void 0) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);\n    }\n  }\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert();\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(function(v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function(v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1));\n      }\n    });\n    return this.vertices;\n  }\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n    target.length = breaks.length;\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n}\nexport {\n  CSMFrustum\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}