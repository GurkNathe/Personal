{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nconst cb = /* @__PURE__ */new Vector3();\nconst ab = /* @__PURE__ */new Vector3();\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\nclass Vertex {\n  constructor(v, id) {\n    __publicField(this, \"position\");\n    __publicField(this, \"id\");\n    __publicField(this, \"faces\");\n    __publicField(this, \"neighbors\");\n    __publicField(this, \"collapseCost\");\n    __publicField(this, \"collapseNeighbor\");\n    __publicField(this, \"minCost\", 0);\n    __publicField(this, \"totalCost\", 0);\n    __publicField(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id;\n    this.faces = [];\n    this.neighbors = [];\n    this.collapseCost = 0;\n    this.collapseNeighbor = null;\n  }\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n    neighbors.splice(offset, 1);\n  }\n}\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    __publicField(this, \"a\");\n    __publicField(this, \"b\");\n    __publicField(this, \"c\");\n    __publicField(this, \"v1\");\n    __publicField(this, \"v2\");\n    __publicField(this, \"v3\");\n    __publicField(this, \"normal\", new Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n}\nclass SimplifyModifier {\n  constructor() {\n    __publicField(this, \"computeEdgeCollapseCost\", (u, v) => {\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n        il = u.faces.length,\n        face,\n        sideFace;\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      }\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j];\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n        curvature = Math.max(curvature, minCurvature);\n      }\n      const borders = 0;\n      if (sideFaces.length < 2) {\n        curvature = 1;\n      }\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n    __publicField(this, \"computeEdgeCostAtVertex\", v => {\n      if (v.neighbors.length === 0) {\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n      v.collapseCost = 1e5;\n      v.collapseNeighbor = null;\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n        v.costCount++;\n        v.totalCost += collapseCost;\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      }\n      v.collapseCost = v.totalCost / v.costCount;\n    });\n    __publicField(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f);\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    __publicField(this, \"collapse\", (vertices, faces, u, v) => {\n      if (!v) {\n        this.removeVertex(u, vertices);\n        return;\n      }\n      let i;\n      const tmpVertices = [];\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n      this.removeVertex(u, vertices);\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    __publicField(this, \"minimumCostEdge\", vertices => {\n      let least = vertices[0];\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n      return least;\n    });\n    __publicField(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes;\n      for (let name in attributes) {\n        if (name !== \"position\") geometry.deleteAttribute(name);\n      }\n      geometry = mergeVertices(geometry);\n      const vertices = [];\n      const faces = [];\n      const positionAttribute = geometry.getAttribute(\"position\");\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      }\n      const geomIndex = geometry.getIndex();\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      }\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n      let nextVertex;\n      let z = count;\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n        if (!nextVertex) {\n          console.log(\"THREE.SimplifyModifier: No next vertex\");\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      }\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = [];\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      }\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      }\n      simplifiedGeometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n    removeFromArray(vertices, v);\n  }\n}\nexport { SimplifyModifier };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Vector3","BufferGeometry","Float32BufferAttribute","mergeVertices","cb","ab","pushIfUnique","array","object","indexOf","push","removeFromArray","k","splice","Vertex","constructor","v","id","position","faces","neighbors","collapseCost","collapseNeighbor","addUniqueNeighbor","vertex","removeIfNonNeighbor","n","offset","i","length","hasVertex","Triangle","v1","v2","v3","a","b","c","computeNormal","vA","vB","vC","subVectors","cross","normalize","normal","copy","replaceVertex","oldv","newv","SimplifyModifier","u","edgelength","distanceTo","curvature","sideFaces","il","face","sideFace","minCurvature","j","dotProd","dot","Math","min","max","borders","amt","computeEdgeCollapseCost","minCost","totalCost","costCount","f","vs","vertices","removeVertex","tmpVertices","removeFace","computeEdgeCostAtVertex","least","geometry","count","clone","attributes","name","deleteAttribute","positionAttribute","getAttribute","fromBufferAttribute","geomIndex","getIndex","getX","triangle","nextVertex","z","minimumCostEdge","console","log","collapse","simplifiedGeometry","index","x","y","setAttribute","setIndex","assert","pop"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/modifiers/SimplifyModifier.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nconst cb = /* @__PURE__ */ new Vector3();\nconst ab = /* @__PURE__ */ new Vector3();\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1)\n    array.push(object);\n}\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1)\n    array.splice(k, 1);\n}\nclass Vertex {\n  constructor(v, id) {\n    __publicField(this, \"position\");\n    __publicField(this, \"id\");\n    __publicField(this, \"faces\");\n    __publicField(this, \"neighbors\");\n    __publicField(this, \"collapseCost\");\n    __publicField(this, \"collapseNeighbor\");\n    __publicField(this, \"minCost\", 0);\n    __publicField(this, \"totalCost\", 0);\n    __publicField(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id;\n    this.faces = [];\n    this.neighbors = [];\n    this.collapseCost = 0;\n    this.collapseNeighbor = null;\n  }\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1)\n      return;\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n))\n        return;\n    }\n    neighbors.splice(offset, 1);\n  }\n}\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    __publicField(this, \"a\");\n    __publicField(this, \"b\");\n    __publicField(this, \"c\");\n    __publicField(this, \"v1\");\n    __publicField(this, \"v2\");\n    __publicField(this, \"v3\");\n    __publicField(this, \"normal\", new Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1)\n      this.v1 = newv;\n    else if (oldv === this.v2)\n      this.v2 = newv;\n    else if (oldv === this.v3)\n      this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n}\nclass SimplifyModifier {\n  constructor() {\n    __publicField(this, \"computeEdgeCollapseCost\", (u, v) => {\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i, il = u.faces.length, face, sideFace;\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      }\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j];\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n        curvature = Math.max(curvature, minCurvature);\n      }\n      const borders = 0;\n      if (sideFaces.length < 2) {\n        curvature = 1;\n      }\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n    __publicField(this, \"computeEdgeCostAtVertex\", (v) => {\n      if (v.neighbors.length === 0) {\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n      v.collapseCost = 1e5;\n      v.collapseNeighbor = null;\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n        v.costCount++;\n        v.totalCost += collapseCost;\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      }\n      v.collapseCost = v.totalCost / v.costCount;\n    });\n    __publicField(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1)\n        removeFromArray(f.v1.faces, f);\n      if (f.v2)\n        removeFromArray(f.v2.faces, f);\n      if (f.v3)\n        removeFromArray(f.v3.faces, f);\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2)\n          continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    __publicField(this, \"collapse\", (vertices, faces, u, v) => {\n      if (!v) {\n        this.removeVertex(u, vertices);\n        return;\n      }\n      let i;\n      const tmpVertices = [];\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n      this.removeVertex(u, vertices);\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    __publicField(this, \"minimumCostEdge\", (vertices) => {\n      let least = vertices[0];\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n      return least;\n    });\n    __publicField(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes;\n      for (let name in attributes) {\n        if (name !== \"position\")\n          geometry.deleteAttribute(name);\n      }\n      geometry = mergeVertices(geometry);\n      const vertices = [];\n      const faces = [];\n      const positionAttribute = geometry.getAttribute(\"position\");\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      }\n      const geomIndex = geometry.getIndex();\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      }\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n      let nextVertex;\n      let z = count;\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n        if (!nextVertex) {\n          console.log(\"THREE.SimplifyModifier: No next vertex\");\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      }\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = [];\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      }\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      }\n      simplifiedGeometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n    removeFromArray(vertices, v);\n  }\n}\nexport {\n  SimplifyModifier\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}