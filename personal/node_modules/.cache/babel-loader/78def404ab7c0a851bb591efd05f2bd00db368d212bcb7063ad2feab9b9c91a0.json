{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nconst _Refractor = class extends Mesh {\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(geometry);\n    this.isRefractor = true;\n    this.type = \"Refractor\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Refractor.RefractorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const virtualCamera = this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true\n      // ensures, refractors are drawn from farthest to closest\n    });\n\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"linear-srgb\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    }\n    this.onBeforeRender = function (renderer, scene, camera) {\n      if (camera.userData.refractor === true) return;\n      if (!visible(camera) === true) return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Refractor = _Refractor;\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */\n  `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */\n  `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n});\nexport { Refractor };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Matrix4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","NoToneMapping","_Refractor","constructor","geometry","options","arguments","length","undefined","isRefractor","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","RefractorShader","multisample","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","samples","material","uniforms","clone","vertexShader","fragmentShader","transparent","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","visible2","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","updateRefractorPlane2","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","updateVirtualCamera2","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","dispose","Refractor","tDiffuse"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/objects/Refractor.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nconst _Refractor = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isRefractor = true;\n    this.type = \"Refractor\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Refractor.RefractorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const virtualCamera = this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true\n      // ensures, refractors are drawn from farthest to closest\n    });\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    const visible = function() {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    const updateRefractorPlane = function() {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    const updateVirtualCamera = function() {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer)\n        isSRGB = renderer.outputColorSpace === \"srgb\";\n      else\n        isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"linear-srgb\";\n      else\n        renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n      else\n        renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    }\n    this.onBeforeRender = function(renderer, scene, camera) {\n      if (camera.userData.refractor === true)\n        return;\n      if (!visible(camera) === true)\n        return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n    this.getRenderTarget = function() {\n      return renderTarget;\n    };\n    this.dispose = function() {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Refractor = _Refractor;\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Refractor\n};\n"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAc;AACrC,IAAIC,eAAe,GAAGA,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAID,GAAG,GAAGJ,SAAS,CAACI,GAAG,EAAEC,GAAG,EAAE;EAAEE,UAAU,EAAE,IAAI;EAAEC,YAAY,EAAE,IAAI;EAAEC,QAAQ,EAAE,IAAI;EAAEH;AAAM,CAAC,CAAC,GAAGF,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;AAC/J,IAAII,aAAa,GAAGA,CAACN,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAK;EACvCH,eAAe,CAACC,GAAG,EAAE,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAG,EAAE,GAAGA,GAAG,EAAEC,KAAK,CAAC;EACrE,OAAOA,KAAK;AACd,CAAC;AACD,SAASK,IAAI,EAAEC,iBAAiB,EAAEC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,cAAc,EAAEC,aAAa,EAAEC,OAAO,EAAEC,UAAU,EAAEC,OAAO,EAAEC,aAAa,QAAQ,OAAO;AACpL,MAAMC,UAAU,GAAG,cAAcb,IAAI,CAAC;EACpCc,WAAWA,CAACC,QAAQ,EAAgB;IAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAChC,KAAK,CAACF,QAAQ,CAAC;IACf,IAAI,CAACK,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,IAAI,GAAG,WAAW;IACvB,IAAI,CAACC,MAAM,GAAG,IAAIrB,iBAAiB,CAAC,CAAC;IACrC,MAAMsB,KAAK,GAAG,IAAI;IAClB,MAAMC,KAAK,GAAGR,OAAO,CAACQ,KAAK,KAAK,KAAK,CAAC,GAAG,IAAItB,KAAK,CAACc,OAAO,CAACQ,KAAK,CAAC,GAAG,IAAItB,KAAK,CAAC,OAAO,CAAC;IACtF,MAAMuB,YAAY,GAAGT,OAAO,CAACS,YAAY,IAAI,GAAG;IAChD,MAAMC,aAAa,GAAGV,OAAO,CAACU,aAAa,IAAI,GAAG;IAClD,MAAMC,QAAQ,GAAGX,OAAO,CAACW,QAAQ,IAAI,CAAC;IACtC,MAAMC,MAAM,GAAGZ,OAAO,CAACY,MAAM,IAAIf,UAAU,CAACgB,eAAe;IAC3D,MAAMC,WAAW,GAAGd,OAAO,CAACc,WAAW,KAAK,KAAK,CAAC,GAAGd,OAAO,CAACc,WAAW,GAAG,CAAC;IAC5E,MAAMC,aAAa,GAAG,IAAI,CAACT,MAAM;IACjCS,aAAa,CAACC,gBAAgB,GAAG,KAAK;IACtCD,aAAa,CAACE,QAAQ,CAACC,SAAS,GAAG,IAAI;IACvC,MAAMC,cAAc,GAAG,IAAIhC,KAAK,CAAC,CAAC;IAClC,MAAMiC,aAAa,GAAG,IAAIhC,OAAO,CAAC,CAAC;IACnC,MAAMiC,YAAY,GAAG,IAAIhC,iBAAiB,CAACoB,YAAY,EAAEC,aAAa,EAAE;MACtEY,OAAO,EAAER,WAAW;MACpBT,IAAI,EAAEf;IACR,CAAC,CAAC;IACF,IAAI,CAACiC,QAAQ,GAAG,IAAIhC,cAAc,CAAC;MACjCiC,QAAQ,EAAEhC,aAAa,CAACiC,KAAK,CAACb,MAAM,CAACY,QAAQ,CAAC;MAC9CE,YAAY,EAAEd,MAAM,CAACc,YAAY;MACjCC,cAAc,EAAEf,MAAM,CAACe,cAAc;MACrCC,WAAW,EAAE;MACb;IACF,CAAC,CAAC;;IACF,IAAI,CAACL,QAAQ,CAACC,QAAQ,CAAC,OAAO,CAAC,CAAC7C,KAAK,GAAG6B,KAAK;IAC7C,IAAI,CAACe,QAAQ,CAACC,QAAQ,CAAC,UAAU,CAAC,CAAC7C,KAAK,GAAG0C,YAAY,CAACQ,OAAO;IAC/D,IAAI,CAACN,QAAQ,CAACC,QAAQ,CAAC,eAAe,CAAC,CAAC7C,KAAK,GAAGyC,aAAa;IAC7D,MAAMU,OAAO,GAAG,YAAW;MACzB,MAAMC,sBAAsB,GAAG,IAAItC,OAAO,CAAC,CAAC;MAC5C,MAAMuC,mBAAmB,GAAG,IAAIvC,OAAO,CAAC,CAAC;MACzC,MAAMwC,cAAc,GAAG,IAAI7C,OAAO,CAAC,CAAC;MACpC,MAAM8C,IAAI,GAAG,IAAIzC,OAAO,CAAC,CAAC;MAC1B,MAAM0C,MAAM,GAAG,IAAI1C,OAAO,CAAC,CAAC;MAC5B,OAAO,SAAS2C,QAAQA,CAAC9B,MAAM,EAAE;QAC/ByB,sBAAsB,CAACM,qBAAqB,CAAC9B,KAAK,CAAC+B,WAAW,CAAC;QAC/DN,mBAAmB,CAACK,qBAAqB,CAAC/B,MAAM,CAACgC,WAAW,CAAC;QAC7DJ,IAAI,CAACK,UAAU,CAACR,sBAAsB,EAAEC,mBAAmB,CAAC;QAC5DC,cAAc,CAACO,eAAe,CAACjC,KAAK,CAAC+B,WAAW,CAAC;QACjDH,MAAM,CAACM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACnBN,MAAM,CAACO,YAAY,CAACT,cAAc,CAAC;QACnC,OAAOC,IAAI,CAACS,GAAG,CAACR,MAAM,CAAC,GAAG,CAAC;MAC7B,CAAC;IACH,CAAC,CAAC,CAAC;IACH,MAAMS,oBAAoB,GAAG,YAAW;MACtC,MAAMT,MAAM,GAAG,IAAI1C,OAAO,CAAC,CAAC;MAC5B,MAAMoD,QAAQ,GAAG,IAAIpD,OAAO,CAAC,CAAC;MAC9B,MAAMqD,UAAU,GAAG,IAAIpD,UAAU,CAAC,CAAC;MACnC,MAAMqD,KAAK,GAAG,IAAItD,OAAO,CAAC,CAAC;MAC3B,OAAO,SAASuD,qBAAqBA,CAAA,EAAG;QACtCzC,KAAK,CAAC+B,WAAW,CAACW,SAAS,CAACJ,QAAQ,EAAEC,UAAU,EAAEC,KAAK,CAAC;QACxDZ,MAAM,CAACM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACS,eAAe,CAACJ,UAAU,CAAC,CAACK,SAAS,CAAC,CAAC;QAC3DhB,MAAM,CAACiB,MAAM,CAAC,CAAC;QACfjC,cAAc,CAACkC,6BAA6B,CAAClB,MAAM,EAAEU,QAAQ,CAAC;MAChE,CAAC;IACH,CAAC,CAAC,CAAC;IACH,MAAMS,mBAAmB,GAAG,YAAW;MACrC,MAAMC,SAAS,GAAG,IAAIpE,KAAK,CAAC,CAAC;MAC7B,MAAMqE,UAAU,GAAG,IAAI7D,OAAO,CAAC,CAAC;MAChC,MAAM8D,CAAC,GAAG,IAAI9D,OAAO,CAAC,CAAC;MACvB,OAAO,SAAS+D,oBAAoBA,CAACpD,MAAM,EAAE;QAC3CS,aAAa,CAACuB,WAAW,CAACqB,IAAI,CAACrD,MAAM,CAACgC,WAAW,CAAC;QAClDvB,aAAa,CAAC6C,kBAAkB,CAACD,IAAI,CAAC5C,aAAa,CAACuB,WAAW,CAAC,CAACuB,MAAM,CAAC,CAAC;QACzE9C,aAAa,CAAC+C,gBAAgB,CAACH,IAAI,CAACrD,MAAM,CAACwD,gBAAgB,CAAC;QAC5D/C,aAAa,CAACgD,GAAG,GAAGzD,MAAM,CAACyD,GAAG;QAC9BR,SAAS,CAACI,IAAI,CAACxC,cAAc,CAAC;QAC9BoC,SAAS,CAACb,YAAY,CAAC3B,aAAa,CAAC6C,kBAAkB,CAAC;QACxDJ,UAAU,CAACf,GAAG,CAACc,SAAS,CAACpB,MAAM,CAAC6B,CAAC,EAAET,SAAS,CAACpB,MAAM,CAAC8B,CAAC,EAAEV,SAAS,CAACpB,MAAM,CAAC+B,CAAC,EAAEX,SAAS,CAACY,QAAQ,CAAC;QAC9F,MAAML,gBAAgB,GAAG/C,aAAa,CAAC+C,gBAAgB;QACvDL,CAAC,CAACO,CAAC,GAAG,CAACI,IAAI,CAACC,IAAI,CAACb,UAAU,CAACQ,CAAC,CAAC,GAAGF,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC;QAC7Fb,CAAC,CAACQ,CAAC,GAAG,CAACG,IAAI,CAACC,IAAI,CAACb,UAAU,CAACS,CAAC,CAAC,GAAGH,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC;QAC7Fb,CAAC,CAACS,CAAC,GAAG,CAAC,CAAC;QACRT,CAAC,CAACc,CAAC,GAAG,CAAC,CAAC,GAAGT,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC;QACzEd,UAAU,CAACgB,cAAc,CAAC,CAAC,GAAGhB,UAAU,CAACb,GAAG,CAACc,CAAC,CAAC,CAAC;QAChDK,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,GAAGd,UAAU,CAACQ,CAAC;QAC3CF,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,GAAGd,UAAU,CAACS,CAAC;QAC3CH,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,GAAGd,UAAU,CAACU,CAAC,GAAG,CAAC,GAAGvD,QAAQ;QAC3DmD,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,GAAGd,UAAU,CAACe,CAAC;MAC9C,CAAC;IACH,CAAC,CAAC,CAAC;IACH,SAASE,mBAAmBA,CAACnE,MAAM,EAAE;MACnCc,aAAa,CAACqB,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC7ErB,aAAa,CAACsD,QAAQ,CAACpE,MAAM,CAACwD,gBAAgB,CAAC;MAC/C1C,aAAa,CAACsD,QAAQ,CAACpE,MAAM,CAACsD,kBAAkB,CAAC;MACjDxC,aAAa,CAACsD,QAAQ,CAACnE,KAAK,CAAC+B,WAAW,CAAC;IAC3C;IACA,SAASqC,MAAMA,CAACC,QAAQ,EAAEC,KAAK,EAAEvE,MAAM,EAAE;MACvCC,KAAK,CAACuB,OAAO,GAAG,KAAK;MACrB,MAAMgD,mBAAmB,GAAGF,QAAQ,CAACG,eAAe,CAAC,CAAC;MACtD,MAAMC,gBAAgB,GAAGJ,QAAQ,CAACK,EAAE,CAACC,OAAO;MAC5C,MAAMC,uBAAuB,GAAGP,QAAQ,CAACQ,SAAS,CAACC,UAAU;MAC7D,MAAMC,kBAAkB,GAAGV,QAAQ,CAACW,WAAW;MAC/C,IAAIC,MAAM,GAAG,KAAK;MAClB,IAAI,kBAAkB,IAAIZ,QAAQ,EAChCY,MAAM,GAAGZ,QAAQ,CAACa,gBAAgB,KAAK,MAAM,CAAC,KAE9CD,MAAM,GAAGZ,QAAQ,CAACc,cAAc,KAAK,IAAI;MAC3Cd,QAAQ,CAACK,EAAE,CAACC,OAAO,GAAG,KAAK;MAC3BN,QAAQ,CAACQ,SAAS,CAACC,UAAU,GAAG,KAAK;MACrC,IAAI,kBAAkB,IAAIT,QAAQ,EAChCA,QAAQ,CAACa,gBAAgB,GAAG,aAAa,CAAC,KAE1Cb,QAAQ,CAACc,cAAc,GAAG,GAAG;MAC/Bd,QAAQ,CAACW,WAAW,GAAG3F,aAAa;MACpCgF,QAAQ,CAACe,eAAe,CAACtE,YAAY,CAAC;MACtC,IAAIuD,QAAQ,CAACgB,SAAS,KAAK,KAAK,EAC9BhB,QAAQ,CAACiB,KAAK,CAAC,CAAC;MAClBjB,QAAQ,CAACD,MAAM,CAACE,KAAK,EAAE9D,aAAa,CAAC;MACrC6D,QAAQ,CAACK,EAAE,CAACC,OAAO,GAAGF,gBAAgB;MACtCJ,QAAQ,CAACQ,SAAS,CAACC,UAAU,GAAGF,uBAAuB;MACvDP,QAAQ,CAACW,WAAW,GAAGD,kBAAkB;MACzCV,QAAQ,CAACe,eAAe,CAACb,mBAAmB,CAAC;MAC7C,IAAI,kBAAkB,IAAIF,QAAQ,EAChCA,QAAQ,CAACa,gBAAgB,GAAGD,MAAM,GAAG,MAAM,GAAG,aAAa,CAAC,KAE5DZ,QAAQ,CAACc,cAAc,GAAGF,MAAM,GAAG,IAAI,GAAG,GAAG;MAC/C,MAAMM,QAAQ,GAAGxF,MAAM,CAACwF,QAAQ;MAChC,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvBlB,QAAQ,CAACmB,KAAK,CAACD,QAAQ,CAACA,QAAQ,CAAC;MACnC;MACAvF,KAAK,CAACuB,OAAO,GAAG,IAAI;IACtB;IACA,IAAI,CAACkE,cAAc,GAAG,UAASpB,QAAQ,EAAEC,KAAK,EAAEvE,MAAM,EAAE;MACtD,IAAIA,MAAM,CAACW,QAAQ,CAACC,SAAS,KAAK,IAAI,EACpC;MACF,IAAI,CAACY,OAAO,CAACxB,MAAM,CAAC,KAAK,IAAI,EAC3B;MACFsC,oBAAoB,CAAC,CAAC;MACtB6B,mBAAmB,CAACnE,MAAM,CAAC;MAC3BgD,mBAAmB,CAAChD,MAAM,CAAC;MAC3BqE,MAAM,CAACC,QAAQ,EAAEC,KAAK,EAAEvE,MAAM,CAAC;IACjC,CAAC;IACD,IAAI,CAACyE,eAAe,GAAG,YAAW;MAChC,OAAO1D,YAAY;IACrB,CAAC;IACD,IAAI,CAAC4E,OAAO,GAAG,YAAW;MACxB5E,YAAY,CAAC4E,OAAO,CAAC,CAAC;MACtB1F,KAAK,CAACgB,QAAQ,CAAC0E,OAAO,CAAC,CAAC;IAC1B,CAAC;EACH;AACF,CAAC;AACD,IAAIC,SAAS,GAAGrG,UAAU;AAC1Bd,aAAa,CAACmH,SAAS,EAAE,iBAAiB,EAAE;EAC1C1E,QAAQ,EAAE;IACRhB,KAAK,EAAE;MACL7B,KAAK,EAAE;IACT,CAAC;IACDwH,QAAQ,EAAE;MACRxH,KAAK,EAAE;IACT,CAAC;IACDyC,aAAa,EAAE;MACbzC,KAAK,EAAE;IACT;EACF,CAAC;EACD+C,YAAY,EACV;EACC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IACG;EACDC,cAAc,EACZ;EACC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC,CAAC;AACF,SACEuE,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}