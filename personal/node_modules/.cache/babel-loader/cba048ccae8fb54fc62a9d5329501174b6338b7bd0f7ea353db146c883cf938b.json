{"ast":null,"code":"const baseId = Date.now().toString().slice(5);\nlet lastId = 0;\nconst k = 1024;\nconst nano = BigInt(1e3);\nconst milli = BigInt(1e6);\nconst second = BigInt(1e9);\nexport const isServer = typeof window === 'undefined';\n/**\n * This value can be increased up to 100_000\n * But i don't know if this value change from nodejs to nodejs\n * So I will keep a safer value here.\n */\nexport const MAX_ARGUMENT_FOR_STACK = 65535;\n/**\n * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301\n * that issue is caused because the array that is pushed is huge (>100k)\n *\n * @example\n * ```ts\n * safeArrayPush(myArray, [1, 2])\n * ```\n */\nexport function safeArrayPush(arr, newArr) {\n  if (newArr.length < MAX_ARGUMENT_FOR_STACK) {\n    Array.prototype.push.apply(arr, newArr);\n  } else {\n    for (let i = 0; i < newArr.length; i += MAX_ARGUMENT_FOR_STACK) {\n      Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));\n    }\n  }\n}\nexport function sprintf(template) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return template.replace(/%(?:(?<position>\\d+)\\$)?(?<width>-?\\d*\\.?\\d*)(?<type>[dfs])/g, function () {\n    var _ref;\n    const groups = (_ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);\n    const {\n      width: rawWidth,\n      type,\n      position\n    } = groups;\n    const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();\n    const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth);\n    switch (type) {\n      case 'd':\n        return replacement.toString().padStart(width, '0');\n      case 'f':\n        {\n          let value = replacement;\n          const [padding, precision] = rawWidth.split('.').map(w => Number.parseFloat(w));\n          if (typeof precision === 'number' && precision >= 0) {\n            value = value.toFixed(precision);\n          }\n          return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString();\n        }\n      case 's':\n        return width < 0 ? replacement.toString().padEnd(-width, ' ') : replacement.toString().padStart(width, ' ');\n      default:\n        return replacement;\n    }\n  });\n}\nexport async function formatBytes(bytes) {\n  let decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  if (bytes === 0) {\n    return '0 Bytes';\n  }\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return \"\".concat(parseFloat((bytes / Math.pow(k, i)).toFixed(dm)), \" \").concat(sizes[i]);\n}\nexport async function formatNanoseconds(value) {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n  if (value < nano) {\n    return \"\".concat(value, \"ns\");\n  } else if (value < milli) {\n    return \"\".concat(value / nano, \"\\u03BCs\");\n  } else if (value < second) {\n    return \"\".concat(value / milli, \"ms\");\n  }\n  return \"\".concat(value / second, \"s\");\n}\nexport async function getNanosecondsTime() {\n  if (typeof process !== 'undefined' && process.hrtime !== undefined) {\n    return process.hrtime.bigint();\n  }\n  if (typeof performance !== 'undefined') {\n    return BigInt(Math.floor(performance.now() * 1e6));\n  }\n  // @todo: fallback to V8 native method to get microtime\n  return BigInt(0);\n}\nexport async function uniqueId() {\n  return \"\".concat(baseId, \"-\").concat(lastId++);\n}\nexport function getOwnProperty(object, property) {\n  // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n  if (Object.hasOwn === undefined) {\n    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\n  }\n  return Object.hasOwn(object, property) ? object[property] : undefined;\n}\nexport function getTokenFrequency(token, tokens) {\n  let count = 0;\n  for (const t of tokens) {\n    if (t === token) {\n      count++;\n    }\n  }\n  return count;\n}\nexport function insertSortedValue(arr, el) {\n  let compareFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sortTokenScorePredicate;\n  let low = 0;\n  let high = arr.length;\n  let mid;\n  while (low < high) {\n    mid = low + high >>> 1;\n    if (compareFn(el, arr[mid]) < 0) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  arr.splice(low, 0, el);\n  return arr;\n}\nexport function sortTokenScorePredicate(a, b) {\n  if (b[1] === a[1]) {\n    return a[0] - b[0];\n  }\n  return b[1] - a[1];\n}\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect(arrays) {\n  if (arrays.length === 0) {\n    return [];\n  } else if (arrays.length === 1) {\n    return arrays[0];\n  }\n  for (let i = 1; i < arrays.length; i++) {\n    if (arrays[i].length < arrays[0].length) {\n      const tmp = arrays[0];\n      arrays[0] = arrays[i];\n      arrays[i] = tmp;\n    }\n  }\n  const set = new Map();\n  for (const elem of arrays[0]) {\n    set.set(elem, 1);\n  }\n  for (let i = 1; i < arrays.length; i++) {\n    let found = 0;\n    for (const elem of arrays[i]) {\n      const count = set.get(elem);\n      if (count === i) {\n        set.set(elem, count + 1);\n        found++;\n      }\n    }\n    if (found === 0) return [];\n  }\n  return arrays[0].filter(e => {\n    const count = set.get(e);\n    if (count !== undefined) set.set(e, 0);\n    return count === arrays.length;\n  });\n}\nexport async function getDocumentProperties(doc, paths) {\n  const properties = {};\n  const pathsLength = paths.length;\n  for (let i = 0; i < pathsLength; i++) {\n    const path = paths[i];\n    const pathTokens = path.split('.');\n    let current = doc;\n    const pathTokensLength = pathTokens.length;\n    for (let j = 0; j < pathTokensLength; j++) {\n      current = current[pathTokens[j]];\n      // We found an object but we were supposed to be done\n      if (typeof current === 'object' && !Array.isArray(current) && current !== null && j === pathTokensLength - 1) {\n        current = undefined;\n        break;\n      } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {\n        // We can't recurse anymore but we were supposed to\n        current = undefined;\n        break;\n      }\n    }\n    if (typeof current !== 'undefined') {\n      properties[path] = current;\n    }\n  }\n  return properties;\n}\nexport async function getNested(obj, path) {\n  const props = await getDocumentProperties(obj, [path]);\n  return props[path];\n}\nexport function flattenObject(obj) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  const result = {};\n  for (const key in obj) {\n    const prop = \"\".concat(prefix).concat(key);\n    const objKey = obj[key];\n    if (typeof objKey === 'object' && objKey !== null) {\n      Object.assign(result, flattenObject(objKey, \"\".concat(prop, \".\")));\n    } else {\n      result[prop] = objKey;\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["baseId","Date","now","toString","slice","lastId","k","nano","BigInt","milli","second","isServer","window","MAX_ARGUMENT_FOR_STACK","safeArrayPush","arr","newArr","length","Array","prototype","push","apply","i","sprintf","template","_len","arguments","args","_key","replace","_ref","groups","undefined","width","rawWidth","type","position","replacement","Number","parseInt","shift","padStart","value","padding","precision","split","map","w","parseFloat","toFixed","padEnd","formatBytes","bytes","decimals","dm","sizes","Math","floor","log","concat","pow","formatNanoseconds","getNanosecondsTime","process","hrtime","bigint","performance","uniqueId","getOwnProperty","object","property","Object","hasOwn","hasOwnProperty","call","getTokenFrequency","token","tokens","count","t","insertSortedValue","el","compareFn","sortTokenScorePredicate","low","high","mid","splice","a","b","intersect","arrays","tmp","set","Map","elem","found","get","filter","e","getDocumentProperties","doc","paths","properties","pathsLength","path","pathTokens","current","pathTokensLength","j","isArray","getNested","obj","props","flattenObject","prefix","result","key","prop","objKey","assign"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/utils.ts"],"sourcesContent":["import type { AnyDocument, SearchableValue, TokenScore } from './types.js'\n\nconst baseId = Date.now().toString().slice(5)\nlet lastId = 0\n\nconst k = 1024\nconst nano = BigInt(1e3)\nconst milli = BigInt(1e6)\nconst second = BigInt(1e9)\n\nexport const isServer = typeof window === 'undefined'\n\n/**\n * This value can be increased up to 100_000\n * But i don't know if this value change from nodejs to nodejs\n * So I will keep a safer value here.\n */\nexport const MAX_ARGUMENT_FOR_STACK = 65535;\n\n/**\n * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301\n * that issue is caused because the array that is pushed is huge (>100k)\n *\n * @example\n * ```ts\n * safeArrayPush(myArray, [1, 2])\n * ```\n */\nexport function safeArrayPush<T>(arr: T[], newArr: T[]): void {\n  if (newArr.length < MAX_ARGUMENT_FOR_STACK) {\n    Array.prototype.push.apply(arr, newArr)\n  } else {\n    for (let i = 0; i < newArr.length; i += MAX_ARGUMENT_FOR_STACK) {\n      Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK))\n    }\n  }\n}\n\nexport function sprintf(template: string, ...args: (string | number)[]): string {\n  return template.replace(\n    /%(?:(?<position>\\d+)\\$)?(?<width>-?\\d*\\.?\\d*)(?<type>[dfs])/g,\n    function (...replaceArgs: Array<string | number | Record<string, string>>): string {\n      const groups = replaceArgs[replaceArgs.length - 1] as Record<string, string>\n      const { width: rawWidth, type, position } = groups\n\n      const replacement = position ? args[Number.parseInt(position) - 1]! : args.shift()!\n      const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth)\n\n      switch (type) {\n        case 'd':\n          return replacement.toString().padStart(width, '0')\n        case 'f': {\n          let value = replacement\n          const [padding, precision] = rawWidth.split('.').map(w => Number.parseFloat(w))\n\n          if (typeof precision === 'number' && precision >= 0) {\n            value = (value as number).toFixed(precision)\n          }\n\n          return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString()\n        }\n        case 's':\n          return width < 0\n            ? (replacement as string).toString().padEnd(-width, ' ')\n            : (replacement as string).toString().padStart(width, ' ')\n\n        default:\n          return replacement as string\n      }\n    },\n  )\n}\n\nexport async function formatBytes(bytes: number, decimals = 2): Promise<string> {\n  if (bytes === 0) {\n    return '0 Bytes'\n  }\n  const dm = decimals < 0 ? 0 : decimals\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`\n}\n\nexport async function formatNanoseconds(value: number | bigint): Promise<string> {\n  if (typeof value === 'number') {\n    value = BigInt(value)\n  }\n\n  if (value < nano) {\n    return `${value}ns`\n  } else if (value < milli) {\n    return `${value / nano}μs`\n  } else if (value < second) {\n    return `${value / milli}ms`\n  }\n\n  return `${value / second}s`\n}\n\nexport async function getNanosecondsTime(): Promise<bigint> {\n  if (typeof process !== 'undefined' && process.hrtime !== undefined) {\n    return process.hrtime.bigint()\n  }\n\n  if (typeof performance !== 'undefined') {\n    return BigInt(Math.floor(performance.now() * 1e6))\n  }\n\n  // @todo: fallback to V8 native method to get microtime\n  return BigInt(0)\n}\n\nexport async function uniqueId(): Promise<string> {\n  return `${baseId}-${lastId++}`\n}\n\nexport function getOwnProperty<T = unknown>(object: Record<string, T>, property: string): T | undefined {\n  // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n  if (Object.hasOwn === undefined) {\n    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined\n  }\n\n  return Object.hasOwn(object, property) ? object[property] : undefined\n}\n\nexport function getTokenFrequency(token: string, tokens: string[]): number {\n  let count = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      count++\n    }\n  }\n\n  return count\n}\n\nexport function insertSortedValue(\n  arr: TokenScore[],\n  el: TokenScore,\n  compareFn = sortTokenScorePredicate,\n): TokenScore[] {\n  let low = 0\n  let high = arr.length\n  let mid\n\n  while (low < high) {\n    mid = (low + high) >>> 1\n    if (compareFn(el, arr[mid]) < 0) {\n      high = mid\n    } else {\n      low = mid + 1\n    }\n  }\n\n  arr.splice(low, 0, el)\n\n  return arr\n}\n\nexport function sortTokenScorePredicate(a: TokenScore, b: TokenScore): number {\n  if (b[1] === a[1]) {\n    return a[0] - b[0]\n  }\n\n  return b[1] - a[1]\n}\n\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect<T>(arrays: ReadonlyArray<T>[]): T[] {\n  if (arrays.length === 0) {\n    return []\n  } else if (arrays.length === 1) {\n    return arrays[0] as T[]\n  }\n\n  for (let i = 1; i < arrays.length; i++) {\n    if (arrays[i].length < arrays[0].length) {\n      const tmp = arrays[0]\n      arrays[0] = arrays[i]\n      arrays[i] = tmp\n    }\n  }\n\n  const set = new Map()\n  for (const elem of arrays[0]) {\n    set.set(elem, 1)\n  }\n  for (let i = 1; i < arrays.length; i++) {\n    let found = 0\n    for (const elem of arrays[i]) {\n      const count = set.get(elem)\n      if (count === i) {\n        set.set(elem, count + 1)\n        found++\n      }\n    }\n    if (found === 0) return []\n  }\n\n  return arrays[0].filter(e => {\n    const count = set.get(e)\n    if (count !== undefined) set.set(e, 0)\n    return count === arrays.length\n  })\n}\n\nexport async function getDocumentProperties(doc: AnyDocument, paths: string[]): Promise<Record<string, SearchableValue>> {\n  const properties: Record<string, SearchableValue> = {}\n\n  const pathsLength = paths.length\n  for (let i = 0; i < pathsLength; i++) {\n    const path = paths[i]\n    const pathTokens = path.split('.')\n\n    let current: SearchableValue | AnyDocument | undefined = doc\n    const pathTokensLength = pathTokens.length\n    for (let j = 0; j < pathTokensLength; j++) {\n      current = (current as AnyDocument)[pathTokens[j]!] as AnyDocument | SearchableValue\n\n      // We found an object but we were supposed to be done\n      if (typeof current === 'object' && !Array.isArray(current) && current !== null && j === pathTokensLength - 1) {\n        current = undefined\n        break\n      } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {\n        // We can't recurse anymore but we were supposed to\n        current = undefined\n        break\n      }\n    }\n\n    if (typeof current !== 'undefined') {\n      properties[path] = current as SearchableValue\n    }\n  }\n\n  return properties\n}\n\nexport async function getNested<T = SearchableValue>(obj: object, path: string): Promise<T | undefined> {\n  const props = await getDocumentProperties(obj as AnyDocument, [path])\n\n  return props[path] as T | undefined\n}\n\nexport function flattenObject(obj: object, prefix = ''): AnyDocument {\n  const result: AnyDocument = {}\n\n  for (const key in obj) {\n    const prop = `${prefix}${key}`\n    const objKey = (obj as AnyDocument)[key]\n\n    if (typeof objKey === 'object' && objKey !== null) {\n      Object.assign(result, flattenObject(objKey, `${prop}.`))\n    } else {\n      result[prop] = objKey\n    }\n  }\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}