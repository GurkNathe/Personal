{"ast":null,"code":"import { Loader, FileLoader, LineBasicMaterial, BufferGeometry, Float32BufferAttribute, LineSegments, Group, Euler } from \"three\";\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.splitLayer = false;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    let state = {\n      x: 0,\n      y: 0,\n      z: 0,\n      e: 0,\n      f: 0,\n      extruding: false,\n      relative: false\n    };\n    let layers = [];\n    let currentLayer = void 0;\n    const pathMaterial = new LineBasicMaterial({\n      color: 16711680\n    });\n    pathMaterial.name = \"path\";\n    const extrudingMaterial = new LineBasicMaterial({\n      color: 65280\n    });\n    extrudingMaterial.name = \"extruded\";\n    function newLayer(line) {\n      currentLayer = {\n        vertex: [],\n        pathVertex: [],\n        z: line.z\n      };\n      layers.push(currentLayer);\n    }\n    function addSegment(p1, p2) {\n      if (currentLayer === void 0) {\n        newLayer(p1);\n      }\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z);\n        currentLayer.vertex.push(p2.x, p2.y, p2.z);\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n      }\n    }\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1;\n    }\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2;\n    }\n    let lines = data.replace(/;.+/g, \"\").split(\"\\n\");\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(\" \");\n      let cmd = tokens[0].toUpperCase();\n      let args = {};\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== void 0) {\n          let key = token[0].toLowerCase();\n          let value = parseFloat(token.substring(1));\n          args[key] = value;\n        }\n      });\n      if (cmd === \"G0\" || cmd === \"G1\") {\n        let line = {\n          x: args.x !== void 0 ? absolute(state.x, args.x) : state.x,\n          y: args.y !== void 0 ? absolute(state.y, args.y) : state.y,\n          z: args.z !== void 0 ? absolute(state.z, args.z) : state.z,\n          e: args.e !== void 0 ? absolute(state.e, args.e) : state.e,\n          f: args.f !== void 0 ? absolute(state.f, args.f) : state.f\n        };\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0;\n          if (currentLayer == void 0 || line.z != currentLayer.z) {\n            newLayer(line);\n          }\n        }\n        addSegment(state, line);\n        state = line;\n      } else if (cmd === \"G2\" || cmd === \"G3\") {} else if (cmd === \"G90\") {\n        state.relative = false;\n      } else if (cmd === \"G91\") {\n        state.relative = true;\n      } else if (cmd === \"G92\") {\n        let line = state;\n        line.x = args.x !== void 0 ? args.x : line.x;\n        line.y = args.y !== void 0 ? args.y : line.y;\n        line.z = args.z !== void 0 ? args.z : line.z;\n        line.e = args.e !== void 0 ? args.e : line.e;\n        state = line;\n      } else {}\n    }\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertex, 3));\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n      segments.name = \"layer\" + i;\n      object.add(segments);\n    }\n    const object = new Group();\n    object.name = \"gcode\";\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        addObject(layer.vertex, true, i);\n        addObject(layer.pathVertex, false, i);\n      }\n    } else {\n      const vertex = [],\n        pathVertex = [];\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        let layerVertex = layer.vertex;\n        let layerPathVertex = layer.pathVertex;\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j]);\n        }\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j]);\n        }\n      }\n      addObject(vertex, true, layers.length);\n      addObject(pathVertex, false, layers.length);\n    }\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    return object;\n  }\n}\nexport { GCodeLoader };","map":{"version":3,"names":["Loader","FileLoader","LineBasicMaterial","BufferGeometry","Float32BufferAttribute","LineSegments","Group","Euler","GCodeLoader","constructor","manager","splitLayer","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","state","x","y","z","f","extruding","relative","layers","currentLayer","pathMaterial","color","name","extrudingMaterial","newLayer","line","vertex","pathVertex","push","addSegment","p1","p2","delta","v1","v2","absolute","lines","replace","split","i","length","tokens","cmd","toUpperCase","args","splice","forEach","token","key","toLowerCase","value","parseFloat","substring","addObject","geometry","setAttribute","segments","object","add","layer","layerVertex","layerPathVertex","j","quaternion","setFromEuler","Math","PI"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/GCodeLoader.js"],"sourcesContent":["import { Loader, FileLoader, LineBasicMaterial, BufferGeometry, Float32BufferAttribute, LineSegments, Group, Euler } from \"three\";\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.splitLayer = false;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data) {\n    let state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };\n    let layers = [];\n    let currentLayer = void 0;\n    const pathMaterial = new LineBasicMaterial({ color: 16711680 });\n    pathMaterial.name = \"path\";\n    const extrudingMaterial = new LineBasicMaterial({ color: 65280 });\n    extrudingMaterial.name = \"extruded\";\n    function newLayer(line) {\n      currentLayer = { vertex: [], pathVertex: [], z: line.z };\n      layers.push(currentLayer);\n    }\n    function addSegment(p1, p2) {\n      if (currentLayer === void 0) {\n        newLayer(p1);\n      }\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z);\n        currentLayer.vertex.push(p2.x, p2.y, p2.z);\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n      }\n    }\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1;\n    }\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2;\n    }\n    let lines = data.replace(/;.+/g, \"\").split(\"\\n\");\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(\" \");\n      let cmd = tokens[0].toUpperCase();\n      let args = {};\n      tokens.splice(1).forEach(function(token) {\n        if (token[0] !== void 0) {\n          let key = token[0].toLowerCase();\n          let value = parseFloat(token.substring(1));\n          args[key] = value;\n        }\n      });\n      if (cmd === \"G0\" || cmd === \"G1\") {\n        let line = {\n          x: args.x !== void 0 ? absolute(state.x, args.x) : state.x,\n          y: args.y !== void 0 ? absolute(state.y, args.y) : state.y,\n          z: args.z !== void 0 ? absolute(state.z, args.z) : state.z,\n          e: args.e !== void 0 ? absolute(state.e, args.e) : state.e,\n          f: args.f !== void 0 ? absolute(state.f, args.f) : state.f\n        };\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0;\n          if (currentLayer == void 0 || line.z != currentLayer.z) {\n            newLayer(line);\n          }\n        }\n        addSegment(state, line);\n        state = line;\n      } else if (cmd === \"G2\" || cmd === \"G3\") {\n      } else if (cmd === \"G90\") {\n        state.relative = false;\n      } else if (cmd === \"G91\") {\n        state.relative = true;\n      } else if (cmd === \"G92\") {\n        let line = state;\n        line.x = args.x !== void 0 ? args.x : line.x;\n        line.y = args.y !== void 0 ? args.y : line.y;\n        line.z = args.z !== void 0 ? args.z : line.z;\n        line.e = args.e !== void 0 ? args.e : line.e;\n        state = line;\n      } else {\n      }\n    }\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertex, 3));\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n      segments.name = \"layer\" + i;\n      object.add(segments);\n    }\n    const object = new Group();\n    object.name = \"gcode\";\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        addObject(layer.vertex, true, i);\n        addObject(layer.pathVertex, false, i);\n      }\n    } else {\n      const vertex = [], pathVertex = [];\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        let layerVertex = layer.vertex;\n        let layerPathVertex = layer.pathVertex;\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j]);\n        }\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j]);\n        }\n      }\n      addObject(vertex, true, layers.length);\n      addObject(pathVertex, false, layers.length);\n    }\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    return object;\n  }\n}\nexport {\n  GCodeLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}