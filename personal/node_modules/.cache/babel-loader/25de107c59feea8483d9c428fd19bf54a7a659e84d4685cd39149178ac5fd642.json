{"ast":null,"code":"import { createError } from '../errors.js';\nimport { create as avlCreate, find as avlFind, greaterThan as avlGreaterThan, insert as avlInsert, lessThan as avlLessThan, rangeSearch as avlRangeSearch, removeDocument as avlRemoveDocument } from '../trees/avl.js';\nimport { create as flatCreate, filter as flatFilter, filterArr as flatFilterArr, insert as flatInsert, removeDocument as flatRemoveDocument } from '../trees/flat.js';\nimport { create as radixCreate, find as radixFind, insert as radixInsert, removeDocumentByWord as radixRemoveDocument } from '../trees/radix.js';\nimport { intersect, safeArrayPush } from '../utils.js';\nimport { BM25 } from './algorithms.js';\nimport { getMagnitude } from './cosine-similarity.js';\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js';\nimport { getInternalDocumentId } from './internal-document-id-store.js';\nexport async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;\n  index.fieldLengths[prop][internalId] = tokens.length;\n  index.frequencies[prop][internalId] = {};\n}\nexport async function insertTokenScoreParameters(index, prop, id, tokens, token) {\n  let tokenFrequency = 0;\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++;\n    }\n  }\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  const tf = tokenFrequency / tokens.length;\n  index.frequencies[prop][internalId][token] = tf;\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0;\n  }\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;\n}\nexport async function removeDocumentScoreParameters(index, prop, id, docsCount) {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);\n  index.fieldLengths[prop][internalId] = undefined;\n  index.frequencies[prop][internalId] = undefined;\n}\nexport async function removeTokenScoreParameters(index, prop, token) {\n  index.tokenOccurrences[prop][token]--;\n}\nexport async function calculateResultScores(context, index, prop, term, ids) {\n  const documentIDs = Array.from(ids);\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop];\n  const fieldLengths = index.fieldLengths[prop];\n  const oramaOccurrences = index.tokenOccurrences[prop];\n  const oramaFrequencies = index.frequencies[prop];\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0;\n  const scoreList = [];\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length;\n  for (let k = 0; k < documentIDsLength; k++) {\n    var _oramaFrequencies_internalId;\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k]);\n    const tf = (oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_internalId = oramaFrequencies[internalId]) === null || _oramaFrequencies_internalId === void 0 ? void 0 : _oramaFrequencies_internalId[term]) ?? 0;\n    const bm25 = BM25(tf, termOccurrences, context.docsCount, fieldLengths[internalId], avgFieldLength, context.params.relevance);\n    scoreList.push([internalId, bm25]);\n  }\n  return scoreList;\n}\nexport async function create(orama, sharedInternalDocumentStore, schema, index, prefix = '') {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      vectorIndexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {}\n    };\n  }\n  for (const [prop, type] of Object.entries(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type, index, path);\n      continue;\n    }\n    if (isVectorType(type)) {\n      index.searchableProperties.push(path);\n      index.searchablePropertiesWithTypes[path] = type;\n      index.vectorIndexes[path] = {\n        size: getVectorSize(type),\n        vectors: {}\n      };\n    } else {\n      const isArray = /\\[/.test(type);\n      switch (type) {\n        case 'boolean':\n        case 'boolean[]':\n          index.indexes[path] = {\n            type: 'Bool',\n            node: {\n              true: [],\n              false: []\n            },\n            isArray\n          };\n          break;\n        case 'number':\n        case 'number[]':\n          index.indexes[path] = {\n            type: 'AVL',\n            node: avlCreate(0, []),\n            isArray\n          };\n          break;\n        case 'string':\n        case 'string[]':\n          index.indexes[path] = {\n            type: 'Radix',\n            node: radixCreate(),\n            isArray\n          };\n          index.avgFieldLength[path] = 0;\n          index.frequencies[path] = {};\n          index.tokenOccurrences[path] = {};\n          index.fieldLengths[path] = {};\n          break;\n        case 'enum':\n        case 'enum[]':\n          index.indexes[path] = {\n            type: 'Flat',\n            node: flatCreate(),\n            isArray\n          };\n          break;\n        default:\n          throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n      }\n      index.searchableProperties.push(path);\n      index.searchablePropertiesWithTypes[path] = type;\n    }\n  }\n  return index;\n}\nasync function insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  const {\n    type,\n    node\n  } = index.indexes[prop];\n  switch (type) {\n    case 'Bool':\n      {\n        node[value ? 'true' : 'false'].push(internalId);\n        break;\n      }\n    case 'AVL':\n      avlInsert(node, value, [internalId]);\n      break;\n    case 'Radix':\n      {\n        const tokens = await tokenizer.tokenize(value, language, prop);\n        await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);\n        for (const token of tokens) {\n          await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);\n          radixInsert(node, token, internalId);\n        }\n        break;\n      }\n    case 'Flat':\n      {\n        flatInsert(node, value, internalId);\n        break;\n      }\n  }\n}\nexport async function insert(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  if (isVectorType(schemaType)) {\n    return insertVector(index, prop, value, id);\n  }\n  if (!isArrayType(schemaType)) {\n    return insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n  }\n  const innerSchemaType = getInnerType(schemaType);\n  const elements = value;\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n  }\n}\nfunction insertVector(index, prop, value, id) {\n  if (!(value instanceof Float32Array)) {\n    value = new Float32Array(value);\n  }\n  const size = index.vectorIndexes[prop].size;\n  const magnitude = getMagnitude(value, size);\n  index.vectorIndexes[prop].vectors[id] = [magnitude, value];\n}\nasync function removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  if (isVectorType(schemaType)) {\n    delete index.vectorIndexes[prop].vectors[id];\n    return true;\n  }\n  const {\n    type,\n    node\n  } = index.indexes[prop];\n  switch (type) {\n    case 'AVL':\n      {\n        avlRemoveDocument(node, internalId, value);\n        return true;\n      }\n    case 'Bool':\n      {\n        const booleanKey = value ? 'true' : 'false';\n        const position = node[booleanKey].indexOf(internalId);\n        node[value ? 'true' : 'false'].splice(position, 1);\n        return true;\n      }\n    case 'Radix':\n      {\n        const tokens = await tokenizer.tokenize(value, language, prop);\n        await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);\n        for (const token of tokens) {\n          await implementation.removeTokenScoreParameters(index, prop, token);\n          radixRemoveDocument(node, token, internalId);\n        }\n        return true;\n      }\n    case 'Flat':\n      {\n        flatRemoveDocument(node, internalId, value);\n        return true;\n      }\n  }\n}\nexport async function remove(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n  }\n  const innerSchemaType = getInnerType(schemaType);\n  const elements = value;\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n  }\n  return true;\n}\nexport async function search(context, index, prop, term) {\n  if (!(prop in index.tokenOccurrences)) {\n    return [];\n  }\n  const {\n    node,\n    type\n  } = index.indexes[prop];\n  if (type !== 'Radix') {\n    throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop);\n  }\n  const {\n    exact,\n    tolerance\n  } = context.params;\n  const searchResult = radixFind(node, {\n    term,\n    exact,\n    tolerance\n  });\n  const ids = new Set();\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id);\n    }\n  }\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));\n}\nexport async function searchByWhereClause(context, index, filters) {\n  const filterKeys = Object.keys(filters);\n  const filtersMap = filterKeys.reduce((acc, key) => ({\n    [key]: [],\n    ...acc\n  }), {});\n  for (const param of filterKeys) {\n    const operation = filters[param];\n    if (typeof index.indexes[param] === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param);\n    }\n    const {\n      node,\n      type,\n      isArray\n    } = index.indexes[param];\n    if (type === 'Bool') {\n      const idx = node;\n      const filteredIDs = idx[operation.toString()];\n      safeArrayPush(filtersMap[param], filteredIDs);\n      continue;\n    }\n    if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param);\n        for (const t of term) {\n          const filteredIDsResults = radixFind(node, {\n            term: t,\n            exact: true\n          });\n          safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat());\n        }\n      }\n      continue;\n    }\n    const operationKeys = Object.keys(operation);\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length);\n    }\n    if (type === 'Flat') {\n      if (isArray) {\n        safeArrayPush(filtersMap[param], flatFilterArr(node, operation));\n      } else {\n        safeArrayPush(filtersMap[param], flatFilter(node, operation));\n      }\n      continue;\n    }\n    if (type === 'AVL') {\n      const operationOpt = operationKeys[0];\n      const operationValue = operation[operationOpt];\n      let filteredIDs = [];\n      switch (operationOpt) {\n        case 'gt':\n          {\n            filteredIDs = avlGreaterThan(node, operationValue, false);\n            break;\n          }\n        case 'gte':\n          {\n            filteredIDs = avlGreaterThan(node, operationValue, true);\n            break;\n          }\n        case 'lt':\n          {\n            filteredIDs = avlLessThan(node, operationValue, false);\n            break;\n          }\n        case 'lte':\n          {\n            filteredIDs = avlLessThan(node, operationValue, true);\n            break;\n          }\n        case 'eq':\n          {\n            filteredIDs = avlFind(node, operationValue) ?? [];\n            break;\n          }\n        case 'between':\n          {\n            const [min, max] = operationValue;\n            filteredIDs = avlRangeSearch(node, min, max);\n            break;\n          }\n      }\n      safeArrayPush(filtersMap[param], filteredIDs);\n    }\n  }\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap));\n  return result;\n}\nexport async function getSearchableProperties(index) {\n  return index.searchableProperties;\n}\nexport async function getSearchablePropertiesWithTypes(index) {\n  return index.searchablePropertiesWithTypes;\n}\nfunction loadRadixNode(node) {\n  const convertedNode = radixCreate(node.e, node.s, node.k);\n  convertedNode.d = node.d;\n  convertedNode.w = node.w;\n  for (const childrenKey of Object.keys(node.c)) {\n    convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey]);\n  }\n  return convertedNode;\n}\nfunction loadFlatNode(node) {\n  return {\n    numberToDocumentId: new Map(node)\n  };\n}\nfunction saveFlatNode(node) {\n  return Array.from(node.numberToDocumentId.entries());\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n  const {\n    indexes: rawIndexes,\n    vectorIndexes: rawVectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = raw;\n  const indexes = {};\n  const vectorIndexes = {};\n  for (const prop of Object.keys(rawIndexes)) {\n    const {\n      node,\n      type,\n      isArray\n    } = rawIndexes[prop];\n    switch (type) {\n      case 'Radix':\n        indexes[prop] = {\n          type: 'Radix',\n          node: loadRadixNode(node),\n          isArray\n        };\n        break;\n      case 'Flat':\n        indexes[prop] = {\n          type: 'Flat',\n          node: loadFlatNode(node),\n          isArray\n        };\n        break;\n      default:\n        indexes[prop] = rawIndexes[prop];\n    }\n  }\n  for (const idx of Object.keys(rawVectorIndexes)) {\n    const vectors = rawVectorIndexes[idx].vectors;\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], new Float32Array(vectors[vec][1])];\n    }\n    vectorIndexes[idx] = {\n      size: rawVectorIndexes[idx].size,\n      vectors\n    };\n  }\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  };\n}\nexport async function save(index) {\n  const {\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = index;\n  const vectorIndexesAsArrays = {};\n  for (const idx of Object.keys(vectorIndexes)) {\n    const vectors = vectorIndexes[idx].vectors;\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], Array.from(vectors[vec][1])];\n    }\n    vectorIndexesAsArrays[idx] = {\n      size: vectorIndexes[idx].size,\n      vectors\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const savedIndexes = {};\n  for (const name of Object.keys(indexes)) {\n    const {\n      type,\n      node,\n      isArray\n    } = indexes[name];\n    if (type !== 'Flat') {\n      savedIndexes[name] = indexes[name];\n      continue;\n    }\n    savedIndexes[name] = {\n      type: 'Flat',\n      node: saveFlatNode(node),\n      isArray\n    };\n  }\n  return {\n    indexes: savedIndexes,\n    vectorIndexes: vectorIndexesAsArrays,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  };\n}\nexport async function createIndex() {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save\n  };\n}","map":{"version":3,"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","flatCreate","filter","flatFilter","filterArr","flatFilterArr","flatInsert","flatRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","intersect","safeArrayPush","BM25","getMagnitude","getInnerType","getVectorSize","isArrayType","isVectorType","getInternalDocumentId","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","internalId","sharedInternalDocumentStore","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrences","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","documentIDs","Array","from","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","k","_oramaFrequencies_internalId","bm25","params","relevance","push","orama","schema","prefix","indexes","vectorIndexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","path","isArray","size","vectors","test","node","true","false","insertScalar","implementation","value","schemaType","language","tokenizer","tokenize","insertVector","innerSchemaType","elements","elementsLength","i","Float32Array","magnitude","removeScalar","booleanKey","position","indexOf","splice","remove","search","exact","tolerance","searchResult","Set","key","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","raw","flat","filteredIDsResults","values","operationKeys","operationOpt","operationValue","min","max","result","getSearchableProperties","getSearchablePropertiesWithTypes","loadRadixNode","convertedNode","e","s","d","w","childrenKey","c","loadFlatNode","numberToDocumentId","Map","saveFlatNode","load","rawIndexes","rawVectorIndexes","vec","save","vectorIndexesAsArrays","savedIndexes","name","createIndex"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/index.ts"],"sourcesContent":["import type {\n  AnyIndexStore,\n  AnyOrama,\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  EnumArrComparisonOperator,\n  EnumComparisonOperator,\n  IIndex,\n  ScalarSearchableType,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  Tokenizer,\n  TokenScore,\n  TypedDocument,\n  VectorIndex,\n  VectorType,\n  WhereCondition,\n} from '../types.js'\nimport { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  Node as AVLNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument,\n} from '../trees/avl.js'\nimport {\n  create as flatCreate,\n  filter as flatFilter,\n  filterArr as flatFilterArr,\n  insert as flatInsert,\n  removeDocument as flatRemoveDocument,\n  FlatTree,\n} from '../trees/flat.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument,\n} from '../trees/radix.js'\n\nimport { intersect, safeArrayPush } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getMagnitude } from './cosine-similarity.js'\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n} from './internal-document-id-store.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: InternalDocumentID]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: InternalDocumentID[]\n  false: InternalDocumentID[]\n}\n\nexport type TreeType =\n  | 'AVL'\n  | 'Radix'\n  | 'Bool'\n  | 'Flat'\n\nexport type TTree<T = TreeType, N = unknown> = {\n  type: T,\n  node: N\n  isArray: boolean\n}\n\nexport type Tree =\n  | TTree<'Radix', RadixNode>\n  | TTree<'AVL',   AVLNode<number, InternalDocumentID[]>>\n  | TTree<'Bool',  BooleanIndex>\n  | TTree<'Flat',  FlatTree>\n\nexport interface Index extends AnyIndexStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  indexes: Record<string, Tree>\n  vectorIndexes: Record<string, VectorIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrences: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<InternalDocumentID, number | undefined>>\n}\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][internalId] = tokens.length\n  index.frequencies[prop][internalId] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  token: string,\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][internalId]![token] = tf\n\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] =\n    (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]!) / (docsCount - 1)\n  index.fieldLengths[prop][internalId] = undefined\n  index.frequencies[prop][internalId] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrences[prop][token]--\n}\n\nexport async function calculateResultScores<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: DocumentID[],\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrences = index.tokenOccurrences[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k])\n    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrences,\n      context.docsCount,\n      fieldLengths[internalId]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>,\n    )\n\n    scoreList.push([internalId, bm25])\n  }\n  return scoreList\n}\n\nexport async function create<T extends AnyOrama, TSchema extends T['schema']>(\n  orama: T,\n  sharedInternalDocumentStore: T['internalDocumentIDStore'],\n  schema: TSchema,\n  index?: Index,\n  prefix = '',\n): Promise<Index> {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      vectorIndexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {},\n    }\n  }\n\n  for (const [prop, type] of Object.entries<SearchableType>(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type, index, path)\n      continue\n    }\n\n    if (isVectorType(type)) {\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n      index.vectorIndexes[path] = {\n        size: getVectorSize(type),\n        vectors: {},\n      }\n    } else {\n      const isArray = /\\[/.test(type as string)\n      switch (type) {\n        case 'boolean':\n        case 'boolean[]':\n          index.indexes[path] = { type: 'Bool', node: { true: [], false: [] }, isArray }\n          break\n        case 'number':\n        case 'number[]':\n          index.indexes[path] = { type: 'AVL', node: avlCreate<number, InternalDocumentID[]>(0, []), isArray }\n          break\n        case 'string':\n        case 'string[]':\n          index.indexes[path] = { type: 'Radix', node: radixCreate(), isArray }\n          index.avgFieldLength[path] = 0\n          index.frequencies[path] = {}\n          index.tokenOccurrences[path] = {}\n          index.fieldLengths[path] = {}\n          break\n        case 'enum':\n        case 'enum[]':\n          index.indexes[path] = { type: 'Flat', node: flatCreate(), isArray }\n          break\n        default:\n          throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path)\n      }\n\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n    }\n  }\n\n  return index\n}\n\nasync function insertScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'Bool': {\n      node[value ? 'true' : 'false'].push(internalId)\n      break\n    }\n    case 'AVL':\n      avlInsert(node, value as number, [internalId])\n      break\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n      await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount)\n\n      for (const token of tokens) {\n        await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token)\n\n        radixInsert(node, token, internalId)\n      }\n\n      break\n    }\n    case 'Flat': {\n      flatInsert(node, value as ScalarSearchableType, internalId)\n      break\n    }\n  }\n}\n\nexport async function insert(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  if (isVectorType(schemaType)) {\n    return insertVector(index, prop, value as number[] | Float32Array, id)\n  }\n\n  if (!isArrayType(schemaType)) {\n    return insertScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n}\n\nfunction insertVector(index: Index, prop: string, value: number[] | VectorType, id: DocumentID): void {\n  if (!(value instanceof Float32Array)) {\n    value = new Float32Array(value)\n  }\n\n  const size = index.vectorIndexes[prop].size\n  const magnitude = getMagnitude(value, size)\n\n  index.vectorIndexes[prop].vectors[id] = [magnitude, value]\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  if (isVectorType(schemaType)) {\n    delete index.vectorIndexes[prop].vectors[id]\n    return true\n  }\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'AVL': {\n      avlRemoveDocument(node, internalId, value as number)\n      return true\n    }\n    case 'Bool': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = node[booleanKey].indexOf(internalId)\n\n      node[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(node, token, internalId)\n      }\n\n      return true\n    }\n    case 'Flat': {\n      flatRemoveDocument(node, internalId, value as ScalarSearchableType)\n      return true\n    }\n  }\n}\n\nexport async function remove(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  prop: string,\n  term: string,\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrences)) {\n    return []\n  }\n\n  const { node, type } = index.indexes[prop]\n  if (type !== 'Radix') {\n    throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop)\n  }\n\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(node, { term, exact, tolerance })\n  const ids = new Set<InternalDocumentID>()\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  filters: Partial<WhereCondition<T['schema']>>,\n): Promise<number[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, InternalDocumentID[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc,\n    }),\n    {},\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]!\n\n    if (typeof index.indexes[param] === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param)\n    }\n\n    const { node, type, isArray } = index.indexes[param]\n\n    if (type === 'Bool') {\n      const idx = node\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      safeArrayPush(filtersMap[param], filteredIDs);\n      continue\n    }\n\n    if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        for (const t of term) {\n          const filteredIDsResults = radixFind(node, { term: t, exact: true })\n          safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat())}\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    if (type === 'Flat') {\n      if (isArray) {\n        safeArrayPush(filtersMap[param], flatFilterArr(node, operation as EnumArrComparisonOperator))\n      } else {\n        safeArrayPush(filtersMap[param], flatFilter(node, operation as EnumComparisonOperator))\n      }\n      continue\n    }\n\n    if (type === 'AVL') {\n      const operationOpt = operationKeys[0] as keyof ComparisonOperator\n      const operationValue = (operation as ComparisonOperator)[operationOpt]\n      let filteredIDs: InternalDocumentID[] = [];\n\n      switch (operationOpt) {\n        case 'gt': {\n          filteredIDs = avlGreaterThan(node, operationValue, false)\n          break\n        }\n        case 'gte': {\n          filteredIDs = avlGreaterThan(node, operationValue, true)\n          break\n        }\n        case 'lt': {\n          filteredIDs = avlLessThan(node, operationValue, false)\n          break\n        }\n        case 'lte': {\n          filteredIDs = avlLessThan(node, operationValue, true)\n          break\n        }\n        case 'eq': {\n          filteredIDs = avlFind(node, operationValue) ?? []\n          break\n        }\n        case 'between': {\n          const [min, max] = operationValue as number[]\n          filteredIDs = avlRangeSearch(node, min, max)\n          break\n        }\n      }\n\n      safeArrayPush(filtersMap[param], filteredIDs)\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap))\n\n  return result\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nfunction loadRadixNode(node: RadixNode): RadixNode {\n  const convertedNode = radixCreate(node.e, node.s, node.k)\n\n  convertedNode.d = node.d\n  convertedNode.w = node.w\n\n  for (const childrenKey of Object.keys(node.c)) {\n    convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey])\n  }\n\n  return convertedNode\n}\n\nfunction loadFlatNode(node: unknown): FlatTree {\n  return {\n    numberToDocumentId: new Map(node as [ScalarSearchableType, InternalDocumentID[]][]),\n  }\n}\n\nfunction saveFlatNode(node: FlatTree): unknown {\n  return Array.from(node.numberToDocumentId.entries())\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Index> {\n  const {\n    indexes: rawIndexes,\n    vectorIndexes: rawVectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = raw as Index\n\n  const indexes: Index['indexes'] = {}\n  const vectorIndexes: Index['vectorIndexes'] = {}\n\n  for (const prop of Object.keys(rawIndexes)) {\n    const { node, type, isArray } = rawIndexes[prop]\n\n    switch (type) {\n      case 'Radix':\n        indexes[prop] = {\n          type: 'Radix',\n          node: loadRadixNode(node),\n          isArray\n        }\n        break\n      case 'Flat':\n        indexes[prop] = {\n          type: 'Flat',\n          node: loadFlatNode(node),\n          isArray\n        }\n        break\n      default:\n        indexes[prop] = rawIndexes[prop]\n    }\n  }\n\n  for (const idx of Object.keys(rawVectorIndexes)) {\n    const vectors = rawVectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], new Float32Array(vectors[vec][1])]\n    }\n\n    vectorIndexes[idx] = {\n      size: rawVectorIndexes[idx].size,\n      vectors,\n    }\n  }\n\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = index\n\n  const vectorIndexesAsArrays: Index['vectorIndexes'] = {}\n\n  for (const idx of Object.keys(vectorIndexes)) {\n    const vectors = vectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], Array.from(vectors[vec][1]) as unknown as Float32Array]\n    }\n\n    vectorIndexesAsArrays[idx] = {\n      size: vectorIndexes[idx].size,\n      vectors,\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const savedIndexes: any = {}\n  for (const name of Object.keys(indexes)) {\n    const {type, node, isArray} = indexes[name]\n    if (type !== 'Flat') {\n      savedIndexes[name] = indexes[name]\n      continue\n    }\n    savedIndexes[name] = {\n      type: 'Flat',\n      node: saveFlatNode(node),\n      isArray,\n    }\n  }\n\n  return {\n    indexes: savedIndexes,\n    vectorIndexes: vectorIndexesAsArrays,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } as R\n}\n\nexport async function createIndex(): Promise<IIndex<Index>> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save,\n  }\n}\n"],"mappings":"AAoBA,SAASA,WAAW,QAAQ;AAC5B,SACEC,MAAA,IAAUC,SAAS,EACnBC,IAAA,IAAQC,OAAO,EACfC,WAAA,IAAeC,cAAc,EAC7BC,MAAA,IAAUC,SAAS,EACnBC,QAAA,IAAYC,WAAW,EAEvBC,WAAA,IAAeC,cAAc,EAC7BC,cAAA,IAAkBC,iBAAiB,QAC9B;AACP,SACEb,MAAA,IAAUc,UAAU,EACpBC,MAAA,IAAUC,UAAU,EACpBC,SAAA,IAAaC,aAAa,EAC1BZ,MAAA,IAAUa,UAAU,EACpBP,cAAA,IAAkBQ,kBAAkB,QAE/B;AACP,SACEpB,MAAA,IAAUqB,WAAW,EACrBnB,IAAA,IAAQoB,SAAS,EACjBhB,MAAA,IAAUiB,WAAW,EAErBC,oBAAA,IAAwBC,mBAAmB,QACtC;AAEP,SAASC,SAAS,EAAEC,aAAa,QAAQ;AACzC,SAASC,IAAI,QAAQ;AACrB,SAASC,YAAY,QAAQ;AAC7B,SAASC,YAAY,EAAEC,aAAa,EAAEC,WAAW,EAAEC,YAAY,QAAQ;AACvE,SAEEC,qBAAqB,QAGhB;AA+CP,OAAO,eAAeC,8BACpBC,KAAY,EACZC,IAAY,EACZC,EAAc,EACdC,MAAgB,EAChBC,SAAiB,EACF;EACf,MAAMC,UAAA,GAAaP,qBAAA,CAAsBE,KAAA,CAAMM,2BAA2B,EAAEJ,EAAA;EAE5EF,KAAA,CAAMO,cAAc,CAACN,IAAA,CAAK,GAAG,CAAC,CAACD,KAAA,CAAMO,cAAc,CAACN,IAAA,CAAK,IAAI,MAAMG,SAAA,GAAY,KAAKD,MAAA,CAAOK,MAAM,IAAIJ,SAAA;EACrGJ,KAAA,CAAMS,YAAY,CAACR,IAAA,CAAK,CAACI,UAAA,CAAW,GAAGF,MAAA,CAAOK,MAAM;EACpDR,KAAA,CAAMU,WAAW,CAACT,IAAA,CAAK,CAACI,UAAA,CAAW,GAAG,CAAC;AACzC;AAEA,OAAO,eAAeM,2BACpBX,KAAY,EACZC,IAAY,EACZC,EAAc,EACdC,MAAgB,EAChBS,KAAa,EACE;EACf,IAAIC,cAAA,GAAiB;EAErB,KAAK,MAAMC,CAAA,IAAKX,MAAA,EAAQ;IACtB,IAAIW,CAAA,KAAMF,KAAA,EAAO;MACfC,cAAA;IACF;EACF;EAEA,MAAMR,UAAA,GAAaP,qBAAA,CAAsBE,KAAA,CAAMM,2BAA2B,EAAEJ,EAAA;EAC5E,MAAMa,EAAA,GAAKF,cAAA,GAAiBV,MAAA,CAAOK,MAAM;EAEzCR,KAAA,CAAMU,WAAW,CAACT,IAAA,CAAK,CAACI,UAAA,CAAW,CAAEO,KAAA,CAAM,GAAGG,EAAA;EAE9C,IAAI,EAAEH,KAAA,IAASZ,KAAA,CAAMgB,gBAAgB,CAACf,IAAA,CAAK,CAAD,EAAI;IAC5CD,KAAA,CAAMgB,gBAAgB,CAACf,IAAA,CAAK,CAACW,KAAA,CAAM,GAAG;EACxC;EAEA;EACAZ,KAAA,CAAMgB,gBAAgB,CAACf,IAAA,CAAK,CAACW,KAAA,CAAM,GAAG,CAACZ,KAAA,CAAMgB,gBAAgB,CAACf,IAAA,CAAK,CAACW,KAAA,CAAM,IAAI,KAAK;AACrF;AAEA,OAAO,eAAeK,8BACpBjB,KAAY,EACZC,IAAY,EACZC,EAAc,EACdE,SAAiB,EACF;EACf,MAAMC,UAAA,GAAaP,qBAAA,CAAsBE,KAAA,CAAMM,2BAA2B,EAAEJ,EAAA;EAE5EF,KAAA,CAAMO,cAAc,CAACN,IAAA,CAAK,GACxB,CAACD,KAAA,CAAMO,cAAc,CAACN,IAAA,CAAK,GAAGG,SAAA,GAAYJ,KAAA,CAAMS,YAAY,CAACR,IAAA,CAAK,CAACI,UAAA,CAAW,KAAMD,SAAA,GAAY;EAClGJ,KAAA,CAAMS,YAAY,CAACR,IAAA,CAAK,CAACI,UAAA,CAAW,GAAGa,SAAA;EACvClB,KAAA,CAAMU,WAAW,CAACT,IAAA,CAAK,CAACI,UAAA,CAAW,GAAGa,SAAA;AACxC;AAEA,OAAO,eAAeC,2BAA2BnB,KAAY,EAAEC,IAAY,EAAEW,KAAa,EAAiB;EACzGZ,KAAA,CAAMgB,gBAAgB,CAACf,IAAA,CAAK,CAACW,KAAA,CAAM;AACrC;AAEA,OAAO,eAAeQ,sBACpBC,OAAyC,EACzCrB,KAAY,EACZC,IAAY,EACZqB,IAAY,EACZC,GAAiB,EACM;EACvB,MAAMC,WAAA,GAAcC,KAAA,CAAMC,IAAI,CAACH,GAAA;EAE/B;EACA,MAAMhB,cAAA,GAAiBP,KAAA,CAAMO,cAAc,CAACN,IAAA,CAAK;EACjD,MAAMQ,YAAA,GAAeT,KAAA,CAAMS,YAAY,CAACR,IAAA,CAAK;EAC7C,MAAM0B,gBAAA,GAAmB3B,KAAA,CAAMgB,gBAAgB,CAACf,IAAA,CAAK;EACrD,MAAM2B,gBAAA,GAAmB5B,KAAA,CAAMU,WAAW,CAACT,IAAA,CAAK;EAEhD;EACA,MAAM4B,eAAA,GAAkB,OAAOF,gBAAgB,CAACL,IAAA,CAAK,KAAK,WAAWK,gBAAgB,CAACL,IAAA,CAAK,IAAI,IAAI,CAAC;EAEpG,MAAMQ,SAAA,GAA0B,EAAE;EAElC;EACA,MAAMC,iBAAA,GAAoBP,WAAA,CAAYhB,MAAM;EAC5C,KAAK,IAAIwB,CAAA,GAAI,GAAGA,CAAA,GAAID,iBAAA,EAAmBC,CAAA,IAAK;QAE/BC,4BAAA;IADX,MAAM5B,UAAA,GAAaP,qBAAA,CAAsBE,KAAA,CAAMM,2BAA2B,EAAEkB,WAAW,CAACQ,CAAA,CAAE;IAC1F,MAAMjB,EAAA,GAAK,CAAAa,gBAAA,aAAAA,gBAAA,wBAAAK,4BAAA,GAAAL,gBAAkB,CAACvB,UAAA,CAAW,cAA9B4B,4BAAA,uBAAAA,4BAAgC,CAACX,IAAA,CAAK,KAAI;IAErD,MAAMY,IAAA,GAAO1C,IAAA,CACXuB,EAAA,EACAc,eAAA,EACAR,OAAA,CAAQjB,SAAS,EACjBK,YAAY,CAACJ,UAAA,CAAW,EACxBE,cAAA,EACAc,OAAA,CAAQc,MAAM,CAACC,SAAS;IAG1BN,SAAA,CAAUO,IAAI,CAAC,CAAChC,UAAA,EAAY6B,IAAA,CAAK;EACnC;EACA,OAAOJ,SAAA;AACT;AAEA,OAAO,eAAelE,OACpB0E,KAAQ,EACRhC,2BAAyD,EACzDiC,MAAe,EACfvC,KAAa,EACbwC,MAAA,GAAS,EAAE,EACK;EAChB,IAAI,CAACxC,KAAA,EAAO;IACVA,KAAA,GAAQ;MACNM,2BAAA;MACAmC,OAAA,EAAS,CAAC;MACVC,aAAA,EAAe,CAAC;MAChBC,oBAAA,EAAsB,EAAE;MACxBC,6BAAA,EAA+B,CAAC;MAChClC,WAAA,EAAa,CAAC;MACdM,gBAAA,EAAkB,CAAC;MACnBT,cAAA,EAAgB,CAAC;MACjBE,YAAA,EAAc,CAAC;IACjB;EACF;EAEA,KAAK,MAAM,CAACR,IAAA,EAAM4C,IAAA,CAAK,IAAIC,MAAA,CAAOC,OAAO,CAAiBR,MAAA,GAAS;IACjE,MAAMS,IAAA,GAAQ,GAAER,MAAO,GAAEA,MAAA,GAAS,MAAM,EAAG,GAAEvC,IAAK,EAAC;IAEnD,IAAI,OAAO4C,IAAA,KAAS,YAAY,CAACpB,KAAA,CAAMwB,OAAO,CAACJ,IAAA,GAAO;MACpD;MACAjF,MAAA,CAAO0E,KAAA,EAAOhC,2BAAA,EAA6BuC,IAAA,EAAM7C,KAAA,EAAOgD,IAAA;MACxD;IACF;IAEA,IAAInD,YAAA,CAAagD,IAAA,GAAO;MACtB7C,KAAA,CAAM2C,oBAAoB,CAACN,IAAI,CAACW,IAAA;MAChChD,KAAA,CAAM4C,6BAA6B,CAACI,IAAA,CAAK,GAAGH,IAAA;MAC5C7C,KAAA,CAAM0C,aAAa,CAACM,IAAA,CAAK,GAAG;QAC1BE,IAAA,EAAMvD,aAAA,CAAckD,IAAA;QACpBM,OAAA,EAAS,CAAC;MACZ;IACF,OAAO;MACL,MAAMF,OAAA,GAAU,KAAKG,IAAI,CAACP,IAAA;MAC1B,QAAQA,IAAA;QACN,KAAK;QACL,KAAK;UACH7C,KAAA,CAAMyC,OAAO,CAACO,IAAA,CAAK,GAAG;YAAEH,IAAA,EAAM;YAAQQ,IAAA,EAAM;cAAEC,IAAA,EAAM,EAAE;cAAEC,KAAA,EAAO;YAAG;YAAGN;UAAQ;UAC7E;QACF,KAAK;QACL,KAAK;UACHjD,KAAA,CAAMyC,OAAO,CAACO,IAAA,CAAK,GAAG;YAAEH,IAAA,EAAM;YAAOQ,IAAA,EAAMxF,SAAA,CAAwC,GAAG,EAAE;YAAGoF;UAAQ;UACnG;QACF,KAAK;QACL,KAAK;UACHjD,KAAA,CAAMyC,OAAO,CAACO,IAAA,CAAK,GAAG;YAAEH,IAAA,EAAM;YAASQ,IAAA,EAAMpE,WAAA;YAAegE;UAAQ;UACpEjD,KAAA,CAAMO,cAAc,CAACyC,IAAA,CAAK,GAAG;UAC7BhD,KAAA,CAAMU,WAAW,CAACsC,IAAA,CAAK,GAAG,CAAC;UAC3BhD,KAAA,CAAMgB,gBAAgB,CAACgC,IAAA,CAAK,GAAG,CAAC;UAChChD,KAAA,CAAMS,YAAY,CAACuC,IAAA,CAAK,GAAG,CAAC;UAC5B;QACF,KAAK;QACL,KAAK;UACHhD,KAAA,CAAMyC,OAAO,CAACO,IAAA,CAAK,GAAG;YAAEH,IAAA,EAAM;YAAQQ,IAAA,EAAM3E,UAAA;YAAcuE;UAAQ;UAClE;QACF;UACE,MAAMtF,WAAA,CAAY,uBAAuB8D,KAAA,CAAMwB,OAAO,CAACJ,IAAA,IAAQ,UAAUA,IAAI,EAAEG,IAAA;MACnF;MAEAhD,KAAA,CAAM2C,oBAAoB,CAACN,IAAI,CAACW,IAAA;MAChChD,KAAA,CAAM4C,6BAA6B,CAACI,IAAA,CAAK,GAAGH,IAAA;IAC9C;EACF;EAEA,OAAO7C,KAAA;AACT;AAEA,eAAewD,aACbC,cAA6B,EAC7BzD,KAAY,EACZC,IAAY,EACZC,EAAc,EACdwD,KAAsB,EACtBC,UAAgC,EAChCC,QAA4B,EAC5BC,SAAoB,EACpBzD,SAAiB,EACF;EACf,MAAMC,UAAA,GAAaP,qBAAA,CAAsBE,KAAA,CAAMM,2BAA2B,EAAEJ,EAAA;EAE5E,MAAM;IAAE2C,IAAA;IAAMQ;EAAI,CAAE,GAAGrD,KAAA,CAAMyC,OAAO,CAACxC,IAAA,CAAK;EAC1C,QAAQ4C,IAAA;IACN,KAAK;MAAQ;QACXQ,IAAI,CAACK,KAAA,GAAQ,SAAS,OAAO,CAAC,CAACrB,IAAI,CAAChC,UAAA;QACpC;MACF;IACA,KAAK;MACHlC,SAAA,CAAUkF,IAAA,EAAMK,KAAA,EAAiB,CAACrD,UAAA,CAAW;MAC7C;IACF,KAAK;MAAS;QACZ,MAAMF,MAAA,GAAS,MAAM0D,SAAA,CAAUC,QAAQ,CAACJ,KAAA,EAAiBE,QAAA,EAAU3D,IAAA;QACnE,MAAMwD,cAAA,CAAe1D,6BAA6B,CAACC,KAAA,EAAOC,IAAA,EAAMI,UAAA,EAAYF,MAAA,EAAQC,SAAA;QAEpF,KAAK,MAAMQ,KAAA,IAAST,MAAA,EAAQ;UAC1B,MAAMsD,cAAA,CAAe9C,0BAA0B,CAACX,KAAA,EAAOC,IAAA,EAAMI,UAAA,EAAYF,MAAA,EAAQS,KAAA;UAEjFzB,WAAA,CAAYkE,IAAA,EAAMzC,KAAA,EAAOP,UAAA;QAC3B;QAEA;MACF;IACA,KAAK;MAAQ;QACXtB,UAAA,CAAWsE,IAAA,EAAMK,KAAA,EAA+BrD,UAAA;QAChD;MACF;EACF;AACF;AAEA,OAAO,eAAenC,OACpBuF,cAA6B,EAC7BzD,KAAY,EACZC,IAAY,EACZC,EAAc,EACdwD,KAAsB,EACtBC,UAA0B,EAC1BC,QAA4B,EAC5BC,SAAoB,EACpBzD,SAAiB,EACF;EACf,IAAIP,YAAA,CAAa8D,UAAA,GAAa;IAC5B,OAAOI,YAAA,CAAa/D,KAAA,EAAOC,IAAA,EAAMyD,KAAA,EAAkCxD,EAAA;EACrE;EAEA,IAAI,CAACN,WAAA,CAAY+D,UAAA,GAAa;IAC5B,OAAOH,YAAA,CACLC,cAAA,EACAzD,KAAA,EACAC,IAAA,EACAC,EAAA,EACAwD,KAAA,EACAC,UAAA,EACAC,QAAA,EACAC,SAAA,EACAzD,SAAA;EAEJ;EAEA,MAAM4D,eAAA,GAAkBtE,YAAA,CAAaiE,UAAA;EAErC,MAAMM,QAAA,GAAWP,KAAA;EACjB,MAAMQ,cAAA,GAAiBD,QAAA,CAASzD,MAAM;EACtC,KAAK,IAAI2D,CAAA,GAAI,GAAGA,CAAA,GAAID,cAAA,EAAgBC,CAAA,IAAK;IACvC,MAAMX,YAAA,CAAaC,cAAA,EAAgBzD,KAAA,EAAOC,IAAA,EAAMC,EAAA,EAAI+D,QAAQ,CAACE,CAAA,CAAE,EAAEH,eAAA,EAAiBJ,QAAA,EAAUC,SAAA,EAAWzD,SAAA;EACzG;AACF;AAEA,SAAS2D,aAAa/D,KAAY,EAAEC,IAAY,EAAEyD,KAA4B,EAAExD,EAAc,EAAQ;EACpG,IAAI,EAAEwD,KAAA,YAAiBU,YAAW,GAAI;IACpCV,KAAA,GAAQ,IAAIU,YAAA,CAAaV,KAAA;EAC3B;EAEA,MAAMR,IAAA,GAAOlD,KAAA,CAAM0C,aAAa,CAACzC,IAAA,CAAK,CAACiD,IAAI;EAC3C,MAAMmB,SAAA,GAAY5E,YAAA,CAAaiE,KAAA,EAAOR,IAAA;EAEtClD,KAAA,CAAM0C,aAAa,CAACzC,IAAA,CAAK,CAACkD,OAAO,CAACjD,EAAA,CAAG,GAAG,CAACmE,SAAA,EAAWX,KAAA,CAAM;AAC5D;AAEA,eAAeY,aACbb,cAA6B,EAC7BzD,KAAY,EACZC,IAAY,EACZC,EAAc,EACdwD,KAAsB,EACtBC,UAAgC,EAChCC,QAA4B,EAC5BC,SAAoB,EACpBzD,SAAiB,EACC;EAClB,MAAMC,UAAA,GAAaP,qBAAA,CAAsBE,KAAA,CAAMM,2BAA2B,EAAEJ,EAAA;EAE5E,IAAIL,YAAA,CAAa8D,UAAA,GAAa;IAC5B,OAAO3D,KAAA,CAAM0C,aAAa,CAACzC,IAAA,CAAK,CAACkD,OAAO,CAACjD,EAAA,CAAG;IAC5C,OAAO,IAAI;EACb;EAEA,MAAM;IAAE2C,IAAA;IAAMQ;EAAI,CAAE,GAAGrD,KAAA,CAAMyC,OAAO,CAACxC,IAAA,CAAK;EAC1C,QAAQ4C,IAAA;IACN,KAAK;MAAO;QACVpE,iBAAA,CAAkB4E,IAAA,EAAMhD,UAAA,EAAYqD,KAAA;QACpC,OAAO,IAAI;MACb;IACA,KAAK;MAAQ;QACX,MAAMa,UAAA,GAAab,KAAA,GAAQ,SAAS,OAAO;QAC3C,MAAMc,QAAA,GAAWnB,IAAI,CAACkB,UAAA,CAAW,CAACE,OAAO,CAACpE,UAAA;QAE1CgD,IAAI,CAACK,KAAA,GAAQ,SAAS,OAAO,CAAC,CAACgB,MAAM,CAACF,QAAA,EAAU;QAChD,OAAO,IAAI;MACb;IACA,KAAK;MAAS;QACZ,MAAMrE,MAAA,GAAS,MAAM0D,SAAA,CAAUC,QAAQ,CAACJ,KAAA,EAAiBE,QAAA,EAAU3D,IAAA;QAEnE,MAAMwD,cAAA,CAAexC,6BAA6B,CAACjB,KAAA,EAAOC,IAAA,EAAMC,EAAA,EAAIE,SAAA;QAEpE,KAAK,MAAMQ,KAAA,IAAST,MAAA,EAAQ;UAC1B,MAAMsD,cAAA,CAAetC,0BAA0B,CAACnB,KAAA,EAAOC,IAAA,EAAMW,KAAA;UAC7DvB,mBAAA,CAAoBgE,IAAA,EAAMzC,KAAA,EAAOP,UAAA;QACnC;QAEA,OAAO,IAAI;MACb;IACA,KAAK;MAAQ;QACXrB,kBAAA,CAAmBqE,IAAA,EAAMhD,UAAA,EAAYqD,KAAA;QACrC,OAAO,IAAI;MACb;EACF;AACF;AAEA,OAAO,eAAeiB,OACpBlB,cAA6B,EAC7BzD,KAAY,EACZC,IAAY,EACZC,EAAc,EACdwD,KAAsB,EACtBC,UAA0B,EAC1BC,QAA4B,EAC5BC,SAAoB,EACpBzD,SAAiB,EACC;EAClB,IAAI,CAACR,WAAA,CAAY+D,UAAA,GAAa;IAC5B,OAAOW,YAAA,CACLb,cAAA,EACAzD,KAAA,EACAC,IAAA,EACAC,EAAA,EACAwD,KAAA,EACAC,UAAA,EACAC,QAAA,EACAC,SAAA,EACAzD,SAAA;EAEJ;EAEA,MAAM4D,eAAA,GAAkBtE,YAAA,CAAaiE,UAAA;EAErC,MAAMM,QAAA,GAAWP,KAAA;EACjB,MAAMQ,cAAA,GAAiBD,QAAA,CAASzD,MAAM;EACtC,KAAK,IAAI2D,CAAA,GAAI,GAAGA,CAAA,GAAID,cAAA,EAAgBC,CAAA,IAAK;IACvC,MAAMG,YAAA,CAAab,cAAA,EAAgBzD,KAAA,EAAOC,IAAA,EAAMC,EAAA,EAAI+D,QAAQ,CAACE,CAAA,CAAE,EAAEH,eAAA,EAAiBJ,QAAA,EAAUC,SAAA,EAAWzD,SAAA;EACzG;EAEA,OAAO,IAAI;AACb;AAEA,OAAO,eAAewE,OACpBvD,OAAyC,EACzCrB,KAAY,EACZC,IAAY,EACZqB,IAAY,EACW;EACvB,IAAI,EAAErB,IAAA,IAAQD,KAAA,CAAMgB,gBAAgB,CAAD,EAAI;IACrC,OAAO,EAAE;EACX;EAEA,MAAM;IAAEqC,IAAA;IAAMR;EAAI,CAAE,GAAG7C,KAAA,CAAMyC,OAAO,CAACxC,IAAA,CAAK;EAC1C,IAAI4C,IAAA,KAAS,SAAS;IACpB,MAAMlF,WAAA,CAAY,8BAA8BsC,IAAA;EAClD;EAEA,MAAM;IAAE4E,KAAA;IAAOC;EAAS,CAAE,GAAGzD,OAAA,CAAQc,MAAM;EAC3C,MAAM4C,YAAA,GAAe7F,SAAA,CAAUmE,IAAA,EAAM;IAAE/B,IAAA;IAAMuD,KAAA;IAAOC;EAAU;EAC9D,MAAMvD,GAAA,GAAM,IAAIyD,GAAA;EAEhB,KAAK,MAAMC,GAAA,IAAOF,YAAA,EAAc;IAC9B,KAAK,MAAM7E,EAAA,IAAM6E,YAAY,CAACE,GAAA,CAAI,EAAE;MAClC1D,GAAA,CAAI2D,GAAG,CAAChF,EAAA;IACV;EACF;EAEA,OAAOmB,OAAA,CAAQrB,KAAK,CAACoB,qBAAqB,CAACC,OAAA,EAASrB,KAAA,EAAOC,IAAA,EAAMqB,IAAA,EAAMG,KAAA,CAAMC,IAAI,CAACH,GAAA;AACpF;AAEA,OAAO,eAAe4D,oBACpB9D,OAAyC,EACzCrB,KAAY,EACZoF,OAA6C,EAC1B;EACnB,MAAMC,UAAA,GAAavC,MAAA,CAAOwC,IAAI,CAACF,OAAA;EAE/B,MAAMG,UAAA,GAAmDF,UAAA,CAAWG,MAAM,CACxE,CAACC,GAAA,EAAKR,GAAA,MAAS;IACb,CAACA,GAAA,GAAM,EAAE;IACT,GAAGQ;EACL,IACA,CAAC;EAGH,KAAK,MAAMC,KAAA,IAASL,UAAA,EAAY;IAC9B,MAAMM,SAAA,GAAYP,OAAO,CAACM,KAAA,CAAM;IAEhC,IAAI,OAAO1F,KAAA,CAAMyC,OAAO,CAACiD,KAAA,CAAM,KAAK,aAAa;MAC/C,MAAM/H,WAAA,CAAY,2BAA2B+H,KAAA;IAC/C;IAEA,MAAM;MAAErC,IAAA;MAAMR,IAAA;MAAMI;IAAO,CAAE,GAAGjD,KAAA,CAAMyC,OAAO,CAACiD,KAAA,CAAM;IAEpD,IAAI7C,IAAA,KAAS,QAAQ;MACnB,MAAM+C,GAAA,GAAMvC,IAAA;MACZ,MAAMwC,WAAA,GAAcD,GAAG,CAACD,SAAA,CAAUG,QAAQ,GAAyB;MACnEvG,aAAA,CAAcgG,UAAU,CAACG,KAAA,CAAM,EAAEG,WAAA;MACjC;IACF;IAEA,IAAIhD,IAAA,KAAS,YAAY,OAAO8C,SAAA,KAAc,YAAYlE,KAAA,CAAMwB,OAAO,CAAC0C,SAAA,CAAS,GAAI;MACnF,KAAK,MAAMI,GAAA,IAAO,CAACJ,SAAA,CAAU,CAACK,IAAI,IAAI;QACpC,MAAM1E,IAAA,GAAO,MAAMD,OAAA,CAAQwC,SAAS,CAACC,QAAQ,CAACiC,GAAA,EAAK1E,OAAA,CAAQuC,QAAQ,EAAE8B,KAAA;QACrE,KAAK,MAAM5E,CAAA,IAAKQ,IAAA,EAAM;UACpB,MAAM2E,kBAAA,GAAqB/G,SAAA,CAAUmE,IAAA,EAAM;YAAE/B,IAAA,EAAMR,CAAA;YAAG+D,KAAA,EAAO;UAAK;UAClEtF,aAAA,CAAcgG,UAAU,CAACG,KAAA,CAAM,EAAE5C,MAAA,CAAOoD,MAAM,CAACD,kBAAA,EAAoBD,IAAI;QAAG;MAC9E;MAEA;IACF;IAEA,MAAMG,aAAA,GAAgBrD,MAAA,CAAOwC,IAAI,CAACK,SAAA;IAElC,IAAIQ,aAAA,CAAc3F,MAAM,GAAG,GAAG;MAC5B,MAAM7C,WAAA,CAAY,4BAA4BwI,aAAA,CAAc3F,MAAM;IACpE;IAEA,IAAIqC,IAAA,KAAS,QAAQ;MACnB,IAAII,OAAA,EAAS;QACX1D,aAAA,CAAcgG,UAAU,CAACG,KAAA,CAAM,EAAE5G,aAAA,CAAcuE,IAAA,EAAMsC,SAAA;MACvD,OAAO;QACLpG,aAAA,CAAcgG,UAAU,CAACG,KAAA,CAAM,EAAE9G,UAAA,CAAWyE,IAAA,EAAMsC,SAAA;MACpD;MACA;IACF;IAEA,IAAI9C,IAAA,KAAS,OAAO;MAClB,MAAMuD,YAAA,GAAeD,aAAa,CAAC,EAAE;MACrC,MAAME,cAAA,GAAiBV,SAAiC,CAACS,YAAA,CAAa;MACtE,IAAIP,WAAA,GAAoC,EAAE;MAE1C,QAAQO,YAAA;QACN,KAAK;UAAM;YACTP,WAAA,GAAc5H,cAAA,CAAeoF,IAAA,EAAMgD,cAAA,EAAgB,KAAK;YACxD;UACF;QACA,KAAK;UAAO;YACVR,WAAA,GAAc5H,cAAA,CAAeoF,IAAA,EAAMgD,cAAA,EAAgB,IAAI;YACvD;UACF;QACA,KAAK;UAAM;YACTR,WAAA,GAAcxH,WAAA,CAAYgF,IAAA,EAAMgD,cAAA,EAAgB,KAAK;YACrD;UACF;QACA,KAAK;UAAO;YACVR,WAAA,GAAcxH,WAAA,CAAYgF,IAAA,EAAMgD,cAAA,EAAgB,IAAI;YACpD;UACF;QACA,KAAK;UAAM;YACTR,WAAA,GAAc9H,OAAA,CAAQsF,IAAA,EAAMgD,cAAA,KAAmB,EAAE;YACjD;UACF;QACA,KAAK;UAAW;YACd,MAAM,CAACC,GAAA,EAAKC,GAAA,CAAI,GAAGF,cAAA;YACnBR,WAAA,GAActH,cAAA,CAAe8E,IAAA,EAAMiD,GAAA,EAAKC,GAAA;YACxC;UACF;MACF;MAEAhH,aAAA,CAAcgG,UAAU,CAACG,KAAA,CAAM,EAAEG,WAAA;IACnC;EACF;EAEA;EACA,MAAMW,MAAA,GAASlH,SAAA,CAAUwD,MAAA,CAAOoD,MAAM,CAACX,UAAA;EAEvC,OAAOiB,MAAA;AACT;AAEA,OAAO,eAAeC,wBAAwBzG,KAAY,EAAqB;EAC7E,OAAOA,KAAA,CAAM2C,oBAAoB;AACnC;AAEA,OAAO,eAAe+D,iCAAiC1G,KAAY,EAA2C;EAC5G,OAAOA,KAAA,CAAM4C,6BAA6B;AAC5C;AAEA,SAAS+D,cAActD,IAAe,EAAa;EACjD,MAAMuD,aAAA,GAAgB3H,WAAA,CAAYoE,IAAA,CAAKwD,CAAC,EAAExD,IAAA,CAAKyD,CAAC,EAAEzD,IAAA,CAAKrB,CAAC;EAExD4E,aAAA,CAAcG,CAAC,GAAG1D,IAAA,CAAK0D,CAAC;EACxBH,aAAA,CAAcI,CAAC,GAAG3D,IAAA,CAAK2D,CAAC;EAExB,KAAK,MAAMC,WAAA,IAAenE,MAAA,CAAOwC,IAAI,CAACjC,IAAA,CAAK6D,CAAC,GAAG;IAC7CN,aAAA,CAAcM,CAAC,CAACD,WAAA,CAAY,GAAGN,aAAA,CAActD,IAAA,CAAK6D,CAAC,CAACD,WAAA,CAAY;EAClE;EAEA,OAAOL,aAAA;AACT;AAEA,SAASO,aAAa9D,IAAa,EAAY;EAC7C,OAAO;IACL+D,kBAAA,EAAoB,IAAIC,GAAA,CAAIhE,IAAA;EAC9B;AACF;AAEA,SAASiE,aAAajE,IAAc,EAAW;EAC7C,OAAO5B,KAAA,CAAMC,IAAI,CAAC2B,IAAA,CAAK+D,kBAAkB,CAACrE,OAAO;AACnD;AAEA,OAAO,eAAewE,KAAkBjH,2BAAoD,EAAEyF,GAAM,EAAkB;EACpH,MAAM;IACJtD,OAAA,EAAS+E,UAAA;IACT9E,aAAA,EAAe+E,gBAAA;IACf9E,oBAAA;IACAC,6BAAA;IACAlC,WAAA;IACAM,gBAAA;IACAT,cAAA;IACAE;EAAY,CACb,GAAGsF,GAAA;EAEJ,MAAMtD,OAAA,GAA4B,CAAC;EACnC,MAAMC,aAAA,GAAwC,CAAC;EAE/C,KAAK,MAAMzC,IAAA,IAAQ6C,MAAA,CAAOwC,IAAI,CAACkC,UAAA,GAAa;IAC1C,MAAM;MAAEnE,IAAA;MAAMR,IAAA;MAAMI;IAAO,CAAE,GAAGuE,UAAU,CAACvH,IAAA,CAAK;IAEhD,QAAQ4C,IAAA;MACN,KAAK;QACHJ,OAAO,CAACxC,IAAA,CAAK,GAAG;UACd4C,IAAA,EAAM;UACNQ,IAAA,EAAMsD,aAAA,CAActD,IAAA;UACpBJ;QACF;QACA;MACF,KAAK;QACHR,OAAO,CAACxC,IAAA,CAAK,GAAG;UACd4C,IAAA,EAAM;UACNQ,IAAA,EAAM8D,YAAA,CAAa9D,IAAA;UACnBJ;QACF;QACA;MACF;QACER,OAAO,CAACxC,IAAA,CAAK,GAAGuH,UAAU,CAACvH,IAAA,CAAK;IACpC;EACF;EAEA,KAAK,MAAM2F,GAAA,IAAO9C,MAAA,CAAOwC,IAAI,CAACmC,gBAAA,GAAmB;IAC/C,MAAMtE,OAAA,GAAUsE,gBAAgB,CAAC7B,GAAA,CAAI,CAACzC,OAAO;IAE7C,KAAK,MAAMuE,GAAA,IAAOvE,OAAA,EAAS;MACzBA,OAAO,CAACuE,GAAA,CAAI,GAAG,CAACvE,OAAO,CAACuE,GAAA,CAAI,CAAC,EAAE,EAAE,IAAItD,YAAA,CAAajB,OAAO,CAACuE,GAAA,CAAI,CAAC,EAAE,EAAE;IACrE;IAEAhF,aAAa,CAACkD,GAAA,CAAI,GAAG;MACnB1C,IAAA,EAAMuE,gBAAgB,CAAC7B,GAAA,CAAI,CAAC1C,IAAI;MAChCC;IACF;EACF;EAEA,OAAO;IACL7C,2BAAA;IACAmC,OAAA;IACAC,aAAA;IACAC,oBAAA;IACAC,6BAAA;IACAlC,WAAA;IACAM,gBAAA;IACAT,cAAA;IACAE;EACF;AACF;AAEA,OAAO,eAAekH,KAAkB3H,KAAY,EAAc;EAChE,MAAM;IACJyC,OAAA;IACAC,aAAA;IACAC,oBAAA;IACAC,6BAAA;IACAlC,WAAA;IACAM,gBAAA;IACAT,cAAA;IACAE;EAAY,CACb,GAAGT,KAAA;EAEJ,MAAM4H,qBAAA,GAAgD,CAAC;EAEvD,KAAK,MAAMhC,GAAA,IAAO9C,MAAA,CAAOwC,IAAI,CAAC5C,aAAA,GAAgB;IAC5C,MAAMS,OAAA,GAAUT,aAAa,CAACkD,GAAA,CAAI,CAACzC,OAAO;IAE1C,KAAK,MAAMuE,GAAA,IAAOvE,OAAA,EAAS;MACzBA,OAAO,CAACuE,GAAA,CAAI,GAAG,CAACvE,OAAO,CAACuE,GAAA,CAAI,CAAC,EAAE,EAAEjG,KAAA,CAAMC,IAAI,CAACyB,OAAO,CAACuE,GAAA,CAAI,CAAC,EAAE,EAA6B;IAC1F;IAEAE,qBAAqB,CAAChC,GAAA,CAAI,GAAG;MAC3B1C,IAAA,EAAMR,aAAa,CAACkD,GAAA,CAAI,CAAC1C,IAAI;MAC7BC;IACF;EACF;EAEA;EACA,MAAM0E,YAAA,GAAoB,CAAC;EAC3B,KAAK,MAAMC,IAAA,IAAQhF,MAAA,CAAOwC,IAAI,CAAC7C,OAAA,GAAU;IACvC,MAAM;MAACI,IAAA;MAAMQ,IAAA;MAAMJ;IAAO,CAAC,GAAGR,OAAO,CAACqF,IAAA,CAAK;IAC3C,IAAIjF,IAAA,KAAS,QAAQ;MACnBgF,YAAY,CAACC,IAAA,CAAK,GAAGrF,OAAO,CAACqF,IAAA,CAAK;MAClC;IACF;IACAD,YAAY,CAACC,IAAA,CAAK,GAAG;MACnBjF,IAAA,EAAM;MACNQ,IAAA,EAAMiE,YAAA,CAAajE,IAAA;MACnBJ;IACF;EACF;EAEA,OAAO;IACLR,OAAA,EAASoF,YAAA;IACTnF,aAAA,EAAekF,qBAAA;IACfjF,oBAAA;IACAC,6BAAA;IACAlC,WAAA;IACAM,gBAAA;IACAT,cAAA;IACAE;EACF;AACF;AAEA,OAAO,eAAesH,YAAA,EAAsC;EAC1D,OAAO;IACLnK,MAAA;IACAM,MAAA;IACAyG,MAAA;IACA5E,6BAAA;IACAY,0BAAA;IACAM,6BAAA;IACAE,0BAAA;IACAC,qBAAA;IACAwD,MAAA;IACAO,mBAAA;IACAsB,uBAAA;IACAC,gCAAA;IACAa,IAAA;IACAI;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}