{"ast":null,"code":"import _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { FloatType, Scene, Camera, Mesh, PlaneGeometry, NearestFilter, ShaderMaterial, ClampToEdgeWrapping, WebGLRenderTarget, RGBAFormat, DataTexture, NoToneMapping } from \"three\";\nvar GPUComputationRenderer = /*#__PURE__*/_createClass(function GPUComputationRenderer(sizeX, sizeY, renderer) {\n  _classCallCheck(this, GPUComputationRenderer);\n  this.variables = [];\n  this.currentTextureIndex = 0;\n  var dataType = FloatType;\n  var scene = new Scene();\n  var camera = new Camera();\n  camera.position.z = 1;\n  var passThruUniforms = {\n    passThruTexture: {\n      value: null\n    }\n  };\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n  var mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n  scene.add(mesh);\n  this.setDataType = function (type) {\n    dataType = type;\n    return this;\n  };\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n    var material = this.createShaderMaterial(computeFragmentShader);\n    var variable = {\n      name: variableName,\n      initialValueTexture: initialValueTexture,\n      material: material,\n      dependencies: null,\n      renderTargets: [],\n      wrapS: null,\n      wrapT: null,\n      minFilter: NearestFilter,\n      magFilter: NearestFilter\n    };\n    this.variables.push(variable);\n    return variable;\n  };\n  this.setVariableDependencies = function (variable, dependencies) {\n    variable.dependencies = dependencies;\n  };\n  this.init = function () {\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n      return \"No OES_texture_float support for float textures.\";\n    }\n    if (renderer.capabilities.maxVertexTextures === 0) {\n      return \"No support for vertex shader textures.\";\n    }\n    for (var i = 0; i < this.variables.length; i++) {\n      var variable = this.variables[i];\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n      var material = variable.material;\n      var uniforms = material.uniforms;\n      if (variable.dependencies !== null) {\n        for (var d = 0; d < variable.dependencies.length; d++) {\n          var depVar = variable.dependencies[d];\n          if (depVar.name !== variable.name) {\n            var found = false;\n            for (var j = 0; j < this.variables.length; j++) {\n              if (depVar.name === this.variables[j].name) {\n                found = true;\n                break;\n              }\n            }\n            if (!found) {\n              return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n            }\n          }\n          uniforms[depVar.name] = {\n            value: null\n          };\n          material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n        }\n      }\n    }\n    this.currentTextureIndex = 0;\n    return null;\n  };\n  this.compute = function () {\n    var currentTextureIndex = this.currentTextureIndex;\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n    for (var i = 0, il = this.variables.length; i < il; i++) {\n      var variable = this.variables[i];\n      if (variable.dependencies !== null) {\n        var uniforms = variable.material.uniforms;\n        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {\n          var depVar = variable.dependencies[d];\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n        }\n      }\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n    }\n    this.currentTextureIndex = nextTextureIndex;\n  };\n  this.getCurrentRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex];\n  };\n  this.getAlternateRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n  };\n  this.dispose = function () {\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    var variables = this.variables;\n    for (var i = 0; i < variables.length; i++) {\n      var variable = variables[i];\n      if (variable.initialValueTexture) variable.initialValueTexture.dispose();\n      var renderTargets = variable.renderTargets;\n      for (var j = 0; j < renderTargets.length; j++) {\n        var renderTarget = renderTargets[j];\n        renderTarget.dispose();\n      }\n    }\n  };\n  function addResolutionDefine(materialShader) {\n    materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n  }\n  this.addResolutionDefine = addResolutionDefine;\n  function createShaderMaterial(computeFragmentShader, uniforms) {\n    uniforms = uniforms || {};\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: getPassThroughVertexShader(),\n      fragmentShader: computeFragmentShader\n    });\n    addResolutionDefine(material);\n    return material;\n  }\n  this.createShaderMaterial = createShaderMaterial;\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n    sizeXTexture = sizeXTexture || sizeX;\n    sizeYTexture = sizeYTexture || sizeY;\n    wrapS = wrapS || ClampToEdgeWrapping;\n    wrapT = wrapT || ClampToEdgeWrapping;\n    minFilter = minFilter || NearestFilter;\n    magFilter = magFilter || NearestFilter;\n    var renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n      wrapS: wrapS,\n      wrapT: wrapT,\n      minFilter: minFilter,\n      magFilter: magFilter,\n      format: RGBAFormat,\n      type: dataType,\n      depthBuffer: false\n    });\n    return renderTarget;\n  };\n  this.createTexture = function () {\n    var data = new Float32Array(sizeX * sizeY * 4);\n    var texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n    texture.needsUpdate = true;\n    return texture;\n  };\n  this.renderTexture = function (input, output) {\n    passThruUniforms.passThruTexture.value = input;\n    this.doRenderTarget(passThruShader, output);\n    passThruUniforms.passThruTexture.value = null;\n  };\n  this.doRenderTarget = function (material, output) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    var currentOutputColorSpace = renderer.outputColorSpace;\n    var currentToneMapping = renderer.toneMapping;\n    renderer.xr.enabled = false;\n    renderer.shadowMap.autoUpdate = false;\n    if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.encoding = 3e3;\n    renderer.toneMapping = NoToneMapping;\n    mesh.material = material;\n    renderer.setRenderTarget(output);\n    renderer.render(scene, camera);\n    mesh.material = passThruShader;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.outputColorSpace = currentOutputColorSpace;\n    renderer.toneMapping = currentToneMapping;\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n  function getPassThroughVertexShader() {\n    return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n  }\n  function getPassThroughFragmentShader() {\n    return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n  }\n});\nexport { GPUComputationRenderer };","map":{"version":3,"names":["FloatType","Scene","Camera","Mesh","PlaneGeometry","NearestFilter","ShaderMaterial","ClampToEdgeWrapping","WebGLRenderTarget","RGBAFormat","DataTexture","NoToneMapping","GPUComputationRenderer","_createClass","sizeX","sizeY","renderer","_classCallCheck","variables","currentTextureIndex","dataType","scene","camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","add","setDataType","type","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","has","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","dispose","geometry","renderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","format","depthBuffer","createTexture","data","Float32Array","needsUpdate","input","output","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentOutputColorSpace","outputColorSpace","currentToneMapping","toneMapping","encoding","setRenderTarget","render"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/misc/GPUComputationRenderer.js"],"sourcesContent":["import { FloatType, Scene, Camera, Mesh, PlaneGeometry, NearestFilter, ShaderMaterial, ClampToEdgeWrapping, WebGLRenderTarget, RGBAFormat, DataTexture, NoToneMapping } from \"three\";\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = [];\n    this.currentTextureIndex = 0;\n    let dataType = FloatType;\n    const scene = new Scene();\n    const camera = new Camera();\n    camera.position.z = 1;\n    const passThruUniforms = {\n      passThruTexture: { value: null }\n    };\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n    scene.add(mesh);\n    this.setDataType = function(type) {\n      dataType = type;\n      return this;\n    };\n    this.addVariable = function(variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader);\n      const variable = {\n        name: variableName,\n        initialValueTexture,\n        material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n      };\n      this.variables.push(variable);\n      return variable;\n    };\n    this.setVariableDependencies = function(variable, dependencies) {\n      variable.dependencies = dependencies;\n    };\n    this.init = function() {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n        return \"No OES_texture_float support for float textures.\";\n      }\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return \"No support for vertex shader textures.\";\n      }\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i];\n        variable.renderTargets[0] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter\n        );\n        variable.renderTargets[1] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter\n        );\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n        const material = variable.material;\n        const uniforms = material.uniforms;\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d];\n            if (depVar.name !== variable.name) {\n              let found = false;\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true;\n                  break;\n                }\n              }\n              if (!found) {\n                return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n              }\n            }\n            uniforms[depVar.name] = { value: null };\n            material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n          }\n        }\n      }\n      this.currentTextureIndex = 0;\n      return null;\n    };\n    this.compute = function() {\n      const currentTextureIndex = this.currentTextureIndex;\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i];\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms;\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d];\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n          }\n        }\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n      }\n      this.currentTextureIndex = nextTextureIndex;\n    };\n    this.getCurrentRenderTarget = function(variable) {\n      return variable.renderTargets[this.currentTextureIndex];\n    };\n    this.getAlternateRenderTarget = function(variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n    };\n    this.dispose = function() {\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n      const variables = this.variables;\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i];\n        if (variable.initialValueTexture)\n          variable.initialValueTexture.dispose();\n        const renderTargets = variable.renderTargets;\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j];\n          renderTarget.dispose();\n        }\n      }\n    };\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n    }\n    this.addResolutionDefine = addResolutionDefine;\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {};\n      const material = new ShaderMaterial({\n        uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader\n      });\n      addResolutionDefine(material);\n      return material;\n    }\n    this.createShaderMaterial = createShaderMaterial;\n    this.createRenderTarget = function(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX;\n      sizeYTexture = sizeYTexture || sizeY;\n      wrapS = wrapS || ClampToEdgeWrapping;\n      wrapT = wrapT || ClampToEdgeWrapping;\n      minFilter = minFilter || NearestFilter;\n      magFilter = magFilter || NearestFilter;\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS,\n        wrapT,\n        minFilter,\n        magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false\n      });\n      return renderTarget;\n    };\n    this.createTexture = function() {\n      const data = new Float32Array(sizeX * sizeY * 4);\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n      texture.needsUpdate = true;\n      return texture;\n    };\n    this.renderTexture = function(input, output) {\n      passThruUniforms.passThruTexture.value = input;\n      this.doRenderTarget(passThruShader, output);\n      passThruUniforms.passThruTexture.value = null;\n    };\n    this.doRenderTarget = function(material, output) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentOutputColorSpace = renderer.outputColorSpace;\n      const currentToneMapping = renderer.toneMapping;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"srgb-linear\";\n      else\n        renderer.encoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      mesh.material = material;\n      renderer.setRenderTarget(output);\n      renderer.render(scene, camera);\n      mesh.material = passThruShader;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.outputColorSpace = currentOutputColorSpace;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n    };\n    function getPassThroughVertexShader() {\n      return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n    }\n    function getPassThroughFragmentShader() {\n      return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n    }\n  }\n}\nexport {\n  GPUComputationRenderer\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}