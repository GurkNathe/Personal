{"ast":null,"code":"import { intersect, safeArrayPush } from '../utils.js';\nexport function create() {\n  return {\n    numberToDocumentId: new Map()\n  };\n}\nexport function insert(root, key, value) {\n  if (root.numberToDocumentId.has(key)) {\n    root.numberToDocumentId.get(key).push(value);\n    return root;\n  }\n  root.numberToDocumentId.set(key, [value]);\n  return root;\n}\nexport function find(root, key) {\n  var _root$numberToDocumen;\n  return (_root$numberToDocumen = root.numberToDocumentId.get(key)) !== null && _root$numberToDocumen !== void 0 ? _root$numberToDocumen : null;\n}\nexport function remove(root, key) {\n  if (root != null) {\n    root.numberToDocumentId.delete(key);\n  }\n  return root;\n}\nexport function removeDocument(root, id, key) {\n  var _ref;\n  var _root_numberToDocumentId_get, _root_numberToDocumentId_get1;\n  root === null || root === void 0 ? void 0 : root.numberToDocumentId.set(key, (_ref = (_root_numberToDocumentId_get = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get === void 0 ? void 0 : _root_numberToDocumentId_get.filter(v => v !== id)) !== null && _ref !== void 0 ? _ref : []);\n  if (((_root_numberToDocumentId_get1 = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get1 === void 0 ? void 0 : _root_numberToDocumentId_get1.length) === 0) {\n    root === null || root === void 0 ? void 0 : root.numberToDocumentId.delete(key);\n  }\n}\nexport function contains(node, key) {\n  return !(find(node, key) == null);\n}\nexport function getSize(root) {\n  let size = 0;\n  for (const [, value] of (_ref2 = root === null || root === void 0 ? void 0 : root.numberToDocumentId) !== null && _ref2 !== void 0 ? _ref2 : []) {\n    var _ref2;\n    size += value.length;\n  }\n  return size;\n}\nexport function filter(root, operation) {\n  const operationKeys = Object.keys(operation);\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation');\n  }\n  const operationType = operationKeys[0];\n  switch (operationType) {\n    case 'eq':\n      {\n        var _root$numberToDocumen2;\n        const value = operation[operationType];\n        return (_root$numberToDocumen2 = root.numberToDocumentId.get(value)) !== null && _root$numberToDocumen2 !== void 0 ? _root$numberToDocumen2 : [];\n      }\n    case 'in':\n      {\n        const value = operation[operationType];\n        const result = [];\n        for (const v of value) {\n          const ids = root.numberToDocumentId.get(v);\n          if (ids != null) {\n            safeArrayPush(result, ids);\n          }\n        }\n        return result;\n      }\n    case 'nin':\n      {\n        const value = operation[operationType];\n        const result = [];\n        const keys = root.numberToDocumentId.keys();\n        for (const key of keys) {\n          if (value.includes(key)) {\n            continue;\n          }\n          const ids = root.numberToDocumentId.get(key);\n          if (ids != null) {\n            safeArrayPush(result, ids);\n          }\n        }\n        return result;\n      }\n  }\n  throw new Error('Invalid operation');\n}\nexport function filterArr(root, operation) {\n  const operationKeys = Object.keys(operation);\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation');\n  }\n  const operationType = operationKeys[0];\n  switch (operationType) {\n    case 'containsAll':\n      {\n        const values = operation[operationType];\n        const ids = values.map(value => {\n          var _root$numberToDocumen3;\n          return (_root$numberToDocumen3 = root.numberToDocumentId.get(value)) !== null && _root$numberToDocumen3 !== void 0 ? _root$numberToDocumen3 : [];\n        });\n        return intersect(ids);\n      }\n  }\n  throw new Error('Invalid operation');\n}","map":{"version":3,"names":["intersect","safeArrayPush","create","numberToDocumentId","Map","insert","root","key","value","has","get","push","set","find","_root$numberToDocumen","remove","delete","removeDocument","id","_ref","_root_numberToDocumentId_get","_root_numberToDocumentId_get1","filter","v","length","contains","node","getSize","size","_ref2","operation","operationKeys","Object","keys","Error","operationType","_root$numberToDocumen2","result","ids","includes","filterArr","values","map","_root$numberToDocumen3"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/trees/flat.ts"],"sourcesContent":["import { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { EnumArrComparisonOperator, EnumComparisonOperator, Nullable, ScalarSearchableValue } from '../types.js'\nimport { intersect, safeArrayPush } from '../utils.js'\n\nexport interface FlatTree {\n  numberToDocumentId: Map<ScalarSearchableValue, InternalDocumentID[]>\n}\n\nexport function create (): FlatTree {\n  return {\n    numberToDocumentId: new Map()\n  }\n}\n\nexport function insert (root: FlatTree, key: ScalarSearchableValue, value: InternalDocumentID): FlatTree {\n  if (root.numberToDocumentId.has(key)) {\n    root.numberToDocumentId.get(key)!.push(value)\n    return root\n  }\n  root.numberToDocumentId.set(key, [value])\n  return root\n}\n\nexport function find (root: FlatTree, key: ScalarSearchableValue): Nullable<InternalDocumentID[]> {\n  return root.numberToDocumentId.get(key) ?? null\n}\n\nexport function remove (root: Nullable<FlatTree>, key: ScalarSearchableValue): Nullable<FlatTree> {\n  if (root != null) {\n    root.numberToDocumentId.delete(key)\n  }\n  return root\n}\nexport function removeDocument (root: FlatTree, id: InternalDocumentID, key: ScalarSearchableValue): void {\n  root?.numberToDocumentId.set(key, root?.numberToDocumentId.get(key)?.filter((v) => v !== id) ?? [])\n  if (root?.numberToDocumentId.get(key)?.length === 0) {\n    root?.numberToDocumentId.delete(key)\n  }\n}\n\nexport function contains (node: FlatTree, key: ScalarSearchableValue): boolean {\n  return !(find(node, key) == null)\n}\n\nexport function getSize (root: Nullable<FlatTree>): number {\n  let size = 0\n  for (const [, value] of root?.numberToDocumentId ?? []) {\n    size += value.length\n  }\n  return size\n}\nexport function filter (root: FlatTree, operation: EnumComparisonOperator): InternalDocumentID[] {\n  const operationKeys = Object.keys(operation)\n\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation')\n  }\n\n  const operationType = operationKeys[0] as keyof EnumComparisonOperator\n  switch (operationType) {\n    case 'eq': {\n      const value = operation[operationType]!\n      return root.numberToDocumentId.get(value) ?? []\n    }\n    case 'in': {\n      const value = operation[operationType]!\n      const result: InternalDocumentID[] = []\n      for (const v of value) {\n        const ids = root.numberToDocumentId.get(v)\n        if (ids != null) {\n          safeArrayPush(result, ids)\n        }\n      }\n      return result\n    }\n    case 'nin': {\n      const value = operation[operationType]!\n      const result: InternalDocumentID[] = []\n\n      const keys = root.numberToDocumentId.keys()\n      for (const key of keys) {\n        if (value.includes(key)) {\n          continue\n        }\n        const ids = root.numberToDocumentId.get(key)\n        if (ids != null) {\n          safeArrayPush(result, ids)\n        }\n      }\n      return result\n    }\n  }\n\n  throw new Error('Invalid operation')\n}\n\nexport function filterArr (root: FlatTree, operation: EnumArrComparisonOperator): InternalDocumentID[] {\n  const operationKeys = Object.keys(operation)\n\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation')\n  }\n\n  const operationType = operationKeys[0] as keyof EnumArrComparisonOperator\n  switch (operationType) {\n    case 'containsAll': {\n      const values = operation[operationType]!\n      const ids = values.map((value) => root.numberToDocumentId.get(value) ?? [])\n      return intersect(ids)\n    }\n  }\n\n  throw new Error('Invalid operation')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}