{"ast":null,"code":"import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityShader } from \"../shaders/LuminosityShader.js\";\nimport { ToneMapShader } from \"../shaders/ToneMapShader.js\";\nclass AdaptiveToneMappingPass extends Pass {\n  constructor(adaptive, resolution) {\n    super();\n    this.resolution = resolution !== void 0 ? resolution : 256;\n    this.needsInit = true;\n    this.adaptive = adaptive !== void 0 ? !!adaptive : true;\n    this.luminanceRT = null;\n    this.previousLuminanceRT = null;\n    this.currentLuminanceRT = null;\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false\n    });\n    this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2)).toFixed(1)\n      },\n      uniforms: {\n        lastLum: {\n          value: null\n        },\n        currentLum: {\n          value: null\n        },\n        minLuminance: {\n          value: 0.01\n        },\n        delta: {\n          value: 0.016\n        },\n        tau: {\n          value: 1\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D lastLum;\n\t\t\t\tuniform sampler2D currentLum;\n\t\t\t\tuniform float minLuminance;\n\t\t\t\tuniform float delta;\n\t\t\t\tuniform float tau;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\n\t\t\t\t\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\n\n\t\t\t\t\tfloat fLastLum = max( minLuminance, lastLum.r );\n\t\t\t\t\tfloat fCurrentLum = max( minLuminance, currentLum.r );\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\tfCurrentLum *= fCurrentLum;\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\n\t\t\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t\t\t}`\n    };\n    this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n      vertexShader: this.adaptLuminanceShader.vertexShader,\n      fragmentShader: this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, this.adaptLuminanceShader.defines),\n      blending: NoBlending\n    });\n    this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.fsQuad = new FullScreenQuad(null);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n    if (this.adaptive) {\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  }\n  reset() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n    this.previousLuminanceRT.texture.generateMipmaps = false;\n    const pars = {\n      minFilter: LinearMipmapLinearFilter,\n      generateMipmaps: true\n    };\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n    if (this.adaptive) {\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    }\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 7829367\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  }\n  setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  }\n  setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  }\n  setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  }\n  setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  }\n  dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n}\nexport { AdaptiveToneMappingPass };","map":{"version":3,"names":["UniformsUtils","ShaderMaterial","NoBlending","WebGLRenderTarget","LinearMipmapLinearFilter","MeshBasicMaterial","Pass","FullScreenQuad","CopyShader","LuminosityShader","ToneMapShader","AdaptiveToneMappingPass","constructor","adaptive","resolution","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","copyShader","copyUniforms","clone","uniforms","materialCopy","vertexShader","fragmentShader","blending","depthTest","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","materialAdaptiveLum","Object","assign","materialToneMap","fsQuad","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","name","generateMipmaps","pars","minFilter","luminanceMap","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js"],"sourcesContent":["import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityShader } from \"../shaders/LuminosityShader.js\";\nimport { ToneMapShader } from \"../shaders/ToneMapShader.js\";\nclass AdaptiveToneMappingPass extends Pass {\n  constructor(adaptive, resolution) {\n    super();\n    this.resolution = resolution !== void 0 ? resolution : 256;\n    this.needsInit = true;\n    this.adaptive = adaptive !== void 0 ? !!adaptive : true;\n    this.luminanceRT = null;\n    this.previousLuminanceRT = null;\n    this.currentLuminanceRT = null;\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false\n    });\n    this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2)).toFixed(1)\n      },\n      uniforms: {\n        lastLum: { value: null },\n        currentLum: { value: null },\n        minLuminance: { value: 0.01 },\n        delta: { value: 0.016 },\n        tau: { value: 1 }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D lastLum;\n\t\t\t\tuniform sampler2D currentLum;\n\t\t\t\tuniform float minLuminance;\n\t\t\t\tuniform float delta;\n\t\t\t\tuniform float tau;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\n\t\t\t\t\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\n\n\t\t\t\t\tfloat fLastLum = max( minLuminance, lastLum.r );\n\t\t\t\t\tfloat fCurrentLum = max( minLuminance, currentLum.r );\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\tfCurrentLum *= fCurrentLum;\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\n\t\t\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t\t\t}`\n    };\n    this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n      vertexShader: this.adaptLuminanceShader.vertexShader,\n      fragmentShader: this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, this.adaptLuminanceShader.defines),\n      blending: NoBlending\n    });\n    this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.fsQuad = new FullScreenQuad(null);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n    if (this.adaptive) {\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear)\n        renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  }\n  reset() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n    this.previousLuminanceRT.texture.generateMipmaps = false;\n    const pars = { minFilter: LinearMipmapLinearFilter, generateMipmaps: true };\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n    if (this.adaptive) {\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    }\n    this.fsQuad.material = new MeshBasicMaterial({ color: 7829367 });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  }\n  setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  }\n  setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  }\n  setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  }\n  setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  }\n  dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n}\nexport {\n  AdaptiveToneMappingPass\n};\n"],"mappings":"AAAA,SAASA,aAAa,EAAEC,cAAc,EAAEC,UAAU,EAAEC,iBAAiB,EAAEC,wBAAwB,EAAEC,iBAAiB,QAAQ,OAAO;AACjI,SAASC,IAAI,EAAEC,cAAc,QAAQ,WAAW;AAChD,SAASC,UAAU,QAAQ,0BAA0B;AACrD,SAASC,gBAAgB,QAAQ,gCAAgC;AACjE,SAASC,aAAa,QAAQ,6BAA6B;AAC3D,MAAMC,uBAAuB,SAASL,IAAI,CAAC;EACzCM,WAAWA,CAACC,QAAQ,EAAEC,UAAU,EAAE;IAChC,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,UAAU,GAAGA,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAG,GAAG;IAC1D,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACF,QAAQ,GAAGA,QAAQ,KAAK,KAAK,CAAC,GAAG,CAAC,CAACA,QAAQ,GAAG,IAAI;IACvD,IAAI,CAACG,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACC,kBAAkB,GAAG,IAAI;IAC9B,MAAMC,UAAU,GAAGX,UAAU;IAC7B,IAAI,CAACY,YAAY,GAAGpB,aAAa,CAACqB,KAAK,CAACF,UAAU,CAACG,QAAQ,CAAC;IAC5D,IAAI,CAACC,YAAY,GAAG,IAAItB,cAAc,CAAC;MACrCqB,QAAQ,EAAE,IAAI,CAACF,YAAY;MAC3BI,YAAY,EAAEL,UAAU,CAACK,YAAY;MACrCC,cAAc,EAAEN,UAAU,CAACM,cAAc;MACzCC,QAAQ,EAAExB,UAAU;MACpByB,SAAS,EAAE;IACb,CAAC,CAAC;IACF,IAAI,CAACC,iBAAiB,GAAG,IAAI3B,cAAc,CAAC;MAC1CqB,QAAQ,EAAEtB,aAAa,CAACqB,KAAK,CAACZ,gBAAgB,CAACa,QAAQ,CAAC;MACxDE,YAAY,EAAEf,gBAAgB,CAACe,YAAY;MAC3CC,cAAc,EAAEhB,gBAAgB,CAACgB,cAAc;MAC/CC,QAAQ,EAAExB;IACZ,CAAC,CAAC;IACF,IAAI,CAAC2B,oBAAoB,GAAG;MAC1BC,OAAO,EAAE;QACPC,aAAa,EAAE,CAACC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACnB,UAAU,CAAC,GAAGkB,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,EAAEC,OAAO,CAAC,CAAC;MACpE,CAAC;MACDZ,QAAQ,EAAE;QACRa,OAAO,EAAE;UAAEC,KAAK,EAAE;QAAK,CAAC;QACxBC,UAAU,EAAE;UAAED,KAAK,EAAE;QAAK,CAAC;QAC3BE,YAAY,EAAE;UAAEF,KAAK,EAAE;QAAK,CAAC;QAC7BG,KAAK,EAAE;UAAEH,KAAK,EAAE;QAAM,CAAC;QACvBI,GAAG,EAAE;UAAEJ,KAAK,EAAE;QAAE;MAClB,CAAC;MACDZ,YAAY,EAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;MACAC,cAAc,EAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,CAAC;IACD,IAAI,CAACgB,mBAAmB,GAAG,IAAIxC,cAAc,CAAC;MAC5CqB,QAAQ,EAAEtB,aAAa,CAACqB,KAAK,CAAC,IAAI,CAACQ,oBAAoB,CAACP,QAAQ,CAAC;MACjEE,YAAY,EAAE,IAAI,CAACK,oBAAoB,CAACL,YAAY;MACpDC,cAAc,EAAE,IAAI,CAACI,oBAAoB,CAACJ,cAAc;MACxDK,OAAO,EAAEY,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACd,oBAAoB,CAACC,OAAO,CAAC;MAC7DJ,QAAQ,EAAExB;IACZ,CAAC,CAAC;IACF,IAAI,CAAC0C,eAAe,GAAG,IAAI3C,cAAc,CAAC;MACxCqB,QAAQ,EAAEtB,aAAa,CAACqB,KAAK,CAACX,aAAa,CAACY,QAAQ,CAAC;MACrDE,YAAY,EAAEd,aAAa,CAACc,YAAY;MACxCC,cAAc,EAAEf,aAAa,CAACe,cAAc;MAC5CC,QAAQ,EAAExB;IACZ,CAAC,CAAC;IACF,IAAI,CAAC2C,MAAM,GAAG,IAAItC,cAAc,CAAC,IAAI,CAAC;EACxC;EACAuC,MAAMA,CAACC,QAAQ,EAAEC,WAAW,EAAEC,UAAU,EAAEC,SAAS,EAAE;IACnD,IAAI,IAAI,CAACnC,SAAS,EAAE;MAClB,IAAI,CAACoC,KAAK,CAACJ,QAAQ,CAAC;MACpB,IAAI,CAAC/B,WAAW,CAACoC,OAAO,CAACC,IAAI,GAAGJ,UAAU,CAACG,OAAO,CAACC,IAAI;MACvD,IAAI,CAACpC,mBAAmB,CAACmC,OAAO,CAACC,IAAI,GAAGJ,UAAU,CAACG,OAAO,CAACC,IAAI;MAC/D,IAAI,CAACnC,kBAAkB,CAACkC,OAAO,CAACC,IAAI,GAAGJ,UAAU,CAACG,OAAO,CAACC,IAAI;MAC9D,IAAI,CAACtC,SAAS,GAAG,KAAK;IACxB;IACA,IAAI,IAAI,CAACF,QAAQ,EAAE;MACjB,IAAI,CAACgC,MAAM,CAACS,QAAQ,GAAG,IAAI,CAAC1B,iBAAiB;MAC7C,IAAI,CAACA,iBAAiB,CAACN,QAAQ,CAACiC,QAAQ,CAACnB,KAAK,GAAGa,UAAU,CAACG,OAAO;MACnEL,QAAQ,CAACS,eAAe,CAAC,IAAI,CAACtC,kBAAkB,CAAC;MACjD,IAAI,CAAC2B,MAAM,CAACC,MAAM,CAACC,QAAQ,CAAC;MAC5B,IAAI,CAACF,MAAM,CAACS,QAAQ,GAAG,IAAI,CAACb,mBAAmB;MAC/C,IAAI,CAACA,mBAAmB,CAACnB,QAAQ,CAACiB,KAAK,CAACH,KAAK,GAAGc,SAAS;MACzD,IAAI,CAACT,mBAAmB,CAACnB,QAAQ,CAACa,OAAO,CAACC,KAAK,GAAG,IAAI,CAACnB,mBAAmB,CAACmC,OAAO;MAClF,IAAI,CAACX,mBAAmB,CAACnB,QAAQ,CAACe,UAAU,CAACD,KAAK,GAAG,IAAI,CAAClB,kBAAkB,CAACkC,OAAO;MACpFL,QAAQ,CAACS,eAAe,CAAC,IAAI,CAACxC,WAAW,CAAC;MAC1C,IAAI,CAAC6B,MAAM,CAACC,MAAM,CAACC,QAAQ,CAAC;MAC5B,IAAI,CAACF,MAAM,CAACS,QAAQ,GAAG,IAAI,CAAC/B,YAAY;MACxC,IAAI,CAACH,YAAY,CAACmC,QAAQ,CAACnB,KAAK,GAAG,IAAI,CAACpB,WAAW,CAACoC,OAAO;MAC3DL,QAAQ,CAACS,eAAe,CAAC,IAAI,CAACvC,mBAAmB,CAAC;MAClD,IAAI,CAAC4B,MAAM,CAACC,MAAM,CAACC,QAAQ,CAAC;IAC9B;IACA,IAAI,CAACF,MAAM,CAACS,QAAQ,GAAG,IAAI,CAACV,eAAe;IAC3C,IAAI,CAACA,eAAe,CAACtB,QAAQ,CAACiC,QAAQ,CAACnB,KAAK,GAAGa,UAAU,CAACG,OAAO;IACjE,IAAI,IAAI,CAACK,cAAc,EAAE;MACvBV,QAAQ,CAACS,eAAe,CAAC,IAAI,CAAC;MAC9B,IAAI,CAACX,MAAM,CAACC,MAAM,CAACC,QAAQ,CAAC;IAC9B,CAAC,MAAM;MACLA,QAAQ,CAACS,eAAe,CAACR,WAAW,CAAC;MACrC,IAAI,IAAI,CAACU,KAAK,EACZX,QAAQ,CAACW,KAAK,CAAC,CAAC;MAClB,IAAI,CAACb,MAAM,CAACC,MAAM,CAACC,QAAQ,CAAC;IAC9B;EACF;EACAI,KAAKA,CAAA,EAAG;IACN,IAAI,IAAI,CAACnC,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAAC2C,OAAO,CAAC,CAAC;IAC5B;IACA,IAAI,IAAI,CAACzC,kBAAkB,EAAE;MAC3B,IAAI,CAACA,kBAAkB,CAACyC,OAAO,CAAC,CAAC;IACnC;IACA,IAAI,IAAI,CAAC1C,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAAC0C,OAAO,CAAC,CAAC;IACpC;IACA,IAAI,CAAC3C,WAAW,GAAG,IAAIb,iBAAiB,CAAC,IAAI,CAACW,UAAU,EAAE,IAAI,CAACA,UAAU,CAAC;IAC1E,IAAI,CAACE,WAAW,CAACoC,OAAO,CAACQ,IAAI,GAAG,2BAA2B;IAC3D,IAAI,CAAC5C,WAAW,CAACoC,OAAO,CAACS,eAAe,GAAG,KAAK;IAChD,IAAI,CAAC5C,mBAAmB,GAAG,IAAId,iBAAiB,CAAC,IAAI,CAACW,UAAU,EAAE,IAAI,CAACA,UAAU,CAAC;IAClF,IAAI,CAACG,mBAAmB,CAACmC,OAAO,CAACQ,IAAI,GAAG,4BAA4B;IACpE,IAAI,CAAC3C,mBAAmB,CAACmC,OAAO,CAACS,eAAe,GAAG,KAAK;IACxD,MAAMC,IAAI,GAAG;MAAEC,SAAS,EAAE3D,wBAAwB;MAAEyD,eAAe,EAAE;IAAK,CAAC;IAC3E,IAAI,CAAC3C,kBAAkB,GAAG,IAAIf,iBAAiB,CAAC,IAAI,CAACW,UAAU,EAAE,IAAI,CAACA,UAAU,EAAEgD,IAAI,CAAC;IACvF,IAAI,CAAC5C,kBAAkB,CAACkC,OAAO,CAACQ,IAAI,GAAG,4BAA4B;IACnE,IAAI,IAAI,CAAC/C,QAAQ,EAAE;MACjB,IAAI,CAAC+B,eAAe,CAACd,OAAO,CAAC,mBAAmB,CAAC,GAAG,EAAE;MACtD,IAAI,CAACc,eAAe,CAACtB,QAAQ,CAAC0C,YAAY,CAAC5B,KAAK,GAAG,IAAI,CAACpB,WAAW,CAACoC,OAAO;IAC7E;IACA,IAAI,CAACP,MAAM,CAACS,QAAQ,GAAG,IAAIjD,iBAAiB,CAAC;MAAE4D,KAAK,EAAE;IAAQ,CAAC,CAAC;IAChE,IAAI,CAACrC,iBAAiB,CAACsC,WAAW,GAAG,IAAI;IACzC,IAAI,CAACzB,mBAAmB,CAACyB,WAAW,GAAG,IAAI;IAC3C,IAAI,CAACtB,eAAe,CAACsB,WAAW,GAAG,IAAI;EACzC;EACAC,WAAWA,CAACtD,QAAQ,EAAE;IACpB,IAAIA,QAAQ,EAAE;MACZ,IAAI,CAACA,QAAQ,GAAG,IAAI;MACpB,IAAI,CAAC+B,eAAe,CAACd,OAAO,CAAC,mBAAmB,CAAC,GAAG,EAAE;MACtD,IAAI,CAACc,eAAe,CAACtB,QAAQ,CAAC0C,YAAY,CAAC5B,KAAK,GAAG,IAAI,CAACpB,WAAW,CAACoC,OAAO;IAC7E,CAAC,MAAM;MACL,IAAI,CAACvC,QAAQ,GAAG,KAAK;MACrB,OAAO,IAAI,CAAC+B,eAAe,CAACd,OAAO,CAAC,mBAAmB,CAAC;MACxD,IAAI,CAACc,eAAe,CAACtB,QAAQ,CAAC0C,YAAY,CAAC5B,KAAK,GAAG,IAAI;IACzD;IACA,IAAI,CAACQ,eAAe,CAACsB,WAAW,GAAG,IAAI;EACzC;EACAE,eAAeA,CAACC,IAAI,EAAE;IACpB,IAAIA,IAAI,EAAE;MACR,IAAI,CAAC5B,mBAAmB,CAACnB,QAAQ,CAACkB,GAAG,CAACJ,KAAK,GAAGJ,IAAI,CAACsC,GAAG,CAACD,IAAI,CAAC;IAC9D;EACF;EACAE,eAAeA,CAACC,MAAM,EAAE;IACtB,IAAIA,MAAM,EAAE;MACV,IAAI,CAAC5B,eAAe,CAACtB,QAAQ,CAACgB,YAAY,CAACF,KAAK,GAAGoC,MAAM;MACzD,IAAI,CAAC/B,mBAAmB,CAACnB,QAAQ,CAACgB,YAAY,CAACF,KAAK,GAAGoC,MAAM;IAC/D;EACF;EACAC,eAAeA,CAACC,MAAM,EAAE;IACtB,IAAIA,MAAM,EAAE;MACV,IAAI,CAAC9B,eAAe,CAACtB,QAAQ,CAACqD,YAAY,CAACvC,KAAK,GAAGsC,MAAM;IAC3D;EACF;EACAE,mBAAmBA,CAACC,MAAM,EAAE;IAC1B,IAAIA,MAAM,EAAE;MACV,IAAI,CAACjC,eAAe,CAACtB,QAAQ,CAACwD,gBAAgB,CAAC1C,KAAK,GAAGyC,MAAM;IAC/D;EACF;EACAE,aAAaA,CAACC,UAAU,EAAE;IACxB,IAAIA,UAAU,EAAE;MACd,IAAI,CAACpC,eAAe,CAACtB,QAAQ,CAAC0D,UAAU,CAAC5C,KAAK,GAAG4C,UAAU;IAC7D;EACF;EACArB,OAAOA,CAAA,EAAG;IACR,IAAI,IAAI,CAAC3C,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAAC2C,OAAO,CAAC,CAAC;IAC5B;IACA,IAAI,IAAI,CAAC1C,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAAC0C,OAAO,CAAC,CAAC;IACpC;IACA,IAAI,IAAI,CAACzC,kBAAkB,EAAE;MAC3B,IAAI,CAACA,kBAAkB,CAACyC,OAAO,CAAC,CAAC;IACnC;IACA,IAAI,IAAI,CAAC/B,iBAAiB,EAAE;MAC1B,IAAI,CAACA,iBAAiB,CAAC+B,OAAO,CAAC,CAAC;IAClC;IACA,IAAI,IAAI,CAAClB,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAACkB,OAAO,CAAC,CAAC;IACpC;IACA,IAAI,IAAI,CAACpC,YAAY,EAAE;MACrB,IAAI,CAACA,YAAY,CAACoC,OAAO,CAAC,CAAC;IAC7B;IACA,IAAI,IAAI,CAACf,eAAe,EAAE;MACxB,IAAI,CAACA,eAAe,CAACe,OAAO,CAAC,CAAC;IAChC;EACF;AACF;AACA,SACEhD,uBAAuB"},"metadata":{},"sourceType":"module","externalDependencies":[]}