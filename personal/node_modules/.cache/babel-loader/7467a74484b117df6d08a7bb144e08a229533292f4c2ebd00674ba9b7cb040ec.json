{"ast":null,"code":"import { createError } from '../errors.js';\nimport { uniqueId, formatNanoseconds } from '../utils.js';\nexport { getDocumentProperties } from '../utils.js';\nexport async function formatElapsedTime(n) {\n  return {\n    raw: Number(n),\n    formatted: await formatNanoseconds(n)\n  };\n}\nexport async function getDocumentIndexId(doc) {\n  if (doc.id) {\n    if (typeof doc.id !== 'string') {\n      throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);\n    }\n    return doc.id;\n  }\n  return await uniqueId();\n}\nexport async function validateSchema(doc, schema) {\n  for (const [prop, type] of Object.entries(schema)) {\n    const value = doc[prop];\n    const typeOfValue = typeof value;\n    if (typeOfValue === 'undefined') {\n      continue;\n    }\n    const typeOfType = typeof type;\n    if (typeOfType === 'string' && isArrayType(type)) {\n      if (!Array.isArray(value)) {\n        return prop;\n      }\n      const expectedType = getInnerType(type);\n      const valueLength = value.length;\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== expectedType) {\n          return prop + '.' + i;\n        }\n      }\n      continue;\n    }\n    if (typeOfType === 'object') {\n      if (!value || typeOfValue !== 'object') {\n        return prop;\n      }\n      const subProp = await validateSchema(value, type);\n      if (subProp) {\n        return prop + '.' + subProp;\n      }\n      continue;\n    }\n    if (typeOfValue !== type) {\n      return prop;\n    }\n  }\n  return undefined;\n}\nconst IS_ARRAY_TYPE = {\n  string: false,\n  number: false,\n  boolean: false,\n  'string[]': true,\n  'number[]': true,\n  'boolean[]': true\n};\nconst INNER_TYPE = {\n  'string[]': 'string',\n  'number[]': 'number',\n  'boolean[]': 'boolean'\n};\nexport function isArrayType(type) {\n  return IS_ARRAY_TYPE[type];\n}\nexport function getInnerType(type) {\n  return INNER_TYPE[type];\n}","map":{"version":3,"names":["createError","uniqueId","formatNanoseconds","getDocumentProperties","formatElapsedTime","n","raw","Number","formatted","getDocumentIndexId","doc","id","validateSchema","schema","prop","type","Object","entries","value","typeOfValue","typeOfType","isArrayType","Array","isArray","expectedType","getInnerType","valueLength","length","i","subProp","undefined","IS_ARRAY_TYPE","string","number","boolean","INNER_TYPE"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.0.3/node_modules/@orama/orama/src/components/defaults.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { ArraySearchableType, Document, ElapsedTime, ScalarSearchableType, Schema, SearchableType } from '../types.js'\nimport { uniqueId, formatNanoseconds } from '../utils.js'\n\nexport { getDocumentProperties } from '../utils.js'\n\nexport async function formatElapsedTime(n: bigint): Promise<ElapsedTime> {\n  return {\n    raw: Number(n),\n    formatted: await formatNanoseconds(n),\n  }\n}\n\nexport async function getDocumentIndexId(doc: Document): Promise<string> {\n  if (doc.id) {\n    if (typeof doc.id !== 'string') {\n      throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id)\n    }\n\n    return doc.id\n  }\n\n  return await uniqueId()\n}\n\nexport async function validateSchema<S extends Schema = Schema>(doc: Document, schema: S): Promise<string | undefined> {\n  for (const [prop, type] of Object.entries(schema)) {\n    const value = doc[prop]\n    const typeOfValue = typeof value\n\n    if (typeOfValue === 'undefined') {\n      continue\n    }\n\n    const typeOfType = typeof type\n\n    if (typeOfType === 'string' && isArrayType(type as SearchableType)) {\n      if (!Array.isArray(value)) {\n        return prop\n      }\n      const expectedType = getInnerType(type as ArraySearchableType)\n\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== expectedType) {\n          return prop + '.' + i\n        }\n      }\n\n      continue\n    }\n\n    if (typeOfType === 'object') {\n      if (!value || typeOfValue !== 'object') {\n        return prop\n      }\n\n      const subProp = await validateSchema(value as Document, type as Schema)\n      if (subProp) {\n        return prop + '.' + subProp\n      }\n      continue\n    }\n\n    if (typeOfValue !== type) {\n      return prop\n    }\n  }\n\n  return undefined\n}\n\nconst IS_ARRAY_TYPE: Record<SearchableType, boolean> = {\n  string: false,\n  number: false,\n  boolean: false,\n  'string[]': true,\n  'number[]': true,\n  'boolean[]': true,\n}\nconst INNER_TYPE: Record<ArraySearchableType, ScalarSearchableType> = {\n  'string[]': 'string',\n  'number[]': 'number',\n  'boolean[]': 'boolean',\n}\nexport function isArrayType(type: SearchableType) {\n  return IS_ARRAY_TYPE[type]\n}\nexport function getInnerType(type: ArraySearchableType): ScalarSearchableType {\n  return INNER_TYPE[type]\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ;AAE5B,SAASC,QAAQ,EAAEC,iBAAiB,QAAQ;AAE5C,SAASC,qBAAqB,QAAQ;AAEtC,OAAO,eAAeC,kBAAkBC,CAAS,EAAwB;EACvE,OAAO;IACLC,GAAA,EAAKC,MAAA,CAAOF,CAAA;IACZG,SAAA,EAAW,MAAMN,iBAAA,CAAkBG,CAAA;EACrC;AACF;AAEA,OAAO,eAAeI,mBAAmBC,GAAa,EAAmB;EACvE,IAAIA,GAAA,CAAIC,EAAE,EAAE;IACV,IAAI,OAAOD,GAAA,CAAIC,EAAE,KAAK,UAAU;MAC9B,MAAMX,WAAA,CAAY,8BAA8B,OAAOU,GAAA,CAAIC,EAAE;IAC/D;IAEA,OAAOD,GAAA,CAAIC,EAAE;EACf;EAEA,OAAO,MAAMV,QAAA;AACf;AAEA,OAAO,eAAeW,eAA0CF,GAAa,EAAEG,MAAS,EAA+B;EACrH,KAAK,MAAM,CAACC,IAAA,EAAMC,IAAA,CAAK,IAAIC,MAAA,CAAOC,OAAO,CAACJ,MAAA,GAAS;IACjD,MAAMK,KAAA,GAAQR,GAAG,CAACI,IAAA,CAAK;IACvB,MAAMK,WAAA,GAAc,OAAOD,KAAA;IAE3B,IAAIC,WAAA,KAAgB,aAAa;MAC/B;IACF;IAEA,MAAMC,UAAA,GAAa,OAAOL,IAAA;IAE1B,IAAIK,UAAA,KAAe,YAAYC,WAAA,CAAYN,IAAA,GAAyB;MAClE,IAAI,CAACO,KAAA,CAAMC,OAAO,CAACL,KAAA,GAAQ;QACzB,OAAOJ,IAAA;MACT;MACA,MAAMU,YAAA,GAAeC,YAAA,CAAaV,IAAA;MAElC,MAAMW,WAAA,GAAcR,KAAA,CAAMS,MAAM;MAChC,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,WAAA,EAAaE,CAAA,IAAK;QACpC,IAAI,OAAOV,KAAK,CAACU,CAAA,CAAE,KAAKJ,YAAA,EAAc;UACpC,OAAOV,IAAA,GAAO,MAAMc,CAAA;QACtB;MACF;MAEA;IACF;IAEA,IAAIR,UAAA,KAAe,UAAU;MAC3B,IAAI,CAACF,KAAA,IAASC,WAAA,KAAgB,UAAU;QACtC,OAAOL,IAAA;MACT;MAEA,MAAMe,OAAA,GAAU,MAAMjB,cAAA,CAAeM,KAAA,EAAmBH,IAAA;MACxD,IAAIc,OAAA,EAAS;QACX,OAAOf,IAAA,GAAO,MAAMe,OAAA;MACtB;MACA;IACF;IAEA,IAAIV,WAAA,KAAgBJ,IAAA,EAAM;MACxB,OAAOD,IAAA;IACT;EACF;EAEA,OAAOgB,SAAA;AACT;AAEA,MAAMC,aAAA,GAAiD;EACrDC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACbC,OAAA,EAAS,KAAK;EACd,YAAY,IAAI;EAChB,YAAY,IAAI;EAChB,aAAa;AACf;AACA,MAAMC,UAAA,GAAgE;EACpE,YAAY;EACZ,YAAY;EACZ,aAAa;AACf;AACA,OAAO,SAASd,YAAYN,IAAoB,EAAE;EAChD,OAAOgB,aAAa,CAAChB,IAAA,CAAK;AAC5B;AACA,OAAO,SAASU,aAAaV,IAAyB,EAAwB;EAC5E,OAAOoB,UAAU,CAACpB,IAAA,CAAK;AACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}