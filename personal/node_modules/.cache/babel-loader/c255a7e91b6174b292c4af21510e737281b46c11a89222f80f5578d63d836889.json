{"ast":null,"code":"export const kInsertions = Symbol('orama.insertions');\nexport const kRemovals = Symbol('orama.removals');","map":{"version":3,"names":["kInsertions","Symbol","kRemovals"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/types.ts"],"sourcesContent":["import { DocumentsStore } from './components/documents-store.js'\nimport { Index } from './components/index.js'\nimport { DocumentID, InternalDocumentID, InternalDocumentIDStore } from './components/internal-document-id-store.js'\nimport { Sorter } from './components/sorter.js'\nimport { Language } from './components/tokenizer/languages.js'\n\nexport type Nullable<T> = T | null\n\nexport type SingleOrArray<T> = T | T[]\n\nexport type SyncOrAsyncValue<T = void> = T | PromiseLike<T>\n\n// Given a type T, return a new type with:\n// - the concatenation of nested properties as key\n// - the type of the nested property as value\ntype Flatten<T extends object> = object extends T\n  ? object\n  : {\n    [K in keyof T]-?: (\n      // Create a function as argument:\n      // - Pick<T, K> if the value is not an object (not run recursion)\n      // - { [key concatenation]: function calculated by recursion }\n      // - never is the value is an array\n      x: NonNullable<T[K]> extends infer V\n          ? V extends object\n            ? V extends readonly any[]\n              ? never // Orama schema doens't allow array as value\n              : Flatten<V> extends infer FV\n              ? {\n                  [P in keyof FV as `${Extract<K, string>}.${Extract<P, string>}`]: FV[P]\n                }\n              : never // Never happen: it is needed due to `extends` typescript syntax\n            : Pick<T, K>\n          : never, // Never happen: it is needed due to typescript syntax\n      ) => void\n  } extends Record<keyof T, (y: infer O) => void>\n  ? O // Return the type of the function argument\n  : never // Never happen: it is needed due to typescript syntax\n\n\nexport type SchemaTypes<Value> = Value extends 'string'\n  ? string\n  : Value extends 'string[]'\n  ? string[]\n  : Value extends 'boolean'\n  ? boolean\n  : Value extends 'boolean[]'\n  ? boolean[]\n  : Value extends 'number'\n  ? number\n  : Value extends 'number[]'\n  ? number[]\n  : Value extends 'enum'\n  ? string | number\n  : Value extends 'enum[]'\n  ? (string | number)[]\n  : // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Value extends `vector[${number}]`\n  ? number[]\n  : Value extends object\n  ? { [Key in keyof Value]: SchemaTypes<Value[Key]> } & {\n      [otherKeys: PropertyKey]: any\n    }\n  : never\n\nexport type Schema<TSchema> = TSchema extends AnySchema\n  ? InternalTypedDocument<{\n      -readonly [Key in keyof TSchema]: SchemaTypes<TSchema[Key]>\n    }>\n  : never\n\nexport type AnyDocument = InternalTypedDocument<any>\n\nexport type InternalTypedDocument<TSchema extends object> = { id: DocumentID } & TSchema & {\n    [otherKeys: PropertyKey]: any\n  }\nexport type TypedDocument<T extends AnyOrama> = T['typeSchema']\n\nexport type AnySchema = {\n  [key: PropertyKey]: SearchableType | AnySchema\n}\n\nexport type PartialSchemaDeepObject<T> = T extends object\n  ? {\n      [K in keyof T]?: T[K]\n    }\n  : T\n\nexport type PartialSchemaDeep<T> = {\n  [K in keyof T]?: PartialSchemaDeepObject<T[K]>\n}\n\n/**\n * @deprecated\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Document extends Record<string, SearchableValue | Document | unknown> {}\n\nexport type Magnitude = number\nexport type Vector = `vector[${number}]`\nexport type VectorType = Float32Array\n\nexport type ScalarSearchableType = 'string' | 'number' | 'boolean' | 'enum'\nexport type ArraySearchableType = 'string[]' | 'number[]' | 'boolean[]' | 'enum[]' | Vector\n\nexport type SearchableType = ScalarSearchableType | ArraySearchableType\n\nexport type ScalarSearchableValue = string | number | boolean\nexport type ArraySearchableValue = string[] | number[] | boolean[] | VectorType\nexport type SearchableValue = ScalarSearchableValue | ArraySearchableValue\n\nexport type SortType = 'string' | 'number' | 'boolean'\nexport type SortValue = string | number | boolean\n\nexport type VectorIndex = {\n  size: number\n  vectors: {\n    [docID: string]: [Magnitude, VectorType]\n  }\n}\n\nexport type BM25Params = {\n  k?: number\n  b?: number\n  d?: number\n}\n\nexport type FacetSorting = 'asc' | 'desc' | 'ASC' | 'DESC'\n\nexport interface StringFacetDefinition {\n  limit?: number\n  offset?: number\n  sort?: FacetSorting\n}\n\nexport interface NumberFacetDefinition {\n  ranges: { from: number; to: number }[]\n}\n\nexport interface BooleanFacetDefinition {\n  true?: boolean\n  false?: boolean\n}\n\nexport type FacetsParams<T extends AnyOrama> = Partial<Record<LiteralUnion<T['schema']>, FacetDefinition>>\n\nexport type FacetDefinition = StringFacetDefinition | NumberFacetDefinition | BooleanFacetDefinition\n\nexport type ReduceFunction<T, R> = (values: ScalarSearchableValue[], acc: T, value: R, index: number) => T\nexport type Reduce<T, R = AnyDocument> = {\n  reducer: ReduceFunction<T, R>\n  getInitialValue: (elementCount: number) => T\n}\n\nexport type GroupByParams<T extends AnyOrama, ResultDocument> = {\n  properties: LiteralUnion<T['schema']>[]\n  maxResult?: number\n  reduce?: Reduce<ResultDocument>\n}\n\nexport type ComparisonOperator = {\n  gt?: number\n  gte?: number\n  lt?: number\n  lte?: number\n  eq?: number\n  between?: [number, number]\n}\n\nexport type EnumComparisonOperator = {\n  eq?: string | number | boolean\n  in?: (string | number | boolean)[]\n  nin?: (string | number | boolean)[]\n}\n\nexport type EnumArrComparisonOperator = {\n  containsAll ?: (string | number | boolean)[]\n}\n\nexport type Operator<Value> = Value extends 'string'\n  ? (string | string[])\n  : Value extends 'string[]'\n  ? (string | string[])\n  : Value extends 'boolean'\n  ? boolean\n  : Value extends 'boolean[]'\n  ? boolean\n  : Value extends 'number'\n  ? ComparisonOperator\n  : Value extends 'number[]'\n  ? ComparisonOperator\n  : Value extends 'enum'\n  ? EnumComparisonOperator\n  : Value extends 'enum[]'\n  ? EnumArrComparisonOperator\n  : never\nexport type WhereCondition<TSchema> = {\n  [key in keyof TSchema]?: Operator<TSchema[key]>\n}\n\n/**\n * A custom sorter function item as [id, score, document].\n */\nexport type CustomSorterFunctionItem<ResultDocument> = [InternalDocumentID, number, ResultDocument]\n\nexport type CustomSorterFunction<ResultDocument> = (\n  a: CustomSorterFunctionItem<ResultDocument>,\n  b: CustomSorterFunctionItem<ResultDocument>,\n) => number\n// thanks to https://github.com/sindresorhus/type-fest/blob/main/source/literal-union.d.ts\nexport type LiteralUnion<T> = (keyof T extends string ? keyof T : never) | (string & Record<never, never>)\n/**\n * Define which properties to sort for.\n */\nexport type SorterParams<T extends AnyOrama> = {\n  /**\n   * The key of the document used to sort the result.\n   */\n  property: LiteralUnion<T['schema']>;\n  /**\n   * Whether to sort the result in ascending or descending order.\n   */\n  order?: 'ASC' | 'DESC'\n}\n\n\nexport type FlattenSchema<T extends AnyOrama> = Flatten<T['schema']>\nexport type FlattenSchemaProperty<T extends AnyOrama> = T['schema'] extends object ? keyof FlattenSchema<T> : string\nexport type OnlyStrings<T extends any[]> = T[number] extends infer V ? V extends string ? V : never : never\n\nexport type SortByParams<T extends AnyOrama, ResultDocument> = SorterParams<T> | CustomSorterFunction<ResultDocument>\n\nexport type SearchParams<T extends AnyOrama, ResultDocument = TypedDocument<T>> = {\n  /**\n   * The word to search.\n   */\n  term?: string\n  /**\n   * The properties of the document to search in.\n   */\n  properties?: '*' | FlattenSchemaProperty<T>[]\n  /**\n   * The number of matched documents to return.\n   */\n  limit?: number\n  /**\n   * The number of matched documents to skip.\n   */\n  offset?: number\n  /**\n   * The key of the document used to sort the result.\n   */\n  sortBy?: SortByParams<T, ResultDocument>\n  /**\n   * Whether to match the term exactly.\n   */\n  exact?: boolean\n  /**\n   * The maximum [levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\n   * between the term and the searchable property.\n   */\n  tolerance?: number\n  /**\n   * The BM25 parameters to use.\n   *\n   * k: Term frequency saturation parameter.\n   * The higher the value, the more important the term frequency becomes.\n   * The default value is 1.2. It should be set to a value between 1.2 and 2.0.\n   *\n   * b: Document length saturation impact. The higher the value, the more\n   * important the document length becomes. The default value is 0.75.\n   *\n   * d: Frequency normalization lower bound. Default value is 0.5.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/BM25-algorithm\n   *\n   * @see https://en.wikipedia.org/wiki/Okapi_BM25\n   */\n  relevance?: BM25Params\n  /**\n   * The boost to apply to the properties.\n   *\n   * The boost is a number that is multiplied to the score of the property.\n   * It can be used to give more importance to some properties.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/fields-boosting\n   *\n   * @example\n   * // Give more importance to the 'title' property.\n   * const result = await search(db, {\n   *  term: 'Michael',\n   *  properties: ['title', 'author'],\n   *  boost: {\n   *   title: 2\n   *  }\n   * });\n   *\n   * // In that case, the score of the 'title' property will be multiplied by 2.\n   */\n  boost?: Partial<Record<OnlyStrings<FlattenSchemaProperty<T>[]>, number>>\n  /**\n   * Facets configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/facets\n   *\n   * A facet is a feature that allows users to narrow down their search results by specific\n   * attributes or characteristics, such as category, price, or location.\n   * This can help users find more relevant and specific results for their search query.\n   *\n   * @example\n   *\n   * const results = await search(db, {\n   *  term: 'Personal Computer',\n   *  properties: ['title', 'description', 'category.primary', 'category.secondary'],\n   *  facets: {\n   *    'category.primary': {\n   *      size: 10,\n   *      sort: 'ASC',\n   *    }\n   *  }\n   * });\n   */\n  facets?: FacetsParams<T>\n\n  /**\n   * Distinct configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/introduction#distinct\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  distinctOn: 'category.primary',\n   * })\n   */\n  distinctOn?: LiteralUnion<T['schema']>\n\n  /**\n   * Groups configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/grouping\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  groupBy: {\n   *   properties: ['category.primary'],\n   *   maxResult: 10,\n   *  }\n   * })\n   */\n  groupBy?: GroupByParams<T, ResultDocument>\n\n  /**\n   * Filter the search results.\n   * Full documentation: https://docs.oramasearch.com/usage/search/filters\n   *\n   * @example\n   * // Search for documents that contain 'Headphones' in the 'description' and 'title' fields and\n   * // have a price less than 100.\n   *\n   * const result = await search(db, {\n   *  term: 'Headphones',\n   *  properties: ['description', 'title'],\n   *  where: {\n   *    price: {\n   *      lt: 100\n   *    }\n   *  }\n   * });\n   */\n  where?: Partial<WhereCondition<T['schema']>>\n\n  /**\n   * Threshold to use for refining the search results.\n   * The threshold is a number between 0 and 1 that represents the minimum score of the documents to return.\n   * By default, the threshold is 1.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/threshold\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 0\n   * });\n   *\n   * // The result will contain all the documents that contain both 'Red' and 'Headphones' in their properties.\n   *\n   * const result2 = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 1\n   * });\n   *\n   * // The result will contain all the documents that contain either 'Red' and 'Headphones' in their properties.\n   */\n  threshold?: number\n\n  /**\n   * Preflight query.\n   * Will return just the facets (if needed) and the number of matched documents for the given query.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/preflight\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones',\n   *  preflight: true\n   * });\n   *\n   * console.log(result);\n   *\n   * // {\n   * //   elapsed: {\n   * //     raw: 181208,\n   * //     formatted: '181μs'\n   * //   },\n   * //   count: 100,\n   * // }\n   */\n  preflight?: boolean\n}\n\nexport type Result<Document> = {\n  /**\n   * The id of the document.\n   */\n  id: string\n  /**\n   * The score of the document in the search.\n   */\n  score: number\n  /**\n   * The document\n   */\n  document: Document\n}\n\nexport type FacetResult = Record<\n  string,\n  {\n    count: number\n    values: Record<string, number>\n  }\n>\n\nexport type GroupResult<Document> =\n  | {\n      values: ScalarSearchableValue[]\n      result: Result<Document>[]\n    }[]\n\nexport type TokenScore = [InternalDocumentID, number]\n\nexport type TokenMap = Record<string, TokenScore[]>\n\nexport type IndexMap = Record<string, TokenMap>\n\nexport type SearchContext<T extends AnyOrama, ResultDocument = TypedDocument<T>> = {\n  timeStart: bigint\n  tokenizer: Tokenizer\n  index: T['index']\n  documentsStore: T['documentsStore']\n  language: string | undefined\n  params: SearchParams<T, ResultDocument>\n  docsCount: number\n  uniqueDocsIDs: Record<number, number>\n  indexMap: IndexMap\n  docsIntersection: TokenMap\n}\n\nexport type ElapsedTime = {\n  raw: number\n  formatted: string\n}\n\nexport type Results<Document> = {\n  /**\n   * The number of all the matched documents.\n   */\n  count: number\n  /**\n   * An array of matched documents taking `limit` and `offset` into account.\n   */\n  hits: Result<Document>[]\n  /**\n   * The time taken to search.\n   */\n  elapsed: ElapsedTime\n  /**\n   * The facets results.\n   */\n  facets?: FacetResult\n\n  groups?: GroupResult<Document>\n}\n\n/**\n * Sometimes {@link doc} will not have the correct type; in these cases,\n * you can simply create a new variable and convert it to the correct type like:\n *\n * @example```ts\n * const fixedType = doc as MyType;\n * ```\n */\nexport type SingleCallbackComponent<T extends AnyOrama> = (\n  orama: T,\n  id: string,\n  doc?: TypedDocument<T>,\n) => SyncOrAsyncValue\n\n/**\n * Sometimes {@link doc} will not have the correct type; in these cases,\n * you can simply create a new variable and convert it to the correct type like:\n *\n * @example```ts\n * const fixedType = doc as MyType;\n * ```\n */\nexport type MultipleCallbackComponent<T extends AnyOrama> = (\n  orama: T,\n  doc: TypedDocument<T>[] | string[],\n) => SyncOrAsyncValue\n\n/**\n * Sometimes {@link results} will not have the correct type; in these cases,\n * you can simply create a new variable and convert it to the correct type like:\n *\n * @example```ts\n * const fixedType = results as Results<MyType>;\n * ```\n */\nexport type AfterSearch<T extends AnyOrama, ResultDocument extends TypedDocument<T> = TypedDocument<T>> = (\n  db: T,\n  params: SearchParams<T, ResultDocument>,\n  language: string | undefined,\n  results: Results<ResultDocument>,\n) => SyncOrAsyncValue\n\nexport type IIndexInsertOrRemoveHookFunction = <R = void>(\n  index: AnyIndexStore,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  type: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n) => SyncOrAsyncValue<R>\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface AnyIndexStore {\n  vectorIndexes: Record<string, VectorIndex>\n}\nexport type AnyIndex = IIndex<AnyIndexStore>\n\nexport interface IIndex<I extends AnyIndexStore> {\n  create<T extends AnyOrama>(\n    orama: T,\n    sharedInternalDocumentStore: T['internalDocumentIDStore'],\n    schema: T['schema'],\n  ): SyncOrAsyncValue<I>\n\n  beforeInsert?: IIndexInsertOrRemoveHookFunction\n  insert: <T extends I>(\n    implementation: IIndex<T>,\n    index: T,\n    prop: string,\n    id: DocumentID,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number,\n  ) => SyncOrAsyncValue\n  afterInsert?: IIndexInsertOrRemoveHookFunction\n\n  beforeRemove?: IIndexInsertOrRemoveHookFunction\n  remove: <T extends I>(\n    implementation: IIndex<T>,\n    index: T,\n    prop: string,\n    id: DocumentID,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number,\n  ) => SyncOrAsyncValue<boolean>\n  afterRemove?: IIndexInsertOrRemoveHookFunction\n\n  insertDocumentScoreParameters(\n    index: I,\n    prop: string,\n    id: DocumentID,\n    tokens: string[],\n    docsCount: number,\n  ): SyncOrAsyncValue\n  insertTokenScoreParameters(index: I, prop: string, id: DocumentID, tokens: string[], token: string): SyncOrAsyncValue\n  removeDocumentScoreParameters(index: I, prop: string, id: DocumentID, docsCount: number): SyncOrAsyncValue\n  removeTokenScoreParameters(index: I, prop: string, token: string): SyncOrAsyncValue\n  calculateResultScores<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n    context: SearchContext<T, ResultDocument>,\n    index: I,\n    prop: string,\n    term: string,\n    ids: DocumentID[],\n  ): SyncOrAsyncValue<TokenScore[]>\n\n  search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n    context: SearchContext<T, ResultDocument>,\n    index: I,\n    prop: string,\n    term: string,\n  ): SyncOrAsyncValue<TokenScore[]>\n  searchByWhereClause<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n    context: SearchContext<T, ResultDocument>,\n    index: I,\n    filters: Partial<WhereCondition<T['schema']>>,\n  ): SyncOrAsyncValue<InternalDocumentID[]>\n\n  getSearchableProperties(index: I): SyncOrAsyncValue<string[]>\n  getSearchablePropertiesWithTypes(index: I): SyncOrAsyncValue<Record<string, SearchableType>>\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<I>\n  save<R = unknown>(index: I): SyncOrAsyncValue<R>\n}\n\nexport interface AnyDocumentStore {\n  docs: Record<InternalDocumentID, AnyDocument>\n}\n\nexport interface IDocumentsStore<D extends AnyDocumentStore = AnyDocumentStore> {\n  create<T extends AnyOrama>(orama: T, sharedInternalDocumentStore: InternalDocumentIDStore): SyncOrAsyncValue<D>\n  get(store: D, id: DocumentID): SyncOrAsyncValue<AnyDocument | undefined>\n  getMultiple(store: D, ids: DocumentID[]): SyncOrAsyncValue<(AnyDocument | undefined)[]>\n  getAll(store: D): SyncOrAsyncValue<Record<InternalDocumentID, AnyDocument>>\n  store(store: D, id: DocumentID, doc: AnyDocument): SyncOrAsyncValue<boolean>\n  remove(store: D, id: DocumentID): SyncOrAsyncValue<boolean>\n  count(store: D): SyncOrAsyncValue<number>\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<D>\n  save<R = unknown>(store: D): SyncOrAsyncValue<R>\n}\n\nexport interface SorterConfig {\n  enabled?: boolean\n  unsortableProperties?: string[]\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface AnySorterStore {}\nexport type AnySorter = ISorter<AnySorterStore>\n\nexport interface ISorter<So extends AnySorterStore> {\n  create<T extends AnyOrama>(\n    orama: T,\n    sharedInternalDocumentStore: InternalDocumentIDStore,\n    schema: T['schema'],\n    sorterConfig?: SorterConfig,\n  ): SyncOrAsyncValue<So>\n  insert: <T extends So>(\n    sorter: T,\n    prop: string,\n    id: DocumentID,\n    value: SortValue,\n    schemaType: SortType,\n    language: string | undefined,\n  ) => SyncOrAsyncValue\n  remove: <T extends So>(sorter: T, prop: string, id: DocumentID) => SyncOrAsyncValue\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<So>\n  save<R = unknown>(sorter: So): SyncOrAsyncValue<R>\n\n  sortBy<T extends AnyOrama>(\n    sorter: So,\n    docIds: [DocumentID, number][],\n    by: SorterParams<T>,\n  ): Promise<[DocumentID, number][]>\n\n  getSortableProperties(sorter: So): SyncOrAsyncValue<string[]>\n  getSortablePropertiesWithTypes(sorter: So): SyncOrAsyncValue<Record<string, SortType>>\n}\n\nexport type Stemmer = (word: string) => string\n\nexport type DefaultTokenizerConfig = {\n  language?: Language\n  stemming?: boolean\n  stemmer?: Stemmer\n  stemmerSkipProperties?: string | string[]\n  tokenizeSkipProperties?: string | string[]\n  stopWords?: boolean | string[] | ((stopWords: string[]) => string[] | Promise<string[]>)\n  allowDuplicates?: boolean\n}\n\nexport interface Tokenizer {\n  language: string\n  normalizationCache: Map<string, string>\n  tokenize: (raw: string, language?: string, prop?: string) => SyncOrAsyncValue<string[]>\n}\n\nexport interface ObjectComponents<I, D, So> {\n  tokenizer: Tokenizer | DefaultTokenizerConfig\n  index: I\n  documentsStore: D\n  sorter: So\n}\n\nexport interface FunctionComponents<S> {\n  validateSchema(doc: AnyDocument, schema: S): SyncOrAsyncValue<string | undefined>\n  getDocumentIndexId(doc: AnyDocument): SyncOrAsyncValue<string>\n  getDocumentProperties(doc: AnyDocument, paths: string[]): SyncOrAsyncValue<Record<string, string | number | boolean>>\n  formatElapsedTime(number: bigint): SyncOrAsyncValue<number | string | object | ElapsedTime>\n}\n\nexport interface SingleOrArrayCallbackComponents<T extends AnyOrama> {\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeInsert: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterInsert: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeRemove: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterRemove: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeUpdate: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterUpdate: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link AfterSearch}\n   */\n  afterSearch: SingleOrArray<AfterSearch<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeMultipleInsert: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterMultipleInsert: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeMultipleRemove: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterMultipleRemove: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeMultipleUpdate: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterMultipleUpdate: SingleOrArray<MultipleCallbackComponent<T>>\n}\n\nexport interface ArrayCallbackComponents<T extends AnyOrama> {\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeInsert: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterInsert: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeRemove: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterRemove: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeUpdate: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterUpdate: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link AfterSearch}\n   */\n  afterSearch: AfterSearch<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeMultipleInsert: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterMultipleInsert: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeMultipleRemove: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterMultipleRemove: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeMultipleUpdate: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterMultipleUpdate: MultipleCallbackComponent<T>[]\n}\n\nexport type Components<T extends AnyOrama, TSchema, TIndex, TDocumentStore, TSorter> = Partial<\n  ObjectComponents<TIndex, TDocumentStore, TSorter> & FunctionComponents<TSchema> & SingleOrArrayCallbackComponents<T>\n>\n\nexport const kInsertions = Symbol('orama.insertions')\nexport const kRemovals = Symbol('orama.removals')\n\nexport type PickIfExtends<T, TExtends, TDefault> = T extends TExtends ? T : TDefault\n\ntype Internals<\n  TSchema,\n  TIndex extends AnyIndexStore,\n  TDocumentStore extends AnyDocumentStore,\n  TSorter extends AnySorterStore,\n> = {\n  schema: TSchema\n  typeSchema: Schema<TSchema>\n  tokenizer: Tokenizer\n  index: IIndex<TIndex>\n  documentsStore: IDocumentsStore<TDocumentStore>\n  sorter: ISorter<TSorter>\n  data: {\n    index: TIndex\n    docs: TDocumentStore\n    sorting: TSorter\n  }\n  internalDocumentIDStore: InternalDocumentIDStore\n  caches: Record<string, unknown>\n  [kInsertions]: number | undefined\n  [kRemovals]: number | undefined\n}\n\ntype OramaID = {\n  id: string\n}\n\nexport type ExtractSchema<T> = T extends { schema: infer RawSchema } ? Schema<RawSchema> : never\n\nexport type AnyGeneric<T> = T[]\nexport type AnyGenericIndex<T> = T extends IIndex<infer TStore>\n  ? TStore extends AnyIndexStore\n    ? TStore\n    : never\n  : AnyIndexStore\nexport type AnyGenericDocumentStore<T> = T extends IDocumentsStore<infer TStore>\n  ? TStore extends AnyDocumentStore\n    ? TStore\n    : never\n  : AnyDocumentStore\nexport type AnyGenericSorter<T> = T extends ISorter<infer TSorter>\n  ? TSorter extends AnySorterStore\n    ? TSorter\n    : never\n  : AnySorterStore\n\nexport type PickInferGeneric<T, Default> = T extends AnyGeneric<infer Generic>\n  ? Generic extends Default\n    ? Generic\n    : never\n  : never\n\nexport type Orama<TSchema, TIndex = IIndex<Index>, TDocumentStore = IDocumentsStore<DocumentsStore>, TSorter = ISorter<Sorter>> = FunctionComponents<TSchema> &\n  Internals<TSchema, AnyGenericIndex<TIndex>, AnyGenericDocumentStore<TDocumentStore>, AnyGenericSorter<TSorter>> &\n  ArrayCallbackComponents<any> &\n  OramaID\n\nexport type AnyOrama<TSchema = any> = FunctionComponents<TSchema> &\n  Internals<TSchema, AnyIndexStore, AnyDocumentStore, AnySorterStore> &\n  ArrayCallbackComponents<any> &\n  OramaID\n"],"mappings":"AA4zBA,OAAO,MAAMA,WAAA,GAAcC,MAAA,CAAO;AAClC,OAAO,MAAMC,SAAA,GAAYD,MAAA,CAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}