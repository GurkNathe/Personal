{"ast":null,"code":"import { createError } from '../errors.js';\nimport { getNested } from '../utils.js';\nfunction sortingPredicate(order = 'desc', a, b) {\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1];\n  } else {\n    return b[1] - a[1];\n  }\n}\nexport async function getFacets(orama, results, facetsConfig) {\n  const facets = {};\n  const allIDs = results.map(([id]) => id);\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n  const facetKeys = Object.keys(facetsConfig);\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n  for (const facet of facetKeys) {\n    let values = {};\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const {\n        ranges\n      } = facetsConfig[facet];\n      const tmp = [];\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0]);\n      }\n      values = Object.fromEntries(tmp);\n    }\n    facets[facet] = {\n      count: 0,\n      values\n    };\n  }\n  const allDocsLength = allDocs.length;\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i];\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.') ? await getNested(doc, facet) : doc[facet];\n      const propertyType = properties[facet];\n      switch (propertyType) {\n        case 'number':\n          {\n            const ranges = facetsConfig[facet].ranges;\n            calculateNumberFacet(ranges, facets[facet].values, facetValue);\n            break;\n          }\n        case 'number[]':\n          {\n            const alreadyInsertedValues = new Set();\n            const ranges = facetsConfig[facet].ranges;\n            for (const v of facetValue) {\n              calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues);\n            }\n            break;\n          }\n        case 'boolean':\n        case 'enum':\n        case 'string':\n          {\n            calculateBooleanStringOrEnumFacet(facets[facet].values, facetValue, propertyType);\n            break;\n          }\n        case 'boolean[]':\n        case 'enum[]':\n        case 'string[]':\n          {\n            const alreadyInsertedValues = new Set();\n            const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string';\n            for (const v of facetValue) {\n              calculateBooleanStringOrEnumFacet(facets[facet].values, v, innerType, alreadyInsertedValues);\n            }\n            break;\n          }\n        default:\n          throw createError('FACET_NOT_SUPPORTED', propertyType);\n      }\n    }\n  }\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length;\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig;\n      facets[facet].values = Object.fromEntries(Object.entries(facets[facet].values).sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b)).slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10));\n    }\n  }\n  return facets;\n}\nfunction calculateNumberFacet(ranges, values, facetValue, alreadyInsertedValues) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`;\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue;\n    }\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1;\n      } else {\n        values[value]++;\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value);\n        }\n      }\n    }\n  }\n}\nfunction calculateBooleanStringOrEnumFacet(values, facetValue, propertyType, alreadyInsertedValues) {\n  // String or boolean based facets\n  const value = (facetValue === null || facetValue === void 0 ? void 0 : facetValue.toString()) ?? (propertyType === 'boolean' ? 'false' : '');\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return;\n  }\n  values[value] = (values[value] ?? 0) + 1;\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value);\n  }\n}","map":{"version":3,"names":["createError","getNested","sortingPredicate","order","a","b","toLowerCase","getFacets","orama","results","facetsConfig","facets","allIDs","map","id","allDocs","documentsStore","getMultiple","data","docs","facetKeys","Object","keys","properties","index","getSearchablePropertiesWithTypes","facet","values","ranges","tmp","range","push","from","to","fromEntries","count","allDocsLength","length","i","doc","facetValue","includes","propertyType","calculateNumberFacet","alreadyInsertedValues","Set","v","calculateBooleanStringOrEnumFacet","innerType","stringFacetDefinition","entries","sort","slice","offset","limit","value","has","undefined","add","toString"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/facets.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport type {\n  AnyOrama,\n  FacetResult,\n  FacetSorting,\n  FacetsParams,\n  NumberFacetDefinition,\n  SearchableValue,\n  StringFacetDefinition,\n  TokenScore,\n} from '../types.js'\nimport { getNested } from '../utils.js'\n\ntype FacetValue = string | boolean | number\n\nfunction sortingPredicate(order: FacetSorting = 'desc', a: [string, number], b: [string, number]) {\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1]\n  } else {\n    return b[1] - a[1]\n  }\n}\n\nexport async function getFacets<T extends AnyOrama>(\n  orama: T,\n  results: TokenScore[],\n  facetsConfig: FacetsParams<T>,\n): Promise<FacetResult> {\n  const facets: FacetResult = {}\n  const allIDs = results.map(([id]) => id)\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const facetKeys = Object.keys(facetsConfig!)\n\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n\n  for (const facet of facetKeys) {\n    let values = {}\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const { ranges } = facetsConfig[facet] as NumberFacetDefinition\n      const tmp: [string, number][] = []\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0])\n      }\n      values = Object.fromEntries(tmp)\n    }\n\n    facets[facet] = {\n      count: 0,\n      values,\n    }\n  }\n\n  const allDocsLength = allDocs.length\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i]\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? (await getNested<string>(doc!, facet))!\n        : (doc![facet] as SearchableValue)\n\n      const propertyType = properties[facet]\n      switch (propertyType) {\n        case 'number': {\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          calculateNumberFacet(ranges, facets[facet].values, facetValue as number)\n          break\n        }\n        case 'number[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          for (const v of facetValue as Array<number>) {\n            calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues)\n          }\n          break\n        }\n        case 'boolean':\n        case 'enum':\n        case 'string': {\n          calculateBooleanStringOrEnumFacet(facets[facet].values, facetValue as FacetValue, propertyType)\n          break\n        }\n        case 'boolean[]':\n        case 'enum[]':\n        case 'string[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string'\n          for (const v of facetValue as Array<FacetValue>) {\n            calculateBooleanStringOrEnumFacet(facets[facet].values, v, innerType, alreadyInsertedValues)\n          }\n          break\n        }\n        default:\n          throw createError('FACET_NOT_SUPPORTED', propertyType)\n      }\n    }\n  }\n\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length\n\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig as StringFacetDefinition\n\n      facets[facet].values = Object.fromEntries(\n        Object.entries(facets[facet].values)\n          .sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b))\n          .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10),\n      )\n    }\n  }\n\n  return facets\n}\n\nfunction calculateNumberFacet(\n  ranges: NumberFacetDefinition['ranges'],\n  values: Record<string, number>,\n  facetValue: number,\n  alreadyInsertedValues?: Set<string>,\n) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue\n    }\n\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1\n      } else {\n        values[value]++\n\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value)\n        }\n      }\n    }\n  }\n}\n\nfunction calculateBooleanStringOrEnumFacet(\n  values: Record<string, number>,\n  facetValue: FacetValue,\n  propertyType: 'string' | 'boolean' | 'enum',\n  alreadyInsertedValues?: Set<string>,\n) {\n  // String or boolean based facets\n  const value = facetValue?.toString() ?? (propertyType === 'boolean' ? 'false' : '')\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return\n  }\n  values[value] = (values[value] ?? 0) + 1\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}