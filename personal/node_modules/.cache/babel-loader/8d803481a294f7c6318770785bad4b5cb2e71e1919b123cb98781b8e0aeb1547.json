{"ast":null,"code":"import { createError } from '../errors.js';\nimport { getNested, intersect, safeArrayPush } from '../utils.js';\nimport { getDocumentIdFromInternalId } from './internal-document-id-store.js';\nconst DEFAULT_REDUCE = {\n  reducer: (_, acc, res, index) => {\n    acc[index] = res;\n    return acc;\n  },\n  getInitialValue: length => Array.from({\n    length\n  })\n};\nconst ALLOWED_TYPES = ['string', 'number', 'boolean'];\nexport async function getGroups(orama, results, groupBy) {\n  const properties = groupBy.properties;\n  const propertiesLength = properties.length;\n  const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i];\n    if (typeof schemaProperties[property] === 'undefined') {\n      throw createError('UNKNOWN_GROUP_BY_PROPERTY', property);\n    }\n    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {\n      throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property]);\n    }\n  }\n  const allIDs = results.map(([id]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id));\n  // allDocs is already sorted by the sortBy algorithm\n  // We leverage on that to limit the number of documents returned\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n  const allDocsLength = allDocs.length;\n  const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER;\n  const listOfValues = [];\n  // We want to understand which documents have which values\n  // and group them by the property and values\n  const g = {};\n  for (let i = 0; i < propertiesLength; i++) {\n    const groupByKey = properties[i];\n    const group = {\n      property: groupByKey,\n      perValue: {}\n    };\n    const values = new Set();\n    for (let j = 0; j < allDocsLength; j++) {\n      const doc = allDocs[j];\n      const value = await getNested(doc, groupByKey);\n      // we don't want to consider undefined values\n      if (typeof value === 'undefined') {\n        continue;\n      }\n      const keyValue = typeof value !== 'boolean' ? value : '' + value;\n      if (typeof group.perValue[keyValue] === 'undefined') {\n        group.perValue[keyValue] = {\n          indexes: [],\n          count: 0\n        };\n      }\n      if (group.perValue[keyValue].count >= returnedCount) {\n        continue;\n      }\n      // We use the index to keep track of the original order\n      group.perValue[keyValue].indexes.push(j);\n      group.perValue[keyValue].count++;\n      values.add(value);\n    }\n    listOfValues.push(Array.from(values));\n    g[groupByKey] = group;\n  }\n  const combinations = calculateCombination(listOfValues);\n  const combinationsLength = combinations.length;\n  const groups = [];\n  for (let i = 0; i < combinationsLength; i++) {\n    const combination = combinations[i];\n    const combinationLength = combination.length;\n    const group = {\n      values: [],\n      indexes: []\n    };\n    const indexes = [];\n    for (let j = 0; j < combinationLength; j++) {\n      const value = combination[j];\n      const property = properties[j];\n      indexes.push(g[property].perValue[typeof value !== 'boolean' ? value : '' + value].indexes);\n      group.values.push(value);\n    }\n    // We leverage on the index to sort the results by the original order\n    group.indexes = intersect(indexes).sort((a, b) => a - b);\n    // don't generate empty groups\n    if (group.indexes.length === 0) {\n      continue;\n    }\n    groups.push(group);\n  }\n  const groupsLength = groups.length;\n  const res = Array.from({\n    length: groupsLength\n  });\n  for (let i = 0; i < groupsLength; i++) {\n    const group = groups[i];\n    const reduce = groupBy.reduce || DEFAULT_REDUCE;\n    const docs = group.indexes.map(index => {\n      return {\n        id: allIDs[index],\n        score: results[index][1],\n        document: allDocs[index]\n      };\n    });\n    const func = reduce.reducer.bind(null, group.values);\n    const initialValue = reduce.getInitialValue(group.indexes.length);\n    const aggregationValue = docs.reduce(func, initialValue);\n    res[i] = {\n      values: group.values,\n      result: aggregationValue\n    };\n  }\n  return res;\n}\nfunction calculateCombination(arrs, index = 0) {\n  if (index + 1 === arrs.length) return arrs[index].map(item => [item]);\n  const head = arrs[index];\n  const c = calculateCombination(arrs, index + 1);\n  const combinations = [];\n  for (const value of head) {\n    for (const combination of c) {\n      const result = [value];\n      safeArrayPush(result, combination);\n      combinations.push(result);\n    }\n  }\n  return combinations;\n}","map":{"version":3,"names":["createError","getNested","intersect","safeArrayPush","getDocumentIdFromInternalId","DEFAULT_REDUCE","reducer","_","acc","res","index","getInitialValue","length","Array","from","ALLOWED_TYPES","getGroups","orama","results","groupBy","properties","propertiesLength","schemaProperties","getSearchablePropertiesWithTypes","data","i","property","includes","join","allIDs","map","id","internalDocumentIDStore","allDocs","documentsStore","getMultiple","docs","allDocsLength","returnedCount","maxResult","Number","MAX_SAFE_INTEGER","listOfValues","g","groupByKey","group","perValue","values","Set","j","doc","value","keyValue","indexes","count","push","add","combinations","calculateCombination","combinationsLength","groups","combination","combinationLength","sort","a","b","groupsLength","reduce","score","document","func","bind","initialValue","aggregationValue","result","arrs","item","head","c"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/groups.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { getNested, intersect, safeArrayPush } from '../utils.js'\nimport type { AnyDocument, AnyOrama, GroupByParams, GroupResult, Reduce, Result, ScalarSearchableValue, TokenScore, TypedDocument } from '../types.js'\nimport { getDocumentIdFromInternalId } from './internal-document-id-store.js'\n\ninterface PropertyGroup {\n  property: string\n  perValue: Record<\n    string,\n    {\n      indexes: number[]\n      count: number\n    }\n  >\n}\n\ninterface Group {\n  values: ScalarSearchableValue[]\n  indexes: number[]\n}\n\nconst DEFAULT_REDUCE: Reduce<Result<AnyDocument>[]> = {\n  reducer: (_, acc, res, index) => {\n    acc[index] = res\n    return acc\n  },\n  getInitialValue: length => Array.from({ length }),\n}\n\nconst ALLOWED_TYPES = ['string', 'number', 'boolean']\n\nexport async function getGroups<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  results: TokenScore[],\n  groupBy: GroupByParams<T, ResultDocument>,\n): Promise<GroupResult<ResultDocument>> {\n  const properties = groupBy.properties\n  const propertiesLength = properties.length\n\n  const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i]\n    if (typeof schemaProperties[property] === 'undefined') {\n      throw createError('UNKNOWN_GROUP_BY_PROPERTY', property)\n    }\n    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {\n      throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property])\n    }\n  }\n\n  const allIDs = results.map(([id]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id))\n\n  // allDocs is already sorted by the sortBy algorithm\n  // We leverage on that to limit the number of documents returned\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const allDocsLength = allDocs.length\n\n  const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER\n\n  const listOfValues: ScalarSearchableValue[][] = []\n\n  // We want to understand which documents have which values\n  // and group them by the property and values\n  const g: Record<string, PropertyGroup> = {}\n  for (let i = 0; i < propertiesLength; i++) {\n    const groupByKey = properties[i]\n    const group: PropertyGroup = {\n      property: groupByKey,\n      perValue: {},\n    }\n\n    const values: Set<ScalarSearchableValue> = new Set()\n    for (let j = 0; j < allDocsLength; j++) {\n      const doc = allDocs[j]\n\n      const value = await getNested<ScalarSearchableValue>(doc as object, groupByKey)\n      // we don't want to consider undefined values\n      if (typeof value === 'undefined') {\n        continue\n      }\n      const keyValue = typeof value !== 'boolean' ? value : '' + value\n      if (typeof group.perValue[keyValue] === 'undefined') {\n        group.perValue[keyValue] = {\n          indexes: [],\n          count: 0,\n        }\n      }\n      if (group.perValue[keyValue].count >= returnedCount) {\n        // We stop early because for this value we react the limit\n        continue\n      }\n\n      // We use the index to keep track of the original order\n      group.perValue[keyValue].indexes.push(j)\n      group.perValue[keyValue].count++\n\n      values.add(value)\n    }\n\n    listOfValues.push(Array.from(values))\n\n    g[groupByKey] = group\n  }\n\n  const combinations = calculateCombination(listOfValues)\n  const combinationsLength = combinations.length\n\n  const groups: Group[] = []\n  for (let i = 0; i < combinationsLength; i++) {\n    const combination = combinations[i]\n    const combinationLength = combination.length\n\n    const group: Group = {\n      values: [],\n      indexes: [],\n    }\n    const indexes: number[][] = []\n    for (let j = 0; j < combinationLength; j++) {\n      const value = combination[j]\n      const property = properties[j]\n      indexes.push(g[property].perValue[typeof value !== 'boolean' ? value : '' + value].indexes)\n      group.values.push(value)\n    }\n    // We leverage on the index to sort the results by the original order\n    group.indexes = intersect(indexes).sort((a, b) => a - b)\n\n    // don't generate empty groups\n    if (group.indexes.length === 0) {\n      continue\n    }\n\n    groups.push(group)\n  }\n\n  const groupsLength = groups.length\n  const res: GroupResult<ResultDocument> = Array.from({ length: groupsLength })\n  for (let i = 0; i < groupsLength; i++) {\n    const group = groups[i]\n\n    const reduce = (groupBy.reduce || DEFAULT_REDUCE) as Reduce<Result<ResultDocument>[]>\n\n    const docs = group.indexes.map(index => {\n      return {\n        id: allIDs[index],\n        score: results[index][1],\n        document: allDocs[index]!,\n      }\n    })\n\n    const func = reduce.reducer.bind(null, group.values)\n    const initialValue = reduce.getInitialValue(group.indexes.length)\n    const aggregationValue = docs.reduce(func, initialValue)\n\n    res[i] = {\n      values: group.values,\n      result: aggregationValue,\n    }\n  }\n\n  return res\n}\n\nfunction calculateCombination(arrs: ScalarSearchableValue[][], index = 0): ScalarSearchableValue[][] {\n  if (index + 1 === arrs.length) return arrs[index].map(item => [item])\n\n  const head = arrs[index]\n  const c = calculateCombination(arrs, index + 1)\n\n  const combinations: ScalarSearchableValue[][] = []\n  for (const value of head) {\n    for (const combination of c) {\n      const result = [value];\n\n      safeArrayPush(result, combination)\n\n      combinations.push(result)\n    }\n  }\n\n  return combinations\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}