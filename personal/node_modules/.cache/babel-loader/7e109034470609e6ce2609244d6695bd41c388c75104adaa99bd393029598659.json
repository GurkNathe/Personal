{"ast":null,"code":"import { Vector2 } from \"three\";\nvar DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: /* @__PURE__ */new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [/* @__PURE__ */new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1e3\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: [\"#include <common>\", \"uniform vec2 size;\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"void main() {\", \"\tvUv = uv;\", \"\tvInvSize = 1.0 / size;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"#include <packing>\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform float depthCutoff;\", \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\", \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tif( depth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = -getViewZ( depth );\", \"\tbool rBreak = false, lBreak = false;\", \"\tfloat weightSum = sampleWeights[0];\", \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\", \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\", \"\t\tfloat sampleWeight = sampleWeights[i];\", \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\", \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\", \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\", \"\t\tif( ! rBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t\tsampleUv = vUv - sampleUvOffset;\", \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\", \"\t\tif( ! lBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = diffuseSum / weightSum;\", \"}\"].join(\"\\n\")\n};\nvar BlurShaderUtils = {\n  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {\n    var gaussian = function gaussian(x, stdDev2) {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    var weights = [];\n    for (var i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {\n    var offsets = [];\n    for (var i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: function configure(shader, kernelRadius, stdDev, uvIncrement) {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":{"version":3,"names":["Vector2","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","stdDev2","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","shader","needsUpdate"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    sampleUvOffsets: { value: [/* @__PURE__ */ new Vector2(0, 0)] },\n    sampleWeights: { value: [1] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1e3 },\n    depthCutoff: { value: 10 }\n  },\n  vertexShader: [\n    \"#include <common>\",\n    \"uniform vec2 size;\",\n    \"varying vec2 vUv;\",\n    \"varying vec2 vInvSize;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tvInvSize = 1.0 / size;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#include <common>\",\n    \"#include <packing>\",\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform sampler2D tDepth;\",\n    \"uniform float cameraNear;\",\n    \"uniform float cameraFar;\",\n    \"uniform float depthCutoff;\",\n    \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\",\n    \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\",\n    \"varying vec2 vUv;\",\n    \"varying vec2 vInvSize;\",\n    \"float getDepth( const in vec2 screenPosition ) {\",\n    \"\t#if DEPTH_PACKING == 1\",\n    \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n    \"\t#else\",\n    \"\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"\t#endif\",\n    \"}\",\n    \"float getViewZ( const in float depth ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#endif\",\n    \"}\",\n    \"void main() {\",\n    \"\tfloat depth = getDepth( vUv );\",\n    \"\tif( depth >= ( 1.0 - EPSILON ) ) {\",\n    \"\t\tdiscard;\",\n    \"\t}\",\n    \"\tfloat centerViewZ = -getViewZ( depth );\",\n    \"\tbool rBreak = false, lBreak = false;\",\n    \"\tfloat weightSum = sampleWeights[0];\",\n    \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\",\n    \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\",\n    \"\t\tfloat sampleWeight = sampleWeights[i];\",\n    \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\",\n    \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\",\n    \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\",\n    \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\",\n    \"\t\tif( ! rBreak ) {\",\n    \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n    \"\t\t\tweightSum += sampleWeight;\",\n    \"\t\t}\",\n    \"\t\tsampleUv = vUv - sampleUvOffset;\",\n    \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\",\n    \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\",\n    \"\t\tif( ! lBreak ) {\",\n    \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n    \"\t\t\tweightSum += sampleWeight;\",\n    \"\t\t}\",\n    \"\t}\",\n    \"\tgl_FragColor = diffuseSum / weightSum;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport {\n  BlurShaderUtils,\n  DepthLimitedBlurShader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}