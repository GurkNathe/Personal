{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from \"three\";\nimport potpack from \"potpack\";\nvar ProgressiveLightMap = /*#__PURE__*/function () {\n  function ProgressiveLightMap(renderer) {\n    var _this = this;\n    var res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    _classCallCheck(this, ProgressiveLightMap);\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = function (shader) {\n      shader.vertexShader = \"#define USE_LIGHTMAP\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }\";\n      var bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"varying vec2 vUv2;\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\\n\\t\\t\\t\\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\n\\t\\t\\t}\";\n      shader.uniforms.previousShadowMap = {\n        value: _this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      _this.uvMat.uniforms = shader.uniforms;\n      _this.uvMat.userData.shader = shader;\n      _this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  _createClass(ProgressiveLightMap, [{\n    key: \"addObjectsToLightMap\",\n    value: function addObjectsToLightMap(objects) {\n      this.uv_boxes = [];\n      var padding = 3 / this.res;\n      for (var ob = 0; ob < objects.length; ob++) {\n        var object = objects[ob];\n        if (object.isLight) {\n          this.scene.attach(object);\n          continue;\n        }\n        if (!object.geometry.hasAttribute(\"uv\")) {\n          console.warn(\"All lightmap objects need UVs!\");\n          continue;\n        }\n        if (this.blurringPlane == null) {\n          this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n        }\n        object.material.lightMap = this.progressiveLightMap2.texture;\n        object.material.dithering = true;\n        object.castShadow = true;\n        object.receiveShadow = true;\n        object.renderOrder = 1e3 + ob;\n        this.uv_boxes.push({\n          w: 1 + padding * 2,\n          h: 1 + padding * 2,\n          index: ob\n        });\n        this.lightMapContainers.push({\n          basicMat: object.material,\n          object: object\n        });\n        this.compiled = false;\n      }\n      var dimensions = potpack(this.uv_boxes);\n      this.uv_boxes.forEach(function (box) {\n        var uv2 = objects[box.index].geometry.getAttribute(\"uv\").clone();\n        for (var i = 0; i < uv2.array.length; i += uv2.itemSize) {\n          uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n          uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n        }\n        objects[box.index].geometry.setAttribute(\"uv2\", uv2);\n        objects[box.index].geometry.getAttribute(\"uv2\").needsUpdate = true;\n      });\n    }\n    /**\n     * This function renders each mesh one at a time into their respective surface maps\n     * @param {Camera} camera Standard Rendering Camera\n     * @param {number} blendWindow When >1, samples will accumulate over time.\n     * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n     */\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (this.blurringPlane == null) {\n        return;\n      }\n      var oldTarget = this.renderer.getRenderTarget();\n      this.blurringPlane.visible = blurEdges;\n      for (var l = 0; l < this.lightMapContainers.length; l++) {\n        this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n        this.scene.attach(this.lightMapContainers[l].object);\n      }\n      if (this.firstUpdate) {\n        this.renderer.setRenderTarget(this.tinyTarget);\n        this.renderer.render(this.scene, camera);\n        this.firstUpdate = false;\n      }\n      for (var _l = 0; _l < this.lightMapContainers.length; _l++) {\n        this.uvMat.uniforms.averagingWindow = {\n          value: blendWindow\n        };\n        this.lightMapContainers[_l].object.material = this.uvMat;\n        this.lightMapContainers[_l].object.oldFrustumCulled = this.lightMapContainers[_l].object.frustumCulled;\n        this.lightMapContainers[_l].object.frustumCulled = false;\n      }\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n      this.renderer.setRenderTarget(activeMap);\n      this.uvMat.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.blurringPlane.material.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera);\n      for (var _l2 = 0; _l2 < this.lightMapContainers.length; _l2++) {\n        this.lightMapContainers[_l2].object.frustumCulled = this.lightMapContainers[_l2].object.oldFrustumCulled;\n        this.lightMapContainers[_l2].object.material = this.lightMapContainers[_l2].basicMat;\n        this.lightMapContainers[_l2].object.oldScene.attach(this.lightMapContainers[_l2].object);\n      }\n      this.renderer.setRenderTarget(oldTarget);\n    }\n    /** DEBUG\n     * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n     * @param {boolean} visible Whether the debug plane should be visible\n     * @param {Vector3} position Where the debug plane should be drawn\n     */\n  }, {\n    key: \"showDebugLightmap\",\n    value: function showDebugLightmap(visible) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n      if (this.lightMapContainers.length == 0) {\n        if (!this.warned) {\n          console.warn(\"Call this after adding the objects!\");\n          this.warned = true;\n        }\n        return;\n      }\n      if (this.labelMesh == null) {\n        this.labelMaterial = new MeshBasicMaterial({\n          map: this.progressiveLightMap1.texture,\n          side: DoubleSide\n        });\n        this.labelPlane = new PlaneGeometry(100, 100);\n        this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n        this.labelMesh.position.y = 250;\n        this.lightMapContainers[0].object.parent.add(this.labelMesh);\n      }\n      if (position != void 0) {\n        this.labelMesh.position.copy(position);\n      }\n      this.labelMesh.visible = visible;\n    }\n    /**\n     * INTERNAL Creates the Blurring Plane\n     * @param {number} res The square resolution of this object's lightMap.\n     * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n     */\n  }, {\n    key: \"_initializeBlurPlane\",\n    value: function _initializeBlurPlane(res) {\n      var _this2 = this;\n      var lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var blurMaterial = new MeshBasicMaterial();\n      blurMaterial.uniforms = {\n        previousShadowMap: {\n          value: null\n        },\n        pixelOffset: {\n          value: 1 / res\n        },\n        polygonOffset: true,\n        polygonOffsetFactor: -1,\n        polygonOffsetUnits: 3\n      };\n      blurMaterial.onBeforeCompile = function (shader) {\n        shader.vertexShader = \"#define USE_UV\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n        var bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n        shader.fragmentShader = \"#define USE_UV\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\tgl_FragColor.rgb = (\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\\n\\t\\t}\";\n        shader.uniforms.previousShadowMap = {\n          value: lightMap.texture\n        };\n        shader.uniforms.pixelOffset = {\n          value: 0.5 / res\n        };\n        blurMaterial.uniforms = shader.uniforms;\n        blurMaterial.userData.shader = shader;\n        _this2.compiled = true;\n      };\n      this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n      this.blurringPlane.name = \"Blurring Plane\";\n      this.blurringPlane.frustumCulled = false;\n      this.blurringPlane.renderOrder = 0;\n      this.blurringPlane.material.depthWrite = false;\n      this.scene.add(this.blurringPlane);\n    }\n  }]);\n  return ProgressiveLightMap;\n}();\nexport { ProgressiveLightMap };","map":{"version":3,"names":["Scene","WebGLRenderTarget","FloatType","MeshPhongMaterial","MeshBasicMaterial","DoubleSide","PlaneGeometry","Mesh","potpack","ProgressiveLightMap","renderer","_this","res","arguments","length","undefined","_classCallCheck","lightMapContainers","compiled","scene","background","tinyTarget","buffer1Active","firstUpdate","warned","format","test","navigator","userAgent","alfFloatType","progressiveLightMap1","type","progressiveLightMap2","uvMat","uniforms","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","previousShadowMap","value","texture","averagingWindow","userData","_createClass","key","addObjectsToLightMap","objects","uv_boxes","padding","ob","object","isLight","attach","geometry","hasAttribute","console","warn","blurringPlane","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","dimensions","forEach","box","uv2","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","update","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","setRenderTarget","render","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","showDebugLightmap","position","labelMesh","labelMaterial","map","side","labelPlane","add","copy","_this2","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/misc/ProgressiveLightmap.js"],"sourcesContent":["import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from \"three\";\nimport potpack from \"potpack\";\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, { type: format });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, { type: format });\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = (shader) => {\n      shader.vertexShader = \"#define USE_LIGHTMAP\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }\";\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"varying vec2 vUv2;\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n      shader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };\n      shader.uniforms.averagingWindow = { value: 100 };\n      this.uvMat.uniforms = shader.uniforms;\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob];\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n      if (!object.geometry.hasAttribute(\"uv\")) {\n        console.warn(\"All lightmap objects need UVs!\");\n        continue;\n      }\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      }\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1e3 + ob;\n      this.uv_boxes.push({ w: 1 + padding * 2, h: 1 + padding * 2, index: ob });\n      this.lightMapContainers.push({ basicMat: object.material, object });\n      this.compiled = false;\n    }\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach((box) => {\n      const uv2 = objects[box.index].geometry.getAttribute(\"uv\").clone();\n      for (let i = 0; i < uv2.array.length; i += uv2.itemSize) {\n        uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n        uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n      objects[box.index].geometry.setAttribute(\"uv2\", uv2);\n      objects[box.index].geometry.getAttribute(\"uv2\").needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return;\n    }\n    const oldTarget = this.renderer.getRenderTarget();\n    this.blurringPlane.visible = blurEdges;\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    }\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget);\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    }\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = { value: blendWindow };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    }\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };\n    this.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    }\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n  showDebugLightmap(visible, position = void 0) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn(\"Call this after adding the objects!\");\n        this.warned = true;\n      }\n      return;\n    }\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n    if (position != void 0) {\n      this.labelMesh.position.copy(position);\n    }\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: { value: null },\n      pixelOffset: { value: 1 / res },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3\n    };\n    blurMaterial.onBeforeCompile = (shader) => {\n      shader.vertexShader = \"#define USE_UV\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"#define USE_UV\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`;\n      shader.uniforms.previousShadowMap = { value: lightMap.texture };\n      shader.uniforms.pixelOffset = { value: 0.5 / res };\n      blurMaterial.uniforms = shader.uniforms;\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = \"Blurring Plane\";\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n}\nexport {\n  ProgressiveLightMap\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}