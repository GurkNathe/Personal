{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, BufferAttribute, LoaderUtils } from \"three\";\nimport { unzlibSync } from \"fflate\";\nclass VTKLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    function parseASCII(data2) {\n      var indices = [];\n      var positions = [];\n      var colors = [];\n      var normals = [];\n      var result;\n      var patWord = /^[^\\d.\\s-]+/;\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n      var patPOINTS = /^POINTS /;\n      var patPOLYGONS = /^POLYGONS /;\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n      var lines = data2.split(\"\\n\");\n      for (var i in lines) {\n        var line = lines[i].trim();\n        if (line.indexOf(\"DATASET\") === 0) {\n          var dataset = line.split(\" \")[1];\n          if (dataset !== \"POLYDATA\") throw new Error(\"Unsupported DATASET type: \" + dataset);\n        } else if (inPointsSection) {\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break;\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1;\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              var i0, i1, i2;\n              for (var j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 2]);\n                  i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 1]);\n                  i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n      var geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n      if (normals.length === positions.length) {\n        geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      }\n      if (colors.length !== indices.length) {\n        if (colors.length === positions.length) {\n          geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        geometry = geometry.toNonIndexed();\n        var numTriangles = geometry.attributes.position.count / 3;\n        if (colors.length === numTriangles * 3) {\n          var newColors = [];\n          for (var i = 0; i < numTriangles; i++) {\n            var r = colors[3 * i + 0];\n            var g = colors[3 * i + 1];\n            var b = colors[3 * i + 2];\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n          }\n          geometry.setAttribute(\"color\", new Float32BufferAttribute(newColors, 3));\n        }\n      }\n      return geometry;\n    }\n    function parseBinary(data2) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data2);\n      var dataView = new DataView(data2);\n      var points = [];\n      var normals = [];\n      var indices = [];\n      var vtk = [];\n      var index = 0;\n      function findString(buffer2, start) {\n        var index2 = start;\n        var c = buffer2[index2];\n        var s2 = [];\n        while (c !== 10) {\n          s2.push(String.fromCharCode(c));\n          index2++;\n          c = buffer2[index2];\n        }\n        return {\n          start,\n          end: index2,\n          next: index2 + 1,\n          parsedString: s2.join(\"\")\n        };\n      }\n      var state, line;\n      while (true) {\n        state = findString(buffer, index);\n        line = state.parsedString;\n        if (line.indexOf(\"DATASET\") === 0) {\n          var dataset = line.split(\" \")[1];\n          if (dataset !== \"POLYDATA\") throw new Error(\"Unsupported DATASET type: \" + dataset);\n        } else if (line.indexOf(\"POINTS\") === 0) {\n          vtk.push(line);\n          numberOfPoints = parseInt(line.split(\" \")[1], 10);\n          count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          }\n          state.next = state.next + count + 1;\n        } else if (line.indexOf(\"TRIANGLE_STRIPS\") === 0) {\n          var numberOfStrips = parseInt(line.split(\" \")[1], 10);\n          var size = parseInt(line.split(\" \")[2], 10);\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          }\n          state.next = state.next + count + 1;\n        } else if (line.indexOf(\"POLYGONS\") === 0) {\n          var numberOfStrips = parseInt(line.split(\" \")[1], 10);\n          var size = parseInt(line.split(\" \")[2], 10);\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n            for (var j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          }\n          state.next = state.next + count + 1;\n        } else if (line.indexOf(\"POINT_DATA\") === 0) {\n          numberOfPoints = parseInt(line.split(\" \")[1], 10);\n          state = findString(buffer, state.next);\n          count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          }\n          state.next = state.next + count;\n        }\n        index = state.next;\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n      var geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute(\"position\", new BufferAttribute(points, 3));\n      if (normals.length === points.length) {\n        geometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n      }\n      return geometry;\n    }\n    function Float32Concat(first, second) {\n      const firstLength = first.length,\n        result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n        result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function parseXML(stringFile) {\n      function xmlToJson(xml) {\n        var obj = {};\n        if (xml.nodeType === 1) {\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj[\"attributes\"] = {};\n              for (var j2 = 0; j2 < xml.attributes.length; j2++) {\n                var attribute = xml.attributes.item(j2);\n                obj[\"attributes\"][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          obj = xml.nodeValue.trim();\n        }\n        if (xml.hasChildNodes()) {\n          for (var i2 = 0; i2 < xml.childNodes.length; i2++) {\n            var item = xml.childNodes.item(i2);\n            var nodeName = item.nodeName;\n            if (typeof obj[nodeName] === \"undefined\") {\n              var tmp = xmlToJson(item);\n              if (tmp !== \"\") obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === \"undefined\") {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n              var tmp = xmlToJson(item);\n              if (tmp !== \"\") obj[nodeName].push(tmp);\n            }\n          }\n        }\n        return obj;\n      }\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n        var i2;\n        var lookup = [];\n        var revLookup = [];\n        var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        var len2 = code.length;\n        for (i2 = 0; i2 < len2; i2++) {\n          lookup[i2] = code[i2];\n        }\n        for (i2 = 0; i2 < len2; ++i2) {\n          revLookup[code.charCodeAt(i2)] = i2;\n        }\n        revLookup[\"-\".charCodeAt(0)] = 62;\n        revLookup[\"_\".charCodeAt(0)] = 63;\n        var j2, l, tmp, placeHolders, arr2;\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        placeHolders = b64[len2 - 2] === \"=\" ? 2 : b64[len2 - 1] === \"=\" ? 1 : 0;\n        arr2 = new Arr(len2 * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len2 - 4 : len2;\n        var L = 0;\n        for (i2 = 0, j2 = 0; i2 < l; i2 += 4, j2 += 3) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr2[L++] = (tmp & 16711680) >> 16;\n          arr2[L++] = (tmp & 65280) >> 8;\n          arr2[L++] = tmp & 255;\n        }\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr2[L++] = tmp & 255;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr2[L++] = tmp >> 8 & 255;\n          arr2[L++] = tmp & 255;\n        }\n        return arr2;\n      }\n      function parseDataArray(ele, compressed2) {\n        var numBytes = 0;\n        if (json.attributes.header_type === \"UInt64\") {\n          numBytes = 8;\n        } else if (json.attributes.header_type === \"UInt32\") {\n          numBytes = 4;\n        }\n        if (ele.attributes.format === \"binary\" && compressed2) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n          if (ele.attributes.type === \"Float32\") {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === \"Int64\") {\n            var txt = new Int32Array();\n          }\n          rawData = ele[\"#text\"];\n          byteData = Base64toByteArray(rawData);\n          blocks = byteData[0];\n          for (var i2 = 1; i2 < numBytes - 1; i2++) {\n            blocks = blocks | byteData[i2] << i2 * numBytes;\n          }\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset);\n          cSizeStart = 3 * numBytes;\n          for (var i2 = 0; i2 < blocks; i2++) {\n            var currentBlockSize = byteData[i2 * numBytes + cSizeStart];\n            for (var j2 = 1; j2 < numBytes - 1; j2++) {\n              currentBlockSize = currentBlockSize | byteData[i2 * numBytes + cSizeStart + j2] << j2 * 8;\n            }\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n          for (var i2 = 0; i2 < dataOffsets.length - 1; i2++) {\n            var data2 = unzlibSync(byteData.slice(dataOffsets[i2], dataOffsets[i2 + 1]));\n            content = data2.buffer;\n            if (ele.attributes.type === \"Float32\") {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === \"Int64\") {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n          delete ele[\"#text\"];\n          if (ele.attributes.type === \"Int64\") {\n            if (ele.attributes.format === \"binary\") {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === \"binary\" && !compressed2) {\n            var content = Base64toByteArray(ele[\"#text\"]);\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele[\"#text\"]) {\n              var content = ele[\"#text\"].split(/\\s+/).filter(function (el) {\n                if (el !== \"\") return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n          delete ele[\"#text\"];\n          if (ele.attributes.type === \"Float32\") {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === \"Int32\") {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === \"Int64\") {\n            var txt = new Int32Array(content);\n            if (ele.attributes.format === \"binary\") {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        }\n        return txt;\n      }\n      var dom = null;\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, \"text/xml\");\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject(\"Microsoft.XMLDOM\");\n          dom.async = false;\n          if (!dom.loadXML(\n            /* xml */\n          )) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error(\"Cannot parse xml string!\");\n      }\n      var doc = dom.documentElement;\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty(\"compressor\");\n        var sections = [\"PointData\", \"Points\", \"Strips\", \"Polys\"];\n        var sectionIndex = 0,\n          numberOfSections = sections.length;\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]];\n          if (section && section.DataArray) {\n            if (Object.prototype.toString.call(section.DataArray) === \"[object Array]\") {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n            var dataArrayIndex = 0,\n              numberOfDataArrays = arr.length;\n            while (dataArrayIndex < numberOfDataArrays) {\n              if (\"#text\" in arr[dataArrayIndex] && arr[dataArrayIndex][\"#text\"].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n              dataArrayIndex++;\n            }\n            switch (sections[sectionIndex]) {\n              case \"PointData\":\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n                if (numberOfPoints > 0) {\n                  for (var i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[i].text, 0);\n                    }\n                  }\n                }\n                break;\n              case \"Points\":\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n                break;\n              case \"Strips\":\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                  var indicesIndex = 0;\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = [];\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s]);\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 2];\n                        indices[indicesIndex++] = strip[j + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 1];\n                        indices[indicesIndex++] = strip[j + 2];\n                      }\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                  }\n                }\n                break;\n              case \"Polys\":\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0,\n                    connectivityIndex = 0;\n                  var i = 0,\n                    len = numberOfPolys,\n                    len0 = 0;\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0,\n                      len1 = offset[i];\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n                    var j = 1;\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n                break;\n              default:\n                break;\n            }\n          }\n          sectionIndex++;\n        }\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute(\"position\", new BufferAttribute(points, 3));\n        if (normals.length === points.length) {\n          geometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n        }\n        return geometry;\n      } else {\n        throw new Error(\"Unsupported DATASET type\");\n      }\n    }\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split(\"\\n\");\n    if (meta[0].indexOf(\"xml\") !== -1) {\n      return parseXML(LoaderUtils.decodeText(data));\n    } else if (meta[2].includes(\"ASCII\")) {\n      return parseASCII(LoaderUtils.decodeText(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n}\nexport { VTKLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","Float32BufferAttribute","BufferAttribute","LoaderUtils","unzlibSync","VTKLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","parseASCII","data2","indices","positions","colors","normals","result","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","split","i","line","trim","indexOf","dataset","Error","exec","x","parseFloat","y","z","push","numVertices","parseInt","inds","i0","i1","i2","k","j","r","g","b","nx","ny","nz","geometry","setIndex","setAttribute","length","toNonIndexed","numTriangles","attributes","position","count","newColors","parseBinary","pointIndex","numberOfPoints","s","buffer","Uint8Array","dataView","DataView","points","vtk","index","findString","buffer2","start","index2","c","s2","String","fromCharCode","end","next","parsedString","join","state","Float32Array","getFloat32","numberOfStrips","size","Uint32Array","indicesIndex","indexCount","getInt32","strip","byteLength","Float32Concat","first","second","firstLength","set","Int32Concat","Int32Array","parseXML","stringFile","xmlToJson","xml","obj","nodeType","j2","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","tmp","old","Base64toByteArray","b64","Arr","Array","lookup","revLookup","code","len2","charCodeAt","l","placeHolders","arr2","L","parseDataArray","ele","compressed2","numBytes","json","header_type","format","rawData","content","byteData","blocks","cSizeStart","headerSize","padding","dataOffsets","currentOffset","type","txt","currentBlockSize","slice","filter","el","idx","dom","window","DOMParser","parseFromString","ActiveXObject","async","loadXML","parseError","reason","srcText","doc","documentElement","PolyData","piece","Piece","compressed","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","Object","prototype","toString","call","arr","dataArrayIndex","numberOfDataArrays","NumberOfPoints","normalsName","Normals","len","Name","components","NumberOfComponents","NumberOfStrips","connectivity","offset","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","meta","decodeText","includes"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/VTKLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, BufferAttribute, LoaderUtils } from \"three\";\nimport { unzlibSync } from \"fflate\";\nclass VTKLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data) {\n    function parseASCII(data2) {\n      var indices = [];\n      var positions = [];\n      var colors = [];\n      var normals = [];\n      var result;\n      var patWord = /^[^\\d.\\s-]+/;\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n      var patPOINTS = /^POINTS /;\n      var patPOLYGONS = /^POLYGONS /;\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n      var lines = data2.split(\"\\n\");\n      for (var i in lines) {\n        var line = lines[i].trim();\n        if (line.indexOf(\"DATASET\") === 0) {\n          var dataset = line.split(\" \")[1];\n          if (dataset !== \"POLYDATA\")\n            throw new Error(\"Unsupported DATASET type: \" + dataset);\n        } else if (inPointsSection) {\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null)\n              break;\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1;\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              var i0, i1, i2;\n              for (var j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 2]);\n                  i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 1]);\n                  i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null)\n                break;\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null)\n                break;\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n      var geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n      if (normals.length === positions.length) {\n        geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      }\n      if (colors.length !== indices.length) {\n        if (colors.length === positions.length) {\n          geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        geometry = geometry.toNonIndexed();\n        var numTriangles = geometry.attributes.position.count / 3;\n        if (colors.length === numTriangles * 3) {\n          var newColors = [];\n          for (var i = 0; i < numTriangles; i++) {\n            var r = colors[3 * i + 0];\n            var g = colors[3 * i + 1];\n            var b = colors[3 * i + 2];\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n          }\n          geometry.setAttribute(\"color\", new Float32BufferAttribute(newColors, 3));\n        }\n      }\n      return geometry;\n    }\n    function parseBinary(data2) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data2);\n      var dataView = new DataView(data2);\n      var points = [];\n      var normals = [];\n      var indices = [];\n      var vtk = [];\n      var index = 0;\n      function findString(buffer2, start) {\n        var index2 = start;\n        var c = buffer2[index2];\n        var s2 = [];\n        while (c !== 10) {\n          s2.push(String.fromCharCode(c));\n          index2++;\n          c = buffer2[index2];\n        }\n        return { start, end: index2, next: index2 + 1, parsedString: s2.join(\"\") };\n      }\n      var state, line;\n      while (true) {\n        state = findString(buffer, index);\n        line = state.parsedString;\n        if (line.indexOf(\"DATASET\") === 0) {\n          var dataset = line.split(\" \")[1];\n          if (dataset !== \"POLYDATA\")\n            throw new Error(\"Unsupported DATASET type: \" + dataset);\n        } else if (line.indexOf(\"POINTS\") === 0) {\n          vtk.push(line);\n          numberOfPoints = parseInt(line.split(\" \")[1], 10);\n          count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          }\n          state.next = state.next + count + 1;\n        } else if (line.indexOf(\"TRIANGLE_STRIPS\") === 0) {\n          var numberOfStrips = parseInt(line.split(\" \")[1], 10);\n          var size = parseInt(line.split(\" \")[2], 10);\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          }\n          state.next = state.next + count + 1;\n        } else if (line.indexOf(\"POLYGONS\") === 0) {\n          var numberOfStrips = parseInt(line.split(\" \")[1], 10);\n          var size = parseInt(line.split(\" \")[2], 10);\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n            for (var j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          }\n          state.next = state.next + count + 1;\n        } else if (line.indexOf(\"POINT_DATA\") === 0) {\n          numberOfPoints = parseInt(line.split(\" \")[1], 10);\n          state = findString(buffer, state.next);\n          count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          }\n          state.next = state.next + count;\n        }\n        index = state.next;\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n      var geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute(\"position\", new BufferAttribute(points, 3));\n      if (normals.length === points.length) {\n        geometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n      }\n      return geometry;\n    }\n    function Float32Concat(first, second) {\n      const firstLength = first.length, result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function Int32Concat(first, second) {\n      var firstLength = first.length, result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function parseXML(stringFile) {\n      function xmlToJson(xml) {\n        var obj = {};\n        if (xml.nodeType === 1) {\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj[\"attributes\"] = {};\n              for (var j2 = 0; j2 < xml.attributes.length; j2++) {\n                var attribute = xml.attributes.item(j2);\n                obj[\"attributes\"][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          obj = xml.nodeValue.trim();\n        }\n        if (xml.hasChildNodes()) {\n          for (var i2 = 0; i2 < xml.childNodes.length; i2++) {\n            var item = xml.childNodes.item(i2);\n            var nodeName = item.nodeName;\n            if (typeof obj[nodeName] === \"undefined\") {\n              var tmp = xmlToJson(item);\n              if (tmp !== \"\")\n                obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === \"undefined\") {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n              var tmp = xmlToJson(item);\n              if (tmp !== \"\")\n                obj[nodeName].push(tmp);\n            }\n          }\n        }\n        return obj;\n      }\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n        var i2;\n        var lookup = [];\n        var revLookup = [];\n        var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        var len2 = code.length;\n        for (i2 = 0; i2 < len2; i2++) {\n          lookup[i2] = code[i2];\n        }\n        for (i2 = 0; i2 < len2; ++i2) {\n          revLookup[code.charCodeAt(i2)] = i2;\n        }\n        revLookup[\"-\".charCodeAt(0)] = 62;\n        revLookup[\"_\".charCodeAt(0)] = 63;\n        var j2, l, tmp, placeHolders, arr2;\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        placeHolders = b64[len2 - 2] === \"=\" ? 2 : b64[len2 - 1] === \"=\" ? 1 : 0;\n        arr2 = new Arr(len2 * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len2 - 4 : len2;\n        var L = 0;\n        for (i2 = 0, j2 = 0; i2 < l; i2 += 4, j2 += 3) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr2[L++] = (tmp & 16711680) >> 16;\n          arr2[L++] = (tmp & 65280) >> 8;\n          arr2[L++] = tmp & 255;\n        }\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr2[L++] = tmp & 255;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr2[L++] = tmp >> 8 & 255;\n          arr2[L++] = tmp & 255;\n        }\n        return arr2;\n      }\n      function parseDataArray(ele, compressed2) {\n        var numBytes = 0;\n        if (json.attributes.header_type === \"UInt64\") {\n          numBytes = 8;\n        } else if (json.attributes.header_type === \"UInt32\") {\n          numBytes = 4;\n        }\n        if (ele.attributes.format === \"binary\" && compressed2) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n          if (ele.attributes.type === \"Float32\") {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === \"Int64\") {\n            var txt = new Int32Array();\n          }\n          rawData = ele[\"#text\"];\n          byteData = Base64toByteArray(rawData);\n          blocks = byteData[0];\n          for (var i2 = 1; i2 < numBytes - 1; i2++) {\n            blocks = blocks | byteData[i2] << i2 * numBytes;\n          }\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset);\n          cSizeStart = 3 * numBytes;\n          for (var i2 = 0; i2 < blocks; i2++) {\n            var currentBlockSize = byteData[i2 * numBytes + cSizeStart];\n            for (var j2 = 1; j2 < numBytes - 1; j2++) {\n              currentBlockSize = currentBlockSize | byteData[i2 * numBytes + cSizeStart + j2] << j2 * 8;\n            }\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n          for (var i2 = 0; i2 < dataOffsets.length - 1; i2++) {\n            var data2 = unzlibSync(byteData.slice(dataOffsets[i2], dataOffsets[i2 + 1]));\n            content = data2.buffer;\n            if (ele.attributes.type === \"Float32\") {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === \"Int64\") {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n          delete ele[\"#text\"];\n          if (ele.attributes.type === \"Int64\") {\n            if (ele.attributes.format === \"binary\") {\n              txt = txt.filter(function(el, idx) {\n                if (idx % 2 !== 1)\n                  return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === \"binary\" && !compressed2) {\n            var content = Base64toByteArray(ele[\"#text\"]);\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele[\"#text\"]) {\n              var content = ele[\"#text\"].split(/\\s+/).filter(function(el) {\n                if (el !== \"\")\n                  return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n          delete ele[\"#text\"];\n          if (ele.attributes.type === \"Float32\") {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === \"Int32\") {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === \"Int64\") {\n            var txt = new Int32Array(content);\n            if (ele.attributes.format === \"binary\") {\n              txt = txt.filter(function(el, idx) {\n                if (idx % 2 !== 1)\n                  return true;\n              });\n            }\n          }\n        }\n        return txt;\n      }\n      var dom = null;\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, \"text/xml\");\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject(\"Microsoft.XMLDOM\");\n          dom.async = false;\n          if (!dom.loadXML(\n            /* xml */\n          )) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error(\"Cannot parse xml string!\");\n      }\n      var doc = dom.documentElement;\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty(\"compressor\");\n        var sections = [\"PointData\", \"Points\", \"Strips\", \"Polys\"];\n        var sectionIndex = 0, numberOfSections = sections.length;\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]];\n          if (section && section.DataArray) {\n            if (Object.prototype.toString.call(section.DataArray) === \"[object Array]\") {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n            var dataArrayIndex = 0, numberOfDataArrays = arr.length;\n            while (dataArrayIndex < numberOfDataArrays) {\n              if (\"#text\" in arr[dataArrayIndex] && arr[dataArrayIndex][\"#text\"].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n              dataArrayIndex++;\n            }\n            switch (sections[sectionIndex]) {\n              case \"PointData\":\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n                if (numberOfPoints > 0) {\n                  for (var i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[i].text, 0);\n                    }\n                  }\n                }\n                break;\n              case \"Points\":\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n                break;\n              case \"Strips\":\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                  var indicesIndex = 0;\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = [];\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s]);\n                      if (i > 0)\n                        len0 = offset[i - 1];\n                    }\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 2];\n                        indices[indicesIndex++] = strip[j + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 1];\n                        indices[indicesIndex++] = strip[j + 2];\n                      }\n                      if (i > 0)\n                        len0 = offset[i - 1];\n                    }\n                  }\n                }\n                break;\n              case \"Polys\":\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0, connectivityIndex = 0;\n                  var i = 0, len = numberOfPolys, len0 = 0;\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0, len1 = offset[i];\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n                    var j = 1;\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n                break;\n              default:\n                break;\n            }\n          }\n          sectionIndex++;\n        }\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute(\"position\", new BufferAttribute(points, 3));\n        if (normals.length === points.length) {\n          geometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n        }\n        return geometry;\n      } else {\n        throw new Error(\"Unsupported DATASET type\");\n      }\n    }\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split(\"\\n\");\n    if (meta[0].indexOf(\"xml\") !== -1) {\n      return parseXML(LoaderUtils.decodeText(data));\n    } else if (meta[2].includes(\"ASCII\")) {\n      return parseASCII(LoaderUtils.decodeText(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n}\nexport {\n  VTKLoader\n};\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,UAAU,EAAEC,cAAc,EAAEC,sBAAsB,EAAEC,eAAe,EAAEC,WAAW,QAAQ,OAAO;AAChH,SAASC,UAAU,QAAQ,QAAQ;AACnC,MAAMC,SAAS,SAASP,MAAM,CAAC;EAC7BQ,WAAWA,CAACC,OAAO,EAAE;IACnB,KAAK,CAACA,OAAO,CAAC;EAChB;EACAC,IAAIA,CAACC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;IACrC,MAAMC,KAAK,GAAG,IAAI;IAClB,MAAMC,MAAM,GAAG,IAAIf,UAAU,CAACc,KAAK,CAACN,OAAO,CAAC;IAC5CO,MAAM,CAACC,OAAO,CAACF,KAAK,CAACG,IAAI,CAAC;IAC1BF,MAAM,CAACG,eAAe,CAAC,aAAa,CAAC;IACrCH,MAAM,CAACI,gBAAgB,CAACL,KAAK,CAACM,aAAa,CAAC;IAC5CL,MAAM,CAACM,kBAAkB,CAACP,KAAK,CAACQ,eAAe,CAAC;IAChDP,MAAM,CAACN,IAAI,CACTC,GAAG,EACH,UAASa,IAAI,EAAE;MACb,IAAI;QACFZ,MAAM,CAACG,KAAK,CAACU,KAAK,CAACD,IAAI,CAAC,CAAC;MAC3B,CAAC,CAAC,OAAOE,CAAC,EAAE;QACV,IAAIZ,OAAO,EAAE;UACXA,OAAO,CAACY,CAAC,CAAC;QACZ,CAAC,MAAM;UACLC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;QAClB;QACAX,KAAK,CAACN,OAAO,CAACoB,SAAS,CAAClB,GAAG,CAAC;MAC9B;IACF,CAAC,EACDE,UAAU,EACVC,OACF,CAAC;EACH;EACAW,KAAKA,CAACK,IAAI,EAAE;IACV,SAASC,UAAUA,CAACC,KAAK,EAAE;MACzB,IAAIC,OAAO,GAAG,EAAE;MAChB,IAAIC,SAAS,GAAG,EAAE;MAClB,IAAIC,MAAM,GAAG,EAAE;MACf,IAAIC,OAAO,GAAG,EAAE;MAChB,IAAIC,MAAM;MACV,IAAIC,OAAO,GAAG,aAAa;MAC3B,IAAIC,UAAU,GAAG,wEAAwE;MACzF,IAAIC,eAAe,GAAG,oBAAoB;MAC1C,IAAIC,SAAS,GAAG,UAAU;MAC1B,IAAIC,WAAW,GAAG,YAAY;MAC9B,IAAIC,kBAAkB,GAAG,mBAAmB;MAC5C,IAAIC,aAAa,GAAG,sBAAsB;MAC1C,IAAIC,YAAY,GAAG,qBAAqB;MACxC,IAAIC,gBAAgB,GAAG,8BAA8B;MACrD,IAAIC,UAAU,GAAG,4BAA4B;MAC7C,IAAIC,eAAe,GAAG,KAAK;MAC3B,IAAIC,iBAAiB,GAAG,KAAK;MAC7B,IAAIC,sBAAsB,GAAG,KAAK;MAClC,IAAIC,kBAAkB,GAAG,KAAK;MAC9B,IAAIC,iBAAiB,GAAG,KAAK;MAC7B,IAAIC,cAAc,GAAG,KAAK;MAC1B,IAAIC,gBAAgB,GAAG,KAAK;MAC5B,IAAIC,KAAK,GAAGvB,KAAK,CAACwB,KAAK,CAAC,IAAI,CAAC;MAC7B,KAAK,IAAIC,CAAC,IAAIF,KAAK,EAAE;QACnB,IAAIG,IAAI,GAAGH,KAAK,CAACE,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;QAC1B,IAAID,IAAI,CAACE,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;UACjC,IAAIC,OAAO,GAAGH,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UAChC,IAAIK,OAAO,KAAK,UAAU,EACxB,MAAM,IAAIC,KAAK,CAAC,4BAA4B,GAAGD,OAAO,CAAC;QAC3D,CAAC,MAAM,IAAIb,eAAe,EAAE;UAC1B,OAAO,CAACX,MAAM,GAAGE,UAAU,CAACwB,IAAI,CAACL,IAAI,CAAC,MAAM,IAAI,EAAE;YAChD,IAAIpB,OAAO,CAACyB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAC7B;YACF,IAAIM,CAAC,GAAGC,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7B,IAAI6B,CAAC,GAAGD,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7B,IAAI8B,CAAC,GAAGF,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7BH,SAAS,CAACkC,IAAI,CAACJ,CAAC,EAAEE,CAAC,EAAEC,CAAC,CAAC;UACzB;QACF,CAAC,MAAM,IAAIlB,iBAAiB,EAAE;UAC5B,IAAI,CAACZ,MAAM,GAAGG,eAAe,CAACuB,IAAI,CAACL,IAAI,CAAC,MAAM,IAAI,EAAE;YAClD,IAAIW,WAAW,GAAGC,QAAQ,CAACjC,MAAM,CAAC,CAAC,CAAC,CAAC;YACrC,IAAIkC,IAAI,GAAGlC,MAAM,CAAC,CAAC,CAAC,CAACmB,KAAK,CAAC,KAAK,CAAC;YACjC,IAAIa,WAAW,IAAI,CAAC,EAAE;cACpB,IAAIG,EAAE,GAAGF,QAAQ,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;cAC1B,IAAIE,EAAE,EAAEC,EAAE;cACV,IAAIC,CAAC,GAAG,CAAC;cACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,WAAW,GAAG,CAAC,EAAE,EAAEO,CAAC,EAAE;gBACxCH,EAAE,GAAGH,QAAQ,CAACC,IAAI,CAACI,CAAC,CAAC,CAAC;gBACtBD,EAAE,GAAGJ,QAAQ,CAACC,IAAI,CAACI,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC1B1C,OAAO,CAACmC,IAAI,CAACI,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBACxBC,CAAC,EAAE;cACL;YACF;UACF;QACF,CAAC,MAAM,IAAIzB,sBAAsB,EAAE;UACjC,IAAI,CAACb,MAAM,GAAGG,eAAe,CAACuB,IAAI,CAACL,IAAI,CAAC,MAAM,IAAI,EAAE;YAClD,IAAIW,WAAW,GAAGC,QAAQ,CAACjC,MAAM,CAAC,CAAC,CAAC,CAAC;YACrC,IAAIkC,IAAI,GAAGlC,MAAM,CAAC,CAAC,CAAC,CAACmB,KAAK,CAAC,KAAK,CAAC;YACjC,IAAIa,WAAW,IAAI,CAAC,EAAE;cACpB,IAAIG,EAAE,EAAEC,EAAE,EAAEC,EAAE;cACd,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,WAAW,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;gBACxC,IAAIA,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;kBACfJ,EAAE,GAAGF,QAAQ,CAACC,IAAI,CAACK,CAAC,CAAC,CAAC;kBACtBH,EAAE,GAAGH,QAAQ,CAACC,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,CAAC;kBAC1BF,EAAE,GAAGJ,QAAQ,CAACC,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,CAAC;kBAC1B3C,OAAO,CAACmC,IAAI,CAACI,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBAC1B,CAAC,MAAM;kBACLF,EAAE,GAAGF,QAAQ,CAACC,IAAI,CAACK,CAAC,CAAC,CAAC;kBACtBH,EAAE,GAAGH,QAAQ,CAACC,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,CAAC;kBAC1BF,EAAE,GAAGJ,QAAQ,CAACC,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,CAAC;kBAC1B3C,OAAO,CAACmC,IAAI,CAACI,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBAC1B;cACF;YACF;UACF;QACF,CAAC,MAAM,IAAIvB,kBAAkB,IAAIC,iBAAiB,EAAE;UAClD,IAAIC,cAAc,EAAE;YAClB,OAAO,CAAChB,MAAM,GAAGE,UAAU,CAACwB,IAAI,CAACL,IAAI,CAAC,MAAM,IAAI,EAAE;cAChD,IAAIpB,OAAO,CAACyB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAC7B;cACF,IAAImB,CAAC,GAAGZ,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;cAC7B,IAAIyC,CAAC,GAAGb,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;cAC7B,IAAI0C,CAAC,GAAGd,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;cAC7BF,MAAM,CAACiC,IAAI,CAACS,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;YACtB;UACF,CAAC,MAAM,IAAIzB,gBAAgB,EAAE;YAC3B,OAAO,CAACjB,MAAM,GAAGE,UAAU,CAACwB,IAAI,CAACL,IAAI,CAAC,MAAM,IAAI,EAAE;cAChD,IAAIpB,OAAO,CAACyB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAC7B;cACF,IAAIsB,EAAE,GAAGf,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;cAC9B,IAAI4C,EAAE,GAAGhB,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;cAC9B,IAAI6C,EAAE,GAAGjB,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;cAC9BD,OAAO,CAACgC,IAAI,CAACY,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;YAC1B;UACF;QACF;QACA,IAAIxC,WAAW,CAACqB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAAE;UACnCT,iBAAiB,GAAG,IAAI;UACxBD,eAAe,GAAG,KAAK;UACvBE,sBAAsB,GAAG,KAAK;QAChC,CAAC,MAAM,IAAIT,SAAS,CAACsB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAAE;UACxCT,iBAAiB,GAAG,KAAK;UACzBD,eAAe,GAAG,IAAI;UACtBE,sBAAsB,GAAG,KAAK;QAChC,CAAC,MAAM,IAAIP,kBAAkB,CAACoB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAAE;UACjDT,iBAAiB,GAAG,KAAK;UACzBD,eAAe,GAAG,KAAK;UACvBE,sBAAsB,GAAG,IAAI;QAC/B,CAAC,MAAM,IAAIN,aAAa,CAACmB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAAE;UAC5CP,kBAAkB,GAAG,IAAI;UACzBH,eAAe,GAAG,KAAK;UACvBC,iBAAiB,GAAG,KAAK;UACzBC,sBAAsB,GAAG,KAAK;QAChC,CAAC,MAAM,IAAIL,YAAY,CAACkB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAAE;UAC3CN,iBAAiB,GAAG,IAAI;UACxBJ,eAAe,GAAG,KAAK;UACvBC,iBAAiB,GAAG,KAAK;UACzBC,sBAAsB,GAAG,KAAK;QAChC,CAAC,MAAM,IAAIJ,gBAAgB,CAACiB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAAE;UAC/CL,cAAc,GAAG,IAAI;UACrBC,gBAAgB,GAAG,KAAK;UACxBN,eAAe,GAAG,KAAK;UACvBC,iBAAiB,GAAG,KAAK;UACzBC,sBAAsB,GAAG,KAAK;QAChC,CAAC,MAAM,IAAIH,UAAU,CAACgB,IAAI,CAACL,IAAI,CAAC,KAAK,IAAI,EAAE;UACzCJ,gBAAgB,GAAG,IAAI;UACvBD,cAAc,GAAG,KAAK;UACtBL,eAAe,GAAG,KAAK;UACvBC,iBAAiB,GAAG,KAAK;UACzBC,sBAAsB,GAAG,KAAK;QAChC;MACF;MACA,IAAIiC,QAAQ,GAAG,IAAIjF,cAAc,CAAC,CAAC;MACnCiF,QAAQ,CAACC,QAAQ,CAACnD,OAAO,CAAC;MAC1BkD,QAAQ,CAACE,YAAY,CAAC,UAAU,EAAE,IAAIlF,sBAAsB,CAAC+B,SAAS,EAAE,CAAC,CAAC,CAAC;MAC3E,IAAIE,OAAO,CAACkD,MAAM,KAAKpD,SAAS,CAACoD,MAAM,EAAE;QACvCH,QAAQ,CAACE,YAAY,CAAC,QAAQ,EAAE,IAAIlF,sBAAsB,CAACiC,OAAO,EAAE,CAAC,CAAC,CAAC;MACzE;MACA,IAAID,MAAM,CAACmD,MAAM,KAAKrD,OAAO,CAACqD,MAAM,EAAE;QACpC,IAAInD,MAAM,CAACmD,MAAM,KAAKpD,SAAS,CAACoD,MAAM,EAAE;UACtCH,QAAQ,CAACE,YAAY,CAAC,OAAO,EAAE,IAAIlF,sBAAsB,CAACgC,MAAM,EAAE,CAAC,CAAC,CAAC;QACvE;MACF,CAAC,MAAM;QACLgD,QAAQ,GAAGA,QAAQ,CAACI,YAAY,CAAC,CAAC;QAClC,IAAIC,YAAY,GAAGL,QAAQ,CAACM,UAAU,CAACC,QAAQ,CAACC,KAAK,GAAG,CAAC;QACzD,IAAIxD,MAAM,CAACmD,MAAM,KAAKE,YAAY,GAAG,CAAC,EAAE;UACtC,IAAII,SAAS,GAAG,EAAE;UAClB,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,YAAY,EAAE/B,CAAC,EAAE,EAAE;YACrC,IAAIoB,CAAC,GAAG1C,MAAM,CAAC,CAAC,GAAGsB,CAAC,GAAG,CAAC,CAAC;YACzB,IAAIqB,CAAC,GAAG3C,MAAM,CAAC,CAAC,GAAGsB,CAAC,GAAG,CAAC,CAAC;YACzB,IAAIsB,CAAC,GAAG5C,MAAM,CAAC,CAAC,GAAGsB,CAAC,GAAG,CAAC,CAAC;YACzBmC,SAAS,CAACxB,IAAI,CAACS,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;YACvBa,SAAS,CAACxB,IAAI,CAACS,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;YACvBa,SAAS,CAACxB,IAAI,CAACS,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;UACzB;UACAI,QAAQ,CAACE,YAAY,CAAC,OAAO,EAAE,IAAIlF,sBAAsB,CAACyF,SAAS,EAAE,CAAC,CAAC,CAAC;QAC1E;MACF;MACA,OAAOT,QAAQ;IACjB;IACA,SAASU,WAAWA,CAAC7D,KAAK,EAAE;MAC1B,IAAI2D,KAAK,EAAEG,UAAU,EAAErC,CAAC,EAAEsC,cAAc,EAAEC,CAAC;MAC3C,IAAIC,MAAM,GAAG,IAAIC,UAAU,CAAClE,KAAK,CAAC;MAClC,IAAImE,QAAQ,GAAG,IAAIC,QAAQ,CAACpE,KAAK,CAAC;MAClC,IAAIqE,MAAM,GAAG,EAAE;MACf,IAAIjE,OAAO,GAAG,EAAE;MAChB,IAAIH,OAAO,GAAG,EAAE;MAChB,IAAIqE,GAAG,GAAG,EAAE;MACZ,IAAIC,KAAK,GAAG,CAAC;MACb,SAASC,UAAUA,CAACC,OAAO,EAAEC,KAAK,EAAE;QAClC,IAAIC,MAAM,GAAGD,KAAK;QAClB,IAAIE,CAAC,GAAGH,OAAO,CAACE,MAAM,CAAC;QACvB,IAAIE,EAAE,GAAG,EAAE;QACX,OAAOD,CAAC,KAAK,EAAE,EAAE;UACfC,EAAE,CAACzC,IAAI,CAAC0C,MAAM,CAACC,YAAY,CAACH,CAAC,CAAC,CAAC;UAC/BD,MAAM,EAAE;UACRC,CAAC,GAAGH,OAAO,CAACE,MAAM,CAAC;QACrB;QACA,OAAO;UAAED,KAAK;UAAEM,GAAG,EAAEL,MAAM;UAAEM,IAAI,EAAEN,MAAM,GAAG,CAAC;UAAEO,YAAY,EAAEL,EAAE,CAACM,IAAI,CAAC,EAAE;QAAE,CAAC;MAC5E;MACA,IAAIC,KAAK,EAAE1D,IAAI;MACf,OAAO,IAAI,EAAE;QACX0D,KAAK,GAAGZ,UAAU,CAACP,MAAM,EAAEM,KAAK,CAAC;QACjC7C,IAAI,GAAG0D,KAAK,CAACF,YAAY;QACzB,IAAIxD,IAAI,CAACE,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;UACjC,IAAIC,OAAO,GAAGH,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UAChC,IAAIK,OAAO,KAAK,UAAU,EACxB,MAAM,IAAIC,KAAK,CAAC,4BAA4B,GAAGD,OAAO,CAAC;QAC3D,CAAC,MAAM,IAAIH,IAAI,CAACE,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;UACvC0C,GAAG,CAAClC,IAAI,CAACV,IAAI,CAAC;UACdqC,cAAc,GAAGzB,QAAQ,CAACZ,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UACjDmC,KAAK,GAAGI,cAAc,GAAG,CAAC,GAAG,CAAC;UAC9BM,MAAM,GAAG,IAAIgB,YAAY,CAACtB,cAAc,GAAG,CAAC,CAAC;UAC7CD,UAAU,GAAGsB,KAAK,CAACH,IAAI;UACvB,KAAKxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsC,cAAc,EAAEtC,CAAC,EAAE,EAAE;YACnC4C,MAAM,CAAC,CAAC,GAAG5C,CAAC,CAAC,GAAG0C,QAAQ,CAACmB,UAAU,CAACxB,UAAU,EAAE,KAAK,CAAC;YACtDO,MAAM,CAAC,CAAC,GAAG5C,CAAC,GAAG,CAAC,CAAC,GAAG0C,QAAQ,CAACmB,UAAU,CAACxB,UAAU,GAAG,CAAC,EAAE,KAAK,CAAC;YAC9DO,MAAM,CAAC,CAAC,GAAG5C,CAAC,GAAG,CAAC,CAAC,GAAG0C,QAAQ,CAACmB,UAAU,CAACxB,UAAU,GAAG,CAAC,EAAE,KAAK,CAAC;YAC9DA,UAAU,GAAGA,UAAU,GAAG,EAAE;UAC9B;UACAsB,KAAK,CAACH,IAAI,GAAGG,KAAK,CAACH,IAAI,GAAGtB,KAAK,GAAG,CAAC;QACrC,CAAC,MAAM,IAAIjC,IAAI,CAACE,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE;UAChD,IAAI2D,cAAc,GAAGjD,QAAQ,CAACZ,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UACrD,IAAIgE,IAAI,GAAGlD,QAAQ,CAACZ,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UAC3CmC,KAAK,GAAG6B,IAAI,GAAG,CAAC;UAChBvF,OAAO,GAAG,IAAIwF,WAAW,CAAC,CAAC,GAAGD,IAAI,GAAG,CAAC,GAAGD,cAAc,CAAC;UACxD,IAAIG,YAAY,GAAG,CAAC;UACpB5B,UAAU,GAAGsB,KAAK,CAACH,IAAI;UACvB,KAAKxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8D,cAAc,EAAE9D,CAAC,EAAE,EAAE;YACnC,IAAIkE,UAAU,GAAGxB,QAAQ,CAACyB,QAAQ,CAAC9B,UAAU,EAAE,KAAK,CAAC;YACrD,IAAI+B,KAAK,GAAG,EAAE;YACd/B,UAAU,IAAI,CAAC;YACf,KAAKE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2B,UAAU,EAAE3B,CAAC,EAAE,EAAE;cAC/B6B,KAAK,CAACzD,IAAI,CAAC+B,QAAQ,CAACyB,QAAQ,CAAC9B,UAAU,EAAE,KAAK,CAAC,CAAC;cAChDA,UAAU,IAAI,CAAC;YACjB;YACA,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,UAAU,GAAG,CAAC,EAAE/C,CAAC,EAAE,EAAE;cACvC,IAAIA,CAAC,GAAG,CAAC,EAAE;gBACT3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,CAAC;gBAClC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;gBACtC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;cACxC,CAAC,MAAM;gBACL3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,CAAC;gBAClC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;gBACtC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;cACxC;YACF;UACF;UACAwC,KAAK,CAACH,IAAI,GAAGG,KAAK,CAACH,IAAI,GAAGtB,KAAK,GAAG,CAAC;QACrC,CAAC,MAAM,IAAIjC,IAAI,CAACE,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;UACzC,IAAI2D,cAAc,GAAGjD,QAAQ,CAACZ,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UACrD,IAAIgE,IAAI,GAAGlD,QAAQ,CAACZ,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UAC3CmC,KAAK,GAAG6B,IAAI,GAAG,CAAC;UAChBvF,OAAO,GAAG,IAAIwF,WAAW,CAAC,CAAC,GAAGD,IAAI,GAAG,CAAC,GAAGD,cAAc,CAAC;UACxD,IAAIG,YAAY,GAAG,CAAC;UACpB5B,UAAU,GAAGsB,KAAK,CAACH,IAAI;UACvB,KAAKxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8D,cAAc,EAAE9D,CAAC,EAAE,EAAE;YACnC,IAAIkE,UAAU,GAAGxB,QAAQ,CAACyB,QAAQ,CAAC9B,UAAU,EAAE,KAAK,CAAC;YACrD,IAAI+B,KAAK,GAAG,EAAE;YACd/B,UAAU,IAAI,CAAC;YACf,KAAKE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2B,UAAU,EAAE3B,CAAC,EAAE,EAAE;cAC/B6B,KAAK,CAACzD,IAAI,CAAC+B,QAAQ,CAACyB,QAAQ,CAAC9B,UAAU,EAAE,KAAK,CAAC,CAAC;cAChDA,UAAU,IAAI,CAAC;YACjB;YACA,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,UAAU,GAAG,CAAC,EAAE/C,CAAC,EAAE,EAAE;cACvC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;cAClC5F,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,CAAC;cAClC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;YACxC;UACF;UACAwC,KAAK,CAACH,IAAI,GAAGG,KAAK,CAACH,IAAI,GAAGtB,KAAK,GAAG,CAAC;QACrC,CAAC,MAAM,IAAIjC,IAAI,CAACE,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;UAC3CmC,cAAc,GAAGzB,QAAQ,CAACZ,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UACjD4D,KAAK,GAAGZ,UAAU,CAACP,MAAM,EAAEmB,KAAK,CAACH,IAAI,CAAC;UACtCtB,KAAK,GAAGI,cAAc,GAAG,CAAC,GAAG,CAAC;UAC9B3D,OAAO,GAAG,IAAIiF,YAAY,CAACtB,cAAc,GAAG,CAAC,CAAC;UAC9CD,UAAU,GAAGsB,KAAK,CAACH,IAAI;UACvB,KAAKxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsC,cAAc,EAAEtC,CAAC,EAAE,EAAE;YACnCrB,OAAO,CAAC,CAAC,GAAGqB,CAAC,CAAC,GAAG0C,QAAQ,CAACmB,UAAU,CAACxB,UAAU,EAAE,KAAK,CAAC;YACvD1D,OAAO,CAAC,CAAC,GAAGqB,CAAC,GAAG,CAAC,CAAC,GAAG0C,QAAQ,CAACmB,UAAU,CAACxB,UAAU,GAAG,CAAC,EAAE,KAAK,CAAC;YAC/D1D,OAAO,CAAC,CAAC,GAAGqB,CAAC,GAAG,CAAC,CAAC,GAAG0C,QAAQ,CAACmB,UAAU,CAACxB,UAAU,GAAG,CAAC,EAAE,KAAK,CAAC;YAC/DA,UAAU,IAAI,EAAE;UAClB;UACAsB,KAAK,CAACH,IAAI,GAAGG,KAAK,CAACH,IAAI,GAAGtB,KAAK;QACjC;QACAY,KAAK,GAAGa,KAAK,CAACH,IAAI;QAClB,IAAIV,KAAK,IAAIN,MAAM,CAAC6B,UAAU,EAAE;UAC9B;QACF;MACF;MACA,IAAI3C,QAAQ,GAAG,IAAIjF,cAAc,CAAC,CAAC;MACnCiF,QAAQ,CAACC,QAAQ,CAAC,IAAIhF,eAAe,CAAC6B,OAAO,EAAE,CAAC,CAAC,CAAC;MAClDkD,QAAQ,CAACE,YAAY,CAAC,UAAU,EAAE,IAAIjF,eAAe,CAACiG,MAAM,EAAE,CAAC,CAAC,CAAC;MACjE,IAAIjE,OAAO,CAACkD,MAAM,KAAKe,MAAM,CAACf,MAAM,EAAE;QACpCH,QAAQ,CAACE,YAAY,CAAC,QAAQ,EAAE,IAAIjF,eAAe,CAACgC,OAAO,EAAE,CAAC,CAAC,CAAC;MAClE;MACA,OAAO+C,QAAQ;IACjB;IACA,SAAS4C,aAAaA,CAACC,KAAK,EAAEC,MAAM,EAAE;MACpC,MAAMC,WAAW,GAAGF,KAAK,CAAC1C,MAAM;QAAEjD,MAAM,GAAG,IAAIgF,YAAY,CAACa,WAAW,GAAGD,MAAM,CAAC3C,MAAM,CAAC;MACxFjD,MAAM,CAAC8F,GAAG,CAACH,KAAK,CAAC;MACjB3F,MAAM,CAAC8F,GAAG,CAACF,MAAM,EAAEC,WAAW,CAAC;MAC/B,OAAO7F,MAAM;IACf;IACA,SAAS+F,WAAWA,CAACJ,KAAK,EAAEC,MAAM,EAAE;MAClC,IAAIC,WAAW,GAAGF,KAAK,CAAC1C,MAAM;QAAEjD,MAAM,GAAG,IAAIgG,UAAU,CAACH,WAAW,GAAGD,MAAM,CAAC3C,MAAM,CAAC;MACpFjD,MAAM,CAAC8F,GAAG,CAACH,KAAK,CAAC;MACjB3F,MAAM,CAAC8F,GAAG,CAACF,MAAM,EAAEC,WAAW,CAAC;MAC/B,OAAO7F,MAAM;IACf;IACA,SAASiG,QAAQA,CAACC,UAAU,EAAE;MAC5B,SAASC,SAASA,CAACC,GAAG,EAAE;QACtB,IAAIC,GAAG,GAAG,CAAC,CAAC;QACZ,IAAID,GAAG,CAACE,QAAQ,KAAK,CAAC,EAAE;UACtB,IAAIF,GAAG,CAAChD,UAAU,EAAE;YAClB,IAAIgD,GAAG,CAAChD,UAAU,CAACH,MAAM,GAAG,CAAC,EAAE;cAC7BoD,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;cACtB,KAAK,IAAIE,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGH,GAAG,CAAChD,UAAU,CAACH,MAAM,EAAEsD,EAAE,EAAE,EAAE;gBACjD,IAAIC,SAAS,GAAGJ,GAAG,CAAChD,UAAU,CAACqD,IAAI,CAACF,EAAE,CAAC;gBACvCF,GAAG,CAAC,YAAY,CAAC,CAACG,SAAS,CAACE,QAAQ,CAAC,GAAGF,SAAS,CAACG,SAAS,CAACrF,IAAI,CAAC,CAAC;cACpE;YACF;UACF;QACF,CAAC,MAAM,IAAI8E,GAAG,CAACE,QAAQ,KAAK,CAAC,EAAE;UAC7BD,GAAG,GAAGD,GAAG,CAACO,SAAS,CAACrF,IAAI,CAAC,CAAC;QAC5B;QACA,IAAI8E,GAAG,CAACQ,aAAa,CAAC,CAAC,EAAE;UACvB,KAAK,IAAIvE,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG+D,GAAG,CAACS,UAAU,CAAC5D,MAAM,EAAEZ,EAAE,EAAE,EAAE;YACjD,IAAIoE,IAAI,GAAGL,GAAG,CAACS,UAAU,CAACJ,IAAI,CAACpE,EAAE,CAAC;YAClC,IAAIqE,QAAQ,GAAGD,IAAI,CAACC,QAAQ;YAC5B,IAAI,OAAOL,GAAG,CAACK,QAAQ,CAAC,KAAK,WAAW,EAAE;cACxC,IAAII,GAAG,GAAGX,SAAS,CAACM,IAAI,CAAC;cACzB,IAAIK,GAAG,KAAK,EAAE,EACZT,GAAG,CAACK,QAAQ,CAAC,GAAGI,GAAG;YACvB,CAAC,MAAM;cACL,IAAI,OAAOT,GAAG,CAACK,QAAQ,CAAC,CAAC3E,IAAI,KAAK,WAAW,EAAE;gBAC7C,IAAIgF,GAAG,GAAGV,GAAG,CAACK,QAAQ,CAAC;gBACvBL,GAAG,CAACK,QAAQ,CAAC,GAAG,CAACK,GAAG,CAAC;cACvB;cACA,IAAID,GAAG,GAAGX,SAAS,CAACM,IAAI,CAAC;cACzB,IAAIK,GAAG,KAAK,EAAE,EACZT,GAAG,CAACK,QAAQ,CAAC,CAAC3E,IAAI,CAAC+E,GAAG,CAAC;YAC3B;UACF;QACF;QACA,OAAOT,GAAG;MACZ;MACA,SAASW,iBAAiBA,CAACC,GAAG,EAAE;QAC9B,IAAIC,GAAG,GAAG,OAAOrD,UAAU,KAAK,WAAW,GAAGA,UAAU,GAAGsD,KAAK;QAChE,IAAI9E,EAAE;QACN,IAAI+E,MAAM,GAAG,EAAE;QACf,IAAIC,SAAS,GAAG,EAAE;QAClB,IAAIC,IAAI,GAAG,kEAAkE;QAC7E,IAAIC,IAAI,GAAGD,IAAI,CAACrE,MAAM;QACtB,KAAKZ,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGkF,IAAI,EAAElF,EAAE,EAAE,EAAE;UAC5B+E,MAAM,CAAC/E,EAAE,CAAC,GAAGiF,IAAI,CAACjF,EAAE,CAAC;QACvB;QACA,KAAKA,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGkF,IAAI,EAAE,EAAElF,EAAE,EAAE;UAC5BgF,SAAS,CAACC,IAAI,CAACE,UAAU,CAACnF,EAAE,CAAC,CAAC,GAAGA,EAAE;QACrC;QACAgF,SAAS,CAAC,GAAG,CAACG,UAAU,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;QACjCH,SAAS,CAAC,GAAG,CAACG,UAAU,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;QACjC,IAAIjB,EAAE,EAAEkB,CAAC,EAAEX,GAAG,EAAEY,YAAY,EAAEC,IAAI;QAClC,IAAIJ,IAAI,GAAGN,GAAG,CAAChE,MAAM;QACrB,IAAIsE,IAAI,GAAG,CAAC,GAAG,CAAC,EAAE;UAChB,MAAM,IAAI9F,KAAK,CAAC,gDAAgD,CAAC;QACnE;QACAiG,YAAY,GAAGT,GAAG,CAACM,IAAI,GAAG,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,GAAGN,GAAG,CAACM,IAAI,GAAG,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC;QACxEI,IAAI,GAAG,IAAIT,GAAG,CAACK,IAAI,GAAG,CAAC,GAAG,CAAC,GAAGG,YAAY,CAAC;QAC3CD,CAAC,GAAGC,YAAY,GAAG,CAAC,GAAGH,IAAI,GAAG,CAAC,GAAGA,IAAI;QACtC,IAAIK,CAAC,GAAG,CAAC;QACT,KAAKvF,EAAE,GAAG,CAAC,EAAEkE,EAAE,GAAG,CAAC,EAAElE,EAAE,GAAGoF,CAAC,EAAEpF,EAAE,IAAI,CAAC,EAAEkE,EAAE,IAAI,CAAC,EAAE;UAC7CO,GAAG,GAAGO,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,CAAC,CAAC,IAAI,EAAE,GAAGgF,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,GAAGgF,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGgF,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,GAAG,CAAC,CAAC,CAAC;UAChKsF,IAAI,CAACC,CAAC,EAAE,CAAC,GAAG,CAACd,GAAG,GAAG,QAAQ,KAAK,EAAE;UAClCa,IAAI,CAACC,CAAC,EAAE,CAAC,GAAG,CAACd,GAAG,GAAG,KAAK,KAAK,CAAC;UAC9Ba,IAAI,CAACC,CAAC,EAAE,CAAC,GAAGd,GAAG,GAAG,GAAG;QACvB;QACA,IAAIY,YAAY,KAAK,CAAC,EAAE;UACtBZ,GAAG,GAAGO,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,CAAC,CAAC,IAAI,CAAC,GAAGgF,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC;UACjFsF,IAAI,CAACC,CAAC,EAAE,CAAC,GAAGd,GAAG,GAAG,GAAG;QACvB,CAAC,MAAM,IAAIY,YAAY,KAAK,CAAC,EAAE;UAC7BZ,GAAG,GAAGO,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,CAAC,CAAC,IAAI,EAAE,GAAGgF,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGgF,SAAS,CAACJ,GAAG,CAACO,UAAU,CAACnF,EAAE,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC;UAC3HsF,IAAI,CAACC,CAAC,EAAE,CAAC,GAAGd,GAAG,IAAI,CAAC,GAAG,GAAG;UAC1Ba,IAAI,CAACC,CAAC,EAAE,CAAC,GAAGd,GAAG,GAAG,GAAG;QACvB;QACA,OAAOa,IAAI;MACb;MACA,SAASE,cAAcA,CAACC,GAAG,EAAEC,WAAW,EAAE;QACxC,IAAIC,QAAQ,GAAG,CAAC;QAChB,IAAIC,IAAI,CAAC7E,UAAU,CAAC8E,WAAW,KAAK,QAAQ,EAAE;UAC5CF,QAAQ,GAAG,CAAC;QACd,CAAC,MAAM,IAAIC,IAAI,CAAC7E,UAAU,CAAC8E,WAAW,KAAK,QAAQ,EAAE;UACnDF,QAAQ,GAAG,CAAC;QACd;QACA,IAAIF,GAAG,CAAC1E,UAAU,CAAC+E,MAAM,KAAK,QAAQ,IAAIJ,WAAW,EAAE;UACrD,IAAIK,OAAO,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,UAAU,EAAEC,UAAU,EAAEC,OAAO,EAAEC,WAAW,EAAEC,aAAa;UACnG,IAAId,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,SAAS,EAAE;YACrC,IAAIC,GAAG,GAAG,IAAI9D,YAAY,CAAC,CAAC;UAC9B,CAAC,MAAM,IAAI8C,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,OAAO,EAAE;YAC1C,IAAIC,GAAG,GAAG,IAAI9C,UAAU,CAAC,CAAC;UAC5B;UACAoC,OAAO,GAAGN,GAAG,CAAC,OAAO,CAAC;UACtBQ,QAAQ,GAAGtB,iBAAiB,CAACoB,OAAO,CAAC;UACrCG,MAAM,GAAGD,QAAQ,CAAC,CAAC,CAAC;UACpB,KAAK,IAAIjG,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG2F,QAAQ,GAAG,CAAC,EAAE3F,EAAE,EAAE,EAAE;YACxCkG,MAAM,GAAGA,MAAM,GAAGD,QAAQ,CAACjG,EAAE,CAAC,IAAIA,EAAE,GAAG2F,QAAQ;UACjD;UACAS,UAAU,GAAG,CAACF,MAAM,GAAG,CAAC,IAAIP,QAAQ;UACpCU,OAAO,GAAGD,UAAU,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGA,UAAU,GAAG,CAAC,GAAG,CAAC;UACrDA,UAAU,GAAGA,UAAU,GAAGC,OAAO;UACjCC,WAAW,GAAG,EAAE;UAChBC,aAAa,GAAGH,UAAU;UAC1BE,WAAW,CAAC5G,IAAI,CAAC6G,aAAa,CAAC;UAC/BJ,UAAU,GAAG,CAAC,GAAGR,QAAQ;UACzB,KAAK,IAAI3F,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGkG,MAAM,EAAElG,EAAE,EAAE,EAAE;YAClC,IAAI0G,gBAAgB,GAAGT,QAAQ,CAACjG,EAAE,GAAG2F,QAAQ,GAAGQ,UAAU,CAAC;YAC3D,KAAK,IAAIjC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGyB,QAAQ,GAAG,CAAC,EAAEzB,EAAE,EAAE,EAAE;cACxCwC,gBAAgB,GAAGA,gBAAgB,GAAGT,QAAQ,CAACjG,EAAE,GAAG2F,QAAQ,GAAGQ,UAAU,GAAGjC,EAAE,CAAC,IAAIA,EAAE,GAAG,CAAC;YAC3F;YACAqC,aAAa,GAAGA,aAAa,GAAGG,gBAAgB;YAChDJ,WAAW,CAAC5G,IAAI,CAAC6G,aAAa,CAAC;UACjC;UACA,KAAK,IAAIvG,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGsG,WAAW,CAAC1F,MAAM,GAAG,CAAC,EAAEZ,EAAE,EAAE,EAAE;YAClD,IAAI1C,KAAK,GAAG1B,UAAU,CAACqK,QAAQ,CAACU,KAAK,CAACL,WAAW,CAACtG,EAAE,CAAC,EAAEsG,WAAW,CAACtG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5EgG,OAAO,GAAG1I,KAAK,CAACiE,MAAM;YACtB,IAAIkE,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,SAAS,EAAE;cACrCR,OAAO,GAAG,IAAIrD,YAAY,CAACqD,OAAO,CAAC;cACnCS,GAAG,GAAGpD,aAAa,CAACoD,GAAG,EAAET,OAAO,CAAC;YACnC,CAAC,MAAM,IAAIP,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,OAAO,EAAE;cAC1CR,OAAO,GAAG,IAAIrC,UAAU,CAACqC,OAAO,CAAC;cACjCS,GAAG,GAAG/C,WAAW,CAAC+C,GAAG,EAAET,OAAO,CAAC;YACjC;UACF;UACA,OAAOP,GAAG,CAAC,OAAO,CAAC;UACnB,IAAIA,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,OAAO,EAAE;YACnC,IAAIf,GAAG,CAAC1E,UAAU,CAAC+E,MAAM,KAAK,QAAQ,EAAE;cACtCW,GAAG,GAAGA,GAAG,CAACG,MAAM,CAAC,UAASC,EAAE,EAAEC,GAAG,EAAE;gBACjC,IAAIA,GAAG,GAAG,CAAC,KAAK,CAAC,EACf,OAAO,IAAI;cACf,CAAC,CAAC;YACJ;UACF;QACF,CAAC,MAAM;UACL,IAAIrB,GAAG,CAAC1E,UAAU,CAAC+E,MAAM,KAAK,QAAQ,IAAI,CAACJ,WAAW,EAAE;YACtD,IAAIM,OAAO,GAAGrB,iBAAiB,CAACc,GAAG,CAAC,OAAO,CAAC,CAAC;YAC7CO,OAAO,GAAGA,OAAO,CAACW,KAAK,CAAChB,QAAQ,CAAC,CAACpE,MAAM;UAC1C,CAAC,MAAM;YACL,IAAIkE,GAAG,CAAC,OAAO,CAAC,EAAE;cAChB,IAAIO,OAAO,GAAGP,GAAG,CAAC,OAAO,CAAC,CAAC3G,KAAK,CAAC,KAAK,CAAC,CAAC8H,MAAM,CAAC,UAASC,EAAE,EAAE;gBAC1D,IAAIA,EAAE,KAAK,EAAE,EACX,OAAOA,EAAE;cACb,CAAC,CAAC;YACJ,CAAC,MAAM;cACL,IAAIb,OAAO,GAAG,IAAIrC,UAAU,CAAC,CAAC,CAAC,CAACpC,MAAM;YACxC;UACF;UACA,OAAOkE,GAAG,CAAC,OAAO,CAAC;UACnB,IAAIA,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,SAAS,EAAE;YACrC,IAAIC,GAAG,GAAG,IAAI9D,YAAY,CAACqD,OAAO,CAAC;UACrC,CAAC,MAAM,IAAIP,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,OAAO,EAAE;YAC1C,IAAIC,GAAG,GAAG,IAAI9C,UAAU,CAACqC,OAAO,CAAC;UACnC,CAAC,MAAM,IAAIP,GAAG,CAAC1E,UAAU,CAACyF,IAAI,KAAK,OAAO,EAAE;YAC1C,IAAIC,GAAG,GAAG,IAAI9C,UAAU,CAACqC,OAAO,CAAC;YACjC,IAAIP,GAAG,CAAC1E,UAAU,CAAC+E,MAAM,KAAK,QAAQ,EAAE;cACtCW,GAAG,GAAGA,GAAG,CAACG,MAAM,CAAC,UAASC,EAAE,EAAEC,GAAG,EAAE;gBACjC,IAAIA,GAAG,GAAG,CAAC,KAAK,CAAC,EACf,OAAO,IAAI;cACf,CAAC,CAAC;YACJ;UACF;QACF;QACA,OAAOL,GAAG;MACZ;MACA,IAAIM,GAAG,GAAG,IAAI;MACd,IAAIC,MAAM,CAACC,SAAS,EAAE;QACpB,IAAI;UACFF,GAAG,GAAG,IAAIE,SAAS,CAAC,CAAC,CAACC,eAAe,CAACrD,UAAU,EAAE,UAAU,CAAC;QAC/D,CAAC,CAAC,OAAO7G,CAAC,EAAE;UACV+J,GAAG,GAAG,IAAI;QACZ;MACF,CAAC,MAAM,IAAIC,MAAM,CAACG,aAAa,EAAE;QAC/B,IAAI;UACFJ,GAAG,GAAG,IAAII,aAAa,CAAC,kBAAkB,CAAC;UAC3CJ,GAAG,CAACK,KAAK,GAAG,KAAK;UACjB,IAAI,CAACL,GAAG,CAACM,OAAO;YACd;UAAA,CACD,EAAE;YACD,MAAM,IAAIjI,KAAK,CAAC2H,GAAG,CAACO,UAAU,CAACC,MAAM,GAAGR,GAAG,CAACO,UAAU,CAACE,OAAO,CAAC;UACjE;QACF,CAAC,CAAC,OAAOxK,CAAC,EAAE;UACV+J,GAAG,GAAG,IAAI;QACZ;MACF,CAAC,MAAM;QACL,MAAM,IAAI3H,KAAK,CAAC,0BAA0B,CAAC;MAC7C;MACA,IAAIqI,GAAG,GAAGV,GAAG,CAACW,eAAe;MAC7B,IAAI9B,IAAI,GAAG9B,SAAS,CAAC2D,GAAG,CAAC;MACzB,IAAI9F,MAAM,GAAG,EAAE;MACf,IAAIjE,OAAO,GAAG,EAAE;MAChB,IAAIH,OAAO,GAAG,EAAE;MAChB,IAAIqI,IAAI,CAAC+B,QAAQ,EAAE;QACjB,IAAIC,KAAK,GAAGhC,IAAI,CAAC+B,QAAQ,CAACE,KAAK;QAC/B,IAAIC,UAAU,GAAGlC,IAAI,CAAC7E,UAAU,CAACgH,cAAc,CAAC,YAAY,CAAC;QAC7D,IAAIC,QAAQ,GAAG,CAAC,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC;QACzD,IAAIC,YAAY,GAAG,CAAC;UAAEC,gBAAgB,GAAGF,QAAQ,CAACpH,MAAM;QACxD,OAAOqH,YAAY,GAAGC,gBAAgB,EAAE;UACtC,IAAIC,OAAO,GAAGP,KAAK,CAACI,QAAQ,CAACC,YAAY,CAAC,CAAC;UAC3C,IAAIE,OAAO,IAAIA,OAAO,CAACC,SAAS,EAAE;YAChC,IAAIC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACL,OAAO,CAACC,SAAS,CAAC,KAAK,gBAAgB,EAAE;cAC1E,IAAIK,GAAG,GAAGN,OAAO,CAACC,SAAS;YAC7B,CAAC,MAAM;cACL,IAAIK,GAAG,GAAG,CAACN,OAAO,CAACC,SAAS,CAAC;YAC/B;YACA,IAAIM,cAAc,GAAG,CAAC;cAAEC,kBAAkB,GAAGF,GAAG,CAAC7H,MAAM;YACvD,OAAO8H,cAAc,GAAGC,kBAAkB,EAAE;cAC1C,IAAI,OAAO,IAAIF,GAAG,CAACC,cAAc,CAAC,IAAID,GAAG,CAACC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC9H,MAAM,GAAG,CAAC,EAAE;gBAC7E6H,GAAG,CAACC,cAAc,CAAC,CAAC5L,IAAI,GAAG0I,cAAc,CAACiD,GAAG,CAACC,cAAc,CAAC,EAAEZ,UAAU,CAAC;cAC5E;cACAY,cAAc,EAAE;YAClB;YACA,QAAQV,QAAQ,CAACC,YAAY,CAAC;cAC5B,KAAK,WAAW;gBACd,IAAI5G,cAAc,GAAGzB,QAAQ,CAACgI,KAAK,CAAC7G,UAAU,CAAC6H,cAAc,CAAC;gBAC9D,IAAIC,WAAW,GAAGV,OAAO,CAACpH,UAAU,CAAC+H,OAAO;gBAC5C,IAAIzH,cAAc,GAAG,CAAC,EAAE;kBACtB,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEgK,GAAG,GAAGN,GAAG,CAAC7H,MAAM,EAAE7B,CAAC,GAAGgK,GAAG,EAAEhK,CAAC,EAAE,EAAE;oBAC9C,IAAI8J,WAAW,KAAKJ,GAAG,CAAC1J,CAAC,CAAC,CAACgC,UAAU,CAACiI,IAAI,EAAE;sBAC1C,IAAIC,UAAU,GAAGR,GAAG,CAAC1J,CAAC,CAAC,CAACgC,UAAU,CAACmI,kBAAkB;sBACrDxL,OAAO,GAAG,IAAIiF,YAAY,CAACtB,cAAc,GAAG4H,UAAU,CAAC;sBACvDvL,OAAO,CAAC+F,GAAG,CAACgF,GAAG,CAAC1J,CAAC,CAAC,CAACjC,IAAI,EAAE,CAAC,CAAC;oBAC7B;kBACF;gBACF;gBACA;cACF,KAAK,QAAQ;gBACX,IAAIuE,cAAc,GAAGzB,QAAQ,CAACgI,KAAK,CAAC7G,UAAU,CAAC6H,cAAc,CAAC;gBAC9D,IAAIvH,cAAc,GAAG,CAAC,EAAE;kBACtB,IAAI4H,UAAU,GAAGd,OAAO,CAACC,SAAS,CAACrH,UAAU,CAACmI,kBAAkB;kBAChEvH,MAAM,GAAG,IAAIgB,YAAY,CAACtB,cAAc,GAAG4H,UAAU,CAAC;kBACtDtH,MAAM,CAAC8B,GAAG,CAAC0E,OAAO,CAACC,SAAS,CAACtL,IAAI,EAAE,CAAC,CAAC;gBACvC;gBACA;cACF,KAAK,QAAQ;gBACX,IAAI+F,cAAc,GAAGjD,QAAQ,CAACgI,KAAK,CAAC7G,UAAU,CAACoI,cAAc,CAAC;gBAC9D,IAAItG,cAAc,GAAG,CAAC,EAAE;kBACtB,IAAIuG,YAAY,GAAG,IAAIzF,UAAU,CAACwE,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,CAAC8D,MAAM,CAAC;kBACnE,IAAIyI,MAAM,GAAG,IAAI1F,UAAU,CAACwE,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,CAAC8D,MAAM,CAAC;kBAC7DwI,YAAY,CAAC3F,GAAG,CAAC0E,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,EAAE,CAAC,CAAC;kBAC9CuM,MAAM,CAAC5F,GAAG,CAAC0E,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,EAAE,CAAC,CAAC;kBACxC,IAAIgG,IAAI,GAAGD,cAAc,GAAGuG,YAAY,CAACxI,MAAM;kBAC/CrD,OAAO,GAAG,IAAIwF,WAAW,CAAC,CAAC,GAAGD,IAAI,GAAG,CAAC,GAAGD,cAAc,CAAC;kBACxD,IAAIG,YAAY,GAAG,CAAC;kBACpB,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEgK,GAAG,GAAGlG,cAAc,EAAE9D,CAAC,GAAGgK,GAAG,EAAEhK,CAAC,EAAE,EAAE;oBAClD,IAAIoE,KAAK,GAAG,EAAE;oBACd,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEgI,IAAI,GAAGD,MAAM,CAACtK,CAAC,CAAC,EAAEwK,IAAI,GAAG,CAAC,EAAEjI,CAAC,GAAGgI,IAAI,GAAGC,IAAI,EAAEjI,CAAC,EAAE,EAAE;sBAChE6B,KAAK,CAACzD,IAAI,CAAC0J,YAAY,CAAC9H,CAAC,CAAC,CAAC;sBAC3B,IAAIvC,CAAC,GAAG,CAAC,EACPwK,IAAI,GAAGF,MAAM,CAACtK,CAAC,GAAG,CAAC,CAAC;oBACxB;oBACA,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEoJ,IAAI,GAAGD,MAAM,CAACtK,CAAC,CAAC,EAAEwK,IAAI,GAAG,CAAC,EAAErJ,CAAC,GAAGoJ,IAAI,GAAGC,IAAI,GAAG,CAAC,EAAErJ,CAAC,EAAE,EAAE;sBACpE,IAAIA,CAAC,GAAG,CAAC,EAAE;wBACT3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,CAAC;wBAClC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;wBACtC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;sBACxC,CAAC,MAAM;wBACL3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,CAAC;wBAClC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;wBACtC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAGG,KAAK,CAACjD,CAAC,GAAG,CAAC,CAAC;sBACxC;sBACA,IAAInB,CAAC,GAAG,CAAC,EACPwK,IAAI,GAAGF,MAAM,CAACtK,CAAC,GAAG,CAAC,CAAC;oBACxB;kBACF;gBACF;gBACA;cACF,KAAK,OAAO;gBACV,IAAIyK,aAAa,GAAG5J,QAAQ,CAACgI,KAAK,CAAC7G,UAAU,CAAC0I,aAAa,CAAC;gBAC5D,IAAID,aAAa,GAAG,CAAC,EAAE;kBACrB,IAAIJ,YAAY,GAAG,IAAIzF,UAAU,CAACwE,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,CAAC8D,MAAM,CAAC;kBACnE,IAAIyI,MAAM,GAAG,IAAI1F,UAAU,CAACwE,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,CAAC8D,MAAM,CAAC;kBAC7DwI,YAAY,CAAC3F,GAAG,CAAC0E,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,EAAE,CAAC,CAAC;kBAC9CuM,MAAM,CAAC5F,GAAG,CAAC0E,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAACtL,IAAI,EAAE,CAAC,CAAC;kBACxC,IAAIgG,IAAI,GAAG0G,aAAa,GAAGJ,YAAY,CAACxI,MAAM;kBAC9CrD,OAAO,GAAG,IAAIwF,WAAW,CAAC,CAAC,GAAGD,IAAI,GAAG,CAAC,GAAG0G,aAAa,CAAC;kBACvD,IAAIxG,YAAY,GAAG,CAAC;oBAAE0G,iBAAiB,GAAG,CAAC;kBAC3C,IAAI3K,CAAC,GAAG,CAAC;oBAAEgK,GAAG,GAAGS,aAAa;oBAAED,IAAI,GAAG,CAAC;kBACxC,OAAOxK,CAAC,GAAGgK,GAAG,EAAE;oBACd,IAAIY,IAAI,GAAG,EAAE;oBACb,IAAIrI,CAAC,GAAG,CAAC;sBAAEgI,IAAI,GAAGD,MAAM,CAACtK,CAAC,CAAC;oBAC3B,OAAOuC,CAAC,GAAGgI,IAAI,GAAGC,IAAI,EAAE;sBACtBI,IAAI,CAACjK,IAAI,CAAC0J,YAAY,CAACM,iBAAiB,EAAE,CAAC,CAAC;sBAC5CpI,CAAC,EAAE;oBACL;oBACA,IAAIpB,CAAC,GAAG,CAAC;oBACT,OAAOA,CAAC,GAAGoJ,IAAI,GAAGC,IAAI,GAAG,CAAC,EAAE;sBAC1BhM,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAG2G,IAAI,CAAC,CAAC,CAAC;sBACjCpM,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAG2G,IAAI,CAACzJ,CAAC,CAAC;sBACjC3C,OAAO,CAACyF,YAAY,EAAE,CAAC,GAAG2G,IAAI,CAACzJ,CAAC,GAAG,CAAC,CAAC;sBACrCA,CAAC,EAAE;oBACL;oBACAnB,CAAC,EAAE;oBACHwK,IAAI,GAAGF,MAAM,CAACtK,CAAC,GAAG,CAAC,CAAC;kBACtB;gBACF;gBACA;cACF;gBACE;YACJ;UACF;UACAkJ,YAAY,EAAE;QAChB;QACA,IAAIxH,QAAQ,GAAG,IAAIjF,cAAc,CAAC,CAAC;QACnCiF,QAAQ,CAACC,QAAQ,CAAC,IAAIhF,eAAe,CAAC6B,OAAO,EAAE,CAAC,CAAC,CAAC;QAClDkD,QAAQ,CAACE,YAAY,CAAC,UAAU,EAAE,IAAIjF,eAAe,CAACiG,MAAM,EAAE,CAAC,CAAC,CAAC;QACjE,IAAIjE,OAAO,CAACkD,MAAM,KAAKe,MAAM,CAACf,MAAM,EAAE;UACpCH,QAAQ,CAACE,YAAY,CAAC,QAAQ,EAAE,IAAIjF,eAAe,CAACgC,OAAO,EAAE,CAAC,CAAC,CAAC;QAClE;QACA,OAAO+C,QAAQ;MACjB,CAAC,MAAM;QACL,MAAM,IAAIrB,KAAK,CAAC,0BAA0B,CAAC;MAC7C;IACF;IACA,IAAIwK,IAAI,GAAGjO,WAAW,CAACkO,UAAU,CAAC,IAAIrI,UAAU,CAACpE,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC0B,KAAK,CAAC,IAAI,CAAC;IAC3E,IAAI8K,IAAI,CAAC,CAAC,CAAC,CAAC1K,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACjC,OAAO0E,QAAQ,CAACjI,WAAW,CAACkO,UAAU,CAACzM,IAAI,CAAC,CAAC;IAC/C,CAAC,MAAM,IAAIwM,IAAI,CAAC,CAAC,CAAC,CAACE,QAAQ,CAAC,OAAO,CAAC,EAAE;MACpC,OAAOzM,UAAU,CAAC1B,WAAW,CAACkO,UAAU,CAACzM,IAAI,CAAC,CAAC;IACjD,CAAC,MAAM;MACL,OAAO+D,WAAW,CAAC/D,IAAI,CAAC;IAC1B;EACF;AACF;AACA,SACEvB,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}