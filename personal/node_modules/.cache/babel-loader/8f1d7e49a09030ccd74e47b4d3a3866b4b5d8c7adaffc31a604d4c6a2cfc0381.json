{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from \"three\";\nvar PCDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PCDLoader, _Loader);\n  var _super = _createSuper(PCDLoader);\n  function PCDLoader(manager) {\n    var _this;\n    _classCallCheck(this, PCDLoader);\n    _this = _super.call(this, manager);\n    _this.littleEndian = true;\n    return _this;\n  }\n  _createClass(PCDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data, url));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, url) {\n      function decompressLZF(inData, outLength) {\n        var inLength = inData.length;\n        var outData = new Uint8Array(outLength);\n        var inPtr = 0;\n        var outPtr = 0;\n        var ctrl;\n        var len;\n        var ref;\n        do {\n          ctrl = inData[inPtr++];\n          if (ctrl < 1 << 5) {\n            ctrl++;\n            if (outPtr + ctrl > outLength) throw new Error(\"Output buffer is not large enough\");\n            if (inPtr + ctrl > inLength) throw new Error(\"Invalid compressed data\");\n            do {\n              outData[outPtr++] = inData[inPtr++];\n            } while (--ctrl);\n          } else {\n            len = ctrl >> 5;\n            ref = outPtr - ((ctrl & 31) << 8) - 1;\n            if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n            if (len === 7) {\n              len += inData[inPtr++];\n              if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n            }\n            ref -= inData[inPtr++];\n            if (outPtr + len + 2 > outLength) throw new Error(\"Output buffer is not large enough\");\n            if (ref < 0) throw new Error(\"Invalid compressed data\");\n            if (ref >= outPtr) throw new Error(\"Invalid compressed data\");\n            do {\n              outData[outPtr++] = outData[ref++];\n            } while (--len + 2);\n          }\n        } while (inPtr < inLength);\n        return outData;\n      }\n      function parseHeader(data2) {\n        var PCDheader2 = {};\n        var result1 = data2.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n        var result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data2.substr(result1 - 1));\n        PCDheader2.data = result2[1];\n        PCDheader2.headerLen = result2[0].length + result1;\n        PCDheader2.str = data2.substr(0, PCDheader2.headerLen);\n        PCDheader2.str = PCDheader2.str.replace(/\\#.*/gi, \"\");\n        PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);\n        PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);\n        PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);\n        PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);\n        PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);\n        PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);\n        if (PCDheader2.version !== null) PCDheader2.version = parseFloat(PCDheader2.version[1]);\n        if (PCDheader2.fields !== null) PCDheader2.fields = PCDheader2.fields[1].split(\" \");\n        if (PCDheader2.type !== null) PCDheader2.type = PCDheader2.type[1].split(\" \");\n        if (PCDheader2.width !== null) PCDheader2.width = parseInt(PCDheader2.width[1]);\n        if (PCDheader2.height !== null) PCDheader2.height = parseInt(PCDheader2.height[1]);\n        if (PCDheader2.viewpoint !== null) PCDheader2.viewpoint = PCDheader2.viewpoint[1];\n        if (PCDheader2.points !== null) PCDheader2.points = parseInt(PCDheader2.points[1], 10);\n        if (PCDheader2.points === null) PCDheader2.points = PCDheader2.width * PCDheader2.height;\n        if (PCDheader2.size !== null) {\n          PCDheader2.size = PCDheader2.size[1].split(\" \").map(function (x) {\n            return parseInt(x, 10);\n          });\n        }\n        if (PCDheader2.count !== null) {\n          PCDheader2.count = PCDheader2.count[1].split(\" \").map(function (x) {\n            return parseInt(x, 10);\n          });\n        } else {\n          PCDheader2.count = [];\n          for (var i = 0, l = PCDheader2.fields.length; i < l; i++) {\n            PCDheader2.count.push(1);\n          }\n        }\n        PCDheader2.offset = {};\n        var sizeSum = 0;\n        for (var _i = 0, _l = PCDheader2.fields.length; _i < _l; _i++) {\n          if (PCDheader2.data === \"ascii\") {\n            PCDheader2.offset[PCDheader2.fields[_i]] = _i;\n          } else {\n            PCDheader2.offset[PCDheader2.fields[_i]] = sizeSum;\n            sizeSum += PCDheader2.size[_i] * PCDheader2.count[_i];\n          }\n        }\n        PCDheader2.rowSize = sizeSum;\n        return PCDheader2;\n      }\n      var textData = LoaderUtils.decodeText(new Uint8Array(data));\n      var PCDheader = parseHeader(textData);\n      var position = [];\n      var normal = [];\n      var color = [];\n      if (PCDheader.data === \"ascii\") {\n        var offset = PCDheader.offset;\n        var pcdData = textData.substr(PCDheader.headerLen);\n        var lines = pcdData.split(\"\\n\");\n        for (var i = 0, l = lines.length; i < l; i++) {\n          if (lines[i] === \"\") continue;\n          var line = lines[i].split(\" \");\n          if (offset.x !== void 0) {\n            position.push(parseFloat(line[offset.x]));\n            position.push(parseFloat(line[offset.y]));\n            position.push(parseFloat(line[offset.z]));\n          }\n          if (offset.rgb !== void 0) {\n            var rgb = parseFloat(line[offset.rgb]);\n            var r = rgb >> 16 & 255;\n            var g = rgb >> 8 & 255;\n            var b = rgb >> 0 & 255;\n            color.push(r / 255, g / 255, b / 255);\n          }\n          if (offset.normal_x !== void 0) {\n            normal.push(parseFloat(line[offset.normal_x]));\n            normal.push(parseFloat(line[offset.normal_y]));\n            normal.push(parseFloat(line[offset.normal_z]));\n          }\n        }\n      }\n      if (PCDheader.data === \"binary_compressed\") {\n        var sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n        var compressedSize = sizes[0];\n        var decompressedSize = sizes[1];\n        var decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n        var dataview = new DataView(decompressed.buffer);\n        var _offset = PCDheader.offset;\n        for (var _i2 = 0; _i2 < PCDheader.points; _i2++) {\n          if (_offset.x !== void 0) {\n            position.push(dataview.getFloat32(PCDheader.points * _offset.x + PCDheader.size[0] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.y + PCDheader.size[1] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.z + PCDheader.size[2] * _i2, this.littleEndian));\n          }\n          if (_offset.rgb !== void 0) {\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 2) / 255);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 1) / 255);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 0) / 255);\n          }\n          if (_offset.normal_x !== void 0) {\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_x + PCDheader.size[4] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_y + PCDheader.size[5] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_z + PCDheader.size[6] * _i2, this.littleEndian));\n          }\n        }\n      }\n      if (PCDheader.data === \"binary\") {\n        var _dataview = new DataView(data, PCDheader.headerLen);\n        var _offset2 = PCDheader.offset;\n        for (var _i3 = 0, row = 0; _i3 < PCDheader.points; _i3++, row += PCDheader.rowSize) {\n          if (_offset2.x !== void 0) {\n            position.push(_dataview.getFloat32(row + _offset2.x, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.y, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.z, this.littleEndian));\n          }\n          if (_offset2.rgb !== void 0) {\n            color.push(_dataview.getUint8(row + _offset2.rgb + 2) / 255);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 1) / 255);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 0) / 255);\n          }\n          if (_offset2.normal_x !== void 0) {\n            normal.push(_dataview.getFloat32(row + _offset2.normal_x, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_y, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_z, this.littleEndian));\n          }\n        }\n      }\n      var geometry = new BufferGeometry();\n      if (position.length > 0) geometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      if (normal.length > 0) geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal, 3));\n      if (color.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n      geometry.computeBoundingSphere();\n      var material = new PointsMaterial({\n        size: 5e-3\n      });\n      if (color.length > 0) {\n        material.vertexColors = true;\n      } else {\n        material.color.setHex(Math.random() * 16777215);\n      }\n      var mesh = new Points(geometry, material);\n      var name = url.split(\"\").reverse().join(\"\");\n      name = /([^\\/]*)/.exec(name);\n      name = name[1].split(\"\").reverse().join(\"\");\n      mesh.name = name;\n      return mesh;\n    }\n  }]);\n  return PCDLoader;\n}(Loader);\nexport { PCDLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","PointsMaterial","Points","PCDLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","littleEndian","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","decompressLZF","inData","outLength","inLength","length","outData","Uint8Array","inPtr","outPtr","ctrl","len","ref","Error","parseHeader","data2","PCDheader2","result1","search","result2","exec","substr","headerLen","str","replace","version","fields","size","type","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","i","l","push","offset","sizeSum","rowSize","textData","decodeText","PCDheader","position","normal","color","pcdData","lines","line","y","z","rgb","r","g","b","normal_x","normal_y","normal_z","sizes","Uint32Array","slice","compressedSize","decompressedSize","decompressed","dataview","DataView","buffer","getFloat32","getUint8","row","geometry","setAttribute","computeBoundingSphere","material","vertexColors","setHex","Math","random","mesh","name","reverse","join"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/PCDLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from \"three\";\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.littleEndian = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          onLoad(scope.parse(data, url));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data, url) {\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n      do {\n        ctrl = inData[inPtr++];\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength)\n            throw new Error(\"Output buffer is not large enough\");\n          if (inPtr + ctrl > inLength)\n            throw new Error(\"Invalid compressed data\");\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 31) << 8) - 1;\n          if (inPtr >= inLength)\n            throw new Error(\"Invalid compressed data\");\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength)\n              throw new Error(\"Invalid compressed data\");\n          }\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength)\n            throw new Error(\"Output buffer is not large enough\");\n          if (ref < 0)\n            throw new Error(\"Invalid compressed data\");\n          if (ref >= outPtr)\n            throw new Error(\"Invalid compressed data\");\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n      return outData;\n    }\n    function parseHeader(data2) {\n      const PCDheader2 = {};\n      const result1 = data2.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data2.substr(result1 - 1));\n      PCDheader2.data = result2[1];\n      PCDheader2.headerLen = result2[0].length + result1;\n      PCDheader2.str = data2.substr(0, PCDheader2.headerLen);\n      PCDheader2.str = PCDheader2.str.replace(/\\#.*/gi, \"\");\n      PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);\n      PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);\n      PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);\n      PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);\n      PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);\n      PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);\n      if (PCDheader2.version !== null)\n        PCDheader2.version = parseFloat(PCDheader2.version[1]);\n      if (PCDheader2.fields !== null)\n        PCDheader2.fields = PCDheader2.fields[1].split(\" \");\n      if (PCDheader2.type !== null)\n        PCDheader2.type = PCDheader2.type[1].split(\" \");\n      if (PCDheader2.width !== null)\n        PCDheader2.width = parseInt(PCDheader2.width[1]);\n      if (PCDheader2.height !== null)\n        PCDheader2.height = parseInt(PCDheader2.height[1]);\n      if (PCDheader2.viewpoint !== null)\n        PCDheader2.viewpoint = PCDheader2.viewpoint[1];\n      if (PCDheader2.points !== null)\n        PCDheader2.points = parseInt(PCDheader2.points[1], 10);\n      if (PCDheader2.points === null)\n        PCDheader2.points = PCDheader2.width * PCDheader2.height;\n      if (PCDheader2.size !== null) {\n        PCDheader2.size = PCDheader2.size[1].split(\" \").map(function(x) {\n          return parseInt(x, 10);\n        });\n      }\n      if (PCDheader2.count !== null) {\n        PCDheader2.count = PCDheader2.count[1].split(\" \").map(function(x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader2.count = [];\n        for (let i = 0, l = PCDheader2.fields.length; i < l; i++) {\n          PCDheader2.count.push(1);\n        }\n      }\n      PCDheader2.offset = {};\n      let sizeSum = 0;\n      for (let i = 0, l = PCDheader2.fields.length; i < l; i++) {\n        if (PCDheader2.data === \"ascii\") {\n          PCDheader2.offset[PCDheader2.fields[i]] = i;\n        } else {\n          PCDheader2.offset[PCDheader2.fields[i]] = sizeSum;\n          sizeSum += PCDheader2.size[i] * PCDheader2.count[i];\n        }\n      }\n      PCDheader2.rowSize = sizeSum;\n      return PCDheader2;\n    }\n    const textData = LoaderUtils.decodeText(new Uint8Array(data));\n    const PCDheader = parseHeader(textData);\n    const position = [];\n    const normal = [];\n    const color = [];\n    if (PCDheader.data === \"ascii\") {\n      const offset = PCDheader.offset;\n      const pcdData = textData.substr(PCDheader.headerLen);\n      const lines = pcdData.split(\"\\n\");\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === \"\")\n          continue;\n        const line = lines[i].split(\" \");\n        if (offset.x !== void 0) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n        if (offset.rgb !== void 0) {\n          const rgb = parseFloat(line[offset.rgb]);\n          const r = rgb >> 16 & 255;\n          const g = rgb >> 8 & 255;\n          const b = rgb >> 0 & 255;\n          color.push(r / 255, g / 255, b / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    }\n    if (PCDheader.data === \"binary_compressed\") {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(\n        new Uint8Array(data, PCDheader.headerLen + 8, compressedSize),\n        decompressedSize\n      );\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== void 0) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));\n        }\n        if (offset.rgb !== void 0) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian)\n          );\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian)\n          );\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian)\n          );\n        }\n      }\n    }\n    if (PCDheader.data === \"binary\") {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== void 0) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n        if (offset.rgb !== void 0) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    }\n    const geometry = new BufferGeometry();\n    if (position.length > 0)\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n    if (normal.length > 0)\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal, 3));\n    if (color.length > 0)\n      geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere();\n    const material = new PointsMaterial({ size: 5e-3 });\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 16777215);\n    }\n    const mesh = new Points(geometry, material);\n    let name = url.split(\"\").reverse().join(\"\");\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split(\"\").reverse().join(\"\");\n    mesh.name = name;\n    return mesh;\n  }\n}\nexport {\n  PCDLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}