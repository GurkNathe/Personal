{"ast":null,"code":"import { intersect, safeArrayPush } from '../utils.js';\nexport function create() {\n  return {\n    numberToDocumentId: new Map()\n  };\n}\nexport function insert(root, key, value) {\n  if (root.numberToDocumentId.has(key)) {\n    root.numberToDocumentId.get(key).push(value);\n    return root;\n  }\n  root.numberToDocumentId.set(key, [value]);\n  return root;\n}\nexport function find(root, key) {\n  return root.numberToDocumentId.get(key) ?? null;\n}\nexport function remove(root, key) {\n  if (root != null) {\n    root.numberToDocumentId.delete(key);\n  }\n  return root;\n}\nexport function removeDocument(root, id, key) {\n  var _root_numberToDocumentId_get, _root_numberToDocumentId_get1;\n  root === null || root === void 0 ? void 0 : root.numberToDocumentId.set(key, ((_root_numberToDocumentId_get = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get === void 0 ? void 0 : _root_numberToDocumentId_get.filter(v => v !== id)) ?? []);\n  if (((_root_numberToDocumentId_get1 = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get1 === void 0 ? void 0 : _root_numberToDocumentId_get1.length) === 0) {\n    root === null || root === void 0 ? void 0 : root.numberToDocumentId.delete(key);\n  }\n}\nexport function contains(node, key) {\n  return !(find(node, key) == null);\n}\nexport function getSize(root) {\n  let size = 0;\n  for (const [, value] of (root === null || root === void 0 ? void 0 : root.numberToDocumentId) ?? []) {\n    size += value.length;\n  }\n  return size;\n}\nexport function filter(root, operation) {\n  const operationKeys = Object.keys(operation);\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation');\n  }\n  const operationType = operationKeys[0];\n  switch (operationType) {\n    case 'eq':\n      {\n        const value = operation[operationType];\n        return root.numberToDocumentId.get(value) ?? [];\n      }\n    case 'in':\n      {\n        const value = operation[operationType];\n        const result = [];\n        for (const v of value) {\n          const ids = root.numberToDocumentId.get(v);\n          if (ids != null) {\n            safeArrayPush(result, ids);\n          }\n        }\n        return result;\n      }\n    case 'nin':\n      {\n        const value = operation[operationType];\n        const result = [];\n        const keys = root.numberToDocumentId.keys();\n        for (const key of keys) {\n          if (value.includes(key)) {\n            continue;\n          }\n          const ids = root.numberToDocumentId.get(key);\n          if (ids != null) {\n            safeArrayPush(result, ids);\n          }\n        }\n        return result;\n      }\n  }\n  throw new Error('Invalid operation');\n}\nexport function filterArr(root, operation) {\n  const operationKeys = Object.keys(operation);\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation');\n  }\n  const operationType = operationKeys[0];\n  switch (operationType) {\n    case 'containsAll':\n      {\n        const values = operation[operationType];\n        const ids = values.map(value => root.numberToDocumentId.get(value) ?? []);\n        return intersect(ids);\n      }\n  }\n  throw new Error('Invalid operation');\n}","map":{"version":3,"names":["intersect","safeArrayPush","create","numberToDocumentId","Map","insert","root","key","value","has","get","push","set","find","remove","delete","removeDocument","id","_root_numberToDocumentId_get","_root_numberToDocumentId_get1","filter","v","length","contains","node","getSize","size","operation","operationKeys","Object","keys","Error","operationType","result","ids","includes","filterArr","values","map"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/trees/flat.ts"],"sourcesContent":["import { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { EnumArrComparisonOperator, EnumComparisonOperator, Nullable, ScalarSearchableValue } from '../types.js'\nimport { intersect, safeArrayPush } from '../utils.js'\n\nexport interface FlatTree {\n  numberToDocumentId: Map<ScalarSearchableValue, InternalDocumentID[]>\n}\n\nexport function create (): FlatTree {\n  return {\n    numberToDocumentId: new Map()\n  }\n}\n\nexport function insert (root: FlatTree, key: ScalarSearchableValue, value: InternalDocumentID): FlatTree {\n  if (root.numberToDocumentId.has(key)) {\n    root.numberToDocumentId.get(key)!.push(value)\n    return root\n  }\n  root.numberToDocumentId.set(key, [value])\n  return root\n}\n\nexport function find (root: FlatTree, key: ScalarSearchableValue): Nullable<InternalDocumentID[]> {\n  return root.numberToDocumentId.get(key) ?? null\n}\n\nexport function remove (root: Nullable<FlatTree>, key: ScalarSearchableValue): Nullable<FlatTree> {\n  if (root != null) {\n    root.numberToDocumentId.delete(key)\n  }\n  return root\n}\nexport function removeDocument (root: FlatTree, id: InternalDocumentID, key: ScalarSearchableValue): void {\n  root?.numberToDocumentId.set(key, root?.numberToDocumentId.get(key)?.filter((v) => v !== id) ?? [])\n  if (root?.numberToDocumentId.get(key)?.length === 0) {\n    root?.numberToDocumentId.delete(key)\n  }\n}\n\nexport function contains (node: FlatTree, key: ScalarSearchableValue): boolean {\n  return !(find(node, key) == null)\n}\n\nexport function getSize (root: Nullable<FlatTree>): number {\n  let size = 0\n  for (const [, value] of root?.numberToDocumentId ?? []) {\n    size += value.length\n  }\n  return size\n}\nexport function filter (root: FlatTree, operation: EnumComparisonOperator): InternalDocumentID[] {\n  const operationKeys = Object.keys(operation)\n\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation')\n  }\n\n  const operationType = operationKeys[0] as keyof EnumComparisonOperator\n  switch (operationType) {\n    case 'eq': {\n      const value = operation[operationType]!\n      return root.numberToDocumentId.get(value) ?? []\n    }\n    case 'in': {\n      const value = operation[operationType]!\n      const result: InternalDocumentID[] = []\n      for (const v of value) {\n        const ids = root.numberToDocumentId.get(v)\n        if (ids != null) {\n          safeArrayPush(result, ids)\n        }\n      }\n      return result\n    }\n    case 'nin': {\n      const value = operation[operationType]!\n      const result: InternalDocumentID[] = []\n\n      const keys = root.numberToDocumentId.keys()\n      for (const key of keys) {\n        if (value.includes(key)) {\n          continue\n        }\n        const ids = root.numberToDocumentId.get(key)\n        if (ids != null) {\n          safeArrayPush(result, ids)\n        }\n      }\n      return result\n    }\n  }\n\n  throw new Error('Invalid operation')\n}\n\nexport function filterArr (root: FlatTree, operation: EnumArrComparisonOperator): InternalDocumentID[] {\n  const operationKeys = Object.keys(operation)\n\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation')\n  }\n\n  const operationType = operationKeys[0] as keyof EnumArrComparisonOperator\n  switch (operationType) {\n    case 'containsAll': {\n      const values = operation[operationType]!\n      const ids = values.map((value) => root.numberToDocumentId.get(value) ?? [])\n      return intersect(ids)\n    }\n  }\n\n  throw new Error('Invalid operation')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}