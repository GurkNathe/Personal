{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Line3, Plane, Mesh } from \"three\";\nimport { ConvexGeometry } from \"../geometries/ConvexGeometry.js\";\nvar _v1 = /* @__PURE__ */new Vector3();\nvar ConvexObjectBreaker = /*#__PURE__*/function () {\n  function ConvexObjectBreaker() {\n    var minSizeForBreak = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.4;\n    var smallDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    _classCallCheck(this, ConvexObjectBreaker);\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = {\n      object1: null,\n      object2: null\n    };\n    this.segments = [];\n    var n = 30 * 30;\n    for (var i = 0; i < n; i++) this.segments[i] = false;\n  }\n  _createClass(ConvexObjectBreaker, [{\n    key: \"prepareBreakableObject\",\n    value: function prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n      var userData = object.userData;\n      userData.mass = mass;\n      userData.velocity = velocity.clone();\n      userData.angularVelocity = angularVelocity.clone();\n      userData.breakable = breakable;\n    }\n    /*\n     * @param {int} maxRadialIterations Iterations for radial cuts.\n     * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n     *\n     * Returns the array of pieces\n     */\n  }, {\n    key: \"subdivideByImpact\",\n    value: function subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n      var debris = [];\n      var tempPlane1 = this.tempPlane1;\n      var tempPlane2 = this.tempPlane2;\n      this.tempVector3.addVectors(pointOfImpact, normal);\n      tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n      var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n      var scope = this;\n      function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n        if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n          debris.push(subObject);\n          return;\n        }\n        var angle = Math.PI;\n        if (numIterations === 0) {\n          tempPlane2.normal.copy(tempPlane1.normal);\n          tempPlane2.constant = tempPlane1.constant;\n        } else {\n          if (numIterations <= maxRadialIterations) {\n            angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n            scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n            tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n          } else {\n            angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n            scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n            scope.tempVector3_3.copy(normal).add(subObject.position);\n            tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n          }\n        }\n        scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n        var obj1 = scope.tempResultObjects.object1;\n        var obj2 = scope.tempResultObjects.object2;\n        if (obj1) {\n          subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n        }\n        if (obj2) {\n          subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n        }\n      }\n      subdivideRadial(object, 0, 2 * Math.PI, 0);\n      return debris;\n    }\n  }, {\n    key: \"cutByPlane\",\n    value: function cutByPlane(object, plane, output) {\n      var geometry = object.geometry;\n      var coords = geometry.attributes.position.array;\n      var normals = geometry.attributes.normal.array;\n      var numPoints = coords.length / 3;\n      var numFaces = numPoints / 3;\n      var indices = geometry.getIndex();\n      if (indices) {\n        indices = indices.array;\n        numFaces = indices.length / 3;\n      }\n      function getVertexIndex(faceIdx, vert) {\n        var idx = faceIdx * 3 + vert;\n        return indices ? indices[idx] : idx;\n      }\n      var points1 = [];\n      var points2 = [];\n      var delta = this.smallDelta;\n      var numPointPairs = numPoints * numPoints;\n      for (var i = 0; i < numPointPairs; i++) this.segments[i] = false;\n      var p0 = this.tempVector3_P0;\n      var p1 = this.tempVector3_P1;\n      var n0 = this.tempVector3_N0;\n      var n1 = this.tempVector3_N1;\n      for (var _i = 0; _i < numFaces - 1; _i++) {\n        var a1 = getVertexIndex(_i, 0);\n        var b1 = getVertexIndex(_i, 1);\n        var c1 = getVertexIndex(_i, 2);\n        n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n        for (var j = _i + 1; j < numFaces; j++) {\n          var a2 = getVertexIndex(j, 0);\n          var b2 = getVertexIndex(j, 1);\n          var c2 = getVertexIndex(j, 2);\n          n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n          var coplanar = 1 - n0.dot(n1) < delta;\n          if (coplanar) {\n            if (a1 === a2 || a1 === b2 || a1 === c2) {\n              if (b1 === a2 || b1 === b2 || b1 === c2) {\n                this.segments[a1 * numPoints + b1] = true;\n                this.segments[b1 * numPoints + a1] = true;\n              } else {\n                this.segments[c1 * numPoints + a1] = true;\n                this.segments[a1 * numPoints + c1] = true;\n              }\n            } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[c1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + c1] = true;\n            }\n          }\n        }\n      }\n      var localPlane = this.tempPlane_Cut;\n      object.updateMatrix();\n      ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n      for (var _i2 = 0; _i2 < numFaces; _i2++) {\n        var va = getVertexIndex(_i2, 0);\n        var vb = getVertexIndex(_i2, 1);\n        var vc = getVertexIndex(_i2, 2);\n        for (var segment = 0; segment < 3; segment++) {\n          var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n          var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n          var segmentState = this.segments[i0 * numPoints + i1];\n          if (segmentState) continue;\n          this.segments[i0 * numPoints + i1] = true;\n          this.segments[i1 * numPoints + i0] = true;\n          p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n          p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n          var mark0 = 0;\n          var d = localPlane.distanceToPoint(p0);\n          if (d > delta) {\n            mark0 = 2;\n            points2.push(p0.clone());\n          } else if (d < -delta) {\n            mark0 = 1;\n            points1.push(p0.clone());\n          } else {\n            mark0 = 3;\n            points1.push(p0.clone());\n            points2.push(p0.clone());\n          }\n          var mark1 = 0;\n          d = localPlane.distanceToPoint(p1);\n          if (d > delta) {\n            mark1 = 2;\n            points2.push(p1.clone());\n          } else if (d < -delta) {\n            mark1 = 1;\n            points1.push(p1.clone());\n          } else {\n            mark1 = 3;\n            points1.push(p1.clone());\n            points2.push(p1.clone());\n          }\n          if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n            this.tempLine1.start.copy(p0);\n            this.tempLine1.end.copy(p1);\n            var intersection = new Vector3();\n            intersection = localPlane.intersectLine(this.tempLine1, intersection);\n            if (intersection === null) {\n              console.error(\"Internal error: segment does not intersect plane.\");\n              output.segmentedObject1 = null;\n              output.segmentedObject2 = null;\n              return 0;\n            }\n            points1.push(intersection);\n            points2.push(intersection.clone());\n          }\n        }\n      }\n      var newMass = object.userData.mass * 0.5;\n      this.tempCM1.set(0, 0, 0);\n      var radius1 = 0;\n      var numPoints1 = points1.length;\n      if (numPoints1 > 0) {\n        for (var _i3 = 0; _i3 < numPoints1; _i3++) this.tempCM1.add(points1[_i3]);\n        this.tempCM1.divideScalar(numPoints1);\n        for (var _i4 = 0; _i4 < numPoints1; _i4++) {\n          var p = points1[_i4];\n          p.sub(this.tempCM1);\n          radius1 = Math.max(radius1, p.x, p.y, p.z);\n        }\n        this.tempCM1.add(object.position);\n      }\n      this.tempCM2.set(0, 0, 0);\n      var radius2 = 0;\n      var numPoints2 = points2.length;\n      if (numPoints2 > 0) {\n        for (var _i5 = 0; _i5 < numPoints2; _i5++) this.tempCM2.add(points2[_i5]);\n        this.tempCM2.divideScalar(numPoints2);\n        for (var _i6 = 0; _i6 < numPoints2; _i6++) {\n          var _p = points2[_i6];\n          _p.sub(this.tempCM2);\n          radius2 = Math.max(radius2, _p.x, _p.y, _p.z);\n        }\n        this.tempCM2.add(object.position);\n      }\n      var object1 = null;\n      var object2 = null;\n      var numObjects = 0;\n      if (numPoints1 > 4) {\n        object1 = new Mesh(new ConvexGeometry(points1), object.material);\n        object1.position.copy(this.tempCM1);\n        object1.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n        numObjects++;\n      }\n      if (numPoints2 > 4) {\n        object2 = new Mesh(new ConvexGeometry(points2), object.material);\n        object2.position.copy(this.tempCM2);\n        object2.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n        numObjects++;\n      }\n      output.object1 = object1;\n      output.object2 = object2;\n      return numObjects;\n    }\n  }], [{\n    key: \"transformFreeVector\",\n    value: function transformFreeVector(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[4] * y + e[8] * z;\n      v.y = e[1] * x + e[5] * y + e[9] * z;\n      v.z = e[2] * x + e[6] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformFreeVectorInverse\",\n    value: function transformFreeVectorInverse(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z;\n      v.y = e[4] * x + e[5] * y + e[6] * z;\n      v.z = e[8] * x + e[9] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformTiedVectorInverse\",\n    value: function transformTiedVectorInverse(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n      v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n      v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n      return v;\n    }\n  }, {\n    key: \"transformPlaneToLocalSpace\",\n    value: function transformPlaneToLocalSpace(plane, m, resultPlane) {\n      resultPlane.normal.copy(plane.normal);\n      resultPlane.constant = plane.constant;\n      var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n      ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n      resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n    }\n  }]);\n  return ConvexObjectBreaker;\n}();\nexport { ConvexObjectBreaker };","map":{"version":3,"names":["Vector3","Line3","Plane","Mesh","ConvexGeometry","_v1","ConvexObjectBreaker","minSizeForBreak","arguments","length","undefined","smallDelta","_classCallCheck","tempLine1","tempPlane1","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","n","i","_createClass","key","value","prepareBreakableObject","object","mass","velocity","angularVelocity","breakable","userData","clone","subdivideByImpact","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","geometry","coords","attributes","array","normals","numPoints","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","coplanar","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","segmentState","mark0","d","distanceToPoint","mark1","start","end","intersection","intersectLine","console","error","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","resultPlane","referencePoint","coplanarPoint"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/misc/ConvexObjectBreaker.js"],"sourcesContent":["import { Vector3, Line3, Plane, Mesh } from \"three\";\nimport { ConvexGeometry } from \"../geometries/ConvexGeometry.js\";\nconst _v1 = /* @__PURE__ */ new Vector3();\nclass ConvexObjectBreaker {\n  constructor(minSizeForBreak = 1.4, smallDelta = 1e-4) {\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = { object1: null, object2: null };\n    this.segments = [];\n    const n = 30 * 30;\n    for (let i = 0; i < n; i++)\n      this.segments[i] = false;\n  }\n  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    const userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  }\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    const debris = [];\n    const tempPlane1 = this.tempPlane1;\n    const tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    const maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    const scope = this;\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n      let angle = Math.PI;\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      }\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      const obj1 = scope.tempResultObjects.object1;\n      const obj2 = scope.tempResultObjects.object2;\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  }\n  cutByPlane(object, plane, output) {\n    const geometry = object.geometry;\n    const coords = geometry.attributes.position.array;\n    const normals = geometry.attributes.normal.array;\n    const numPoints = coords.length / 3;\n    let numFaces = numPoints / 3;\n    let indices = geometry.getIndex();\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n    function getVertexIndex(faceIdx, vert) {\n      const idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n    const points1 = [];\n    const points2 = [];\n    const delta = this.smallDelta;\n    const numPointPairs = numPoints * numPoints;\n    for (let i = 0; i < numPointPairs; i++)\n      this.segments[i] = false;\n    const p0 = this.tempVector3_P0;\n    const p1 = this.tempVector3_P1;\n    const n0 = this.tempVector3_N0;\n    const n1 = this.tempVector3_N1;\n    for (let i = 0; i < numFaces - 1; i++) {\n      const a1 = getVertexIndex(i, 0);\n      const b1 = getVertexIndex(i, 1);\n      const c1 = getVertexIndex(i, 2);\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n      for (let j = i + 1; j < numFaces; j++) {\n        const a2 = getVertexIndex(j, 0);\n        const b2 = getVertexIndex(j, 1);\n        const c2 = getVertexIndex(j, 2);\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        const coplanar = 1 - n0.dot(n1) < delta;\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    }\n    const localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n    for (let i = 0; i < numFaces; i++) {\n      const va = getVertexIndex(i, 0);\n      const vb = getVertexIndex(i, 1);\n      const vc = getVertexIndex(i, 2);\n      for (let segment = 0; segment < 3; segment++) {\n        const i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        const i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        const segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState)\n          continue;\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n        let mark0 = 0;\n        let d = localPlane.distanceToPoint(p0);\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        }\n        let mark1 = 0;\n        d = localPlane.distanceToPoint(p1);\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          let intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n          if (intersection === null) {\n            console.error(\"Internal error: segment does not intersect plane.\");\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    }\n    const newMass = object.userData.mass * 0.5;\n    this.tempCM1.set(0, 0, 0);\n    let radius1 = 0;\n    const numPoints1 = points1.length;\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++)\n        this.tempCM1.add(points1[i]);\n      this.tempCM1.divideScalar(numPoints1);\n      for (let i = 0; i < numPoints1; i++) {\n        const p = points1[i];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n      this.tempCM1.add(object.position);\n    }\n    this.tempCM2.set(0, 0, 0);\n    let radius2 = 0;\n    const numPoints2 = points2.length;\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++)\n        this.tempCM2.add(points2[i]);\n      this.tempCM2.divideScalar(numPoints2);\n      for (let i = 0; i < numPoints2; i++) {\n        const p = points2[i];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n      this.tempCM2.add(object.position);\n    }\n    let object1 = null;\n    let object2 = null;\n    let numObjects = 0;\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(\n        object1,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius1 > this.minSizeForBreak\n      );\n      numObjects++;\n    }\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(\n        object2,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius2 > this.minSizeForBreak\n      );\n      numObjects++;\n    }\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n  static transformFreeVector(v, m) {\n    const x = v.x, y = v.y, z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[4] * y + e[8] * z;\n    v.y = e[1] * x + e[5] * y + e[9] * z;\n    v.z = e[2] * x + e[6] * y + e[10] * z;\n    return v;\n  }\n  static transformFreeVectorInverse(v, m) {\n    const x = v.x, y = v.y, z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z;\n    v.y = e[4] * x + e[5] * y + e[6] * z;\n    v.z = e[8] * x + e[9] * y + e[10] * z;\n    return v;\n  }\n  static transformTiedVectorInverse(v, m) {\n    const x = v.x, y = v.y, z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n    v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n    v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n    return v;\n  }\n  static transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  }\n}\nexport {\n  ConvexObjectBreaker\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}