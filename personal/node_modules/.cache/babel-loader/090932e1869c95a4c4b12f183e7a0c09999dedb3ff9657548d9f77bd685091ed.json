{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as THREE from \"three\";\nvar PINCH_MAX = 0.05;\nvar PINCH_THRESHOLD = 0.02;\nvar PINCH_MIN = 0.01;\nvar POINTER_ADVANCE_MAX = 0.02;\nvar POINTER_OPACITY_MAX = 1;\nvar POINTER_OPACITY_MIN = 0.4;\nvar POINTER_FRONT_RADIUS = 2e-3;\nvar POINTER_REAR_RADIUS = 0.01;\nvar POINTER_REAR_RADIUS_MIN = 3e-3;\nvar POINTER_LENGTH = 0.035;\nvar POINTER_SEGMENTS = 16;\nvar POINTER_RINGS = 12;\nvar POINTER_HEMISPHERE_ANGLE = 110;\nvar YAXIS = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nvar ZAXIS = /* @__PURE__ */new THREE.Vector3(0, 0, 1);\nvar CURSOR_RADIUS = 0.02;\nvar CURSOR_MAX_DISTANCE = 1.5;\nvar OculusHandPointerModel = /*#__PURE__*/function (_THREE$Object3D) {\n  _inherits(OculusHandPointerModel, _THREE$Object3D);\n  var _super = _createSuper(OculusHandPointerModel);\n  function OculusHandPointerModel(hand, controller) {\n    var _this;\n    _classCallCheck(this, OculusHandPointerModel);\n    _this = _super.call(this);\n    _this.hand = hand;\n    _this.controller = controller;\n    _this.motionController = null;\n    _this.envMap = null;\n    _this.mesh = null;\n    _this.pointerGeometry = null;\n    _this.pointerMesh = null;\n    _this.pointerObject = null;\n    _this.pinched = false;\n    _this.attached = false;\n    _this.cursorObject = null;\n    _this.raycaster = null;\n    hand.addEventListener(\"connected\", function (event) {\n      var xrInputSource = event.data;\n      if (xrInputSource.hand) {\n        _this.visible = true;\n        _this.xrInputSource = xrInputSource;\n        _this.createPointer();\n      }\n    });\n    return _this;\n  }\n  _createClass(OculusHandPointerModel, [{\n    key: \"_drawVerticesRing\",\n    value: function _drawVerticesRing(vertices, baseVector, ringIndex) {\n      var segmentVector = baseVector.clone();\n      for (var i = 0; i < POINTER_SEGMENTS; i++) {\n        segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n        var vid = ringIndex * POINTER_SEGMENTS + i;\n        vertices[3 * vid] = segmentVector.x;\n        vertices[3 * vid + 1] = segmentVector.y;\n        vertices[3 * vid + 2] = segmentVector.z;\n      }\n    }\n  }, {\n    key: \"_updatePointerVertices\",\n    value: function _updatePointerVertices(rearRadius) {\n      var vertices = this.pointerGeometry.attributes.position.array;\n      var frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n      this._drawVerticesRing(vertices, frontFaceBase, 0);\n      var rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n      for (var i = 0; i < POINTER_RINGS; i++) {\n        this._drawVerticesRing(vertices, rearBase, i + 1);\n        rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n      }\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      var frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n      vertices[frontCenterIndex * 3] = frontCenter.x;\n      vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n      vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n      var rearCenter = new THREE.Vector3(0, 0, rearRadius);\n      vertices[rearCenterIndex * 3] = rearCenter.x;\n      vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n      vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n      this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    }\n  }, {\n    key: \"createPointer\",\n    value: function createPointer() {\n      var i, j;\n      var vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n      var indices = [];\n      this.pointerGeometry = new THREE.BufferGeometry();\n      this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      for (i = 0; i < POINTER_RINGS; i++) {\n        for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n          indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n          indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        }\n        indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n        indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      }\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n        indices.push(frontCenterIndex, i + 1, i);\n        indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n      }\n      indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n      indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n      var material = new THREE.MeshBasicMaterial();\n      material.transparent = true;\n      material.opacity = POINTER_OPACITY_MIN;\n      this.pointerGeometry.setIndex(indices);\n      this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerObject = new THREE.Object3D();\n      this.pointerObject.add(this.pointerMesh);\n      this.raycaster = new THREE.Raycaster();\n      var cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n      var cursorMaterial = new THREE.MeshBasicMaterial();\n      cursorMaterial.transparent = true;\n      cursorMaterial.opacity = POINTER_OPACITY_MIN;\n      this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n      this.pointerObject.add(this.cursorObject);\n      this.add(this.pointerObject);\n    }\n  }, {\n    key: \"_updateRaycaster\",\n    value: function _updateRaycaster() {\n      if (this.raycaster) {\n        var pointerMatrix = this.pointerObject.matrixWorld;\n        var tempMatrix = new THREE.Matrix4();\n        tempMatrix.identity().extractRotation(pointerMatrix);\n        this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n        this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n      }\n    }\n  }, {\n    key: \"_updatePointer\",\n    value: function _updatePointer() {\n      this.pointerObject.visible = this.controller.visible;\n      var indexTip = this.hand.joints[\"index-finger-tip\"];\n      var thumbTip = this.hand.joints[\"thumb-tip\"];\n      var distance = indexTip.position.distanceTo(thumbTip.position);\n      var position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n      this.pointerObject.position.copy(position);\n      this.pointerObject.quaternion.copy(this.controller.quaternion);\n      this.pinched = distance <= PINCH_THRESHOLD;\n      var pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n      var focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n      if (pinchScale > 1) {\n        this._updatePointerVertices(POINTER_REAR_RADIUS);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      } else if (pinchScale > 0) {\n        var rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n        this._updatePointerVertices(rearRadius);\n        if (focusScale < 1) {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n        } else {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n        }\n      } else {\n        this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n      }\n      this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      _get(_getPrototypeOf(OculusHandPointerModel.prototype), \"updateMatrixWorld\", this).call(this, force);\n      if (this.pointerGeometry) {\n        this._updatePointer();\n        this._updateRaycaster();\n      }\n    }\n  }, {\n    key: \"isPinched\",\n    value: function isPinched() {\n      return this.pinched;\n    }\n  }, {\n    key: \"setAttached\",\n    value: function setAttached(attached) {\n      this.attached = attached;\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached() {\n      return this.attached;\n    }\n  }, {\n    key: \"intersectObject\",\n    value: function intersectObject(object) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObject(object, recursive);\n      }\n    }\n  }, {\n    key: \"intersectObjects\",\n    value: function intersectObjects(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObjects(objects, recursive);\n      }\n    }\n  }, {\n    key: \"checkIntersections\",\n    value: function checkIntersections(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.raycaster && !this.attached) {\n        var intersections = this.raycaster.intersectObjects(objects, recursive);\n        var direction = new THREE.Vector3(0, 0, -1);\n        if (intersections.length > 0) {\n          var intersection = intersections[0];\n          var distance = intersection.distance;\n          this.cursorObject.position.copy(direction.multiplyScalar(distance));\n        } else {\n          this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n        }\n      }\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(distance) {\n      var direction = new THREE.Vector3(0, 0, -1);\n      if (this.raycaster && !this.attached) {\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      }\n    }\n  }]);\n  return OculusHandPointerModel;\n}(THREE.Object3D);\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","_THREE$Object3D","_inherits","_super","_createSuper","hand","controller","_this","_classCallCheck","call","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","addEventListener","event","xrInputSource","data","visible","createPointer","_createClass","key","value","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","push","material","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","Object3D","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","_get","_getPrototypeOf","prototype","isPinched","setAttached","isAttached","intersectObject","object","recursive","arguments","length","undefined","intersectObjects","objects","checkIntersections","intersections","intersection","setCursor"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from \"three\";\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 2e-3;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 3e-3;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */ new THREE.Vector3(0, 1, 0);\nconst ZAXIS = /* @__PURE__ */ new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    hand.addEventListener(\"connected\", (event) => {\n      const xrInputSource = event.data;\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    });\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array;\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0);\n    const rearBase = new THREE.Vector3(\n      Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius,\n      Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius,\n      0\n    );\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n  }\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS);\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster();\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints[\"index-finger-tip\"];\n    const thumbTip = this.hand.joints[\"thumb-tip\"];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n  isPinched() {\n    return this.pinched;\n  }\n  setAttached(attached) {\n    this.attached = attached;\n  }\n  isAttached() {\n    return this.attached;\n  }\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n}\nexport {\n  OculusHandPointerModel\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}