{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: \"decode\",\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]);\n      });\n    }).then(message => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\"/* draco decoder */\", jsContent, \"\", \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({\n          type: \"init\",\n          decoderConfig: this.decoderConfig\n        });\n        worker2.onmessage = function (e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\"Task load: \", this.workerPool.map(worker => worker._taskLoad));\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            resolve({\n              draco\n            });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: \"decode\",\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = {\n      index: null,\n      attributes: []\n    };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport { DRACOLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","_taskCache","WeakMap","DRACOLoader","constructor","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","attribute","type","BYTES_PER_ELEMENT","name","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","itemSize","setAttribute","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","worker2","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","debug","log","map","dispose","terminate","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/DRACOLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport {\n  DRACOLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}