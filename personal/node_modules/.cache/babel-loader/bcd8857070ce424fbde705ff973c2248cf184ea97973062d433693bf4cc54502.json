{"ast":null,"code":"import { safeArrayPush } from '../utils.js';\nconst BALANCE_STATE = {\n  UNBALANCED_RIGHT: -2,\n  SLIGHTLY_UNBALANCED_RIGHT: -1,\n  BALANCED: 0,\n  SLIGHTLY_UNBALANCED_LEFT: 1,\n  UNBALANCED_LEFT: 2\n};\nfunction getHeight(node) {\n  return node != null ? node.h : -1;\n}\nfunction rotateLeft(node) {\n  const right = node.r;\n  node.r = right.l;\n  right.l = node;\n  node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;\n  right.h = Math.max(getHeight(right.l), getHeight(right.r)) + 1;\n  return right;\n}\nfunction rotateRight(node) {\n  const left = node.l;\n  node.l = left.r;\n  left.r = node;\n  node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;\n  left.h = Math.max(getHeight(left.l), getHeight(left.r)) + 1;\n  return left;\n}\nexport function contains(node, key) {\n  return !!find(node, key);\n}\nexport function getSize(root) {\n  let size = 0;\n  const queue = [];\n  if (root !== null) {\n    queue.push(root);\n  }\n  while (queue.length > 0) {\n    const node = queue.shift();\n    size++;\n    if (node.l !== null) {\n      queue.push(node.l);\n    }\n    if (node.r !== null) {\n      queue.push(node.r);\n    }\n  }\n  return size;\n}\nexport function isBalanced(root) {\n  if (root === null) return true;\n  const stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (node === undefined) return true;\n    const heightDiff = getHeight(node.l) - getHeight(node.r);\n    if (heightDiff > 1 || heightDiff < -1) {\n      return false;\n    }\n    if (node.r !== null) {\n      stack.push(node.r);\n    }\n    if (node.l !== null) {\n      stack.push(node.l);\n    }\n  }\n  return true;\n}\nexport function rangeSearch(node, min, max) {\n  if (!node) {\n    return [];\n  }\n  const result = [];\n  function traverse(node) {\n    if (!node) {\n      return;\n    }\n    if (node.k > min) {\n      traverse(node.l);\n    }\n    if (node.k >= min && node.k <= max) {\n      safeArrayPush(result, node.v);\n    }\n    if (node.k < max) {\n      traverse(node.r);\n    }\n  }\n  traverse(node);\n  return result;\n}\nexport function greaterThan(node, key) {\n  let inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!node) {\n    return [];\n  }\n  const result = [];\n  function traverse(node) {\n    if (!node) {\n      return;\n    }\n    if (inclusive && node.k >= key) {\n      safeArrayPush(result, node.v);\n    }\n    if (!inclusive && node.k > key) {\n      safeArrayPush(result, node.v);\n    }\n    traverse(node.l);\n    traverse(node.r);\n  }\n  traverse(node);\n  return result;\n}\nexport function lessThan(node, key) {\n  let inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!node) {\n    return [];\n  }\n  const result = [];\n  function traverse(node) {\n    if (!node) {\n      return;\n    }\n    if (inclusive && node.k <= key) {\n      safeArrayPush(result, node.v);\n    }\n    if (!inclusive && node.k < key) {\n      safeArrayPush(result, node.v);\n    }\n    traverse(node.l);\n    traverse(node.r);\n  }\n  traverse(node);\n  return result;\n}\nfunction getNodeByKey(node, key) {\n  while (node !== null) {\n    if (key < node.k) {\n      node = node.l;\n    } else if (key > node.k) {\n      node = node.r;\n    } else {\n      return node;\n    }\n  }\n  return null;\n}\nexport function create(key, value) {\n  return {\n    k: key,\n    v: value,\n    l: null,\n    r: null,\n    h: 0\n  };\n}\nexport function insert(root, key, value) {\n  let parent = null;\n  let current = root;\n  while (current !== null) {\n    parent = current;\n    if (key < current.k) {\n      current = current.l;\n    } else if (key > current.k) {\n      current = current.r;\n    } else {\n      // assuming value is an array here\n      current.v = current.v.concat(value);\n      return root;\n    }\n  }\n  const newNode = create(key, value);\n  if (parent == null) {\n    root = newNode // tree was empty\n    ;\n  } else if (key < parent.k) {\n    parent.l = newNode;\n  } else {\n    parent.r = newNode;\n  }\n  current = newNode;\n  while (parent != null) {\n    const balanceFactor = getHeight(parent.l) - getHeight(parent.r);\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {\n      if (key > parent.l.k) {\n        parent.l = rotateLeft(parent.l);\n      }\n      parent = rotateRight(parent);\n    }\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {\n      if (key < parent.r.k) {\n        parent.r = rotateRight(parent.r);\n      }\n      parent = rotateLeft(parent);\n    }\n    if (parent === root) {\n      break;\n    }\n    current = parent;\n    parent = getNodeParent(root, current.k);\n  }\n  return root;\n}\nfunction getNodeParent(root, key) {\n  let current = root;\n  let parent = null;\n  while (current !== null) {\n    if (key < current.k) {\n      parent = current;\n      current = current.l;\n    } else if (key > current.k) {\n      parent = current;\n      current = current.r;\n    } else {\n      break;\n    }\n  }\n  return parent;\n}\nexport function find(root, key) {\n  const node = getNodeByKey(root, key);\n  if (node == null) {\n    return null;\n  }\n  return node.v;\n}\nexport function remove(root, key) {\n  let node = root;\n  let parentNode = null;\n  while (node != null && node.k !== key) {\n    parentNode = node;\n    if (key < node.k) {\n      node = node.l;\n    } else {\n      node = node.r;\n    }\n  }\n  if (node == null) {\n    return null;\n  }\n  if (node.l == null && node.r == null) {\n    if (parentNode == null) {\n      // Node to be deleted is root\n      root = null;\n    } else {\n      if (parentNode.l === node) {\n        parentNode.l = null;\n      } else {\n        parentNode.r = null;\n      }\n    }\n  } else if (node.l != null && node.r != null) {\n    let minValueNode = node.r;\n    let minValueParent = node;\n    while (minValueNode.l != null) {\n      minValueParent = minValueNode;\n      minValueNode = minValueNode.l;\n    }\n    node.k = minValueNode.k;\n    if (minValueParent === node) {\n      minValueParent.r = minValueNode.r;\n    } else {\n      minValueParent.l = minValueNode.r;\n    }\n  } else {\n    const childNode = node.l != null ? node.l : node.r;\n    if (parentNode == null) {\n      root = childNode;\n    } else {\n      if (parentNode.l === node) {\n        parentNode.l = childNode;\n      } else {\n        parentNode.r = childNode;\n      }\n    }\n  }\n  return root;\n}\nexport function removeDocument(root, id, key) {\n  const node = getNodeByKey(root, key);\n  if (!node) {\n    return;\n  }\n  if (node.v.length === 1) {\n    remove(root, key);\n    return;\n  }\n  node.v.splice(node.v.indexOf(id), 1);\n}","map":{"version":3,"names":["safeArrayPush","BALANCE_STATE","UNBALANCED_RIGHT","SLIGHTLY_UNBALANCED_RIGHT","BALANCED","SLIGHTLY_UNBALANCED_LEFT","UNBALANCED_LEFT","getHeight","node","h","rotateLeft","right","r","l","Math","max","rotateRight","left","contains","key","find","getSize","root","size","queue","push","length","shift","isBalanced","stack","pop","undefined","heightDiff","rangeSearch","min","result","traverse","k","v","greaterThan","inclusive","arguments","lessThan","getNodeByKey","create","value","insert","parent","current","concat","newNode","balanceFactor","getNodeParent","remove","parentNode","minValueNode","minValueParent","childNode","removeDocument","id","splice","indexOf"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/trees/avl.ts"],"sourcesContent":["import { Nullable } from '../types.js'\nimport { safeArrayPush } from '../utils.js'\n\nexport interface Node<K, V> {\n  // Node key\n  k: K\n  // Node value\n  v: V\n  // Left child node\n  l: Nullable<Node<K, V>>\n  // Right child node\n  r: Nullable<Node<K, V>>\n  // Tree height from this node\n  h: number\n}\n\nconst BALANCE_STATE = {\n  UNBALANCED_RIGHT: -2,\n  SLIGHTLY_UNBALANCED_RIGHT: -1,\n  BALANCED: 0,\n  SLIGHTLY_UNBALANCED_LEFT: 1,\n  UNBALANCED_LEFT: 2\n}\n\nfunction getHeight<K, V> (node: Nullable<Node<K, V>>): number {\n  return (node != null) ? node.h : -1\n}\n\nfunction rotateLeft<K, V> (node: Node<K, V>): Node<K, V> {\n  const right = node.r as Node<K, V>\n  node.r = right.l\n  right.l = node\n  node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1\n  right.h = Math.max(getHeight(right.l), getHeight(right.r)) + 1\n  return right\n}\n\nfunction rotateRight<K, V> (node: Node<K, V>): Node<K, V> {\n  const left = node.l as Node<K, V>\n  node.l = left.r\n  left.r = node\n  node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1\n  left.h = Math.max(getHeight(left.l), getHeight(left.r)) + 1\n  return left\n}\n\nexport function contains<K, V> (node: Node<K, V>, key: K): boolean {\n  return !!find(node, key)\n}\n\nexport function getSize<K, V> (root: Nullable<Node<K, V>>): number {\n  let size = 0\n  const queue: Array<Node<K, V>> = []\n\n  if (root !== null) {\n    queue.push(root)\n  }\n\n  while (queue.length > 0) {\n    const node = queue.shift() as Node<K, V>\n    size++\n\n    if (node.l !== null) {\n      queue.push(node.l)\n    }\n\n    if (node.r !== null) {\n      queue.push(node.r)\n    }\n  }\n\n  return size\n}\n\nexport function isBalanced<K, V> (root: Nullable<Node<K, V>>): boolean {\n  if (root === null) return true\n\n  const stack: Array<Node<K, V>> = [root]\n\n  while (stack.length > 0) {\n    const node = stack.pop()\n\n    if (node === undefined) return true\n\n    const heightDiff = getHeight(node.l) - getHeight(node.r)\n\n    if (heightDiff > 1 || heightDiff < -1) {\n      return false\n    }\n\n    if (node.r !== null) {\n      stack.push(node.r)\n    }\n\n    if (node.l !== null) {\n      stack.push(node.l)\n    }\n  }\n\n  return true\n}\n\nexport function rangeSearch<K, V> (node: Node<K, V>, min: K, max: K): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  const result: V[] = []\n\n  function traverse (node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (node.k > min) {\n      traverse(node.l as Node<K, V>)\n    }\n\n    if (node.k >= min && node.k <= max) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    if (node.k < max) {\n      traverse(node.r as Node<K, V>)\n    }\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nexport function greaterThan<K, V> (node: Node<K, V>, key: K, inclusive = false): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  const result: V[] = []\n\n  function traverse (node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (inclusive && node.k >= key) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    if (!inclusive && node.k > key) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    traverse(node.l as Node<K, V>)\n    traverse(node.r as Node<K, V>)\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nexport function lessThan<K, V> (node: Node<K, V>, key: K, inclusive = false): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  const result: V[] = []\n\n  function traverse (node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (inclusive && node.k <= key) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    if (!inclusive && node.k < key) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    traverse(node.l as Node<K, V>)\n    traverse(node.r as Node<K, V>)\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nfunction getNodeByKey<K, V> (node: Nullable<Node<K, V>>, key: K): Nullable<Node<K, V>> {\n  while (node !== null) {\n    if (key < node.k) {\n      node = node.l\n    } else if (key > node.k) {\n      node = node.r\n    } else {\n      return node\n    }\n  }\n  return null\n}\n\nexport function create<K, V> (key: K, value: V): Node<K, V> {\n  return {\n    k: key,\n    v: value,\n    l: null,\n    r: null,\n    h: 0\n  }\n}\n\nexport function insert<K, V> (root: Node<K, V>, key: K, value: V): Node<K, V> {\n  let parent: Nullable<Node<K, V>> = null\n  let current: Nullable<Node<K, V>> = root\n\n  while (current !== null) {\n    parent = current\n    if (key < current.k) {\n      current = current.l\n    } else if (key > current.k) {\n      current = current.r\n    } else {\n      // assuming value is an array here\n      (current.v as string[]) = (current.v as string[]).concat(value as string)\n      return root\n    }\n  }\n\n  const newNode = create(key, value)\n\n  if (parent == null) {\n    root = newNode // tree was empty\n  } else if (key < parent.k) {\n    parent.l = newNode\n  } else {\n    parent.r = newNode\n  }\n\n  current = newNode\n\n  while (parent != null) {\n    const balanceFactor = getHeight(parent.l) - getHeight(parent.r)\n\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {\n      if (key > (parent.l as Node<K, V>).k) {\n        parent.l = rotateLeft(parent.l as Node<K, V>)\n      }\n      parent = rotateRight(parent)\n    }\n\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {\n      if (key < (parent.r as Node<K, V>).k) {\n        parent.r = rotateRight(parent.r as Node<K, V>)\n      }\n      parent = rotateLeft(parent)\n    }\n\n    if (parent === root) {\n      break\n    }\n\n    current = parent\n    parent = getNodeParent(root, current.k)\n  }\n\n  return root\n}\n\nfunction getNodeParent<K, V> (root: Node<K, V>, key: K): Nullable<Node<K, V>> {\n  let current: Nullable<Node<K, V>> = root\n  let parent: Nullable<Node<K, V>> = null\n\n  while (current !== null) {\n    if (key < current.k) {\n      parent = current\n      current = current.l\n    } else if (key > current.k) {\n      parent = current\n      current = current.r\n    } else {\n      break\n    }\n  }\n\n  return parent\n}\n\nexport function find<K, V> (root: Node<K, V>, key: K): V | null {\n  const node = getNodeByKey(root, key)\n  if (node == null) {\n    return null\n  }\n  return node.v\n}\n\nexport function remove<K, V> (root: Nullable<Node<K, V>>, key: K): Nullable<Node<K, V>> {\n  let node = root\n  let parentNode: Nullable<Node<K, V>> = null\n\n  while ((node != null) && node.k !== key) {\n    parentNode = node\n    if (key < node.k) {\n      node = node.l as Node<K, V>\n    } else {\n      node = node.r as Node<K, V>\n    }\n  }\n\n  if (node == null) {\n    return null\n  }\n\n  if ((node.l == null) && (node.r == null)) {\n    if (parentNode == null) {\n      // Node to be deleted is root\n      root = null\n    } else {\n      if (parentNode.l === node) {\n        parentNode.l = null\n      } else {\n        parentNode.r = null\n      }\n    }\n  } else if ((node.l != null) && (node.r != null)) {\n    let minValueNode = node.r\n    let minValueParent = node\n\n    while (minValueNode.l != null) {\n      minValueParent = minValueNode\n      minValueNode = minValueNode.l\n    }\n\n    node.k = minValueNode.k\n\n    if (minValueParent === node) {\n      minValueParent.r = minValueNode.r\n    } else {\n      minValueParent.l = minValueNode.r\n    }\n  } else {\n    const childNode = (node.l != null) ? node.l : node.r\n\n    if (parentNode == null) {\n      root = childNode as Node<K, V>\n    } else {\n      if (parentNode.l === node) {\n        parentNode.l = childNode\n      } else {\n        parentNode.r = childNode\n      }\n    }\n  }\n\n  return root\n}\n\nexport function removeDocument<K, V> (root: Node<K, V[]>, id: V, key: K): void {\n  const node = getNodeByKey(root, key)!\n\n  if (!node) {\n    return\n  }\n\n  if (node.v.length === 1) {\n    remove(root, key)\n    return\n  }\n\n  node.v.splice(node.v.indexOf(id), 1)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}