{"ast":null,"code":"import _toConsumableArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { applyProps } from '@react-three/fiber';\n\n// and @0beqz https://gist.github.com/0beqz/8d51b4ae16d68021a09fb504af708fca\n\nvar worldposReplace = /* glsl */\"\\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n  #ifdef BOX_PROJECTED_ENV_MAP\\n    vWorldPosition = worldPosition.xyz;\\n  #endif\\n#endif\\n\";\nvar boxProjectDefinitions = /*glsl */\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  uniform vec3 envMapSize;\\n  uniform vec3 envMapPosition;\\n  varying vec3 vWorldPosition;\\n    \\n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\\n    vec3 nDir = normalize( v );\\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbminmax;\\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \\n    return boxIntersection - cubePos;\\n  }\\n#endif\\n\"; // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nvar getIBLIrradiance_patch = /* glsl */\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\\n#endif\\n\"; // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nvar getIBLRadiance_patch = /* glsl */\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\\n#endif\\n\";\nfunction boxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  shader.defines.BOX_PROJECTED_ENV_MAP = true; // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  }; // vertex shader\n\n  shader.vertexShader = \"\\n  varying vec3 vWorldPosition;\\n  \".concat(shader.vertexShader.replace('#include <worldpos_vertex>', worldposReplace)); // fragment shader\n\n  shader.fragmentShader = \"\\n    \".concat(boxProjectDefinitions, \"\\n    \").concat(shader.fragmentShader.replace('#include <envmap_physical_pars_fragment>', THREE.ShaderChunk.envmap_physical_pars_fragment).replace('vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n         \".concat(getIBLIrradiance_patch, \"\\n         \")).replace('reflectVec = inverseTransformDirection( reflectVec, viewMatrix );', \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n         \".concat(getIBLRadiance_patch, \"\\n        \")));\n}\nfunction useBoxProjectedEnv() {\n  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new THREE.Vector3();\n  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n  var _React$useState = React.useState(function () {\n      return {\n        position: new THREE.Vector3(),\n        size: new THREE.Vector3()\n      };\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    config = _React$useState2[0];\n  applyProps(config, {\n    position: position,\n    size: size\n  });\n  var ref = React.useRef(null);\n  var spread = React.useMemo(function () {\n    return {\n      ref: ref,\n      onBeforeCompile: function onBeforeCompile(shader) {\n        return boxProjectedEnvMap(shader, config.position, config.size);\n      },\n      customProgramCacheKey: function customProgramCacheKey() {\n        return JSON.stringify(config.position.toArray()) + JSON.stringify(config.size.toArray());\n      }\n    };\n  }, [].concat(_toConsumableArray(config.position.toArray()), _toConsumableArray(config.size.toArray())));\n  React.useLayoutEffect(function () {\n    return void (ref.current.needsUpdate = true);\n  }, [config]);\n  return spread;\n}\nexport { useBoxProjectedEnv };","map":{"version":3,"names":["THREE","React","applyProps","worldposReplace","boxProjectDefinitions","getIBLIrradiance_patch","getIBLRadiance_patch","boxProjectedEnvMap","shader","envMapPosition","envMapSize","defines","BOX_PROJECTED_ENV_MAP","uniforms","value","vertexShader","concat","replace","fragmentShader","ShaderChunk","envmap_physical_pars_fragment","useBoxProjectedEnv","position","arguments","length","undefined","Vector3","size","_React$useState","useState","_React$useState2","_slicedToArray","config","ref","useRef","spread","useMemo","onBeforeCompile","customProgramCacheKey","JSON","stringify","toArray","_toConsumableArray","useLayoutEffect","current","needsUpdate"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@react-three+drei@9.72.1_@react-three+fiber@8.13.0_@types+three@0.150.2_react-dom@18.2.0_react@18.2.0_three@0.151.3/node_modules/@react-three/drei/core/useBoxProjectedEnv.js"],"sourcesContent":["import * as THREE from 'three';\nimport * as React from 'react';\nimport { applyProps } from '@react-three/fiber';\n\n// and @0beqz https://gist.github.com/0beqz/8d51b4ae16d68021a09fb504af708fca\n\nconst worldposReplace =\n/* glsl */\n`\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n  #ifdef BOX_PROJECTED_ENV_MAP\n    vWorldPosition = worldPosition.xyz;\n  #endif\n#endif\n`;\nconst boxProjectDefinitions =\n/*glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  uniform vec3 envMapSize;\n  uniform vec3 envMapPosition;\n  varying vec3 vWorldPosition;\n    \n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n    vec3 nDir = normalize( v );\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbminmax;\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \n    return boxIntersection - cubePos;\n  }\n#endif\n`; // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nconst getIBLIrradiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n`; // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nconst getIBLRadiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`;\n\nfunction boxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  shader.defines.BOX_PROJECTED_ENV_MAP = true; // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  }; // vertex shader\n\n  shader.vertexShader = `\n  varying vec3 vWorldPosition;\n  ${shader.vertexShader.replace('#include <worldpos_vertex>', worldposReplace)}`; // fragment shader\n\n  shader.fragmentShader = `\n    ${boxProjectDefinitions}\n    ${shader.fragmentShader.replace('#include <envmap_physical_pars_fragment>', THREE.ShaderChunk.envmap_physical_pars_fragment).replace('vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n         ${getIBLIrradiance_patch}\n         `).replace('reflectVec = inverseTransformDirection( reflectVec, viewMatrix );', `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n         ${getIBLRadiance_patch}\n        `)}`;\n}\n\nfunction useBoxProjectedEnv(position = new THREE.Vector3(), size = new THREE.Vector3()) {\n  const [config] = React.useState(() => ({\n    position: new THREE.Vector3(),\n    size: new THREE.Vector3()\n  }));\n  applyProps(config, {\n    position,\n    size\n  });\n  const ref = React.useRef(null);\n  const spread = React.useMemo(() => ({\n    ref,\n    onBeforeCompile: shader => boxProjectedEnvMap(shader, config.position, config.size),\n    customProgramCacheKey: () => JSON.stringify(config.position.toArray()) + JSON.stringify(config.size.toArray())\n  }), [...config.position.toArray(), ...config.size.toArray()]);\n  React.useLayoutEffect(() => void (ref.current.needsUpdate = true), [config]);\n  return spread;\n}\n\nexport { useBoxProjectedEnv };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}