{"ast":null,"code":"import { createError } from '../errors.js';\nimport { create as avlCreate, find as avlFind, greaterThan as avlGreaterThan, insert as avlInsert, lessThan as avlLessThan, rangeSearch as avlRangeSearch, removeDocument as avlRemoveDocument } from '../trees/avl.js';\nimport { create as flatCreate, filter as flatFilter, filterArr as flatFilterArr, insert as flatInsert, removeDocument as flatRemoveDocument } from '../trees/flat.js';\nimport { create as radixCreate, find as radixFind, insert as radixInsert, removeDocumentByWord as radixRemoveDocument } from '../trees/radix.js';\nimport { intersect, safeArrayPush } from '../utils.js';\nimport { BM25 } from './algorithms.js';\nimport { getMagnitude } from './cosine-similarity.js';\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js';\nimport { getInternalDocumentId } from './internal-document-id-store.js';\nexport async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {\n  var _index$avgFieldLength;\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  index.avgFieldLength[prop] = (((_index$avgFieldLength = index.avgFieldLength[prop]) !== null && _index$avgFieldLength !== void 0 ? _index$avgFieldLength : 0) * (docsCount - 1) + tokens.length) / docsCount;\n  index.fieldLengths[prop][internalId] = tokens.length;\n  index.frequencies[prop][internalId] = {};\n}\nexport async function insertTokenScoreParameters(index, prop, id, tokens, token) {\n  var _index$tokenOccurrenc;\n  let tokenFrequency = 0;\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++;\n    }\n  }\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  const tf = tokenFrequency / tokens.length;\n  index.frequencies[prop][internalId][token] = tf;\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0;\n  }\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = ((_index$tokenOccurrenc = index.tokenOccurrences[prop][token]) !== null && _index$tokenOccurrenc !== void 0 ? _index$tokenOccurrenc : 0) + 1;\n}\nexport async function removeDocumentScoreParameters(index, prop, id, docsCount) {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);\n  index.fieldLengths[prop][internalId] = undefined;\n  index.frequencies[prop][internalId] = undefined;\n}\nexport async function removeTokenScoreParameters(index, prop, token) {\n  index.tokenOccurrences[prop][token]--;\n}\nexport async function calculateResultScores(context, index, prop, term, ids) {\n  var _oramaOccurrences$ter;\n  const documentIDs = Array.from(ids);\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop];\n  const fieldLengths = index.fieldLengths[prop];\n  const oramaOccurrences = index.tokenOccurrences[prop];\n  const oramaFrequencies = index.frequencies[prop];\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? (_oramaOccurrences$ter = oramaOccurrences[term]) !== null && _oramaOccurrences$ter !== void 0 ? _oramaOccurrences$ter : 0 : 0;\n  const scoreList = [];\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length;\n  for (let k = 0; k < documentIDsLength; k++) {\n    var _ref;\n    var _oramaFrequencies_internalId;\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k]);\n    const tf = (_ref = oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_internalId = oramaFrequencies[internalId]) === null || _oramaFrequencies_internalId === void 0 ? void 0 : _oramaFrequencies_internalId[term]) !== null && _ref !== void 0 ? _ref : 0;\n    const bm25 = BM25(tf, termOccurrences, context.docsCount, fieldLengths[internalId], avgFieldLength, context.params.relevance);\n    scoreList.push([internalId, bm25]);\n  }\n  return scoreList;\n}\nexport async function create(orama, sharedInternalDocumentStore, schema, index) {\n  let prefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      vectorIndexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {}\n    };\n  }\n  for (const [prop, type] of Object.entries(schema)) {\n    const path = \"\".concat(prefix).concat(prefix ? '.' : '').concat(prop);\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type, index, path);\n      continue;\n    }\n    if (isVectorType(type)) {\n      index.searchableProperties.push(path);\n      index.searchablePropertiesWithTypes[path] = type;\n      index.vectorIndexes[path] = {\n        size: getVectorSize(type),\n        vectors: {}\n      };\n    } else {\n      const isArray = /\\[/.test(type);\n      switch (type) {\n        case 'boolean':\n        case 'boolean[]':\n          index.indexes[path] = {\n            type: 'Bool',\n            node: {\n              true: [],\n              false: []\n            },\n            isArray\n          };\n          break;\n        case 'number':\n        case 'number[]':\n          index.indexes[path] = {\n            type: 'AVL',\n            node: avlCreate(0, []),\n            isArray\n          };\n          break;\n        case 'string':\n        case 'string[]':\n          index.indexes[path] = {\n            type: 'Radix',\n            node: radixCreate(),\n            isArray\n          };\n          index.avgFieldLength[path] = 0;\n          index.frequencies[path] = {};\n          index.tokenOccurrences[path] = {};\n          index.fieldLengths[path] = {};\n          break;\n        case 'enum':\n        case 'enum[]':\n          index.indexes[path] = {\n            type: 'Flat',\n            node: flatCreate(),\n            isArray\n          };\n          break;\n        default:\n          throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n      }\n      index.searchableProperties.push(path);\n      index.searchablePropertiesWithTypes[path] = type;\n    }\n  }\n  return index;\n}\nasync function insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  const {\n    type,\n    node\n  } = index.indexes[prop];\n  switch (type) {\n    case 'Bool':\n      {\n        node[value ? 'true' : 'false'].push(internalId);\n        break;\n      }\n    case 'AVL':\n      avlInsert(node, value, [internalId]);\n      break;\n    case 'Radix':\n      {\n        const tokens = await tokenizer.tokenize(value, language, prop);\n        await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);\n        for (const token of tokens) {\n          await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);\n          radixInsert(node, token, internalId);\n        }\n        break;\n      }\n    case 'Flat':\n      {\n        flatInsert(node, value, internalId);\n        break;\n      }\n  }\n}\nexport async function insert(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  if (isVectorType(schemaType)) {\n    return insertVector(index, prop, value, id);\n  }\n  if (!isArrayType(schemaType)) {\n    return insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n  }\n  const innerSchemaType = getInnerType(schemaType);\n  const elements = value;\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n  }\n}\nfunction insertVector(index, prop, value, id) {\n  if (!(value instanceof Float32Array)) {\n    value = new Float32Array(value);\n  }\n  const size = index.vectorIndexes[prop].size;\n  const magnitude = getMagnitude(value, size);\n  index.vectorIndexes[prop].vectors[id] = [magnitude, value];\n}\nasync function removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n  if (isVectorType(schemaType)) {\n    delete index.vectorIndexes[prop].vectors[id];\n    return true;\n  }\n  const {\n    type,\n    node\n  } = index.indexes[prop];\n  switch (type) {\n    case 'AVL':\n      {\n        avlRemoveDocument(node, internalId, value);\n        return true;\n      }\n    case 'Bool':\n      {\n        const booleanKey = value ? 'true' : 'false';\n        const position = node[booleanKey].indexOf(internalId);\n        node[value ? 'true' : 'false'].splice(position, 1);\n        return true;\n      }\n    case 'Radix':\n      {\n        const tokens = await tokenizer.tokenize(value, language, prop);\n        await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);\n        for (const token of tokens) {\n          await implementation.removeTokenScoreParameters(index, prop, token);\n          radixRemoveDocument(node, token, internalId);\n        }\n        return true;\n      }\n    case 'Flat':\n      {\n        flatRemoveDocument(node, internalId, value);\n        return true;\n      }\n  }\n}\nexport async function remove(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n  }\n  const innerSchemaType = getInnerType(schemaType);\n  const elements = value;\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n  }\n  return true;\n}\nexport async function search(context, index, prop, term) {\n  if (!(prop in index.tokenOccurrences)) {\n    return [];\n  }\n  const {\n    node,\n    type\n  } = index.indexes[prop];\n  if (type !== 'Radix') {\n    throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop);\n  }\n  const {\n    exact,\n    tolerance\n  } = context.params;\n  const searchResult = radixFind(node, {\n    term,\n    exact,\n    tolerance\n  });\n  const ids = new Set();\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id);\n    }\n  }\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));\n}\nexport async function searchByWhereClause(context, index, filters) {\n  const filterKeys = Object.keys(filters);\n  const filtersMap = filterKeys.reduce((acc, key) => ({\n    [key]: [],\n    ...acc\n  }), {});\n  for (const param of filterKeys) {\n    const operation = filters[param];\n    if (typeof index.indexes[param] === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param);\n    }\n    const {\n      node,\n      type,\n      isArray\n    } = index.indexes[param];\n    if (type === 'Bool') {\n      const idx = node;\n      const filteredIDs = idx[operation.toString()];\n      safeArrayPush(filtersMap[param], filteredIDs);\n      continue;\n    }\n    if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param);\n        for (const t of term) {\n          const filteredIDsResults = radixFind(node, {\n            term: t,\n            exact: true\n          });\n          safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat());\n        }\n      }\n      continue;\n    }\n    const operationKeys = Object.keys(operation);\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length);\n    }\n    if (type === 'Flat') {\n      if (isArray) {\n        safeArrayPush(filtersMap[param], flatFilterArr(node, operation));\n      } else {\n        safeArrayPush(filtersMap[param], flatFilter(node, operation));\n      }\n      continue;\n    }\n    if (type === 'AVL') {\n      const operationOpt = operationKeys[0];\n      const operationValue = operation[operationOpt];\n      let filteredIDs = [];\n      switch (operationOpt) {\n        case 'gt':\n          {\n            filteredIDs = avlGreaterThan(node, operationValue, false);\n            break;\n          }\n        case 'gte':\n          {\n            filteredIDs = avlGreaterThan(node, operationValue, true);\n            break;\n          }\n        case 'lt':\n          {\n            filteredIDs = avlLessThan(node, operationValue, false);\n            break;\n          }\n        case 'lte':\n          {\n            filteredIDs = avlLessThan(node, operationValue, true);\n            break;\n          }\n        case 'eq':\n          {\n            var _avlFind;\n            filteredIDs = (_avlFind = avlFind(node, operationValue)) !== null && _avlFind !== void 0 ? _avlFind : [];\n            break;\n          }\n        case 'between':\n          {\n            const [min, max] = operationValue;\n            filteredIDs = avlRangeSearch(node, min, max);\n            break;\n          }\n      }\n      safeArrayPush(filtersMap[param], filteredIDs);\n    }\n  }\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap));\n  return result;\n}\nexport async function getSearchableProperties(index) {\n  return index.searchableProperties;\n}\nexport async function getSearchablePropertiesWithTypes(index) {\n  return index.searchablePropertiesWithTypes;\n}\nfunction loadRadixNode(node) {\n  const convertedNode = radixCreate(node.e, node.s, node.k);\n  convertedNode.d = node.d;\n  convertedNode.w = node.w;\n  for (const childrenKey of Object.keys(node.c)) {\n    convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey]);\n  }\n  return convertedNode;\n}\nfunction loadFlatNode(node) {\n  return {\n    numberToDocumentId: new Map(node)\n  };\n}\nfunction saveFlatNode(node) {\n  return Array.from(node.numberToDocumentId.entries());\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n  const {\n    indexes: rawIndexes,\n    vectorIndexes: rawVectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = raw;\n  const indexes = {};\n  const vectorIndexes = {};\n  for (const prop of Object.keys(rawIndexes)) {\n    const {\n      node,\n      type,\n      isArray\n    } = rawIndexes[prop];\n    switch (type) {\n      case 'Radix':\n        indexes[prop] = {\n          type: 'Radix',\n          node: loadRadixNode(node),\n          isArray\n        };\n        break;\n      case 'Flat':\n        indexes[prop] = {\n          type: 'Flat',\n          node: loadFlatNode(node),\n          isArray\n        };\n        break;\n      default:\n        indexes[prop] = rawIndexes[prop];\n    }\n  }\n  for (const idx of Object.keys(rawVectorIndexes)) {\n    const vectors = rawVectorIndexes[idx].vectors;\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], new Float32Array(vectors[vec][1])];\n    }\n    vectorIndexes[idx] = {\n      size: rawVectorIndexes[idx].size,\n      vectors\n    };\n  }\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  };\n}\nexport async function save(index) {\n  const {\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = index;\n  const vectorIndexesAsArrays = {};\n  for (const idx of Object.keys(vectorIndexes)) {\n    const vectors = vectorIndexes[idx].vectors;\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], Array.from(vectors[vec][1])];\n    }\n    vectorIndexesAsArrays[idx] = {\n      size: vectorIndexes[idx].size,\n      vectors\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const savedIndexes = {};\n  for (const name of Object.keys(indexes)) {\n    const {\n      type,\n      node,\n      isArray\n    } = indexes[name];\n    if (type !== 'Flat') {\n      savedIndexes[name] = indexes[name];\n      continue;\n    }\n    savedIndexes[name] = {\n      type: 'Flat',\n      node: saveFlatNode(node),\n      isArray\n    };\n  }\n  return {\n    indexes: savedIndexes,\n    vectorIndexes: vectorIndexesAsArrays,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  };\n}\nexport async function createIndex() {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save\n  };\n}","map":{"version":3,"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","flatCreate","filter","flatFilter","filterArr","flatFilterArr","flatInsert","flatRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","intersect","safeArrayPush","BM25","getMagnitude","getInnerType","getVectorSize","isArrayType","isVectorType","getInternalDocumentId","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","_index$avgFieldLength","internalId","sharedInternalDocumentStore","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","_index$tokenOccurrenc","tokenFrequency","t","tf","tokenOccurrences","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","_oramaOccurrences$ter","documentIDs","Array","from","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","k","_ref","_oramaFrequencies_internalId","bm25","params","relevance","push","orama","schema","prefix","arguments","indexes","vectorIndexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","path","concat","isArray","size","vectors","test","node","true","false","insertScalar","implementation","value","schemaType","language","tokenizer","tokenize","insertVector","innerSchemaType","elements","elementsLength","i","Float32Array","magnitude","removeScalar","booleanKey","position","indexOf","splice","remove","search","exact","tolerance","searchResult","Set","key","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","raw","flat","filteredIDsResults","values","operationKeys","operationOpt","operationValue","_avlFind","min","max","result","getSearchableProperties","getSearchablePropertiesWithTypes","loadRadixNode","convertedNode","e","s","d","w","childrenKey","c","loadFlatNode","numberToDocumentId","Map","saveFlatNode","load","rawIndexes","rawVectorIndexes","vec","save","vectorIndexesAsArrays","savedIndexes","name","createIndex"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@orama+orama@1.2.11/node_modules/@orama/orama/src/components/index.ts"],"sourcesContent":["import type {\n  AnyIndexStore,\n  AnyOrama,\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  EnumArrComparisonOperator,\n  EnumComparisonOperator,\n  IIndex,\n  ScalarSearchableType,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  Tokenizer,\n  TokenScore,\n  TypedDocument,\n  VectorIndex,\n  VectorType,\n  WhereCondition,\n} from '../types.js'\nimport { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  Node as AVLNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument,\n} from '../trees/avl.js'\nimport {\n  create as flatCreate,\n  filter as flatFilter,\n  filterArr as flatFilterArr,\n  insert as flatInsert,\n  removeDocument as flatRemoveDocument,\n  FlatTree,\n} from '../trees/flat.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument,\n} from '../trees/radix.js'\n\nimport { intersect, safeArrayPush } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getMagnitude } from './cosine-similarity.js'\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n} from './internal-document-id-store.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: InternalDocumentID]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: InternalDocumentID[]\n  false: InternalDocumentID[]\n}\n\nexport type TreeType =\n  | 'AVL'\n  | 'Radix'\n  | 'Bool'\n  | 'Flat'\n\nexport type TTree<T = TreeType, N = unknown> = {\n  type: T,\n  node: N\n  isArray: boolean\n}\n\nexport type Tree =\n  | TTree<'Radix', RadixNode>\n  | TTree<'AVL',   AVLNode<number, InternalDocumentID[]>>\n  | TTree<'Bool',  BooleanIndex>\n  | TTree<'Flat',  FlatTree>\n\nexport interface Index extends AnyIndexStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  indexes: Record<string, Tree>\n  vectorIndexes: Record<string, VectorIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrences: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<InternalDocumentID, number | undefined>>\n}\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][internalId] = tokens.length\n  index.frequencies[prop][internalId] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  token: string,\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][internalId]![token] = tf\n\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] =\n    (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]!) / (docsCount - 1)\n  index.fieldLengths[prop][internalId] = undefined\n  index.frequencies[prop][internalId] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrences[prop][token]--\n}\n\nexport async function calculateResultScores<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: DocumentID[],\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrences = index.tokenOccurrences[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k])\n    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrences,\n      context.docsCount,\n      fieldLengths[internalId]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>,\n    )\n\n    scoreList.push([internalId, bm25])\n  }\n  return scoreList\n}\n\nexport async function create<T extends AnyOrama, TSchema extends T['schema']>(\n  orama: T,\n  sharedInternalDocumentStore: T['internalDocumentIDStore'],\n  schema: TSchema,\n  index?: Index,\n  prefix = '',\n): Promise<Index> {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      vectorIndexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {},\n    }\n  }\n\n  for (const [prop, type] of Object.entries<SearchableType>(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type, index, path)\n      continue\n    }\n\n    if (isVectorType(type)) {\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n      index.vectorIndexes[path] = {\n        size: getVectorSize(type),\n        vectors: {},\n      }\n    } else {\n      const isArray = /\\[/.test(type as string)\n      switch (type) {\n        case 'boolean':\n        case 'boolean[]':\n          index.indexes[path] = { type: 'Bool', node: { true: [], false: [] }, isArray }\n          break\n        case 'number':\n        case 'number[]':\n          index.indexes[path] = { type: 'AVL', node: avlCreate<number, InternalDocumentID[]>(0, []), isArray }\n          break\n        case 'string':\n        case 'string[]':\n          index.indexes[path] = { type: 'Radix', node: radixCreate(), isArray }\n          index.avgFieldLength[path] = 0\n          index.frequencies[path] = {}\n          index.tokenOccurrences[path] = {}\n          index.fieldLengths[path] = {}\n          break\n        case 'enum':\n        case 'enum[]':\n          index.indexes[path] = { type: 'Flat', node: flatCreate(), isArray }\n          break\n        default:\n          throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path)\n      }\n\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n    }\n  }\n\n  return index\n}\n\nasync function insertScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'Bool': {\n      node[value ? 'true' : 'false'].push(internalId)\n      break\n    }\n    case 'AVL':\n      avlInsert(node, value as number, [internalId])\n      break\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n      await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount)\n\n      for (const token of tokens) {\n        await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token)\n\n        radixInsert(node, token, internalId)\n      }\n\n      break\n    }\n    case 'Flat': {\n      flatInsert(node, value as ScalarSearchableType, internalId)\n      break\n    }\n  }\n}\n\nexport async function insert(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  if (isVectorType(schemaType)) {\n    return insertVector(index, prop, value as number[] | Float32Array, id)\n  }\n\n  if (!isArrayType(schemaType)) {\n    return insertScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n}\n\nfunction insertVector(index: Index, prop: string, value: number[] | VectorType, id: DocumentID): void {\n  if (!(value instanceof Float32Array)) {\n    value = new Float32Array(value)\n  }\n\n  const size = index.vectorIndexes[prop].size\n  const magnitude = getMagnitude(value, size)\n\n  index.vectorIndexes[prop].vectors[id] = [magnitude, value]\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  if (isVectorType(schemaType)) {\n    delete index.vectorIndexes[prop].vectors[id]\n    return true\n  }\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'AVL': {\n      avlRemoveDocument(node, internalId, value as number)\n      return true\n    }\n    case 'Bool': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = node[booleanKey].indexOf(internalId)\n\n      node[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(node, token, internalId)\n      }\n\n      return true\n    }\n    case 'Flat': {\n      flatRemoveDocument(node, internalId, value as ScalarSearchableType)\n      return true\n    }\n  }\n}\n\nexport async function remove(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  prop: string,\n  term: string,\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrences)) {\n    return []\n  }\n\n  const { node, type } = index.indexes[prop]\n  if (type !== 'Radix') {\n    throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop)\n  }\n\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(node, { term, exact, tolerance })\n  const ids = new Set<InternalDocumentID>()\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  filters: Partial<WhereCondition<T['schema']>>,\n): Promise<number[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, InternalDocumentID[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc,\n    }),\n    {},\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]!\n\n    if (typeof index.indexes[param] === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param)\n    }\n\n    const { node, type, isArray } = index.indexes[param]\n\n    if (type === 'Bool') {\n      const idx = node\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      safeArrayPush(filtersMap[param], filteredIDs);\n      continue\n    }\n\n    if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        for (const t of term) {\n          const filteredIDsResults = radixFind(node, { term: t, exact: true })\n          safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat())}\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    if (type === 'Flat') {\n      if (isArray) {\n        safeArrayPush(filtersMap[param], flatFilterArr(node, operation as EnumArrComparisonOperator))\n      } else {\n        safeArrayPush(filtersMap[param], flatFilter(node, operation as EnumComparisonOperator))\n      }\n      continue\n    }\n\n    if (type === 'AVL') {\n      const operationOpt = operationKeys[0] as keyof ComparisonOperator\n      const operationValue = (operation as ComparisonOperator)[operationOpt]\n      let filteredIDs: InternalDocumentID[] = [];\n\n      switch (operationOpt) {\n        case 'gt': {\n          filteredIDs = avlGreaterThan(node, operationValue, false)\n          break\n        }\n        case 'gte': {\n          filteredIDs = avlGreaterThan(node, operationValue, true)\n          break\n        }\n        case 'lt': {\n          filteredIDs = avlLessThan(node, operationValue, false)\n          break\n        }\n        case 'lte': {\n          filteredIDs = avlLessThan(node, operationValue, true)\n          break\n        }\n        case 'eq': {\n          filteredIDs = avlFind(node, operationValue) ?? []\n          break\n        }\n        case 'between': {\n          const [min, max] = operationValue as number[]\n          filteredIDs = avlRangeSearch(node, min, max)\n          break\n        }\n      }\n\n      safeArrayPush(filtersMap[param], filteredIDs)\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap))\n\n  return result\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nfunction loadRadixNode(node: RadixNode): RadixNode {\n  const convertedNode = radixCreate(node.e, node.s, node.k)\n\n  convertedNode.d = node.d\n  convertedNode.w = node.w\n\n  for (const childrenKey of Object.keys(node.c)) {\n    convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey])\n  }\n\n  return convertedNode\n}\n\nfunction loadFlatNode(node: unknown): FlatTree {\n  return {\n    numberToDocumentId: new Map(node as [ScalarSearchableType, InternalDocumentID[]][]),\n  }\n}\n\nfunction saveFlatNode(node: FlatTree): unknown {\n  return Array.from(node.numberToDocumentId.entries())\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Index> {\n  const {\n    indexes: rawIndexes,\n    vectorIndexes: rawVectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = raw as Index\n\n  const indexes: Index['indexes'] = {}\n  const vectorIndexes: Index['vectorIndexes'] = {}\n\n  for (const prop of Object.keys(rawIndexes)) {\n    const { node, type, isArray } = rawIndexes[prop]\n\n    switch (type) {\n      case 'Radix':\n        indexes[prop] = {\n          type: 'Radix',\n          node: loadRadixNode(node),\n          isArray\n        }\n        break\n      case 'Flat':\n        indexes[prop] = {\n          type: 'Flat',\n          node: loadFlatNode(node),\n          isArray\n        }\n        break\n      default:\n        indexes[prop] = rawIndexes[prop]\n    }\n  }\n\n  for (const idx of Object.keys(rawVectorIndexes)) {\n    const vectors = rawVectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], new Float32Array(vectors[vec][1])]\n    }\n\n    vectorIndexes[idx] = {\n      size: rawVectorIndexes[idx].size,\n      vectors,\n    }\n  }\n\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = index\n\n  const vectorIndexesAsArrays: Index['vectorIndexes'] = {}\n\n  for (const idx of Object.keys(vectorIndexes)) {\n    const vectors = vectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], Array.from(vectors[vec][1]) as unknown as Float32Array]\n    }\n\n    vectorIndexesAsArrays[idx] = {\n      size: vectorIndexes[idx].size,\n      vectors,\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const savedIndexes: any = {}\n  for (const name of Object.keys(indexes)) {\n    const {type, node, isArray} = indexes[name]\n    if (type !== 'Flat') {\n      savedIndexes[name] = indexes[name]\n      continue\n    }\n    savedIndexes[name] = {\n      type: 'Flat',\n      node: saveFlatNode(node),\n      isArray,\n    }\n  }\n\n  return {\n    indexes: savedIndexes,\n    vectorIndexes: vectorIndexesAsArrays,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } as R\n}\n\nexport async function createIndex(): Promise<IIndex<Index>> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}