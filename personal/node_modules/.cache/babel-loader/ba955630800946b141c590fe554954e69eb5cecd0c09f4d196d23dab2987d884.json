{"ast":null,"code":"import _classCallCheck from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/@babel+runtime@7.22.3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, ShaderMaterial, SphereGeometry } from \"three\";\nvar LightProbeHelper = /*#__PURE__*/function (_Mesh) {\n  _inherits(LightProbeHelper, _Mesh);\n  var _super = _createSuper(LightProbeHelper);\n  function LightProbeHelper(lightProbe, size) {\n    var _this;\n    _classCallCheck(this, LightProbeHelper);\n    var material = new ShaderMaterial({\n      type: \"LightProbeHelperMaterial\",\n      uniforms: {\n        sh: {\n          value: lightProbe.sh.coefficients\n        },\n        // by reference\n        intensity: {\n          value: lightProbe.intensity\n        }\n      },\n      vertexShader: [\"varying vec3 vNormal;\", \"void main() {\", \"\tvNormal = normalize( normalMatrix * normal );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n      fragmentShader: [\"#define RECIPROCAL_PI 0.318309886\", \"vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\", \"\t// matrix is assumed to be orthogonal\", \"\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\", \"}\", \"// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\", \"vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\", \"\t// normal is assumed to have unit length\", \"\tfloat x = normal.x, y = normal.y, z = normal.z;\", \"\t// band 0\", \"\tvec3 result = shCoefficients[ 0 ] * 0.886227;\", \"\t// band 1\", \"\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\", \"\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\", \"\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\", \"\t// band 2\", \"\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\", \"\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\", \"\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\", \"\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\", \"\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\", \"\treturn result;\", \"}\", \"uniform vec3 sh[ 9 ]; // sh coefficients\", \"uniform float intensity; // light probe intensity\", \"varying vec3 vNormal;\", \"void main() {\", \"\tvec3 normal = normalize( vNormal );\", \"\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\", \"\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\", \"\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\", \"\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );\", \"}\"].join(\"\\n\")\n    });\n    var geometry = new SphereGeometry(1, 32, 16);\n    _this = _super.call(this, geometry, material);\n    _this.lightProbe = lightProbe;\n    _this.size = size;\n    _this.type = \"LightProbeHelper\";\n    _this.onBeforeRender();\n    return _this;\n  }\n  _createClass(LightProbeHelper, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.geometry.dispose();\n      this.material.dispose();\n    }\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender() {\n      this.position.copy(this.lightProbe.position);\n      this.scale.set(1, 1, 1).multiplyScalar(this.size);\n      this.material.uniforms.intensity.value = this.lightProbe.intensity;\n    }\n  }]);\n  return LightProbeHelper;\n}(Mesh);\nexport { LightProbeHelper };","map":{"version":3,"names":["Mesh","ShaderMaterial","SphereGeometry","LightProbeHelper","_Mesh","_inherits","_super","_createSuper","lightProbe","size","_this","_classCallCheck","material","type","uniforms","sh","value","coefficients","intensity","vertexShader","join","fragmentShader","geometry","call","onBeforeRender","_createClass","key","dispose","position","copy","scale","set","multiplyScalar"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/helpers/LightProbeHelper.js"],"sourcesContent":["import { Mesh, ShaderMaterial, SphereGeometry } from \"three\";\nclass LightProbeHelper extends Mesh {\n  constructor(lightProbe, size) {\n    const material = new ShaderMaterial({\n      type: \"LightProbeHelperMaterial\",\n      uniforms: {\n        sh: { value: lightProbe.sh.coefficients },\n        // by reference\n        intensity: { value: lightProbe.intensity }\n      },\n      vertexShader: [\n        \"varying vec3 vNormal;\",\n        \"void main() {\",\n        \"\tvNormal = normalize( normalMatrix * normal );\",\n        \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n        \"}\"\n      ].join(\"\\n\"),\n      fragmentShader: [\n        \"#define RECIPROCAL_PI 0.318309886\",\n        \"vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\",\n        \"\t// matrix is assumed to be orthogonal\",\n        \"\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\",\n        \"}\",\n        \"// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\",\n        \"vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\",\n        \"\t// normal is assumed to have unit length\",\n        \"\tfloat x = normal.x, y = normal.y, z = normal.z;\",\n        \"\t// band 0\",\n        \"\tvec3 result = shCoefficients[ 0 ] * 0.886227;\",\n        \"\t// band 1\",\n        \"\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\",\n        \"\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\",\n        \"\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\",\n        \"\t// band 2\",\n        \"\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\",\n        \"\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\",\n        \"\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\",\n        \"\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\",\n        \"\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\",\n        \"\treturn result;\",\n        \"}\",\n        \"uniform vec3 sh[ 9 ]; // sh coefficients\",\n        \"uniform float intensity; // light probe intensity\",\n        \"varying vec3 vNormal;\",\n        \"void main() {\",\n        \"\tvec3 normal = normalize( vNormal );\",\n        \"\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\",\n        \"\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\",\n        \"\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\",\n        \"\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );\",\n        \"}\"\n      ].join(\"\\n\")\n    });\n    const geometry = new SphereGeometry(1, 32, 16);\n    super(geometry, material);\n    this.lightProbe = lightProbe;\n    this.size = size;\n    this.type = \"LightProbeHelper\";\n    this.onBeforeRender();\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n  onBeforeRender() {\n    this.position.copy(this.lightProbe.position);\n    this.scale.set(1, 1, 1).multiplyScalar(this.size);\n    this.material.uniforms.intensity.value = this.lightProbe.intensity;\n  }\n}\nexport {\n  LightProbeHelper\n};\n"],"mappings":";;;;AAAA,SAASA,IAAI,EAAEC,cAAc,EAAEC,cAAc,QAAQ,OAAO;AAAC,IACvDC,gBAAgB,0BAAAC,KAAA;EAAAC,SAAA,CAAAF,gBAAA,EAAAC,KAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,gBAAA;EACpB,SAAAA,iBAAYK,UAAU,EAAEC,IAAI,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAR,gBAAA;IAC5B,IAAMS,QAAQ,GAAG,IAAIX,cAAc,CAAC;MAClCY,IAAI,EAAE,0BAA0B;MAChCC,QAAQ,EAAE;QACRC,EAAE,EAAE;UAAEC,KAAK,EAAER,UAAU,CAACO,EAAE,CAACE;QAAa,CAAC;QACzC;QACAC,SAAS,EAAE;UAAEF,KAAK,EAAER,UAAU,CAACU;QAAU;MAC3C,CAAC;MACDC,YAAY,EAAE,CACZ,uBAAuB,EACvB,eAAe,EACf,gDAAgD,EAChD,4EAA4E,EAC5E,GAAG,CACJ,CAACC,IAAI,CAAC,IAAI,CAAC;MACZC,cAAc,EAAE,CACd,mCAAmC,EACnC,oEAAoE,EACpE,wCAAwC,EACxC,4DAA4D,EAC5D,GAAG,EACH,mEAAmE,EACnE,yEAAyE,EACzE,2CAA2C,EAC3C,kDAAkD,EAClD,YAAY,EACZ,gDAAgD,EAChD,YAAY,EACZ,sDAAsD,EACtD,sDAAsD,EACtD,sDAAsD,EACtD,YAAY,EACZ,0DAA0D,EAC1D,0DAA0D,EAC1D,mEAAmE,EACnE,0DAA0D,EAC1D,gEAAgE,EAChE,iBAAiB,EACjB,GAAG,EACH,0CAA0C,EAC1C,mDAAmD,EACnD,uBAAuB,EACvB,eAAe,EACf,sCAAsC,EACtC,sEAAsE,EACtE,0DAA0D,EAC1D,+DAA+D,EAC/D,oEAAoE,EACpE,GAAG,CACJ,CAACD,IAAI,CAAC,IAAI;IACb,CAAC,CAAC;IACF,IAAME,QAAQ,GAAG,IAAIpB,cAAc,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC;IAC9CQ,KAAA,GAAAJ,MAAA,CAAAiB,IAAA,OAAMD,QAAQ,EAAEV,QAAQ;IACxBF,KAAA,CAAKF,UAAU,GAAGA,UAAU;IAC5BE,KAAA,CAAKD,IAAI,GAAGA,IAAI;IAChBC,KAAA,CAAKG,IAAI,GAAG,kBAAkB;IAC9BH,KAAA,CAAKc,cAAc,CAAC,CAAC;IAAC,OAAAd,KAAA;EACxB;EAACe,YAAA,CAAAtB,gBAAA;IAAAuB,GAAA;IAAAV,KAAA,EACD,SAAAW,QAAA,EAAU;MACR,IAAI,CAACL,QAAQ,CAACK,OAAO,CAAC,CAAC;MACvB,IAAI,CAACf,QAAQ,CAACe,OAAO,CAAC,CAAC;IACzB;EAAC;IAAAD,GAAA;IAAAV,KAAA,EACD,SAAAQ,eAAA,EAAiB;MACf,IAAI,CAACI,QAAQ,CAACC,IAAI,CAAC,IAAI,CAACrB,UAAU,CAACoB,QAAQ,CAAC;MAC5C,IAAI,CAACE,KAAK,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACC,cAAc,CAAC,IAAI,CAACvB,IAAI,CAAC;MACjD,IAAI,CAACG,QAAQ,CAACE,QAAQ,CAACI,SAAS,CAACF,KAAK,GAAG,IAAI,CAACR,UAAU,CAACU,SAAS;IACpE;EAAC;EAAA,OAAAf,gBAAA;AAAA,EAnE4BH,IAAI;AAqEnC,SACEG,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}