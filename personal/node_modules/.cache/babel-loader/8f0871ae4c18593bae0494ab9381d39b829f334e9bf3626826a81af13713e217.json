{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { IFFParser } from \"./lwo/IFFParser.js\";\nlet _lwoTree;\nclass LWOLoader extends Loader {\n  constructor(manager) {\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : \"\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? extractParentUrl(url, \"Objects\") : scope.path;\n    const modelName = url.split(path).pop().split(\".\")[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n  parseLayers() {\n    const meshes = [];\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === \"points\") mesh = new Points(geometry, materials);else if (layer.geometry.type === \"lines\") mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + \"_layer_\" + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  }\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n    if (type === \"points\" || type === \"lines\") {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n        if (type === \"points\") {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === \"lines\") {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  }\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n    if (!duplicateUVs) return;\n    geometry.setAttribute(\"uv2\", new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n}\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse() {\n    const materials = [];\n    this.textures = {};\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === \"LWO3\") {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === \"LWO2\") {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n    return materials;\n  }\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n  parseMaterialLwo2(materialData, name) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  }\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  }\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === \"Material\") {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== void 0) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== void 0) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case \"Color\":\n          maps.map = texture;\n          break;\n        case \"Roughness\":\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n        case \"Specular\":\n          maps.specularMap = texture;\n          maps.specular = 16777215;\n          break;\n        case \"Luminous\":\n          maps.emissiveMap = texture;\n          maps.emissive = 8421504;\n          break;\n        case \"Luminous Color\":\n          maps.emissive = 8421504;\n          break;\n        case \"Metallic\":\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n        case \"Transparency\":\n        case \"Alpha\":\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case \"Normal\":\n          maps.normalMap = texture;\n          if (node.amplitude !== void 0) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case \"Bump\":\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  }\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== void 0) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== void 0) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case \"Color\":\n            maps.map = texture;\n            break;\n          case \"Diffuse\":\n            maps.aoMap = texture;\n            break;\n          case \"Roughness\":\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case \"Specular\":\n            maps.specularMap = texture;\n            maps.specular = 16777215;\n            break;\n          case \"Luminosity\":\n            maps.emissiveMap = texture;\n            maps.emissive = 8421504;\n            break;\n          case \"Metallic\":\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case \"Transparency\":\n          case \"Alpha\":\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case \"Normal\":\n            maps.normalMap = texture;\n            break;\n          case \"Bump\":\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n  parseAttributes(attributes, maps) {\n    const params = {};\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes[\"Bump Height\"]) params.bumpScale = attributes[\"Bump Height\"].value * 0.1;\n    if (attributes[\"Refraction Index\"]) params.refractionRatio = 1 / attributes[\"Refraction Index\"].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n  parsePhysicalAttributes(params, attributes) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes[\"Clearcoat Gloss\"]) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes[\"Clearcoat Gloss\"].value);\n      }\n    }\n  }\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes[\"Luminous Color\"] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes[\"Luminous Color\"].value);\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes[\"Color Highlight\"]) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes[\"Color Highlight\"].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n        if (attributes.reflectivity !== void 0) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== void 0) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n      maps.envMap = envMap;\n    }\n  }\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = \"\";\n    if (!_lwoTree.textures) return fileName;\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  }\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, void 0, void 0, function () {\n      console.warn(\"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\");\n    });\n    return texture;\n  }\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n}\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices);\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n    return geometry;\n  }\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\");\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  }\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === \"lines\") elemSize = 2;\n    if (geoData.type === \"points\") elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0;\n    const indexPairs = {};\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === void 0) prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    }\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n    geometry.userData.matNames = matNames;\n  }\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  }\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(remappedUVs, 2));\n  }\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === \"relative\") {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return \"./\";\n  return url.substr(0, index);\n}\nexport { LWOLoader };","map":{"version":3,"names":["Loader","FileLoader","TextureLoader","Points","LineSegments","Mesh","PointsMaterial","LineBasicMaterial","BufferAttribute","MeshPhongMaterial","BackSide","DoubleSide","FrontSide","Vector2","Color","AddOperation","EquirectangularRefractionMapping","EquirectangularReflectionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","MeshPhysicalMaterial","MeshStandardMaterial","BufferGeometry","Float32BufferAttribute","IFFParser","_lwoTree","LWOLoader","constructor","manager","parameters","arguments","length","undefined","resourcePath","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","duplicateUVs","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","morphTargets","filtered","filter","Boolean","m","Array","isArray","aoMap","material","setAttribute","attributes","uv","array","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","fromArray","value","Transparency","opacity","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","from","count","uvs","uvIndices","j","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf","substr"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/loaders/LWOLoader.js"],"sourcesContent":["import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { IFFParser } from \"./lwo/IFFParser.js\";\nlet _lwoTree;\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : \"\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? extractParentUrl(url, \"Objects\") : scope.path;\n    const modelName = url.split(path).pop().split(\".\")[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.load(\n      url,\n      function(buffer) {\n        try {\n          onLoad(scope.parse(buffer, path, modelName));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n  parseLayers() {\n    const meshes = [];\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n    _lwoTree.layers.forEach(function(layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1)\n        finalMeshes.push(mesh);\n      else\n        meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === \"points\")\n      mesh = new Points(geometry, materials);\n    else if (layer.geometry.type === \"lines\")\n      mesh = new LineSegments(geometry, materials);\n    else\n      mesh = new Mesh(geometry, materials);\n    if (layer.name)\n      mesh.name = layer.name;\n    else\n      mesh.name = this.defaultLayerName + \"_layer_\" + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  }\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function(mesh) {\n      mesh.traverse(function(child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function(name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n    if (type === \"points\" || type === \"lines\") {\n      materials.forEach(function(mat, i) {\n        const spec = {\n          color: mat.color\n        };\n        if (type === \"points\") {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === \"lines\") {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1)\n      return filtered[0];\n    return materials;\n  }\n  getMaterialByName(name) {\n    return this.materials.filter(function(m) {\n      return m.name === name;\n    })[0];\n  }\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap)\n        duplicateUVs = true;\n    } else {\n      materials.forEach(function(material) {\n        if (material.aoMap)\n          duplicateUVs = true;\n      });\n    }\n    if (!duplicateUVs)\n      return;\n    geometry.setAttribute(\"uv2\", new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n}\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse() {\n    const materials = [];\n    this.textures = {};\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === \"LWO3\") {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === \"LWO2\") {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n    return materials;\n  }\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n  parseMaterialLwo2(materialData, name) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  }\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side)\n      return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  }\n  getSmooth(attributes) {\n    if (!attributes.smooth)\n      return true;\n    return !attributes.smooth;\n  }\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function(name, index) {\n      if (name === \"Material\") {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function(name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName)\n        return nodes[name];\n    }\n  }\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path)\n        return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== void 0)\n        texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== void 0)\n        texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case \"Color\":\n          maps.map = texture;\n          break;\n        case \"Roughness\":\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n        case \"Specular\":\n          maps.specularMap = texture;\n          maps.specular = 16777215;\n          break;\n        case \"Luminous\":\n          maps.emissiveMap = texture;\n          maps.emissive = 8421504;\n          break;\n        case \"Luminous Color\":\n          maps.emissive = 8421504;\n          break;\n        case \"Metallic\":\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n        case \"Transparency\":\n        case \"Alpha\":\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case \"Normal\":\n          maps.normalMap = texture;\n          if (node.amplitude !== void 0)\n            maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case \"Bump\":\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n    if (maps.roughnessMap && maps.specularMap)\n      delete maps.specularMap;\n    return maps;\n  }\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path)\n          return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== void 0)\n          texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== void 0)\n          texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case \"Color\":\n            maps.map = texture;\n            break;\n          case \"Diffuse\":\n            maps.aoMap = texture;\n            break;\n          case \"Roughness\":\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case \"Specular\":\n            maps.specularMap = texture;\n            maps.specular = 16777215;\n            break;\n          case \"Luminosity\":\n            maps.emissiveMap = texture;\n            maps.emissive = 8421504;\n            break;\n          case \"Metallic\":\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case \"Transparency\":\n          case \"Alpha\":\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case \"Normal\":\n            maps.normalMap = texture;\n            break;\n          case \"Bump\":\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n  parseAttributes(attributes, maps) {\n    const params = {};\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes[\"Bump Height\"])\n      params.bumpScale = attributes[\"Bump Height\"].value * 0.1;\n    if (attributes[\"Refraction Index\"])\n      params.refractionRatio = 1 / attributes[\"Refraction Index\"].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n  parsePhysicalAttributes(params, attributes) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes[\"Clearcoat Gloss\"]) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes[\"Clearcoat Gloss\"].value);\n      }\n    }\n  }\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes[\"Luminous Color\"] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes[\"Luminous Color\"].value);\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap)\n      params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap)\n      params.metalness = attributes.Metallic.value;\n  }\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse)\n      params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes[\"Color Highlight\"]) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes[\"Color Highlight\"].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n        if (attributes.reflectivity !== void 0) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== void 0) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n      maps.envMap = envMap;\n    }\n  }\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = \"\";\n    if (!_lwoTree.textures)\n      return fileName;\n    _lwoTree.textures.forEach(function(texture) {\n      if (texture.index === index)\n        fileName = texture.fileName;\n    });\n    return fileName;\n  }\n  loadTexture(path) {\n    if (!path)\n      return null;\n    const texture = this.textureLoader.load(path, void 0, void 0, function() {\n      console.warn(\n        \"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\"\n      );\n    });\n    return texture;\n  }\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0)\n      return MeshPhysicalMaterial;\n    if (nodeData.Roughness)\n      return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n}\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices);\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n    return geometry;\n  }\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function(dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++)\n          remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(\n          indices[i],\n          indices[i + 1],\n          indices[i + 2],\n          indices[i],\n          indices[i + 2],\n          indices[i + 3]\n        );\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\");\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  }\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === \"lines\")\n      elemSize = 2;\n    if (geoData.type === \"points\")\n      elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0;\n    const indexPairs = {};\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0)\n        matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === void 0)\n        prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    }\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n    geometry.userData.matNames = matNames;\n  }\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function(dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  }\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function() {\n      return 0;\n    });\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function(i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(remappedUVs, 2));\n  }\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position)\n        geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function(i, j) {\n        if (type === \"relative\") {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1)\n    return \"./\";\n  return url.substr(0, index);\n}\nexport {\n  LWOLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}