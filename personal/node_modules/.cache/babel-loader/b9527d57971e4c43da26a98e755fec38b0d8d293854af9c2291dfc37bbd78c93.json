{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from \"three\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nclass OutlinePass extends Pass {\n  constructor(resolution, scene, camera, selectedObjects) {\n    super();\n    __publicField(this, \"renderScene\");\n    __publicField(this, \"renderCamera\");\n    __publicField(this, \"selectedObjects\");\n    __publicField(this, \"visibleEdgeColor\");\n    __publicField(this, \"hiddenEdgeColor\");\n    __publicField(this, \"edgeGlow\");\n    __publicField(this, \"usePatternTexture\");\n    __publicField(this, \"edgeThickness\");\n    __publicField(this, \"edgeStrength\");\n    __publicField(this, \"downSampleRatio\");\n    __publicField(this, \"pulsePeriod\");\n    __publicField(this, \"resolution\");\n    __publicField(this, \"renderTargetMaskBuffer\");\n    __publicField(this, \"depthMaterial\");\n    __publicField(this, \"prepareMaskMaterial\");\n    __publicField(this, \"renderTargetDepthBuffer\");\n    __publicField(this, \"renderTargetMaskDownSampleBuffer\");\n    __publicField(this, \"renderTargetBlurBuffer1\");\n    __publicField(this, \"renderTargetBlurBuffer2\");\n    __publicField(this, \"edgeDetectionMaterial\");\n    __publicField(this, \"renderTargetEdgeBuffer1\");\n    __publicField(this, \"renderTargetEdgeBuffer2\");\n    __publicField(this, \"separableBlurMaterial1\");\n    __publicField(this, \"separableBlurMaterial2\");\n    __publicField(this, \"overlayMaterial\");\n    __publicField(this, \"materialCopy\");\n    __publicField(this, \"oldClearAlpha\");\n    __publicField(this, \"fsQuad\");\n    __publicField(this, \"tempPulseColor1\");\n    __publicField(this, \"tempPulseColor2\");\n    __publicField(this, \"textureMatrix\");\n    __publicField(this, \"patternTexture\");\n    __publicField(this, \"_visibilityCache\");\n    __publicField(this, \"_oldClearColor\");\n    __publicField(this, \"copyUniforms\");\n    __publicField(this, \"BlurDirectionX\", new Vector2(1, 0));\n    __publicField(this, \"BlurDirectionY\", new Vector2(0, 1));\n    this.renderScene = scene;\n    this.renderCamera = camera;\n    this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];\n    this.visibleEdgeColor = new Color(1, 1, 1);\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    this.edgeGlow = 0;\n    this.usePatternTexture = false;\n    this.edgeThickness = 1;\n    this.edgeStrength = 3;\n    this.downSampleRatio = 2;\n    this.pulsePeriod = 0;\n    this._visibilityCache = /* @__PURE__ */new Map();\n    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.depthMaterial.side = DoubleSide;\n    this.depthMaterial.depthPacking = RGBADepthPacking;\n    this.depthMaterial.blending = NoBlending;\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n    this.prepareMaskMaterial.side = DoubleSide;\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    this.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    const MAX_EDGE_THICKNESS = 4;\n    const MAX_EDGE_GLOW = 4;\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    this.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n    this.overlayMaterial = this.getOverlayMaterial();\n    if (CopyShader === void 0) console.error(\"THREE.OutlinePass relies on CopyShader\");\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms[\"opacity\"].value = 1;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.fsQuad = new FullScreenQuad(this.materialCopy);\n    this.tempPulseColor1 = new Color();\n    this.tempPulseColor2 = new Color();\n    this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera2) {\n      const type = camera2.isPerspectiveCamera ? \"perspective\" : \"orthographic\";\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + \"DepthToViewZ\");\n    }\n  }\n  dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  }\n  setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    this.renderTargetDepthBuffer.setSize(width, height);\n    let resx = Math.round(width / this.downSampleRatio);\n    let resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(resx, resy);\n  }\n  changeVisibilityOfSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  }\n  changeVisibilityOfNonSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    const selectedMeshes = [];\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        let bFound = false;\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id;\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n        if (bFound === false) {\n          const visibility = object.visible;\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  }\n  updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(16777215, 1);\n      this.changeVisibilityOfSelectedObjects(false);\n      const currentBackground = this.renderScene.background;\n      this.renderScene.background = null;\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.changeVisibilityOfSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.updateTextureMatrix();\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.renderScene.background = currentBackground;\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      }\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms[\"texSize\"].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n      this.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n      this.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n      this.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  }\n  getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t}`,\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}`\n    });\n  }\n  getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new Vector3(1, 1, 1)\n        },\n        hiddenEdgeColor: {\n          value: new Vector3(1, 1, 1)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n    });\n  }\n  getSeperableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n    });\n  }\n  getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1\n        },\n        edgeGlow: {\n          value: 1\n        },\n        usePatternTexture: {\n          value: 0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n}\nexport { OutlinePass };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Pass","FullScreenQuad","Vector2","Color","WebGLRenderTarget","MeshDepthMaterial","DoubleSide","RGBADepthPacking","NoBlending","UniformsUtils","ShaderMaterial","Matrix4","Vector3","AdditiveBlending","CopyShader","OutlinePass","constructor","resolution","scene","camera","selectedObjects","renderScene","renderCamera","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","camera2","type","isPerspectiveCamera","replace","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","maskTexture","texSize","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2"],"sources":["/home/krug/Coding/JavaScript/Websites/Personal/personal/node_modules/.pnpm/three-stdlib@2.23.7_three@0.151.3/node_modules/three-stdlib/postprocessing/OutlinePass.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from \"three\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nclass OutlinePass extends Pass {\n  constructor(resolution, scene, camera, selectedObjects) {\n    super();\n    __publicField(this, \"renderScene\");\n    __publicField(this, \"renderCamera\");\n    __publicField(this, \"selectedObjects\");\n    __publicField(this, \"visibleEdgeColor\");\n    __publicField(this, \"hiddenEdgeColor\");\n    __publicField(this, \"edgeGlow\");\n    __publicField(this, \"usePatternTexture\");\n    __publicField(this, \"edgeThickness\");\n    __publicField(this, \"edgeStrength\");\n    __publicField(this, \"downSampleRatio\");\n    __publicField(this, \"pulsePeriod\");\n    __publicField(this, \"resolution\");\n    __publicField(this, \"renderTargetMaskBuffer\");\n    __publicField(this, \"depthMaterial\");\n    __publicField(this, \"prepareMaskMaterial\");\n    __publicField(this, \"renderTargetDepthBuffer\");\n    __publicField(this, \"renderTargetMaskDownSampleBuffer\");\n    __publicField(this, \"renderTargetBlurBuffer1\");\n    __publicField(this, \"renderTargetBlurBuffer2\");\n    __publicField(this, \"edgeDetectionMaterial\");\n    __publicField(this, \"renderTargetEdgeBuffer1\");\n    __publicField(this, \"renderTargetEdgeBuffer2\");\n    __publicField(this, \"separableBlurMaterial1\");\n    __publicField(this, \"separableBlurMaterial2\");\n    __publicField(this, \"overlayMaterial\");\n    __publicField(this, \"materialCopy\");\n    __publicField(this, \"oldClearAlpha\");\n    __publicField(this, \"fsQuad\");\n    __publicField(this, \"tempPulseColor1\");\n    __publicField(this, \"tempPulseColor2\");\n    __publicField(this, \"textureMatrix\");\n    __publicField(this, \"patternTexture\");\n    __publicField(this, \"_visibilityCache\");\n    __publicField(this, \"_oldClearColor\");\n    __publicField(this, \"copyUniforms\");\n    __publicField(this, \"BlurDirectionX\", new Vector2(1, 0));\n    __publicField(this, \"BlurDirectionY\", new Vector2(0, 1));\n    this.renderScene = scene;\n    this.renderCamera = camera;\n    this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];\n    this.visibleEdgeColor = new Color(1, 1, 1);\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    this.edgeGlow = 0;\n    this.usePatternTexture = false;\n    this.edgeThickness = 1;\n    this.edgeStrength = 3;\n    this.downSampleRatio = 2;\n    this.pulsePeriod = 0;\n    this._visibilityCache = /* @__PURE__ */ new Map();\n    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.depthMaterial.side = DoubleSide;\n    this.depthMaterial.depthPacking = RGBADepthPacking;\n    this.depthMaterial.blending = NoBlending;\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n    this.prepareMaskMaterial.side = DoubleSide;\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(\n      this.prepareMaskMaterial.fragmentShader,\n      this.renderCamera\n    );\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    this.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    const MAX_EDGE_THICKNESS = 4;\n    const MAX_EDGE_GLOW = 4;\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    this.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n    this.overlayMaterial = this.getOverlayMaterial();\n    if (CopyShader === void 0)\n      console.error(\"THREE.OutlinePass relies on CopyShader\");\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms[\"opacity\"].value = 1;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.fsQuad = new FullScreenQuad(this.materialCopy);\n    this.tempPulseColor1 = new Color();\n    this.tempPulseColor2 = new Color();\n    this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera2) {\n      const type = camera2.isPerspectiveCamera ? \"perspective\" : \"orthographic\";\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + \"DepthToViewZ\");\n    }\n  }\n  dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  }\n  setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    this.renderTargetDepthBuffer.setSize(width, height);\n    let resx = Math.round(width / this.downSampleRatio);\n    let resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(resx, resy);\n  }\n  changeVisibilityOfSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  }\n  changeVisibilityOfNonSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    const selectedMeshes = [];\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh)\n        selectedMeshes.push(object);\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        let bFound = false;\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id;\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n        if (bFound === false) {\n          const visibility = object.visible;\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  }\n  updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive)\n        renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(16777215, 1);\n      this.changeVisibilityOfSelectedObjects(false);\n      const currentBackground = this.renderScene.background;\n      this.renderScene.background = null;\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.changeVisibilityOfSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.updateTextureMatrix();\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value.set(\n        this.renderCamera.near,\n        this.renderCamera.far\n      );\n      this.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.renderScene.background = currentBackground;\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      }\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms[\"texSize\"].value.set(\n        this.renderTargetMaskDownSampleBuffer.width,\n        this.renderTargetMaskDownSampleBuffer.height\n      );\n      this.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n      this.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n      this.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n      this.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n      if (maskActive)\n        renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  }\n  getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: { value: null },\n        cameraNearFar: { value: new Vector2(0.5, 0.5) },\n        textureMatrix: { value: null }\n      },\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t}`,\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}`\n    });\n  }\n  getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        visibleEdgeColor: { value: new Vector3(1, 1, 1) },\n        hiddenEdgeColor: { value: new Vector3(1, 1, 1) }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n    });\n  }\n  getSeperableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        direction: { value: new Vector2(0.5, 0.5) },\n        kernelRadius: { value: 1 }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n    });\n  }\n  getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        edgeTexture1: { value: null },\n        edgeTexture2: { value: null },\n        patternTexture: { value: null },\n        edgeStrength: { value: 1 },\n        edgeGlow: { value: 1 },\n        usePatternTexture: { value: 0 }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n}\nexport {\n  OutlinePass\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}